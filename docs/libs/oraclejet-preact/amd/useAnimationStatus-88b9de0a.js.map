{"version":3,"file":"useAnimationStatus-88b9de0a.js","sources":["../../src/hooks/PRIVATE_useAnimationStatus/useAnimationStatus.ts"],"sourcesContent":["import { useRef, useCallback, useState, useEffect } from 'preact/hooks';\nimport { useAnimation, UseAnimationConfig } from '../UNSAFE_useAnimation';\nimport { RefObject } from 'preact';\n\ntype AnimationCallback = UseAnimationConfig<AnimationStatus, HTMLElement>['onAnimationEnd'];\nexport type AnimationStates = UseAnimationConfig<AnimationStatus, HTMLElement>['animationStates'];\n\n/**\n * Animation Status\n * 'unmounted' indicates the element is unmounted from the screen. No transitions should be applied.\n * 'initial' indicates the element is mounted, but stays hidden and is in the initial state\n * 'opening' indicates the element is in the opening state, visible and begins transitioning in.\n * 'closing' indicates the element is in the closing state, visible and begins transitioning out\n * The animation state lifecycle is as follows: 'unmounted' => 'initial' => 'opening' => 'closing' => 'unmounted'\n */\nexport type AnimationStatus = 'unmounted' | 'initial' | 'opening' | 'closing';\n\n/**\n * The AnimationStatus hook properties\n */\nexport type AnimationStatusProps = {\n  /**\n   * isOpen property indicates that animation should change to status opening\n   */\n  isOpen: boolean;\n  /**\n   * If isAnimatedOnMount true, the animation should start on mount\n   */\n  isAnimatedOnMount: boolean;\n  /**\n   * animationStates is the configuration of the animations, how the element should be animated\n   */\n  animationStates: AnimationStates;\n  /**\n   * The callback called after animation is finished\n   * @returns\n   */\n  onTransitionEnd?: (isOpen: boolean) => void;\n};\n\nexport function useAnimationStatus<E extends HTMLElement>({\n  isOpen,\n  isAnimatedOnMount,\n  animationStates,\n  onTransitionEnd\n}: AnimationStatusProps): {\n  /**\n   * status is the animation status\n   */\n  status: AnimationStatus;\n  /**\n   * animationElementRef is the reference of the element that is animated\n   */\n  animationElementRef: RefObject<E | null>;\n  /**\n   * setAnimationElementRef is a callback that should be used to set up element for the animation\n   * @param node an element that animation should be applied to\n   * @returns\n   */\n  setAnimationElementRef: (node: E | null) => void;\n} {\n  const [status, setStatus] = useState<AnimationStatus>(isOpen ? 'initial' : 'unmounted');\n  const animationElementRef = useRef<E | null>(null);\n  const [animationElement, _setAnimationElement] = useState<E | null>(null);\n\n  const { nodeRef } = useAnimation<AnimationStatus, HTMLElement>(status, {\n    animationStates,\n    isAnimatedOnMount: isAnimatedOnMount,\n    onAnimationEnd: useCallback<NonNullable<AnimationCallback>>(() => {\n      if (status === 'opening') {\n        onTransitionEnd?.(true);\n      } else if (!isOpen) {\n        Object.assign(animationElement!.style, {\n          visibility: null\n        });\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      }\n    }, [status, isOpen, onTransitionEnd, animationElement])\n  });\n\n  // We need setRef callback in order to set up visibility and node for the animation\n  // before it gets rendered in the next render cycle, i.e. when status === 'initial' the component is rendered,\n  // after component is rendered but is not yet painted references are applied, here we have the chance to set visibility to hidden\n  // and set up animation node.\n  const setAnimationRef = useCallback(\n    (node: E | null) => {\n      if (animationElementRef.current !== node) {\n        animationElementRef.current = node;\n        // Component will be visually hidden when status is 'initial' to avoid flickering.\n        // Flickering happens because it gets rendered before animation happens\n        // in next render cycle\n        if (node != null && status == 'initial') {\n          Object.assign(node.style, {\n            visibility: 'hidden'\n          });\n        }\n        nodeRef(node);\n        _setAnimationElement(node);\n      }\n    },\n    [status, nodeRef]\n  );\n\n  useEffect(() => {\n    // 1. Ignore status update on initial render\n    if (status === 'unmounted' && !isOpen) {\n      return;\n    }\n    // 2. Mount visually hidden component\n    // Component gets mounted\n    if (status === 'unmounted' && isOpen) {\n      setStatus('initial');\n      return;\n    }\n\n    // 3. Setup animation\n    // Component has been mounted.\n    // We will kick out animation as node is already present in DOM.\n    if (status === 'initial' && isOpen) {\n      setStatus('opening');\n      if (!animationStates.opening) {\n        onTransitionEnd?.(true);\n      }\n      return;\n    }\n\n    // 4. Unhide component.\n    if (status === 'opening' && isOpen) {\n      Object.assign(animationElement!.style, {\n        visibility: 'visible'\n      });\n      return;\n    }\n\n    // 5. Closing\n    if (!isOpen) {\n      if (!animationStates.closing) {\n        Object.assign(animationElement!.style, {\n          visibility: null\n        });\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      } else {\n        setStatus('closing');\n      }\n    }\n  }, [isOpen, animationElement, status, animationStates.closing, onTransitionEnd]);\n\n  return {\n    status,\n    animationElementRef,\n    setAnimationElementRef: setAnimationRef\n  };\n}\n"],"names":["isOpen","isAnimatedOnMount","animationStates","onTransitionEnd","status","setStatus","useState","animationElementRef","useRef","animationElement","_setAnimationElement","nodeRef","useAnimation","onAnimationEnd","useCallback","Object","assign","style","visibility","setAnimationRef","node","current","useEffect","opening","closing","setAnimationElementRef"],"mappings":"+GAwCM,UAAoDA,OACxDA,EAAMC,kBACNA,EAAiBC,gBACjBA,EAAeC,gBACfA,IAiBA,MAAOC,EAAQC,GAAaC,EAAQA,SAAkBN,EAAS,UAAY,aACrEO,EAAsBC,SAAiB,OACtCC,EAAkBC,GAAwBJ,EAAQA,SAAW,OAE9DK,QAAEA,GAAYC,EAAYA,aAA+BR,EAAQ,CACrEF,kBACAD,kBAAmBA,EACnBY,eAAgBC,EAAWA,aAAiC,KAC3C,YAAXV,EACFD,KAAkB,GACRH,IACVe,OAAOC,OAAOP,EAAkBQ,MAAO,CACrCC,WAAY,OAEdb,EAAU,aACVF,KAAkB,GACnB,GACA,CAACC,EAAQJ,EAAQG,EAAiBM,MAOjCU,EAAkBL,eACrBM,IACKb,EAAoBc,UAAYD,IAClCb,EAAoBc,QAAUD,EAIlB,MAARA,GAA0B,WAAVhB,GAClBW,OAAOC,OAAOI,EAAKH,MAAO,CACxBC,WAAY,WAGhBP,EAAQS,GACRV,EAAqBU,GACtB,GAEH,CAAChB,EAAQO,IAgDX,OA7CAW,EAAAA,WAAU,KAER,GAAe,cAAXlB,GAA2BJ,EAA/B,CAKA,GAAe,cAAXI,IAA0BJ,EAQ9B,MAAe,YAAXI,GAAwBJ,GAC1BK,EAAU,gBACLH,EAAgBqB,SACnBpB,KAAkB,UAMP,YAAXC,GAAwBJ,EAC1Be,OAAOC,OAAOP,EAAkBQ,MAAO,CACrCC,WAAY,YAMXlB,IACEE,EAAgBsB,QAOnBnB,EAAU,YANVU,OAAOC,OAAOP,EAAkBQ,MAAO,CACrCC,WAAY,OAEdb,EAAU,aACVF,KAAkB,MA9BpBE,EAAU,UAJX,CAsCA,GACA,CAACL,EAAQS,EAAkBL,EAAQF,EAAgBsB,QAASrB,IAExD,CACLC,SACAG,sBACAkB,uBAAwBN,EAE5B"}