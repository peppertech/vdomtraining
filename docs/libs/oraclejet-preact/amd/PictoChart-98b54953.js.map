{"version":3,"file":"PictoChart-98b54953.js","sources":["../../src/UNSAFE_PictoChart/PictoChartContext.tsx","../../src/UNSAFE_PictoChart/pictoChartLayoutUtils.ts","../../src/UNSAFE_PictoChart/pictoChartUtils.tsx","../../src/UNSAFE_PictoChart/pictoChartNavUtils.ts","../../src/UNSAFE_PictoChart/usePictoChartDatatip.ts","../../src/UNSAFE_PictoChart/PictoChartElement.tsx","../../src/UNSAFE_PictoChart/PictoChartWithDimensions.tsx","../../src/UNSAFE_PictoChart/useEvents.ts","../../src/UNSAFE_PictoChart/PictoChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\ntype PictoChartContextValue = {\n  supportsSelection?: boolean;\n};\n\nconst PictoChartContext = createContext<PictoChartContextValue>({} as PictoChartContextValue);\nconst usePictoChartContext = () => useContext(PictoChartContext);\n\nexport { PictoChartContext, usePictoChartContext };\n","import type { PictoChartItemData } from './pictoChart.type';\nimport { DEFAULT_SIZE } from './themes/PictoChartStyles.css';\n\nconst GAP_RATIO = 0.25;\n\nfunction _ceil(a: number, b: number) {\n  return Math.ceil(a / b) * b;\n}\n\nexport function getFlowingInfo<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  isVert: boolean,\n  width: number,\n  height: number,\n  isFlowingWidth: boolean,\n  isFlowingHeight: boolean,\n  colCount?: number,\n  rowCount?: number,\n  colWidth?: number,\n  rowHeight?: number\n) {\n  let numCells = 0;\n  let maxColSpan = 1;\n  let maxRowSpan = 1;\n  let minSpan = Infinity;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const columnSpan = item.columnSpan || 1;\n    const rowSpan = item.rowSpan || 1;\n    if (columnSpan <= 0 || rowSpan <= 0) continue;\n\n    // Compute the maximum columnSpan and rowSpan\n    if (columnSpan > maxColSpan) maxColSpan = columnSpan;\n    if (rowSpan > maxRowSpan) maxRowSpan = rowSpan;\n\n    // Compute minimum span for gap computation\n    if (columnSpan < minSpan) minSpan = columnSpan;\n    if (rowSpan < minSpan) minSpan = rowSpan;\n\n    numCells += columnSpan * rowSpan * (item.count || 1);\n  }\n\n  if (numCells === 0) return {};\n\n  // Default colWidth and rowHeight for flowing layout\n  if (isFlowingWidth || isFlowingHeight) {\n    if (!colWidth) colWidth = rowHeight ? rowHeight : DEFAULT_SIZE;\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  // Default colCount and rowCount for both layouts\n  // We set the default colCount (or rowCount) to be an integer multiple of the maxColSpan (or maxRowSpan) to\n  // ensure that all the items can find a spot to occupy in the mixed sizes case.\n\n  if (!colCount && !rowCount) {\n    // Try to achieve square cells, (width / colCount) = (height / rowCount)\n    if (!isFlowingWidth && !isFlowingHeight) {\n      if (isVert) rowCount = _ceil(Math.sqrt((numCells * height) / width), maxRowSpan);\n      else colCount = _ceil(Math.sqrt((numCells * width) / height), maxColSpan);\n    } else if (!isFlowingWidth) colCount = Math.max(Math.floor(width / (colWidth || 1)), 1);\n    else if (!isFlowingHeight) rowCount = Math.max(Math.floor(height / (rowHeight || 1)), 1);\n    else {\n      if (isVert) rowCount = _ceil(Math.sqrt(numCells), maxRowSpan);\n      else colCount = _ceil(Math.sqrt(numCells), maxColSpan);\n    }\n  }\n\n  // Now only either colCount or rowCount is undefined\n  if (!colCount) colCount = _ceil(numCells / (rowCount || 1), maxColSpan);\n  else if (!rowCount) rowCount = _ceil(numCells / colCount, maxRowSpan);\n\n  const gridGap = GAP_RATIO * minSpan;\n  // Default colWidth and rowHeight for fixed layout\n  if (!isFlowingWidth && !isFlowingHeight) {\n    if (!colWidth)\n      colWidth = rowHeight ? rowHeight : Math.min(width / colCount, height / (rowCount || 1));\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  if (\n    colCount <= 0 ||\n    !rowCount ||\n    rowCount <= 0 ||\n    !colWidth ||\n    colWidth <= 0 ||\n    !rowHeight ||\n    rowHeight <= 0\n  )\n    return {};\n\n  return {\n    calcColCount: colCount,\n    calcRowCount: rowCount,\n    calcColWidth: colWidth ? colWidth - gridGap : colWidth,\n    calcRowHeight: rowHeight ? rowHeight - gridGap : rowHeight,\n    gridGap: gridGap\n  };\n}\n\n/**\n * Returns whether the pictoChart is layout from bottom to top.\n */\nconst isOriginBottom = (origin: string) => {\n  return origin === 'bottomStart' || origin === 'bottomEnd';\n};\n\n/**\n * Returns whether the pictoChart is layout from right to left.\n */\nconst isOriginRight = (origin: string) => {\n  const isEnd = origin === 'topEnd' || origin === 'bottomEnd';\n  return isEnd;\n};\n\n/**\n * Returns whether the cells are available given col, row and columnSpan, rowSpan needed.\n */\nconst areCellsAvailable = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      if (map[row + r][col + c]) return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Occupies the cell in the map given col, row and columnSpan, rowSpan.\n */\nconst occupyCells = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      map[row + r][col + c] = true;\n    }\n  }\n};\n\n/**\n * Returns whether the cells are available given col, row and the colCount and rowCount of the pictochart.\n */\nconst findNextAvailableCell = (\n  map: boolean[][],\n  columnSpan: number,\n  rowSpan: number,\n  colCount: number,\n  rowCount: number,\n  isVert: boolean\n): { row: number; col: number } | undefined => {\n  if (isVert) {\n    // For vertical layout, switch row and col in the computation, and switch the result back\n    const cell = findNextAvailableCell(map, rowSpan, columnSpan, rowCount, colCount, false);\n    return cell ? { col: cell.row, row: cell.col } : undefined;\n  }\n\n  for (let r = 0; r < rowCount - rowSpan + 1; r++) {\n    for (let c = 0; c < colCount - columnSpan + 1; c++) {\n      if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {\n        occupyCells(map, c, r, columnSpan, rowSpan);\n        return { col: c, row: r };\n      }\n    }\n  }\n\n  return;\n};\n\n/**\n * Returns the picto items with row and col of the pictochart.\n */\nexport function generateElementCoords<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  row: number,\n  column: number,\n  layoutOrigin: 'topStart' | 'topEnd' | 'bottomStart' | 'bottomEnd',\n  isVert: boolean\n) {\n  const rowCount = row;\n  const colCount = column;\n  const isLayoutBottom = isOriginBottom(layoutOrigin);\n  const isLayoutRight = isOriginRight(layoutOrigin);\n\n  const pictoItems = [];\n  const map: boolean[][] = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    map[i] = new Array(colCount).fill(false);\n  }\n\n  for (let i = 0; i < items.length; i++) {\n    const currItem = items[i];\n    let count = 0;\n    const rowSpan = currItem.rowSpan ?? 1;\n    const columnSpan = currItem.columnSpan ?? 1;\n    const totalCount = currItem.count ?? 1;\n\n    while (count < totalCount) {\n      const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);\n      if (cell !== undefined) {\n        pictoItems.push({\n          row: isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row,\n          col: isLayoutRight ? colCount - cell.col - columnSpan : cell.col,\n          countIdx: count,\n          itemIdx: i,\n          item: currItem\n        });\n      }\n      count += 1;\n    }\n  }\n\n  return pictoItems;\n}\n","import { ComponentChildren } from 'preact';\nimport type {\n  ItemInfo,\n  PictoChartItemData,\n  MarkerRendererContext,\n  PictoRendererOptions,\n  DatatipContext\n} from './pictoChart.type';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { MarkerShapes } from '../utils/UNSAFE_visTypes/common';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../UNSAFE_Theme';\nimport { SvgSymbol } from '../PRIVATE_SvgShapes';\nimport { usePictoChartContext } from './PictoChartContext';\nimport { Property } from 'csstype';\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlightedIds?: K[]) {\n  if (!highlightedIds || highlightedIds.length === 0) {\n    return true;\n  }\n  return new Set(highlightedIds).has(id);\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param selectedIds The set of highlighted item\n */\nexport function isItemSelected<K>(id: K, selectedIds?: K[]) {\n  if (!selectedIds || selectedIds.length === 0) {\n    return false;\n  }\n  return new Set(selectedIds).has(id);\n}\n\n/**\n * Returns the value of the data-oj-item-index attribute for a given element.\n * @param element The HTML element.\n */\nexport function getItemInfo(element: HTMLElement) {\n  const itemIdx = element.dataset['idx'];\n  if (itemIdx === undefined) return;\n\n  return {\n    idx: Number(itemIdx)\n  };\n}\n\n/**\n * Returns the item props for PictoChart.\n * @param item The picto chart item.\n * @param itemIdx The item index of the item.\n * @param countIdx The item count of the item.\n * @param isReadOnly Whether the picto chart is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param selectedIds The selected Ids\n * @param focusedItem The info of currently focused item.\n * @param highlightedIds The highlighted ids.\n * @param activeId The active Id\n */\nexport function getItemProps<K, D extends PictoChartItemData<K>>(\n  item: D,\n  itemIdx: number,\n  countIdx: number,\n  isReadOnly: boolean,\n  hoveredItem?: ItemInfo,\n  selectedIds?: Array<K>,\n  focusedItem?: ItemInfo,\n  highlightedIds?: Array<K>,\n  activeId?: string\n) {\n  let isCurrent = false;\n  if (!isReadOnly) {\n    const isFocusedItem = !!focusedItem && itemIdx === focusedItem.idx;\n    const isHoveredItem = !!hoveredItem && itemIdx === hoveredItem.idx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem?.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n  const isHighlighted = isItemHighlighted<K>(item.id, highlightedIds);\n  const isSelected = isItemSelected(item.id, selectedIds);\n  const hasSelection = selectedIds && selectedIds.length !== 0;\n\n  return {\n    isCurrent,\n    isHighlighted: isHighlighted,\n    isSelected: isSelected,\n    hasSelection,\n    isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,\n    key: item.id,\n    itemIdx,\n    countIdx,\n    activeId: isCurrent ? activeId : undefined,\n    isReadOnly,\n    item: item\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport function isEqualItem(item1?: ItemInfo, item2?: ItemInfo) {\n  return item1?.idx === item2?.idx;\n}\n\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemIdx Item index\n */\nexport function hasFocusRing(itemInfo: ItemInfo, itemIdx: number) {\n  if (!itemInfo.isFocusVisible) return false;\n  return itemInfo.idx === itemIdx;\n}\n\n/**\n *\n */\nexport function getCountWithTotal(itemCount: number, totalCount: number, translations: BundleType) {\n  const totalWithCountLabel = `${translations?.vis_labelCountWithTotal({\n    itemCount: itemCount.toString(),\n    totalCount: totalCount.toString()\n  })}`;\n  return totalWithCountLabel;\n}\n\n/**\n * Returns the aria properties for the picto chart.\n * @param isReadOnly { boolean } If the picto chart is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getItemAriaProps(\n  itemCount: number,\n  totalCount: number,\n  supportsSelection: boolean,\n  label?: string,\n  translations?: BundleType,\n  isSelected?: boolean,\n  hasSelection?: boolean,\n  accessibleLabel?: string,\n  activeId?: string\n): {\n  'aria-label'?: HTMLAttributesSignalExcluded['aria-label'];\n  role: HTMLAttributesSignalExcluded['role'];\n  id?: string;\n} {\n  const totalWithCountLabel = translations\n    ? getCountWithTotal(itemCount, totalCount, translations)\n    : '';\n\n  accessibleLabel = accessibleLabel || `${label ? label + ': ' : ''}${totalWithCountLabel}`; // TODO: use a translation string for :\n\n  return {\n    'aria-label':\n      generateAriaLabel(translations!, accessibleLabel, {\n        isSelected: !supportsSelection && !hasSelection ? undefined : isSelected\n      }) || undefined,\n    role: 'img',\n    id: activeId\n  };\n}\n\n/**\n * Returns the marker props for SVGSymbol\n */\nexport function getMarkerProps(\n  shape: MarkerShapes,\n  color?: ColorProps['color'],\n  isFocused?: boolean,\n  isSelected?: boolean,\n  isCurrent?: boolean,\n  supportsSelection?: boolean\n) {\n  const isHuman = shape === 'human';\n  const applyHover = isFocused || (isCurrent && supportsSelection);\n  const isNoneEqualSides = shape === 'ellipse' || shape === 'rectangle';\n  color = color !== '' ? color : rgba(colorSchemeVars.palette.neutral['190'], 0.15);\n  const outerBorderColor = isSelected ? colorSchemeVars.textIcon.primary : applyHover ? color : '';\n\n  return {\n    markerShape: shape,\n    tx: isHuman ? 70 : undefined,\n    ty: isHuman ? 60 : undefined,\n    markerColor: color,\n    borderColor: isSelected || applyHover ? rgb(colorSchemeVars.palette.neutral[0]) : color,\n    outerBorderColor,\n    markerScale: isNoneEqualSides && !outerBorderColor ? 1 : 0.85,\n    setAspectRatioNone: isNoneEqualSides ? true : false\n  };\n}\n\n// Creating component to read the context\nconst PictoRenderer = <K,>({\n  context,\n  markerProps\n}: {\n  context: MarkerRendererContext<K>;\n  markerProps: PictoRendererOptions;\n}) => {\n  const { supportsSelection } = usePictoChartContext();\n  const markerProp = getMarkerProps(\n    markerProps.shape,\n    markerProps.color,\n    context.state.focused,\n    context.state.selected,\n    context.state.hovered,\n    supportsSelection\n  );\n\n  return <SvgSymbol {...markerProp} />;\n};\n\n/**\n * Returns the marker renderer for SVGSymbol\n */\nexport function getPictoDefaultRenderers<\n  K,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>(rendererOptions: (data: D) => PictoRendererOptions) {\n  return {\n    markerRenderer: (context: MarkerRendererContext<D>) => {\n      const props = rendererOptions(context.data); // TODO: should we add default values\n      return <PictoRenderer context={context} markerProps={props} />;\n    },\n    datatipRenderer: (context: DatatipContext<D>) => {\n      const props = rendererOptions(context.data);\n      return { borderColor: props.color };\n    }\n  };\n}\n\nexport function getTotalCount<K>(items: PictoChartItemData<K>[]) {\n  let totalCount = 0;\n  for (let i = 0; i < items.length; i++) {\n    totalCount += items[i].count || 1;\n  }\n  return totalCount;\n}\n\n/**\n * Returns the text for the picto chart datatip.\n * @param items The picto chart items data.\n * @param focusedItem The item currently keyboard focused.\n * @param hoveredItem The item that is currently hovered.\n * @param datatip The datatip.\n */\nexport function getDatatipContent<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  getItem: (itemInfo: ItemInfo, items: D[]) => D | undefined,\n  totalCount: number,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo,\n  datatip?: (context: DatatipContext<D>) => {\n    content?: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  },\n  translations?: BundleType\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && items[hoveredItem.idx].id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  let _content, countWithTotal;\n  let _borderColor: string = rgba(colorSchemeVars.palette.neutral['190'], 0.15);\n  const item = itemInfo && getItem(itemInfo, items);\n  if (item && datatip) {\n    // custom datatip\n    const datatipContext = item && { data: item };\n    const { content, borderColor } = datatip(datatipContext);\n    _content = content;\n    _borderColor = borderColor || _borderColor;\n    countWithTotal = translations\n      ? getCountWithTotal(item.count || 1, totalCount, translations)\n      : '';\n  }\n  return {\n    borderColor: _borderColor,\n    content:\n      _content ||\n      (itemInfo && getItem(itemInfo, items)?.accessibleLabel) ||\n      (itemInfo && getItem(itemInfo, items)?.label + ': ' + countWithTotal) ||\n      countWithTotal\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type {\n  ItemHoverDetail,\n  ItemFocusDetail,\n  ItemInfo,\n  PictoChartItemData\n} from './pictoChart.type';\n\n/**\n * Returns the item based on item info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K, D extends PictoChartItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { idx } = itemInfo;\n  return items[idx];\n}\n\n/**\n * Returns the next item's info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getNextItemInfo<K, D extends PictoChartItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.min(items.length - 1, idx + 1);\n  return { idx: idx };\n}\n\n/**\n * Returns the previous item's info in a picto chart.\n * @param itemInfo\n * @returns\n */\nfunction getPrevItemInfo(itemInfo: ItemInfo) {\n  let idx = itemInfo.idx;\n\n  idx = Math.max(0, idx - 1);\n  return { idx: idx };\n}\n\n/**\n * Returns utils functions for navigation in a picto chart.\n * @param items\n * @returns\n */\nexport function getPictoChartNavUtils<K, D extends PictoChartItemData<K>>(items: D[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemHoverDetail<K, D> | ItemFocusDetail<K, D> => {\n      if (!itemInfo) {\n        return { id: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { id: item ? item.id : undefined, data: item };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Ref } from 'preact/hooks';\nimport type { ItemInfo } from './pictoChart.type';\nimport { calculateOffset, useDatatip } from '../hooks/PRIVATE_useDatatip';\nimport { ComponentChildren } from 'preact';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { Property } from 'csstype';\n\ntype Props = {\n  touchResponse: 'touchStart' | 'touchHold';\n  content?: ComponentChildren;\n  borderColor?: Property.BorderColor;\n  focusedItemInfo: ItemInfo;\n  width: number;\n  focusedItemRef: Ref<HTMLDivElement>;\n};\n\n/**\n * Returns the datatip.\n * @param content The text string for the picto chart item.\n * @param focusedItemRef The ref for focused item node.\n * @param focusedItemInfo The ItemInfo for focused item node.\n * @returns\n */\nexport const usePictoChartDatatip = ({\n  touchResponse,\n  content,\n  borderColor,\n  width,\n  focusedItemRef,\n  focusedItemInfo\n}: Props) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const itemDim = focusedItemRef.current?.getBoundingClientRect();\n  const { datatipContent, datatipProps } = useDatatip({\n    content,\n    placement: 'top-start',\n    offset: calculateOffset(isRtl, width, focusedItemInfo.isCurrent ? itemDim : undefined),\n    borderColor,\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    touchResponse\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { styles } from './themes/PictoChartStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaProps } from './pictoChartUtils';\nimport { Ref } from 'preact/hooks';\nimport { PictoChartItemData } from './pictoChart.type';\n\nexport type PictoElementProps<K, D extends PictoChartItemData<K>> = {\n  item: D;\n  children: ComponentChildren;\n  row: number;\n  column: number;\n  totalCount: number;\n  class?: string;\n  activeId?: string;\n  isHighlighted?: boolean;\n  isSelected?: boolean;\n  hasSelection?: boolean;\n  itemIdx?: number;\n  countIdx?: number;\n  supportsSelection?: boolean;\n  supportsDrill?: boolean;\n  translations?: BundleType;\n  focusedItemRef?: Ref<HTMLDivElement>;\n};\n\nconst PictoChartElement = <K, D extends PictoChartItemData<K>>(props: PictoElementProps<K, D>) => {\n  const isInteractive = props.supportsSelection || props.supportsDrill;\n\n  const { dimmedItemStyle, interactiveItemStyle } = styles;\n\n  const itemClasses = classNames([\n    isInteractive && interactiveItemStyle,\n    !props.isHighlighted && dimmedItemStyle\n  ]);\n  const isFirstElement = props.countIdx === 0;\n  const itemAriaProps =\n    (isFirstElement &&\n      getItemAriaProps(\n        props.item.count || 1,\n        props.totalCount,\n        !!props.supportsSelection,\n        props.item.label,\n        props.translations,\n        props.isSelected,\n        props.hasSelection,\n        props.item.accessibleLabel,\n        props.activeId\n      )) ||\n    {};\n\n  return (\n    <div\n      ref={isFirstElement ? props.focusedItemRef : undefined}\n      id={props.activeId}\n      data-idx={props.itemIdx}\n      data-count-idx={props.countIdx}\n      style={{\n        gridRow: `${props.row + 1} / span ${props.item.rowSpan || 1}`,\n        gridColumn: `${props.column + 1} / span ${props.item.columnSpan || 1}`\n      }}\n      class={itemClasses}\n      {...itemAriaProps}>\n      {props.children}\n    </div>\n  );\n};\n\nexport { PictoChartElement };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { baseStyles } from './themes/PictoChartStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { generateElementCoords, getFlowingInfo } from './pictoChartLayoutUtils';\nimport { useSelection } from '../hooks/PRIVATE_useVisSelection';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { getItemInfo, getDatatipContent, getItemProps, getTotalCount } from './pictoChartUtils';\nimport { getPictoChartNavUtils } from './pictoChartNavUtils';\nimport { useEvents } from './useEvents';\nimport { usePictoChartDatatip } from './usePictoChartDatatip';\nimport { useItemFocus } from '../hooks/PRIVATE_useVisEvents';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\nimport { PictoChartProps, PictoChartItemData } from './pictoChart.type';\nimport { PictoChartElement } from './PictoChartElement';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '#utils/UNSAFE_stringUtils';\n\ntype PictoChartWithDimensionsProps<K, D> = Omit<PictoChartProps<K, D>, 'width' | 'height'> & {\n  width: number;\n  height: number;\n  isFlowingWidth: boolean;\n  isFlowingHeight: boolean;\n};\n\nexport function PictoChartWithDimensions<\n  K extends string | number,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>({\n  width,\n  height,\n  columnWidth,\n  rowHeight,\n  items,\n  columnCount,\n  rowCount,\n  layout,\n  layoutOrigin = 'topStart',\n  selectionMode = 'none',\n  highlightedIds = [],\n  selectedIds = [],\n  drilling = 'off',\n  onItemDrill,\n  onItemHover,\n  isFlowingWidth,\n  isFlowingHeight,\n  onItemFocus,\n  ...props\n}: PictoChartWithDimensionsProps<K, D>) {\n  const hasData = items.length !== 0;\n  const totalCount = getTotalCount(items);\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const supportsSelection = !!(selectionMode && selectionMode !== 'none');\n  const supportsDrill = onItemDrill != null;\n  const isReadOnly =\n    !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;\n  const testIdProps = useTestId(props.testId);\n  const idToDataMap = new Map(items.map((obj) => [obj.id, obj]));\n\n  const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getPictoChartNavUtils<\n    K,\n    D\n  >(items);\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({ type: 'touchStart' });\n\n  const { hoveredItemInfo, focusedItemInfo, activeId, eventsProps } = useEvents<K, D>(\n    touchResponse,\n    !isReadOnly && hasData,\n    selectionMode,\n    getDetailFromInfo,\n    getPrevItemInfo,\n    getNextItemInfo,\n    drilling,\n    onItemDrill,\n    onItemHover,\n    onItemFocus\n  );\n\n  const idExtracter = (event: Event) => {\n    // return focused item for keyboard event.\n    // eventsProps should have already updated the focused item\n    const info =\n      event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target as HTMLElement);\n    return getDetailFromInfo(info).id;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<K, D>({\n    idExtracter,\n    isDrillEnabled: drilling != 'off',\n    selection: selectedIds,\n    selectionMode: selectionMode,\n    getDataById: (id) => idToDataMap.get(id),\n    onChange: props.onSelectionChange\n  });\n\n  const rectangleWidth = columnWidth && parseFloat(columnWidth);\n  const rectangleHeight = rowHeight && parseFloat(rowHeight);\n  const pictoStyleClasses = classNames([baseStyles]);\n  const { focusedItemRef } = useItemFocus(focusedItemInfo);\n  const { content, borderColor } = getDatatipContent(\n    items,\n    getItem,\n    totalCount,\n    focusedItemInfo,\n    hoveredItemInfo,\n    props.datatip,\n    translations\n  );\n  const { calcColCount, calcRowCount, calcColWidth, calcRowHeight, gridGap } = getFlowingInfo<K, D>(\n    items,\n    layout === 'vertical',\n    width,\n    height,\n    isFlowingWidth,\n    isFlowingHeight,\n    columnCount,\n    rowCount,\n    rectangleWidth,\n    rectangleHeight\n  );\n\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = usePictoChartDatatip({\n    touchResponse,\n    content,\n    width,\n    borderColor,\n    focusedItemRef,\n    focusedItemInfo\n  });\n\n  if (!calcColCount)\n    // Nothing to render.\n    return null;\n\n  const elements = generateElementCoords(\n    items,\n    calcRowCount,\n    calcColCount,\n    layoutOrigin,\n    layout === 'vertical'\n  );\n\n  const mergedEventProps = mergeProps(eventsProps, datatipProps, selectionProps);\n  return (\n    <div\n      tabIndex={0}\n      aria-label={props['aria-label']}\n      aria-describedby={merge([props['aria-describedby'], datatipAriaDescribedby])}\n      aria-labelledby={props['aria-labelledby']}\n      aria-activedescendant={activeId}\n      role=\"application\"\n      style={{\n        width: isFlowingWidth ? 'max-content' : `${width}px`,\n        height: isFlowingHeight ? 'max-content' : `${height}px`,\n        gridTemplateRows: `repeat(${calcRowCount}, ${calcRowHeight}px)`,\n        gridTemplateColumns: `repeat(${calcColCount}, ${calcColWidth}px)`,\n        gap: `${gridGap}px`,\n        ...touchResponseStyle\n      }}\n      class={pictoStyleClasses}\n      {...testIdProps}\n      {...mergedEventProps}>\n      {elements.map((elt) => {\n        const isFocusedItem = focusedItemInfo.idx === elt.itemIdx;\n        const itemProps = getItemProps(\n          elt.item,\n          elt.itemIdx,\n          elt.countIdx,\n          isReadOnly,\n          hoveredItemInfo,\n          selectedIds,\n          focusedItemInfo,\n          highlightedIds,\n          activeId\n        );\n\n        const context = {\n          data: elt.item,\n          state: {\n            selected: itemProps.isSelected,\n            focused: itemProps.isFocused,\n            hovered: itemProps.isCurrent\n          }\n        };\n\n        return (\n          <PictoChartElement<K, D>\n            focusedItemRef={isFocusedItem ? focusedItemRef : undefined}\n            row={elt.row}\n            column={elt.col}\n            supportsSelection={supportsSelection}\n            supportsDrill={supportsDrill}\n            translations={translations}\n            totalCount={totalCount}\n            {...itemProps}>\n            {props.children(context)}\n          </PictoChartElement>\n        );\n      })}\n      {datatipContent}\n      {selectionContent}\n    </div>\n  );\n}\n","import { useCallback, useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport type {\n  ItemHoverDetail,\n  ItemFocusDetail,\n  ItemInfo,\n  PictoChartItemData,\n  ItemDrillDetail\n} from './pictoChart.type';\nimport { getItemInfo, isEqualItem } from './pictoChartUtils';\nimport { getRandomId } from '../utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { cancelEvent } from '../utils/UNSAFE_visUtils/eventsUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { useVisDrill } from '#hooks/PRIVATE_useVisDrill';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\n\nexport function useEvents<K, D extends PictoChartItemData<K>>(\n  touchResponse: 'touchStart' | 'touchHold',\n  isInteractive: boolean,\n  selectionMode: 'none' | 'single' | 'multiple',\n  getDetailFromInfo: (info?: ItemInfo) => ItemHoverDetail<K, D> | ItemFocusDetail<K, D>,\n  getPrevItemInfo: (info: ItemInfo) => ItemInfo,\n  getNextItemInfo: (info: ItemInfo) => ItemInfo,\n  drilling?: 'on' | 'off',\n  onItemDrill?: (detail: ItemDrillDetail<K, D>) => void,\n  onItemHover?: (detail: ItemHoverDetail<K, D>) => void,\n  onItemFocus?: (detail: ItemFocusDetail<K, D>) => void\n) {\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo>({ idx: 0 });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo>();\n\n  const activeId = useRef<string>();\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const onHover = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (!isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      if (isInteractive) {\n        setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n        onItemHover?.(getDetailFromInfo(itemInfo));\n      }\n    }\n  };\n\n  const onHoverLeave = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    if (isInteractive) {\n      onItemHover?.(getDetailFromInfo());\n    }\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n\n  const processDrill = useCallback(\n    (info?: ItemInfo) => {\n      const { id, data } = getDetailFromInfo(info);\n      if (id != null && data) {\n        onItemDrill?.({ id, data });\n        activeId.current = getRandomId();\n      }\n    },\n    [getDetailFromInfo, onItemDrill]\n  );\n\n  const onDrill = useCallback(\n    (event: Event) => {\n      if (event.type === 'keydown') {\n        if (drilling == 'on') processDrill(focusedItemInfo);\n      } else {\n        processDrill(getItemInfo(event.target as HTMLElement));\n      }\n    },\n    [drilling, focusedItemInfo, processDrill]\n  );\n\n  const drillProps = useVisDrill(selectionMode, onDrill);\n\n  if (!isInteractive) {\n    return {\n      focusedItemInfo,\n      hoveredItemInfo,\n      // include relevant hover handlers for datatip\n      eventsProps: hoverHandlers\n    };\n  }\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo) {\n    onItemFocus?.(getDetailFromInfo(itemInfo));\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item: ItemInfo) {\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab':\n        return;\n      case 'ArrowDown': {\n        const nextItemInfo = getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowUp': {\n        const nextItemInfo = getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowRight': {\n        const nextItemInfo = isRtl\n          ? getPrevItemInfo(focusedItemInfo)\n          : getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowLeft': {\n        const nextItemInfo = isRtl\n          ? getNextItemInfo(focusedItemInfo)\n          : getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const onKeyUp = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const onBlur = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onItemFocus?.(getDetailFromInfo(undefined));\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    eventsProps: mergeProps(drillProps, hoverHandlers, {\n      onKeyUp,\n      onKeyDown,\n      onBlur\n    })\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PictoChartItemData, PictoChartProps } from './pictoChart.type';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { PictoChartContext } from './PictoChartContext';\nimport { PictoChartWithDimensions } from './PictoChartWithDimensions';\n\n/**\n * A picto chart displays information using icons to visualize an absolute number or the relative sizes of the different parts of a population.\n */\nexport function PictoChart<\n  K extends string | number,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>({ width, height, ...props }: PictoChartProps<K, D>) {\n  //  TODO: investigate if we need to handle empty items for performance reasons.\n  const supportsSelection = !!(props.selectionMode && props.selectionMode !== 'none');\n\n  const isFlowingWidth = width === undefined;\n  const isFlowingHeight = height === undefined;\n\n  return (\n    <PictoChartContext.Provider value={{ supportsSelection }}>\n      <TrackResizeContainer\n        width={isFlowingWidth ? 'initial' : width}\n        height={isFlowingHeight ? 'initial' : height}>\n        {(width, height) => (\n          <PictoChartWithDimensions\n            width={width}\n            height={height}\n            isFlowingWidth={isFlowingWidth}\n            isFlowingHeight={isFlowingHeight}\n            {...props}\n          />\n        )}\n      </TrackResizeContainer>\n    </PictoChartContext.Provider>\n  );\n}\n"],"names":["PictoChartContext","createContext","GAP_RATIO","_ceil","a","b","Math","ceil","isOriginBottom","origin","isOriginRight","areCellsAvailable","map","col","row","columnSpan","rowSpan","r","c","occupyCells","findNextAvailableCell","colCount","rowCount","isVert","cell","undefined","getItemInfo","element","itemIdx","dataset","idx","Number","getItemProps","item","countIdx","isReadOnly","hoveredItem","selectedIds","focusedItem","highlightedIds","activeId","isCurrent","isFocusedItem","isHoveredItem","isHighlighted","id","length","Set","has","isItemHighlighted","isSelected","isItemSelected","hasSelection","isFocused","hasFocusRing","key","isEqualItem","item1","item2","itemInfo","isFocusVisible","getCountWithTotal","itemCount","totalCount","translations","vis_labelCountWithTotal","toString","PictoRenderer","context","markerProps","supportsSelection","useContext","markerProp","shape","color","isHuman","applyHover","isNoneEqualSides","rgba","colorSchemeVars","palette","neutral","outerBorderColor","textIcon","primary","markerShape","tx","ty","markerColor","borderColor","rgb","markerScale","setAspectRatioNone","getMarkerProps","state","focused","selected","hovered","_jsx","jsx","SvgSymbol","getItem","items","getPictoChartNavUtils","getDetailFromInfo","data","getPrevItemInfo","max","getNextItemInfo","min","usePictoChartDatatip","touchResponse","content","width","focusedItemRef","focusedItemInfo","direction","useUser","isRtl","itemDim","current","getBoundingClientRect","datatipContent","datatipProps","useDatatip","placement","offset","calculateOffset","anchor","PictoChartElement","props","isInteractive","supportsDrill","dimmedItemStyle","interactiveItemStyle","styles","itemClasses","classNames","isFirstElement","itemAriaProps","label","accessibleLabel","totalWithCountLabel","generateAriaLabel","role","getItemAriaProps","count","ref","style","gridRow","gridColumn","column","class","children","PictoChartWithDimensions","height","columnWidth","rowHeight","columnCount","layout","layoutOrigin","selectionMode","drilling","onItemDrill","onItemHover","isFlowingWidth","isFlowingHeight","onItemFocus","hasData","i","getTotalCount","useTranslationBundle","testIdProps","useTestId","testId","idToDataMap","Map","obj","touchResponseStyle","useVisTouchResponse","type","hoveredItemInfo","eventsProps","setfocusedItemInfo","useState","sethoveredItemInfo","useRef","hoverHandlers","useVisHover","event","target","getRandomId","processDrill","useCallback","info","onDrill","drillProps","useVisDrill","updatefocusedItemInfo","handleKeyboardInput","mergeProps","onKeyUp","code","cancelEvent","onKeyDown","onBlur","useEvents","selectionContent","selectionProps","useSelection","idExtracter","isDrillEnabled","selection","getDataById","get","onChange","onSelectionChange","rectangleWidth","parseFloat","rectangleHeight","pictoStyleClasses","baseStyles","useItemFocus","datatip","isPointerActive","_content","countWithTotal","_borderColor","datatipContext","getDatatipContent","calcColCount","calcRowCount","calcColWidth","calcRowHeight","gridGap","colWidth","numCells","maxColSpan","maxRowSpan","minSpan","Infinity","DEFAULT_SIZE","sqrt","floor","getFlowingInfo","datatipAriaDescribedby","elements","isLayoutBottom","isLayoutRight","pictoItems","Array","fill","currItem","push","generateElementCoords","mergedEventProps","_jsxs","tabIndex","merge","gridTemplateRows","gridTemplateColumns","gap","elt","itemProps","Provider","value","TrackResizeContainer","rendererOptions","markerRenderer","datatipRenderer"],"mappings":"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"}