{"version":3,"file":"Legend-e4949499.js","sources":["../../src/UNSAFE_Legend/legendNavUtils.ts","../../src/UNSAFE_Legend/getLegendLayout.ts","../../src/UNSAFE_Legend/Legend.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ItemActionDetail,\n  ItemFocusDetail,\n  ItemHoverDetail,\n  ItemInfo,\n  LegendItemData\n} from '#utils/UNSAFE_visTypes/legend';\n\nfunction getItem<K, D extends LegendItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { itemIdx } = itemInfo;\n\n  if (itemIdx == -1) {\n    return items[items.length - 1];\n  }\n  return items[itemIdx];\n}\n\nfunction getNextItemInfo<K>(itemInfo: ItemInfo, items: LegendItemData<K>[]) {\n  let itemIdx = itemInfo.itemIdx;\n\n  if (itemIdx == -1) {\n    itemIdx = items.length - 1;\n  }\n\n  itemIdx = Math.min(items.length - 1, itemIdx + 1);\n  if (items[itemIdx].actionable !== 'off') {\n    return { sectionIdx: 0, itemIdx };\n  } else if (itemIdx === items.length - 1) {\n    itemIdx = itemIdx - 1;\n    return { sectionIdx: 0, itemIdx };\n  }\n\n  return getNextItemInfo({ sectionIdx: 0, itemIdx }, items);\n}\n\nfunction getPrevItemInfo<K>(itemInfo: ItemInfo, items: LegendItemData<K>[]) {\n  let itemIdx = itemInfo.itemIdx;\n\n  if (itemIdx == -1) {\n    itemIdx = items.length - 1;\n  }\n\n  itemIdx = Math.max(0, itemIdx - 1);\n  if (items[itemIdx].actionable !== 'off') {\n    return { sectionIdx: 0, itemIdx };\n  }\n\n  return getPrevItemInfo({ sectionIdx: 0, itemIdx }, items);\n}\n\n/**\n * Returns utils functions for navigation in simple legend.\n * @param items\n * @returns\n */\nexport function getLegendNavUtils<K extends string | number, D extends LegendItemData<K>>(\n  items: D[]\n) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (\n      itemInfo?: ItemInfo\n    ): ItemFocusDetail<K, D> | ItemHoverDetail<K, D> | ItemActionDetail<K, D> => {\n      if (!itemInfo || items.length === 0) {\n        return { itemId: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { itemId: item.id, data: item };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo, items);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject } from 'preact';\nimport { LegendItemData } from '#utils/UNSAFE_visTypes/legend';\nimport { Font, TextDimensions, useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\n\ntype Props<K> = {\n  width: number;\n  getTextDimensions?: ((textString: string, font?: Font | undefined) => TextDimensions) | undefined;\n  resolvedVars: Record<string, any>;\n  rootRef: RefObject<HTMLDivElement>;\n  orientation?: 'vertical' | 'horizontal';\n  legendFontStylesObj?: Font;\n  symbolWidth?: number;\n  symbolHeight?: number;\n  items: LegendItemData<K>[];\n};\nexport type LayoutInfo = {\n  totalWidth: number;\n  maxItemWidth: number;\n  maxItemHeight: number;\n  itemsPerRow: number;\n  isWrapped?: boolean;\n};\ntype getTextDimensionsType = NonNullable<\n  NonNullable<ReturnType<typeof useTextDimensions>>['getTextDimensions']\n>;\n\nexport const getLinearLegendLayoutInfo = <K>({\n  width,\n  getTextDimensions,\n  resolvedVars,\n  rootRef,\n  orientation,\n  legendFontStylesObj = {},\n  symbolWidth,\n  items\n}: Props<K>) => {\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let totalWidth = 0;\n  let isWrapped = false;\n\n  const containerWidth = width;\n\n  if (!rootRef.current || !Object.keys(resolvedVars).length || !getTextDimensions) {\n    return;\n  }\n\n  const unitLength = parseFloat(resolvedVars['unit']);\n\n  const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth(\n    items,\n    unitLength,\n    getTextDimensions,\n    legendFontStylesObj,\n    symbolWidth\n  );\n  totalWidth = horizontalSectionWidth;\n  maxWidth = maxItemWidth;\n  maxHeight = maxItemHeight;\n  isWrapped = horizontalSectionWidth > containerWidth!;\n\n  const legendLayoutInfo = {\n    totalWidth,\n    maxItemWidth: Math.min(maxWidth, containerWidth!),\n    maxItemHeight: maxHeight,\n    itemsPerRow:\n      orientation === 'vertical' ? 1 : Math.max(1, Math.floor(containerWidth / maxWidth)),\n    isWrapped\n  };\n\n  return legendLayoutInfo;\n};\n\n/**\n * Returns maximum of the width among the items in a section of legend also return the width of the entire section.\n * @param items Legend items array\n * @param unitLength Base  element\n * @param getTextDimensions Text width measurement function\n * @param legendFontStylesObj Legend text font style properties object\n * @param symbolWidth Width of legend symbol\n *\n * @returns\n */\nconst getMaxWidth = <K>(\n  items: LegendItemData<K>[],\n  unitLength: number,\n  getTextDimensions: getTextDimensionsType,\n  legendFontStylesObj?: Font,\n  symbolWidth?: number,\n  symbolHeight?: number\n) => {\n  let maxItemWidth = 0;\n  let maxItemHeight = 0;\n  let horizontalSectionWidth = 0;\n  let itemSymbolWidth = 0;\n  let itemSymbolHeight = 0;\n  if (symbolWidth) {\n    itemSymbolWidth = unitLength * 1.5 + symbolWidth;\n  } else {\n    //itemSymbolWidth = marginLeft + marginRight + width below expression is simplified\n    itemSymbolWidth = 4 * unitLength;\n  }\n\n  if (symbolHeight) {\n    // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom\n    itemSymbolHeight = symbolHeight + unitLength * 1.7;\n  } else {\n    // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom\n    itemSymbolHeight = 2.5 * unitLength + unitLength * 1.7;\n  }\n\n  items?.forEach((item) => {\n    const legendItem = item as LegendItemData<K>;\n    const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);\n    //itemTextWidth = paddingLeft + paddingRight + width\n    const itemTextWidth = unitLength * 2.5 + width;\n    //horizontalSectionWidth = total width of the section\n    horizontalSectionWidth += itemSymbolWidth + itemTextWidth;\n    maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);\n    maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);\n  });\n\n  return { maxItemWidth, maxItemHeight, horizontalSectionWidth };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, VNode } from 'preact';\nimport { useRef, useState } from 'preact/hooks';\nimport { BaseLegend } from '#PRIVATE_BaseLegend/BaseLegend';\nimport { useVisEvent } from '#hooks/PRIVATE_useVisEvents/useVisEvents';\nimport { LegendProps, LegendDragStartDetail } from './legend.type';\nimport { getLegendNavUtils } from './legendNavUtils';\nimport {\n  getAriaProps,\n  getDatatipText,\n  getGridNums,\n  getIsLegendItemActionable,\n  getItemInfo,\n  getLegendTextStyle,\n  isEqualItem\n} from '#utils/PRIVATE_legendUtils/legendUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { useLegendDatatip } from './useLegendDatatip';\nimport { useItemFocus } from '#hooks/PRIVATE_useVisEvents';\nimport { styles } from '#PRIVATE_BaseLegend/themes/LegendStyles.css';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { legendVars, getKeyUpHandler } from '#utils/PRIVATE_legendUtils/legendUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport { useLegendContextMenu } from '#PRIVATE_BaseLegend/useLegendContextMenu';\nimport {\n  ItemFocusDetail,\n  ItemActionDetail,\n  ItemInfo,\n  LegendItemData\n} from '#utils/UNSAFE_visTypes/legend';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '#utils/UNSAFE_stringUtils';\nimport { forwardRef, useImperativeHandle } from 'preact/compat';\nimport { TrackResizeContainer } from '#PRIVATE_TrackResizeContainer';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { getLinearLegendLayoutInfo } from './getLegendLayout';\nimport { useLegendDnd } from '#hooks/PRIVATE_useLegendDnD/useLegendDnd';\nimport { styles as VisDndStyles } from '#hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css';\n\nexport type SizeHandle = {\n  _getPreferredSize: (\n    _width: number,\n    _height: number\n  ) => { width: number; height: number } | undefined;\n};\n\ntype ForwardRefLegend = <K extends string | number, D extends LegendItemData<K>>(\n  props: LegendProps<K, D> & { ref?: Ref<SizeHandle> }\n) => VNode | null;\n\n/**\n * A legend displays an interactive description of symbols, colors, etc., used in graphical information representations.\n */\nexport const Legend = forwardRef(\n  <K extends string | number, D extends LegendItemData<K>>(\n    {\n      orientation = 'horizontal',\n      items,\n      isReadOnly = true,\n      onItemAction,\n      onItemHover,\n      onItemFocus,\n      testId,\n      contextMenuConfig,\n      hideAndShowBehavior = 'off',\n      hoverBehavior = 'none',\n      halign = 'start',\n      valign = 'top',\n      ...props\n    }: LegendProps<K, D>,\n    ref: Ref<SizeHandle> = null\n  ) => {\n    return (\n      <TrackResizeContainer\n        width={'100%'}\n        height={'100%'}\n        class={classNames([\n          styles.flexStyle,\n          styles[`${halign}HAlign`],\n          styles[`${valign}VAlign`]\n        ])}>\n        {function _(width) {\n          const testIdProps = useTestId(testId);\n          const rootRef = useRef<HTMLDivElement>(null);\n          const isTestEnv = testIdProps['data-testid'] !== undefined;\n          const rootDimsRef = useRef<DOMRect>();\n          const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } =\n            getLegendNavUtils<K, D>(items);\n          const { resolvedVars, cssContent } = useCssVars(legendVars);\n          const legendFontStylesObj = getLegendTextStyle(\n            {\n              fontStyle: props.textFontStyle,\n              fontSize: props.textFontSize?.toString(),\n              fontWeight: props.textFontWeight?.toString(),\n              fontFamily: props.textFontFamily\n            },\n            resolvedVars\n          );\n          const { textMeasureContent, getTextDimensions } = useTextDimensions();\n          const layoutInfo = getLinearLegendLayoutInfo<K>({\n            width,\n            getTextDimensions,\n            resolvedVars,\n            rootRef,\n            orientation,\n            legendFontStylesObj,\n            symbolWidth: props.symbolWidth,\n            symbolHeight: props.symbolHeight,\n            items\n          });\n          const isLegendItemActionable = getIsLegendItemActionable(items, isReadOnly);\n          const hasData = items.length > 0;\n\n          const legendKeyUpHandler = (\n            triggerOnAction: () => void,\n            updatefocusedItemInfo: (itemInfo: ItemInfo) => void,\n            focusedItemInfo: ItemInfo\n          ) =>\n            getKeyUpHandler(\n              triggerOnAction,\n              updatefocusedItemInfo,\n              focusedItemInfo,\n              props.hiddenIds != null\n            );\n\n          const { touchResponse, touchResponseStyle } = useVisTouchResponse({ type: 'touchStart' });\n          const {\n            focusedItemInfo,\n            hoveredItemInfo,\n            onContextMenuDismissed,\n            activeId,\n            eventsProps\n          } = useVisEvent<ItemInfo, ItemActionDetail<K, D>, ItemFocusDetail<K, D>, D>(\n            touchResponse,\n            !isReadOnly,\n            isLegendItemActionable,\n            legendKeyUpHandler,\n            getDetailFromInfo,\n            getPrevItemInfo,\n            getNextItemInfo,\n            onItemAction,\n            onItemHover,\n            onItemFocus,\n            isEqualItem,\n            getItemInfo,\n            { itemIdx: 0, sectionIdx: 0 },\n            props.hiddenIds != null\n          );\n\n          const { focusedItemRef } = useItemFocus(focusedItemInfo);\n          const datatipText = getDatatipText(items, getItem, focusedItemInfo, hoveredItemInfo);\n          const [datatipDisabled, setDatatipDisabled] = useState(false);\n          const {\n            datatipContent,\n            datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n          } = useLegendDatatip({\n            text: datatipText,\n            rootDimsRef,\n            focusedItemInfo,\n            focusedItemRef,\n            touchResponse,\n            isDisabled: datatipDisabled\n          });\n\n          const ariaProps = getAriaProps<K>(\n            isReadOnly,\n            props['aria-label'],\n            props.hiddenIds,\n            merge([props['aria-describedby'], datatipAriaDescribedby]),\n            props['aria-labelledby']\n          );\n\n          const { contextMenuContent, contextMenuProps } = useLegendContextMenu<D>({\n            rootRef,\n            contextMenuConfig: hasData ? contextMenuConfig : undefined,\n            focusedItemInfo,\n            items,\n            isReadOnly,\n            onContextMenuDismissed\n          });\n\n          const [dragOver, setDragOver] = useState<boolean>();\n\n          const { draggable, dndProps, dndContent } = useLegendDnd<K, D, LegendDragStartDetail<D>>({\n            onDrag: props.onDrag,\n            onDragStart: props.onDragStart,\n            onDragEnd: props.onDragEnd,\n            onDragEnter: props.onDragEnter,\n            onDragLeave: props.onDragLeave,\n            onDragOver: props.onDragOver,\n            onDrop: props.onDrop,\n            items,\n            setDragOver,\n            setDatatipDisabled,\n            itemDraggable: props.itemDraggable\n          });\n\n          const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);\n          const { itemsPerCol, itemsPerRow } = getGridNums(items.length, layoutInfo);\n          const { legendStyle, renderedLegendStyle } = styles;\n\n          useImperativeHandle(\n            ref!,\n            () => ({\n              _getPreferredSize: (_width: number, _height: number) => {\n                if (!getTextDimensions) {\n                  return undefined;\n                }\n\n                const layoutInfo = getLinearLegendLayoutInfo({\n                  width: _width,\n                  getTextDimensions,\n                  resolvedVars,\n                  rootRef,\n                  orientation,\n                  legendFontStylesObj,\n                  symbolWidth: props.symbolWidth,\n                  symbolHeight: props.symbolHeight,\n                  items\n                });\n                const { itemsPerCol, itemsPerRow } = getGridNums(\n                  items.length,\n                  layoutInfo,\n                  orientation\n                );\n                const unitLength = parseFloat(resolvedVars['unit']);\n                const preferredWidth = Math.min(\n                  _width,\n                  itemsPerCol === 1\n                    ? layoutInfo!.totalWidth\n                    : itemsPerRow\n                    ? layoutInfo!.maxItemWidth * itemsPerRow!\n                    : layoutInfo!.totalWidth\n                );\n                const paddingLegendItems = 0.8 * unitLength;\n                const paddingLegendTopBottom = 1.5 * unitLength;\n\n                const legendHeight = itemsPerCol\n                  ? layoutInfo!.maxItemHeight * itemsPerCol! +\n                    (itemsPerCol! - 1) * paddingLegendItems +\n                    paddingLegendTopBottom\n                  : layoutInfo!.maxItemHeight + paddingLegendTopBottom;\n                const preferredHeight = Math.min(_height, legendHeight);\n\n                return { width: preferredWidth, height: preferredHeight };\n              }\n            }),\n            [rootRef, getTextDimensions, legendFontStylesObj, resolvedVars]\n          );\n\n          return (\n            <div\n              ref={rootRef}\n              tabIndex={isReadOnly ? undefined : 0}\n              role=\"application\"\n              draggable={draggable}\n              class={classNames([\n                legendStyle,\n                renderedLegendStyle,\n                dragOver\n                  ? VisDndStyles.dndDragOverHTMLStyle\n                  : dragOver === false\n                  ? VisDndStyles.dndRejectedStyle\n                  : undefined\n              ])}\n              style={touchResponseStyle}\n              {...testIdProps}\n              {...ariaProps}\n              {...mergedProps}\n              aria-activedescendant={activeId}>\n              <BaseLegend\n                {...props}\n                focusedItemRef={focusedItemRef}\n                items={items}\n                isReadOnly={isReadOnly}\n                orientation={orientation}\n                sectionIdx={0}\n                itemsPerRow={itemsPerRow}\n                itemsPerCol={itemsPerCol}\n                itemWidth={layoutInfo?.isWrapped ? layoutInfo?.maxItemWidth : undefined}\n                focusedItemInfo={focusedItemInfo}\n                hoveredItemInfo={hoveredItemInfo}\n                activeId={activeId}\n                hideAndShowBehavior={hideAndShowBehavior}\n                hoverBehavior={hoverBehavior}\n                isTestEnv={isTestEnv}\n              />\n              {datatipContent}\n              {textMeasureContent}\n              {cssContent}\n              {contextMenuContent}\n              {dndContent}\n            </div>\n          );\n        }}\n      </TrackResizeContainer>\n    );\n  }\n) as ForwardRefLegend;\n"],"names":["getItem","itemInfo","items","itemIdx","length","getNextItemInfo","Math","min","actionable","sectionIdx","getPrevItemInfo","max","getLegendNavUtils","getDetailFromInfo","itemId","undefined","data","item","id","getLinearLegendLayoutInfo","width","getTextDimensions","resolvedVars","rootRef","orientation","legendFontStylesObj","symbolWidth","maxWidth","maxHeight","totalWidth","isWrapped","containerWidth","current","Object","keys","unitLength","parseFloat","maxItemWidth","maxItemHeight","horizontalSectionWidth","getMaxWidth","itemsPerRow","floor","symbolHeight","itemSymbolWidth","itemSymbolHeight","forEach","legendItem","height","text","itemTextWidth","Legend","forwardRef","isReadOnly","onItemAction","onItemHover","onItemFocus","testId","contextMenuConfig","hideAndShowBehavior","hoverBehavior","halign","valign","props","ref","_jsx","jsx","TrackResizeContainer","class","classNames","styles","flexStyle","children","testIdProps","useTestId","useRef","isTestEnv","rootDimsRef","cssContent","useCssVars","legendVars","getLegendTextStyle","fontStyle","textFontStyle","fontSize","textFontSize","toString","fontWeight","textFontWeight","fontFamily","textFontFamily","textMeasureContent","useTextDimensions","layoutInfo","isLegendItemActionable","getIsLegendItemActionable","hasData","touchResponse","touchResponseStyle","useVisTouchResponse","type","focusedItemInfo","hoveredItemInfo","onContextMenuDismissed","activeId","eventsProps","useVisEvent","triggerOnAction","updatefocusedItemInfo","getKeyUpHandler","hiddenIds","isEqualItem","getItemInfo","focusedItemRef","useItemFocus","datatipText","getDatatipText","datatipDisabled","setDatatipDisabled","useState","datatipContent","datatipProps","datatipAriaDescribedby","useLegendDatatip","isDisabled","ariaProps","getAriaProps","merge","contextMenuContent","contextMenuProps","useLegendContextMenu","dragOver","setDragOver","draggable","dndProps","dndContent","useLegendDnd","onDrag","onDragStart","onDragEnd","onDragEnter","onDragLeave","onDragOver","onDrop","itemDraggable","mergedProps","mergeProps","itemsPerCol","getGridNums","legendStyle","renderedLegendStyle","useImperativeHandle","_getPreferredSize","_width","_height","preferredWidth","paddingLegendItems","paddingLegendTopBottom","legendHeight","_jsxs","tabIndex","role","VisDndStyles","dndDragOverHTMLStyle","dndRejectedStyle","style","BaseLegend","itemWidth"],"mappings":"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"}