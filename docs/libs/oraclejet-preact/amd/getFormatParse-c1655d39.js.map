{"version":3,"file":"getFormatParse-c1655d39.js","sources":["../../src/UNSAFE_IntlDateTime/CalendarUtils.ts","../../src/UNSAFE_IntlDateTime/ISODateTimezoneOffset.ts","../../src/UNSAFE_IntlDateTime/NativeDateTimeConstants.ts","../../src/UNSAFE_IntlDateTime/dateTimeUtils.ts","../../src/UNSAFE_IntlDateTime/NativeParserImpl.ts","../../src/UNSAFE_IntlDateTime/formatParse.ts","../../src/UNSAFE_IntlDateTime/getFormatParse.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n// This class fills in the localeElements by using the data from Intl.DateTimeFormat.\n// This data is used for parsing.\n\ntype WidthOptions = 'short' | 'narrow' | 'long';\nexport type CalendarWidthNames = 'abbreviated' | 'narrow' | 'wide';\n\ntype WeekdayNames = 'sun' | 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat';\n\ntype MonthType = {\n  '1': string;\n  '2': string;\n  '3': string;\n  '4': string;\n  '5': string;\n  '6': string;\n  '7': string;\n  '8': string;\n  '9': string;\n  '10': string;\n  '11': string;\n  '12': string;\n};\n\ntype DayType = {\n  sun: string;\n  mon: string;\n  tue: string;\n  wed: string;\n  thu: string;\n  fri: string;\n  sat: string;\n};\ntype DayPeriodType = {\n  am: string;\n  pm: string;\n};\ntype ErasWidthType = {\n  '0': string;\n  '1': string;\n};\ntype MonthWidthType = {\n  abbreviated: MonthType;\n  narrow: MonthType;\n  wide: MonthType;\n};\ntype DayWidthType = {\n  abbreviated: DayType;\n  narrow: DayType;\n  wide: DayType;\n};\ntype MonthsNodeType = {\n  format: MonthWidthType;\n  'stand-alone': MonthWidthType;\n};\ntype DaysNodeType = {\n  format: DayWidthType;\n  'stand-alone': DayWidthType;\n};\n\ntype DayPeriodFormatWidthType = {\n  wide: DayPeriodType;\n};\ntype DayPeriodsNodeType = {\n  format: DayPeriodFormatWidthType;\n};\ntype ErasType = {\n  eraNarrow: ErasWidthType;\n  eraAbbr: ErasWidthType;\n  eraName: ErasWidthType;\n};\nexport type CalendarNodeType = {\n  months: MonthsNodeType;\n  days: DaysNodeType;\n  dayPeriods: DayPeriodsNodeType;\n  eras: ErasType;\n  locale: string;\n};\n\ntype EraDesc = Array<{ era: string; start: string }>;\n\nexport class CalendarUtils {\n  // calendars[locale][calendarname]\n  public static calendars: Record<string, Record<string, CalendarNodeType>> | undefined;\n\n  private static readonly _monthNamesFormatMap = {\n    short: 'abbreviated',\n    narrow: 'narrow',\n    long: 'wide'\n  } as const;\n  private static readonly _weekdaysFormatMap = {\n    1: 'sun',\n    2: 'mon',\n    3: 'tue',\n    4: 'wed',\n    5: 'thu',\n    6: 'fri',\n    7: 'sat'\n  } as const;\n\n  // The following locales have month name like '1<literal>' (where literal is the lang's character for 'month')\n  // if we pass in the options\n  // month:'long' or month:'short' the corresponding pattern in CLDR is 'M<literal>'\n  // which is month numeric followed by the <literal>. As a result formatToParts\n  // will return {type: month, value:1} followed by {type: literal, value:<literal>}.\n  // These locales have same names for stand-alone and format month names.\n  // As a work around we will get the format month names for these\n  // locales using the stand-alone option instead of formatToParts.\n  // For example: in ja-JP locale we have:\n  // \"months\": {\n  //   \"format\": {\n  //       \"abbreviated\": {\n  //           \"1\": \"1\\u6708\",\n  //  }\n  // but the corresponding pattern is \"yMMMd\": \"y\\u5e74M\\u6708d\\u65e5\"\n  // so formatToParts will return\n  // {type: month, value:1} followed by {type: literal, value:'\\u6708d'}\n  // As a result we get '1' as month name in the calendar data instead of '1\\u6708'\n\n  private static exceptionLocales = [\n    'ja',\n    'ja-JP',\n    'zh',\n    'zh-Hans',\n    'zh-Hans-CN',\n    'zh-Hans-HK',\n    'zh-Hans-MO',\n    'zh-Hans-SG',\n    'zh-Hant',\n    'zh-Hant-HK',\n    'zh-Hant-MO',\n    'zh-Hant-TW'\n  ];\n  // Uses the Intl.DateTimeFormat formatToParts to get the day periods.\n  // Returns this object\n  // \"dayPeriods\": {\n  //  \"format\": {\n  //    \"wide\": {\n  //      \"am\": \"AM\",\n  //      \"pm\": \"PM\"\n  //    }}}\n  private static _getDayPeriods(locale: string, calendar: string) {\n    const date = new Date(2019, 0, 1, 0, 0, 0);\n\n    function getDayPeriodsFromFormatToParts(formatter: Intl.DateTimeFormat) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'dayPeriod');\n      // TODO Era is failing for chinese calendar. Need to fix it\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n    const options: {\n      hour: Intl.DateTimeFormatOptions['hour'];\n      hour12: Intl.DateTimeFormatOptions['hour12'];\n    } = { hour: 'numeric', hour12: true };\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n    const amValue = getDayPeriodsFromFormatToParts(formatter);\n    date.setHours(20);\n    const pmValue = getDayPeriodsFromFormatToParts(formatter);\n    return { format: { wide: { am: amValue, pm: pmValue } } };\n  }\n\n  private static getFormatterLocale(locale: string, calendar: string) {\n    return locale + '-u-ca-' + calendar;\n  }\n\n  // Example of an eras from localeElements is this, but this fn gets all the data, not just eraAbbr.\n  // \"eras\": {\n  //   \"eraAbbr\": {\n  //     \"0\": \"BC\",\n  //     \"1\": \"AD\"\n  //   }\n  // },\n  private static _getEras(locale: string, calendar: string) {\n    const eras: EraDesc = [{ era: '0', start: '2000-02-11T00:00:00' }];\n    const cal: ErasType = {\n      eraNarrow: { '0': '', '1': '' },\n      eraAbbr: { '0': '', '1': '' },\n      eraName: { '0': '', '1': '' }\n    };\n\n    function getEraFromFormatToParts(formatter: Intl.DateTimeFormat, date: Date) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'era');\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n\n    const eraLenArray: Array<NonNullable<Intl.DateTimeFormatOptions['era']>> = [\n      'narrow',\n      'short',\n      'long'\n    ];\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    // get the erra name for narrow, short, long.\n    // e.g., A, AD, Anno Domini\n    // this is used to map the era option value from Intl.DateTimeFormat to\n    // what we want to short in our CalendarNode\n    const eraMap = {\n      narrow: 'eraNarrow',\n      short: 'eraAbbr',\n      long: 'eraName'\n    };\n\n    for (let i = 0; i < eras.length; i++) {\n      const date = new Date(eras[i].start);\n      for (let j = 0; j < eraLenArray.length; j++) {\n        const eraLenName = eraLenArray[j];\n        const options: {\n          year: Intl.DateTimeFormatOptions['year'];\n          month: Intl.DateTimeFormatOptions['month'];\n          day: Intl.DateTimeFormatOptions['day'];\n          era: Intl.DateTimeFormatOptions['era'];\n        } = { year: 'numeric', month: 'numeric', day: 'numeric', era: eraLenName };\n        const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n        const eraForLength = getEraFromFormatToParts(formatter, date);\n        const eraNameForNode = eraMap[eraLenName] as keyof ErasType;\n        const eraObj = { '0': eraForLength, '1': eraForLength };\n        cal[eraNameForNode] = eraObj;\n      }\n    }\n    return cal;\n  }\n\n  private static _fillMonthAndDays(\n    locale: string,\n    calendar: string,\n    widthVal: CalendarWidthNames,\n    options: Intl.DateTimeFormatOptions,\n    isStandAlone: boolean\n  ) {\n    // These date are used to fill in the months and weekdays.\n    // Each date is a different day of week and month. Like, the first is sun in January, the second is mon in Feb, etc.\n    // If you know that a specific date, such as January 5, 2020, falls on a Sunday in Los Angeles, you can safely assume that it's also a Sunday in China.\n    // This assumption is based on the consistency of the seven-day week cycle used worldwide\n    // and the fact that days of the week are determined by the Earth's rotation.\n    const dates: Array<Array<number>> = [\n      [2020, 0, 5],\n      [2020, 1, 3],\n      [2020, 2, 3],\n      [2020, 3, 1],\n      [2020, 4, 7],\n      [2020, 5, 5],\n      [2020, 6, 4],\n      [2020, 7, 1],\n      [2020, 8, 1],\n      [2020, 9, 1],\n      [2020, 10, 1],\n      [2020, 11, 1]\n    ];\n\n    function getMonthFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const monthPart = formatParts.find((value) => value.type === 'month');\n      if (monthPart) {\n        return monthPart.value;\n      }\n      return null;\n    }\n\n    function getWeekdayFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const weekdayPart = formatParts.find((value) => value.type === 'weekday');\n      if (weekdayPart) {\n        return weekdayPart.value;\n      }\n      return null;\n    }\n\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n\n    type MonthFormatType = {\n      abbreviated?: Partial<MonthType>;\n      narrow?: Partial<MonthType>;\n      wide?: Partial<MonthType>;\n    };\n    type DayFormatType = {\n      abbreviated?: Partial<DayType>;\n      narrow?: Partial<DayType>;\n      wide?: Partial<DayType>;\n    };\n    const calMonthFormat: MonthFormatType = {};\n    const calDayFormat: DayFormatType = {};\n\n    // It loops from 0 to 12, dates is for each month. [0] is the year, [1] is the month, [2] is the day\n    // create a new date with year, month, day. each date[j] is a different month of the year, and it also has a different weekday.\n    for (let j = 0; j < dates.length; j++) {\n      const index = j + 1; // 1 to 12\n      const dayIndexVal: WeekdayNames =\n        CalendarUtils._weekdaysFormatMap[index as keyof typeof CalendarUtils._weekdaysFormatMap];\n      const date = new Date(dates[j][0], dates[j][1], dates[j][2]);\n      const formatParts = formatter.formatToParts(date);\n      let month;\n      let weekday;\n      // for stand-alone (e.g., {month: 'short'}), there is only one entry, so we can just get the\n      // value of format. No need for formatToParts to pull out just the month piece.\n      // Note that for ja format gives you the month kanji character too and formatToParts month is only the number. The kanji character is in the literal.\n      if (isStandAlone) {\n        month = formatter.format(date);\n        weekday = formatter.format(date);\n      } else {\n        month = getMonthFromFormatToParts(formatParts);\n        weekday = getWeekdayFromFormatToParts(formatParts);\n      }\n      // store the month and weekday in the obj; only fill in weekday if (index <= 7)\n      if (calMonthFormat[widthVal] === undefined) {\n        calMonthFormat[widthVal] = {};\n      }\n      // @ts-ignore\n      calMonthFormat[widthVal][index] = month;\n      if (index <= 7) {\n        if (calDayFormat[widthVal] === undefined) {\n          calDayFormat[widthVal] = {};\n        }\n        // @ts-ignore\n        calDayFormat[widthVal][dayIndexVal] = weekday;\n      }\n    }\n    return {\n      monthFormat: calMonthFormat, // This will be an object like {'abbreviated': Partial<MonthType}\n      dayFormat: calDayFormat\n    };\n  }\n\n  private static _getFormatMonthAndDays(locale: string, calendar: string) {\n    const calMonths = [];\n    const calDays = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        month: types[i],\n        weekday: types[i],\n        year: 'numeric',\n        day: 'numeric'\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthDayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        false\n      );\n\n      calMonths[i] = monthDayObjForWidth.monthFormat;\n      calDays[i] = monthDayObjForWidth.dayFormat;\n    }\n\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myDayObj = Object.assign({}, ...calDays);\n\n    const myMonthFormatObj: Partial<MonthsNodeType> = {};\n    myMonthFormatObj.format = myMonthObj;\n    const myDayFormatObj: Partial<DaysNodeType> = {};\n    myDayFormatObj.format = myDayObj;\n\n    myMonthFormatObj['stand-alone'] = myMonthFormatObj.format;\n    myDayFormatObj['stand-alone'] = myDayFormatObj.format;\n\n    return {\n      monthsNode: myMonthFormatObj as MonthsNodeType,\n      daysNode: myDayFormatObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneDays(locale: string, calendar: string) {\n    const calDays = [];\n    // Intl.DateTimeFormat's weekday can take: \"long\" (e.g., Monday)\"short\" (e.g., Mon) \"narrow\" (e.g., M).\n    // stand-alone weekday is displayed when the options conatin only one attribute weekday: options = {weekday:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        weekday: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const dayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calDays[i] = dayObjForWidth.dayFormat;\n    }\n    const myDayObj = Object.assign({}, ...calDays);\n    const myDayStandAloneObj = { 'stand-alone': {} };\n    myDayStandAloneObj['stand-alone'] = myDayObj;\n    return {\n      daysNode: myDayStandAloneObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneMonths(locale: string, calendar: string) {\n    const calMonths = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    // stand-alone month is displayed when the options conatin only one attribute month: options = {month:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options = {\n        month: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calMonths[i] = monthObjForWidth.monthFormat;\n    }\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myMonthStandAloneObj = { 'stand-alone': {} };\n    myMonthStandAloneObj['stand-alone'] = myMonthObj;\n    return {\n      monthsNode: myMonthStandAloneObj as MonthsNodeType\n    };\n  }\n  /**\n   * Fills in CalendarUtils.calendars[locale][calendar] public static object.\n   * @param locale locale name\n   * @param calendar calendar name\n   */\n  public static getCalendar(locale: string, calendar: string): CalendarNodeType {\n    CalendarUtils.calendars = CalendarUtils.calendars ?? {};\n    CalendarUtils.calendars[locale] = CalendarUtils.calendars[locale] ?? {};\n\n    if (CalendarUtils.calendars[locale][calendar] === undefined) {\n      const dayPeriodsObj = CalendarUtils._getDayPeriods(locale, calendar);\n      const erasObj = CalendarUtils._getEras(locale, calendar);\n      let monthFormat;\n      let dayFormat;\n      const standAloneMonths = CalendarUtils._getStandAloneMonths(locale, calendar);\n      const standAloneDays = CalendarUtils._getStandAloneDays(locale, calendar);\n      const useStandAlone = CalendarUtils.exceptionLocales.includes(locale);\n      // TODO this might only be needed for gregorian calendar. Need to check when\n      // we support other calendars\n      if (useStandAlone) {\n        monthFormat = standAloneMonths.monthsNode['stand-alone'];\n        dayFormat = standAloneDays.daysNode['stand-alone'];\n      } else {\n        const monthsDaysNodeObj = CalendarUtils._getFormatMonthAndDays(locale, calendar);\n        monthFormat = monthsDaysNodeObj.monthsNode.format;\n        dayFormat = monthsDaysNodeObj.daysNode.format;\n      }\n      const monthsNodes: MonthsNodeType = {\n        format: monthFormat,\n        'stand-alone': standAloneMonths.monthsNode['stand-alone']\n      };\n      const daysNodes: DaysNodeType = {\n        format: dayFormat,\n        'stand-alone': standAloneDays.daysNode['stand-alone']\n      };\n      CalendarUtils.calendars[locale][calendar] = {\n        dayPeriods: dayPeriodsObj,\n        months: monthsNodes,\n        days: daysNodes,\n        eras: erasObj,\n        locale: locale\n      };\n    }\n    return CalendarUtils.calendars[locale][calendar];\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type DateDef = {\n  year: number;\n  month: number; // 1-based!\n  date: number;\n  hours: number;\n  minutes: number;\n};\n// cache the converters\nconst formatterCache: Map<string, Intl.DateTimeFormat> = new Map();\n\nexport function getISODateOffset(date: DateDef, timeZone: string): number {\n  // Get the timezone-adjusted representation of the date parameter interpreted as UTC\n  const d = new Date(Date.UTC(date.year, date.month - 1, date.date, date.hours, date.minutes));\n  const utcDateAtTimezone = _applyTimezoneToDate(d, timeZone);\n  // get the offset of the target timezone (subject to a possible DTS change ajustment)\n  const offset = _getOffset(date, utcDateAtTimezone);\n  let adjustment = 0;\n  d.setTime(d.getTime() - offset * 60000);\n\n  // check whether the offset is correct\n  if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n    // try to accommodate 'fall back'/move 1 hour west\n    adjustment = -60;\n    d.setTime(d.getTime() + 60 * 60000);\n    if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n      // spring forward/move 1 hour east\n      // This case should always produce a match unless we are hitting the missing hour during the 'spring forward'\n      // JS Date() favors the DST in this case, so we will remain at the 'spring forward' offset even if _compareDates()\n      // would have returned false\n      adjustment = 60;\n      d.setTime(d.getTime() - 120 * 60000);\n    }\n  }\n  const result = offset + adjustment;\n  return result;\n}\n\nfunction _applyTimezoneToDate(d: Date, timeZone: string): DateDef {\n  const cnv = _getConverter(timeZone);\n  const formattedUTC = cnv.format(d);\n  const [localDate, localTime] = formattedUTC.split(',');\n  const [month, date, year] = localDate.split('/');\n  const [hours, minutes] = localTime.trim().split(':');\n  return {\n    year: parseInt(year),\n    month: parseInt(month),\n    date: parseInt(date),\n    hours: parseInt(hours),\n    minutes: parseInt(minutes)\n  };\n}\n\nfunction _getOffset(original: DateDef, asUTC: DateDef): number {\n  let originalMins = original.hours * 60 + original.minutes;\n  let utcMinutes = asUTC.hours * 60 + asUTC.minutes;\n  // any shift in year, month or day indicates the following day\n  let delta = original.year - asUTC.year;\n  if (delta == 0) {\n    delta = original.month - asUTC.month;\n    if (delta === 0) {\n      delta = original.date - asUTC.date;\n    }\n  }\n  if (delta > 0) {\n    originalMins += 24 * 60;\n  } else if (delta < 0) {\n    utcMinutes += 24 * 60;\n  }\n  return utcMinutes - originalMins;\n}\n\nfunction _compareDates(date1: DateDef, date2: DateDef) {\n  return (\n    date1.year === date2.year &&\n    date1.month === date2.month &&\n    date1.hours === date2.hours &&\n    date1.minutes === date2.minutes\n  );\n}\n\nfunction _getConverter(timezone: string) {\n  let formatter = formatterCache.get(timezone);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('en-US', {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      hourCycle: 'h23',\n      timeZone: timezone\n    });\n    formatterCache.set(timezone, formatter);\n  }\n  return formatter;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport class NativeDateTimeConstants {\n  public static readonly _YEAR_AND_DATE_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _YMD_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _TIME_REGEXP =\n    /(\\d{1,2})(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,3}))?/g;\n  public static readonly _TIME_FORMAT_REGEXP = /h|H|K|k/g;\n\n  public static readonly _YEAR_REGEXP = /y{1,4}/;\n  public static readonly _MONTH_REGEXP = /M{1,5}/;\n  public static readonly _DAY_REGEXP = /d{1,2}/;\n  public static readonly _WEEK_DAY_REGEXP = /E{1,5}/;\n  public static readonly _HOUR_REGEXP = /h{1,2}|k{1,2}/i;\n  public static readonly _MINUTE_REGEXP = /m{1,2}/;\n  public static readonly _SECOND_REGEXP = /s{1,2}/;\n  public static readonly _FRACTIONAL_SECOND_REGEXP = /S{1,3}/;\n  public static readonly _AMPM_REGEXP = /a{1,2}/;\n  public static readonly _WORD_REGEXP = '(\\\\D+?\\\\s*)';\n\n  // This eslint disable require to make eacs happy\n  // eslint-disable-next-line no-useless-escape\n  public static readonly _ESCAPE_REGEXP = /([\\^$.*+?|\\[\\](){}])/g;\n\n  public static readonly _TOKEN_REGEXP =\n    /ccccc|cccc|ccc|cc|c|EEEEE|EEEE|EEE|EE|E|dd|d|MMMMM|MMMM|MMM|MM|M|LLLLL|LLLL|LLL|LL|L|yyyy|yy|y|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|aa|a|SSS|SS|S|zzzz|zzz|zz|z|v|ZZZ|ZZ|Z|XXX|XX|X|VV|GGGGG|GGGG|GGG|GG|G/g;\n  public static readonly _ZULU = 'zulu';\n  public static readonly _LOCAL = 'local';\n  public static readonly _AUTO = 'auto';\n  public static readonly _INVARIANT = 'invariant';\n  public static readonly _OFFSET = 'offset';\n  public static readonly _ALNUM_REGEXP = '(\\\\D+|\\\\d\\\\d?\\\\D|\\\\d\\\\d?|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_REGEXP = '(\\\\D+|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_OPT_REGEXP = '(\\\\D*)';\n  public static readonly _STR_REGEXP = '(.+?)';\n  public static readonly _TWO_DIGITS_REGEXP = '(\\\\d\\\\d?)';\n  public static readonly _THREE_DIGITS_REGEXP = '(\\\\d{1,3})';\n  public static readonly _FOUR_DIGITS_REGEXP = '(\\\\d{1,4})';\n  public static readonly _SLASH_REGEXP = '(\\\\/)';\n\n  public static readonly _PROPERTIES_MAP = {\n    MMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'wide',\n      matchIndex: 0,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'narrow',\n      matchIndex: 0,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'wide',\n      matchIndex: 1,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'narrow',\n      matchIndex: 1,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    E: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'wide',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'narrow',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    c: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'wide',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'narrow',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    h: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    hh: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    K: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    KK: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    H: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    HH: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    k: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    kk: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    m: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    mm: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    s: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    ss: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    S: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SSS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    d: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: 'numeric',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    dd: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: '2-digit',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    M: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    MM: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    L: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    LL: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    y: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    yy: {\n      token: 'year',\n      key: 'year',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    yyyy: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    a: {\n      token: 'ampm',\n      key: 'dayPeriod',\n      value: undefined,\n      regExp: NativeDateTimeConstants._WORD_REGEXP\n    },\n    z: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    v: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzzz: {\n      token: 'tzFull',\n      key: 'timeZoneName',\n      value: 'long',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    Z: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    X: {\n      token: 'tzh',\n      key: 'tzh',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XX: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XXX: {\n      token: 'tzhsepm',\n      key: 'tzhsepm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    VV: {\n      token: 'tzid',\n      key: 'tzid',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    G: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraName',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraNarrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    '/': {\n      token: 'slash',\n      regExp: NativeDateTimeConstants._SLASH_REGEXP\n    }\n  };\n\n  public static readonly FRACTIONAL_SECOND_MAP = {\n    a: {\n      key: 'dayPeriod',\n      token: 'dayPeriod',\n      value: 'narrow'\n    },\n    SSS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 3\n    },\n    SS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 2\n    },\n    S: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 1\n    }\n  };\n  // Map between tokens length and options\n  public static readonly _tokenMap = {\n    era: { short: 'GGG', long: 'GGGG', narrow: 'GGGGG' },\n    month: { short: 'MMM', long: 'MMMM', narrow: 'MMMMM', numeric: 'M', '2-digit': 'MM' },\n    weekday: { short: 'EEE', long: 'EEEE', narrow: 'EEEEE' },\n    year: { numeric: 'y', '2-digit': 'yy' },\n    day: { numeric: 'd', '2-digit': 'dd' },\n    hour: { numeric: 'h', '2-digit': 'hh' },\n    minute: { numeric: 'm', '2-digit': 'mm' },\n    second: { numeric: 's', '2-digit': 'ss' },\n    fractionalSecond: { 1: 'S', 2: 'SS', 3: 'SSS' },\n    timeZoneName: { short: 'z', long: 'zzzz' }\n  };\n  // Map between tokens and timeStyle and dateStyle\n  // Always set year to y, hour to h, minute to m, and second to s\n  // We need to get the pattern from the options. It is only needed by parse,\n  // prase does not care of the difference between h an hh, y and yy because\n  // they are all numeric. so 2021/09/01 is equivalent to 21/9/1 because the\n  // pattern is (\\d)+/(\\d)+/(\\(d)+ matches both of inputs\n  public static readonly _dateTimeFormats = {\n    dateStyle: {\n      full: { year: 'y', month_s: 'MM', month_m: 'MMMM', weekday: 'EEEE', day: 'd' },\n      long: { year: 'y', month_s: 'MM', month_m: 'MMMM', day: 'd' },\n      medium: { year: 'y', month_s: 'MM', month_m: 'MMM', day: 'd' },\n      short: { year: 'y', month_s: 'M', month_m: 'MMM', day: 'd' }\n    },\n    timeStyle: {\n      full: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'zzzz' },\n      long: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'z' },\n      medium: { hour: 'h', minute: 'mm', second: 'ss' },\n      short: { hour: 'h', minute: 'mm' }\n    }\n  };\n  // letters a-z and A-Z are reserved for date-time tokens in the pattern\n  // they need to be surrounded by single quote if they are not a token.\n  // for example at should appear as 'at' in the pattern\n  public static readonly _ALPHA_REGEXP = /([a-zA-Z]+)/;\n  public static readonly _HOUR12_REGEXP = /h/g;\n  public static readonly _hourCycleMap = {\n    h12: 'h',\n    h23: 'H',\n    h11: 'K',\n    h24: 'k'\n  };\n  // zh-TW locales have different symbols for pm depending on the time.\n  // The following entries are noon, after noon, and evening\n  public static readonly _zh_tw_locales = ['zh-TW', 'zh-Hant', 'zh-Hant-TW'];\n  public static readonly _zh_tw_pm_symbols = ['\\u4e2d\\u5348', '\\u4e0b\\u5348', '\\u665a\\u4e0a'];\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\n/**\n * Date time utilities.\n */\n\nconst regexTrim = /^\\s+|\\s+$|\\u200f|\\u200e/g;\nconst regexTrimNumber = /\\s+|\\u200f|\\u200e/g;\nconst regexTrimRightZeros = /0+$/g;\nconst zeros = ['0', '00', '000'];\n\n// ISO 8601 string accepted values:\n// -date only: YYYY or YYYY-MM or YYYY-MM-dd\n// -time only without timezone: Thh:mm or Thh:mm:ss or Thh:mm:ss.SSS\n// -time only with timezone: any of the time values above followed by any of the following:\n// Z or +/-hh:mm or +/-hhmm or +/-hh\n// -date time: any of the date values followed by any of the time values\nexport const _ISO_DATE_REGEXP =\n  /^[+-]?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d+)?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?)?$|^T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d+)?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?$/;\n\nconst _ISO_DATE_ONLY_REGEXP = /^[+-]?\\d{4}-\\d{2}-\\d{2}$/;\n\n/**\n * Returns true if the value represents a date-only ISO string.\n *\n * @param {string} value\n * @returns true if the string represents a date-only ISO string\n */\nexport function isDateOnlyIsoString(value?: string | null) {\n  // If value is undefined/null, returns true.\n  // If value is empty or blank string, returns false.\n  // Otherwise checks value against the regexp.\n  const isValid =\n    value === undefined || value === null\n      ? true\n      : value.trim().length > 0\n      ? _ISO_DATE_ONLY_REGEXP.test(value.trim())\n      : false;\n  return isValid;\n}\n\nexport function startsWith(value: string, pattern: string) {\n  return value.indexOf(pattern) === 0;\n}\n\nexport function trim(value: string) {\n  return (value + '').replace(regexTrim, '');\n}\n\nexport function trimRightZeros(value: string) {\n  return (value + '').replace(regexTrimRightZeros, '');\n}\n\nexport function trimNumber(value: string) {\n  const s = (value + '').replace(regexTrimNumber, '');\n  return s;\n}\n\nexport function toUpper(value: string) {\n  // \"he-IL\" has non-breaking space in weekday names.\n  return value.split('\\u00A0').join(' ').toUpperCase();\n}\n\nexport function padZeros(num: number, c: number) {\n  let s = num + '';\n  let isNegative = false;\n  if (num < 0) {\n    s = s.substr(1);\n    isNegative = true;\n  }\n  if (c > 1 && s.length < c) {\n    s = zeros[c - 2] + s;\n    s = s.substr(s.length - c, c);\n  }\n  if (isNegative) {\n    s = '-' + s;\n  }\n  return s;\n}\n\nexport function zeroPad(str: string, count: number, left: boolean) {\n  let result = '' + str;\n\n  for (let l = result.length; l < count; l += 1) {\n    result = left ? '0' + result : result + '0';\n  }\n  return result;\n}\n\nfunction _throwInvalidISOStringRange(\n  isoStr: string,\n  name: string,\n  displayValue: string | number,\n  displayLow: number,\n  displayHigh: number\n) {\n  const msg =\n    'The string ' +\n    isoStr +\n    ' is not a valid ISO 8601 string: ' +\n    displayValue +\n    ' is out of range.  Enter a value between ' +\n    displayLow +\n    ' and ' +\n    displayHigh +\n    ' for ' +\n    name;\n\n  const errorInfo = {\n    cause: {\n      code: 'isoStringOutOfRange',\n      parameterMap: {\n        isoStr: isoStr,\n        value: displayValue,\n        minValue: displayLow,\n        maxValue: displayHigh,\n        propertyName: name\n      }\n    }\n  };\n\n  const rangeError = new (RangeError as any)(msg, errorInfo);\n  throw rangeError;\n}\n\nfunction _throwInvalidISOStringSyntax(str: string) {\n  const msg = 'The string ' + str + ' is not a valid ISO 8601 string syntax.';\n  const errorInfo = {\n    cause: {\n      code: 'invalidISOString',\n      parameterMap: {\n        isoStr: str\n      }\n    }\n  };\n  const e = new (Error as any)(msg, errorInfo);\n  throw e;\n}\n\n/**\n * <p>Returns a local ISO string provided a Date object.\n * This method can be used to convert a moment in time or a local ISO string into\n * a local ISO string. It can also be used to convert any Date object into local ISO\n * string.</p>\n * Examples below are where the local (user's system) time zone is UTC-06:00<br>\n * dateToLocalIso(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03T22:00:00'<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03T20:30:00'<br>\n * In this example the input ISO string is local, the output is the same:<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00')); -->'2021-06-04T02:30:00'<br>\n * In this example we just want to convert a Date object:<br>\n * dateToLocalIso(new Date());<br>\n */\nexport function dateToLocalIso(_date: Date | number) {\n  let date = _date;\n  if (typeof date === 'number') {\n    date = new Date(date);\n  }\n  let isoStr =\n    padZeros(date.getFullYear(), 4) +\n    '-' +\n    padZeros(date.getMonth() + 1, 2) +\n    '-' +\n    padZeros(date.getDate(), 2) +\n    'T' +\n    padZeros(date.getHours(), 2) +\n    ':' +\n    padZeros(date.getMinutes(), 2) +\n    ':' +\n    padZeros(date.getSeconds(), 2);\n  if (date.getMilliseconds() > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(date.getMilliseconds(), 3));\n  }\n  return isoStr;\n}\n\nexport function isLeapYear(y: number) {\n  if (y % 400 === 0) {\n    return true;\n  } else if (y % 100 === 0) {\n    return false;\n  } else if (y % 4 === 0) {\n    return true;\n  }\n  return false;\n}\n\n// Get days in month depending on month and leap year\nexport function getDaysInMonth(y: number, m: number) {\n  switch (m) {\n    case 0:\n    case 2:\n    case 4:\n    case 6:\n    case 7:\n    case 9:\n    case 11:\n      return 31;\n    case 1:\n      if (isLeapYear(y)) {\n        return 29;\n      }\n      return 28;\n    default:\n      return 30;\n  }\n}\n\nexport function IsoStrParts(isoString: string) {\n  const tst = _ISO_DATE_REGEXP.test(isoString);\n  if (tst === false) {\n    _throwInvalidISOStringSyntax(isoString);\n  }\n  const splitted = isoString.split('T');\n  const tIndex = isoString.indexOf('T');\n  const today = new Date();\n  let i;\n  let isBC = false;\n  const datetime = [today.getFullYear(), today.getMonth() + 1, today.getDate(), 0, 0, 0, 0];\n\n  if (splitted[0] !== '') {\n    // contains date portion\n    // test if date is BC, year is negative\n    if (startsWith(splitted[0], '-')) {\n      splitted[0] = splitted[0].slice(1);\n      isBC = true;\n    }\n    const dateSplitted = splitted[0].split('-');\n    for (i = 0; i < dateSplitted.length; i++) {\n      const val = parseInt(dateSplitted[i], 10);\n      // validate month\n      if (i === 1) {\n        if (val < 1 || val > 12) {\n          _throwInvalidISOStringRange(isoString, 'month', val, 1, 12);\n        }\n      }\n      // validate day\n      if (i === 2) {\n        const nbDays = getDaysInMonth(datetime[0], datetime[1] - 1);\n        if (val < 1 || val > nbDays) {\n          _throwInvalidISOStringRange(isoString, 'day', val, 1, nbDays);\n        }\n      }\n      datetime[i] = val;\n    }\n    if (isBC) {\n      datetime[0] = -datetime[0];\n    }\n  }\n\n  if (tIndex !== -1) {\n    const milliSecSplitted = splitted[1].split('.'); // contain millseconds\n    const timeSplitted = milliSecSplitted[0].split(':'); // contain hours, minutes, seconds\n\n    for (i = 0; i < timeSplitted.length; i++) {\n      const tVal = parseInt(timeSplitted[i], 10);\n      // validate hour\n      if (i === 0) {\n        if (tVal < 0 || tVal > 24) {\n          _throwInvalidISOStringRange(isoString, 'hour', tVal, 0, 24);\n        }\n      }\n      // validate minute\n      if (i === 1) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'minute', tVal, 0, 59);\n        }\n      }\n      // validate second\n      if (i === 2) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'second', tVal, 0, 59);\n        }\n      }\n      datetime[3 + i] = tVal;\n    }\n\n    if (milliSecSplitted.length === 2 && milliSecSplitted[1]) {\n      datetime[6] = parseInt(zeroPad(milliSecSplitted[1], 3, false), 10);\n    }\n  }\n  return datetime;\n}\n\nfunction _toBoolean(value: any) {\n  if (typeof value === 'string') {\n    const s = value.toLowerCase().trim();\n    switch (s) {\n      case 'true':\n      case '1':\n        return true;\n      case 'false':\n      case '0':\n        return false;\n      default:\n        return value;\n    }\n  }\n  return value;\n}\n\n// Return a function getOption.\n// The getOption function extracts the value of the property named\n// property from the provided options object, converts it to the required type,\n// checks whether it is one of a List of allowed values, and fills in a\n// fallback value if necessary.\nexport function getGetOption(options: NativeDateTimeResolvedOptions, getOptionCaller: string) {\n  if (options === undefined) {\n    throw new Error('Internal ' + getOptionCaller + ' error. Default options missing.');\n  }\n\n  const getOption = function (property: any, type: any, values: any, defaultValue: any) {\n    if ((options as any)[property] !== undefined) {\n      let value = (options as any)[property];\n      switch (type) {\n        case 'boolean':\n          value = _toBoolean(value);\n          break;\n        case 'string':\n          value = String(value);\n          break;\n        case 'number':\n          value = Number(value);\n          break;\n        default:\n          throw new Error('Internal error. Wrong value type.');\n      }\n      if (values !== undefined && values.indexOf(value) === -1) {\n        const expectedValues = [];\n        for (let i = 0; i < values.length; i++) {\n          expectedValues.push(values[i]);\n        }\n        const msg =\n          \"The value '\" +\n          (options as any)[property] +\n          \"' is out of range for '\" +\n          getOptionCaller +\n          \"' options property '\" +\n          property +\n          \"'. Valid values: \" +\n          expectedValues;\n        const rangeError = new RangeError(msg);\n        const errorInfo = {\n          errorCode: 'optionOutOfRange',\n          parameterMap: {\n            propertyName: property,\n            propertyValue: (options as any)[property],\n            propertyValueValid: expectedValues,\n            caller: getOptionCaller\n          }\n        };\n        (rangeError as any).errorInfo = errorInfo;\n        throw rangeError;\n      }\n\n      return value;\n    }\n    return defaultValue;\n  };\n\n  return getOption;\n}\n\nexport function partsToIsoString(parts: any) {\n  let isoStr =\n    padZeros(parts[0], 4) +\n    '-' +\n    padZeros(parts[1], 2) +\n    '-' +\n    padZeros(parts[2], 2) +\n    'T' +\n    padZeros(parts[3], 2) +\n    ':' +\n    padZeros(parts[4], 2) +\n    ':' +\n    padZeros(parts[5], 2);\n  if (parts[6] > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(parts[6], 3));\n  }\n  return isoStr;\n}\n\n/**\n * Returns a local Date object from a local ISO string. This method is only meant\n * to work with local ISO strings. If the input ISO string contain Z or offset,\n * they will be ignored.\n * @param {string} isoString\n * @memberof oj.OraI18nUtils\n * @method isoToLocalDate\n */\nexport function isoToLocalDate(isoString: string) {\n  if (!isoString || typeof isoString !== 'string') {\n    return null;\n  }\n  return _isoToLocalDateIgnoreTimezone(isoString);\n}\n\nfunction _isoToLocalDateIgnoreTimezone(isoString: string) {\n  const datetime = IsoStrParts(isoString);\n  const date = new Date(\n    datetime[0],\n    datetime[1] - 1,\n    datetime[2],\n    datetime[3],\n    datetime[4],\n    datetime[5],\n    datetime[6]\n  );\n  // As per the documentation:\n  // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);\n  // year - Integer value representing the year and\n  // values from 0 to 99 map to the years 1900 to 1999; all other values are the actual year.\n  // Use Date.prototype.setFullYear to create dates between the years 0 and 99.\n  date.setFullYear(datetime[0]);\n  return date;\n}\n\nexport function getISOStrFormatInfo(isoStr: string) {\n  const res: any = {\n    format: null,\n    dateTime: null,\n    timeZone: '',\n    isoStrParts: null\n  };\n  const exe: any = _ISO_DATE_REGEXP.exec(isoStr);\n\n  if (exe === null) {\n    _throwInvalidISOStringSyntax(isoStr);\n  }\n  if (exe && exe[1] === undefined && exe[2] === undefined) {\n    res.format = 'local';\n    res.dateTime = isoStr;\n    res.isoStrParts = IsoStrParts(res.dateTime);\n    return res;\n  }\n  res.timeZone = exe[1] !== undefined ? exe[1] : exe[2];\n  if (res.timeZone === 'Z') {\n    res.format = 'zulu';\n  } else {\n    res.format = 'offset';\n  }\n  const isoStrLen = isoStr.length;\n  const timeZoneLen = res.timeZone.length;\n  res.dateTime = isoStr.substring(0, isoStrLen - timeZoneLen);\n  res.isoStrParts = IsoStrParts(res.dateTime);\n  return res;\n}\n\nexport function getTimeStringFromOffset(\n  prefix: string,\n  offset: number,\n  reverseSign: boolean,\n  alwaysMinutes: boolean\n) {\n  const isNegative = reverseSign ? offset > 0 : offset < 0;\n  const absOffset = Math.abs(offset);\n  let hours: any = Math.floor(absOffset / 60);\n  const minutes: any = absOffset % 60;\n  const sign = isNegative ? '-' : '+';\n\n  if (alwaysMinutes) {\n    hours = zeroPad(hours, 2, true);\n  }\n  let str = prefix + sign + hours;\n  if (minutes > 0 || alwaysMinutes) {\n    str += ':' + zeroPad(minutes, 2, true);\n  }\n  return str;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarNodeType } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError, FormatParseErrorOptions } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\ninterface ParsedObjectType {\n  value: string;\n  warning: string;\n}\n\ninterface RangeType {\n  name: string;\n  value: number;\n  low: number;\n  high: number;\n  displayValue: number;\n  displayLow: number;\n  displayHigh: number;\n}\n// cache locale system time zone\nlet localSystemTimeZone: string | null = null;\n\nexport class NativeParserImpl {\n  public static parseImpl(\n    str: string,\n    pattern: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    let dtStyle = 0;\n    // First try if str is an iso 8601 string\n    const testIsoStr = LocalOraI18nUtils._ISO_DATE_REGEXP.test(str);\n    let parsedIsoStr = '';\n    let isoStrInfo = null;\n    let res: any;\n    if (testIsoStr === true) {\n      parsedIsoStr = str;\n      dtStyle = this._isoStrDateTimeStyle(str);\n    } else {\n      dtStyle = this._dateTimeStyle(resOptions);\n      res = this._parseExact(str, pattern, resOptions, cal);\n      parsedIsoStr = res.value;\n    }\n    isoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(parsedIsoStr);\n    if (resOptions.timeZone !== undefined && isoStrInfo.format !== NativeDateTimeConstants._LOCAL) {\n      this._adjustHours(isoStrInfo, resOptions);\n    }\n    parsedIsoStr = this._createParseISOStringFromDate(dtStyle, isoStrInfo, resOptions);\n    if (res === undefined) {\n      res = { value: parsedIsoStr, warning: null };\n    } else {\n      res.value = parsedIsoStr;\n      res.warning = null;\n    }\n    // If the returned ISO string is date-time and isoStrFormat is local,\n    // log a warning saying that local is not supported for date-time iso strings\n    // and return offset instead\n    if (dtStyle === 2 && resOptions.isoStrFormat === NativeDateTimeConstants._LOCAL) {\n      // Disable warning since it causes noise in test runs.\n      // TODO: Re-enable once JET-59083 is fixed.\n      //Logger.warn(\n      //  'isoStrFormat was set to local for date-time ISO string. local was ignored and parse returned an ISO string with offset.'\n      //);\n    }\n    return res;\n  }\n  // appends pre- and post- token match strings while removing escaped\n  // characters.\n  // Returns a single quote count which is used to determine if the\n  // token occurs\n  // in a string literal.\n  private static _appendPreOrPostMatch(preMatch: string, strings: Array<string>): number {\n    let quoteCount = 0;\n    let escaped = false;\n    for (let i = 0, il = preMatch.length; i < il; i++) {\n      const c = preMatch.charAt(i);\n      switch (c) {\n        case \"'\":\n          if (escaped) {\n            strings.push(\"'\");\n          } else {\n            quoteCount += 1;\n          }\n          escaped = false;\n          break;\n        case '\\\\':\n          if (escaped) {\n            strings.push('\\\\');\n          }\n          escaped = !escaped;\n          break;\n        default:\n          strings.push(c);\n          escaped = false;\n          break;\n      }\n    }\n    return quoteCount;\n  }\n\n  private static _validateRange(range: RangeType) {\n    if (range.value < range.low || range.value > range.high) {\n      const msg =\n        range.displayValue +\n        ' is out of range.  Enter a value between ' +\n        range.displayLow +\n        ' and ' +\n        range.displayHigh +\n        ' for ' +\n        range.name;\n\n      const errorInfo: FormatParseErrorOptions = {\n        cause: {\n          code: 'datetimeOutOfRange',\n          parameterMap: {\n            value: range.displayValue,\n            minValue: range.displayLow,\n            maxValue: range.displayHigh,\n            propertyName: range.name\n          }\n        }\n      };\n      const rangeError = new (RangeError as any)(msg, errorInfo);\n      throw rangeError;\n    }\n  }\n\n  // Throw an exception if date-time pattern is invalid\n  private static _throwInvalidDateFormat(\n    format: string,\n    options: NativeDateTimeOptions | NativeDateTimeResolvedOptions,\n    m: string\n  ) {\n    const isDate =\n      options.year !== undefined ||\n      options.month !== undefined ||\n      options.weekday !== undefined ||\n      options.day !== undefined;\n    const isTime =\n      options.hour !== undefined || options.minute !== undefined || options.second !== undefined;\n\n    let samplePattern = '';\n    if (isDate && isTime) {\n      samplePattern = 'MM/dd/yy hh:mm:ss a';\n    } else if (isDate) {\n      samplePattern = 'MM/dd/yy';\n    } else {\n      samplePattern = 'hh:mm:ss a';\n    }\n\n    const msg =\n      'Unexpected character(s) ' +\n      m +\n      ' encountered in the pattern \"' +\n      format +\n      ' An example of a valid pattern is \"' +\n      samplePattern +\n      '\".';\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'optionValueInvalid',\n        parameterMap: {\n          propertyName: 'pattern',\n          propertyValue: format\n        }\n      }\n    };\n    const error = new (SyntaxError as any)(msg, errorInfo);\n    throw error;\n  }\n  // parse functions\n  private static _throwWeekdayMismatch(weekday: string, day: number) {\n    const msg = 'The weekday ' + weekday + ' does not match the date ' + day;\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'dateToWeekdayMismatch',\n        parameterMap: {\n          weekday: weekday,\n          date: day\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _throwDateFormatMismatch(value: string, format: string, style: number) {\n    let msg = '';\n    let errorCodeType = '';\n\n    if (style === 2) {\n      msg =\n        'The value \"' + value + '\" does not match the expected date-time format \"' + format + '\"';\n      errorCodeType = 'datetimeFormatMismatch';\n    } else if (style === 0) {\n      msg = 'The value \"' + value + '\" does not match the expected date format \"' + format + '\"';\n      errorCodeType = 'dateFormatMismatch';\n    } else {\n      msg = 'The value \"' + value + '\" does not match the expected time format \"' + format + '\"';\n      errorCodeType = 'timeFormatMismatch';\n    }\n\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: errorCodeType,\n        parameterMap: {\n          value: value,\n          format: format\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _parseTimezoneOffset(_offset: string): Array<number> {\n    const parts: Array<string> = _offset.split(':');\n    const offsetParts = new Array<number>(2);\n\n    // offset is +hh:mm\n    if (parts.length === 2) {\n      offsetParts[0] = parseInt(parts[0], 10);\n      offsetParts[1] = parseInt(parts[1], 10);\n    } else if (_offset.length === 2 || _offset.length === 3) {\n      // offset is +hh or +h\n      offsetParts[0] = parseInt(_offset, 10);\n      offsetParts[1] = 0;\n    } else {\n      // offset is +hhmm\n      offsetParts[0] = parseInt(_offset.substr(0, 3), 10);\n      offsetParts[1] = parseInt(_offset.substr(3), 10);\n    }\n    return offsetParts;\n  }\n\n  private static _expandYear(start2DigitYear: number, year: number): number {\n    // expands 2-digit year into 4 digits.\n    year = Number(year);\n    if (year < 100) {\n      const ambiguousTwoDigitYear = start2DigitYear % 100;\n      // eslint-disable-next-line no-param-reassign\n      year += Math.floor(start2DigitYear / 100) * 100 + (year < ambiguousTwoDigitYear ? 100 : 0);\n    }\n    return year;\n  }\n\n  private static _arrayIndexOfMonthOrDay(\n    monthsDaysData: any,\n    userInput: string,\n    type: 'months' | 'days'\n  ): number {\n    const trimUserInput = NativeParserImpl.toUpperTrimmedNoPeriod(userInput);\n    const keys = Object.keys(monthsDaysData);\n    for (let i = 0; i < keys.length; i++) {\n      const valueFromData = monthsDaysData[keys[i]];\n      const trimValueFromData = NativeParserImpl.toUpperTrimmedNoPeriod(valueFromData);\n      // first try an exact match.\n      if (trimUserInput === trimValueFromData) {\n        return i;\n      }\n\n      // Test if user input is a number. We don't use parseInt because we want\n      // to make sure trimUserInput is only number lie '5' and not '5abc'\n      if (type === 'months') {\n        const trimUserInputNumber = Number(trimUserInput);\n        // In some locales the month name is something like 1月. Remove the literal\n        // before compare in case the user enters only 1.\n        const numberPartFromData = parseInt(trimValueFromData);\n        if (Number.isInteger(numberPartFromData) && Number.isInteger(trimUserInputNumber)) {\n          if (numberPartFromData === trimUserInputNumber) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n\n  private static toUpperTrimmedNoPeriod(value: string) {\n    let trimItem = LocalOraI18nUtils.toUpper(value);\n    trimItem = LocalOraI18nUtils.trim(trimItem);\n    // In some locales the short month name ends with '.', remove it in case\n    // the user does not enter the dot at the end of the month name.\n    trimItem = trimItem.replace(/\\.$/, '');\n    return trimItem;\n  }\n\n  private static _getDayIndex(calNode: CalendarNodeType, value: string) {\n    let ret = 0;\n    let days = [];\n    const calDaysFmt = calNode.days.format;\n    const calDaysStdAlone = calNode.days['stand-alone'];\n    days = [\n      calDaysFmt.abbreviated,\n      calDaysFmt.wide,\n      calDaysStdAlone.abbreviated,\n      calDaysStdAlone.wide\n    ];\n    for (let m = 0; m < days.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(days[m], value, 'days');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  private static _getMonthIndex(calNode: CalendarNodeType, value: string) {\n    let ret = -1;\n    const calMonthsFmt = calNode.months.format;\n    const calMonthsStdAlone = calNode.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStdAlone.wide,\n      calMonthsStdAlone.abbreviated\n    ];\n    for (let m = 0; m < months.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(months[m], value, 'months');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  // converts a format string into a regular expression with groups that\n  // can be used to extract date fields from a date string.\n  // check for a cached parse regex.\n  private static _getParseRegExp(format: string, options: NativeDateTimeResolvedOptions): any {\n    //let re = {};\n    // expand single digit formats, then escape regular expression\n    //  characters.\n    const expFormat = format.replace(NativeDateTimeConstants._ESCAPE_REGEXP, '\\\\\\\\$1');\n    const regexp = ['^'];\n    const groups = [];\n    let index = 0;\n    let quoteCount = 0;\n    // iterate through each date token found.\n    let match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    while (match !== null) {\n      const preMatch = expFormat.slice(index, match.index);\n      index = NativeDateTimeConstants._TOKEN_REGEXP.lastIndex;\n\n      // don't replace any matches that occur inside a string literal.\n      quoteCount += this._appendPreOrPostMatch(preMatch, regexp);\n      if (quoteCount % 2) {\n        regexp.push(match[0]);\n      } else {\n        // add a regex group for the token.\n        const m = match[0];\n        let add = '';\n        if ((NativeDateTimeConstants._PROPERTIES_MAP as any)[m] !== undefined) {\n          add = (NativeDateTimeConstants._PROPERTIES_MAP as any)[m].regExp;\n        } else {\n          this._throwInvalidDateFormat(format, options, m);\n        }\n        if (add) {\n          regexp.push(add);\n        }\n        groups.push(match[0]);\n      }\n      match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    }\n    this._appendPreOrPostMatch(expFormat.slice(index), regexp);\n    regexp.push('$');\n\n    // allow whitespace to differ when matching formats.\n    const regexpStr = regexp.join('').replace(/\\s+/g, '\\\\s+');\n    const parseRegExp = {\n      regExp: regexpStr,\n      groups: groups\n    };\n    // cache the regex for this format.\n    //re[format] = parseRegExp;\n    return parseRegExp;\n  }\n\n  private static _getTokenIndex(arr: Array<any>, token: string): number {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i][token] !== undefined) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // time lenient parse\n  private static _parseLenienthms(\n    result: Date,\n    timepart: string,\n    format: string,\n    dtype: number,\n    calNode: CalendarNodeType\n  ) {\n    // hour, optional minutes and optional seconds\n    (NativeDateTimeConstants._TIME_REGEXP as any).lastIndex = 0;\n    let hour = 0;\n    let minute = 0;\n    let second = 0;\n    let msec = 0;\n    let idx;\n    let match: any = NativeDateTimeConstants._TIME_REGEXP.exec(timepart);\n    let range: RangeType;\n    if (match === null) {\n      this._throwDateFormatMismatch(timepart, format, dtype);\n    }\n    if (match[1] !== undefined) {\n      hour = parseInt(match[1], 10);\n    }\n    if (match[2] !== undefined) {\n      minute = parseInt(match[2], 10);\n    }\n    if (match[3] !== undefined) {\n      second = parseInt(match[3], 10);\n    }\n    if (match[4] !== undefined) {\n      msec = parseInt(match[4], 10);\n    }\n\n    (NativeDateTimeConstants._TIME_FORMAT_REGEXP as any).lastIndex = 0;\n    match = NativeDateTimeConstants._TIME_FORMAT_REGEXP.exec(format);\n    switch (match[0]) {\n      case 'h':\n        // Hour in am/pm (1-12)\n        if (hour === 12) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 12\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'K':\n        // Hour in am/pm (0-11)\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 11\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'H':\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 23\n        };\n        this._validateRange(range);\n        break;\n      case 'k':\n        if (hour === 24) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 24\n        };\n        break;\n      default:\n        break;\n    }\n    // Minutes.\n    range = {\n      name: 'minute',\n      value: minute,\n      low: 0,\n      high: 59,\n      displayValue: minute,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // Seconds.\n    range = {\n      name: 'second',\n      value: second,\n      low: 0,\n      high: 59,\n      displayValue: second,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // millisec\n    range = {\n      name: 'farctionalSecond',\n      value: msec,\n      low: 0,\n      high: 999,\n      displayValue: msec,\n      displayLow: 0,\n      displayHigh: 999\n    };\n    this._validateRange(range);\n    result.setHours(hour, minute, second, msec);\n  }\n\n  private static _getWeekdayName(value: string, calNode: CalendarNodeType): string | null {\n    const calDaysFmt = calNode.days.format;\n    const calDaysStandAlone = calNode.days['stand-alone'];\n    const days = [\n      calDaysFmt.wide,\n      calDaysFmt.abbreviated,\n      calDaysStandAlone.wide,\n      calDaysStandAlone.abbreviated\n    ];\n\n    for (let i = 0; i < days.length; i++) {\n      const dayKeys = Object.keys(days[i]);\n      for (let j = 0; j < dayKeys.length; j++) {\n        const dName = (days as any)[i][dayKeys[j]];\n        const dRegExp = new RegExp(dName + '\\\\b', 'i');\n        if (dRegExp.test(value)) {\n          return dName;\n        }\n      }\n    }\n    return null;\n  }\n\n  // lenient parse yMd and yMEd patterm. Must have year, moth,\n  // date all numbers. Ex: 5/3/2013\n  // weekday is optional. If present it must match date.\n  // Ex:  Tuesday 11/19/2013\n  // if year is 3-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // if date > 12 it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    (NativeDateTimeConstants._YMD_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YMD_REGEXP.exec(value);\n    let dtype = 0;\n    if (match === null) {\n      dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(value, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        M: format.indexOf('M')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundDayIndex = 0;\n    let i = 0;\n    const dayIndex = this._getTokenIndex(tokenIndexes, 'd');\n    let foundYear = false;\n    let foundDay = false;\n\n    for (i = 1; i <= 3; i++) {\n      const tokenMatch: string = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n    }\n    // find day if day value > 12\n    for (i = 0; i < 3; i++) {\n      if (i !== yearIndex && match[i + 1] > 12) {\n        day = match[i + 1];\n        foundDay = true;\n        foundDayIndex = i;\n        break;\n      }\n    }\n    if (!foundDay) {\n      if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      } else if (yearIndex === this._getTokenIndex(tokenIndexes, 'M')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n      } else {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    } else {\n      for (i = 0; i < 3; i++) {\n        if (i !== foundDayIndex && i !== yearIndex) {\n          month = match[i + 1];\n          break;\n        }\n      }\n      if (month === undefined) {\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    }\n    month -= 1;\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    let range: RangeType;\n    // if both month and day > 12 and swapped, throw exception\n    // based on original order\n    if (foundDay && dayIndex !== foundDayIndex && month > 12) {\n      range = {\n        name: 'month',\n        value: day,\n        low: 0,\n        high: 11,\n        displayValue: day,\n        displayLow: 1,\n        displayHigh: 12\n      };\n      this._validateRange(range);\n    }\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    // locate weekday\n    const dName = this._getWeekdayName(value, cal);\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YMD_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  // lenient parse yMMMd and yMMMEd patterns. Must have year, date as numbers\n  // and month name.\n  // weekday is optional. If present it must match date.\n  // Ex:  Monday Nov, 11 2013\n  // weekday and month name can be anywhere in the string.\n  // if year > 2-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMMMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    const origValue = value;\n    // eslint-disable-next-line no-param-reassign\n    value = LocalOraI18nUtils.toUpper(value);\n    // locate month name\n    const calMonthsFmt = cal.months.format;\n    const calMonthsStandAlone = cal.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStandAlone.wide,\n      calMonthsStandAlone.abbreviated\n    ];\n    let foundMatch = false;\n    let reverseMonth = [];\n    let i = 0;\n    let mName = '';\n    for (i = 0; i < months.length; i++) {\n      reverseMonth = [];\n      const monthKeys = Object.keys(months[i]);\n      let j = 0;\n      for (j = 0; j < monthKeys.length; j++) {\n        mName = LocalOraI18nUtils.toUpper(months[i][monthKeys[j]]);\n        reverseMonth.unshift({\n          idx: j,\n          name: mName\n        });\n      }\n\n      reverseMonth.sort(function (a, b) {\n        return b.idx - a.idx;\n      });\n\n      for (j = 0; j < reverseMonth.length; j++) {\n        mName = reverseMonth[j].name;\n        // JET-65914. Do not match if month name is a number in locale data.\n        // Only match strings otherwise we match wrong field. for numeric\n        // month names _parseLenientyMEd will be invoked\n        if (value.indexOf(mName) !== -1 && isNaN(+mName)) {\n          foundMatch = true;\n          // eslint-disable-next-line no-param-reassign\n          value = value.replace(mName, '');\n          break;\n        }\n      }\n      if (foundMatch) {\n        break;\n      }\n    }\n    // There is no month name. Try yMEd lenient parse.\n    if (!foundMatch) {\n      return this._parseLenientyMEd(origValue, format, options, cal, isDateTime);\n    }\n\n    const month = this._getMonthIndex(cal, mName);\n    let range: RangeType = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n\n    // locate weekday\n    const dName = this._getWeekdayName(origValue, cal);\n    const dRegExp = new RegExp(dName + '\\\\W', 'i');\n    if (dName !== null) {\n      // eslint-disable-next-line no-param-reassign\n      value = value.replace(dRegExp, '');\n    }\n    // find year and date\n    (NativeDateTimeConstants._YEAR_AND_DATE_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.exec(value);\n    if (match === null) {\n      const dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(origValue, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n\n    let year = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundYear = false;\n    for (i = 1; i <= 2; i++) {\n      const tokenMatch = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    }\n    if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    } else {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'd') + 1], 10);\n    }\n\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  private static _parseLenient(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    const dtStyle = this._dateTimeStyle(options);\n    let result: ParsedObjectType;\n    switch (dtStyle) {\n      case 0:\n        // date style\n        result = this._parseLenientyMMMEd(value, format, options, cal, false);\n        break;\n      case 1:\n        // time style\n        const d = new Date();\n        this._parseLenienthms(d, value, format, 1, cal);\n        const isoStr = LocalOraI18nUtils.dateToLocalIso(d);\n        result = { value: isoStr, warning: 'lenient parsing was used' };\n        break;\n      case 2:\n        // date-time style\n        result = this._parseLenientyMMMEd(value, format, options, cal, true);\n        break;\n      default:\n        result = { value: '', warning: 'lenient parsing was used' };\n        break;\n    }\n    // convert result to gregorian\n    const parts = LocalOraI18nUtils.IsoStrParts(result.value);\n    const gregParts = [parts[0], parts[1], parts[2]];\n    const isoParts = result.value.split('T');\n    result.value =\n      LocalOraI18nUtils.padZeros(gregParts[0], 4) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[1], 2) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[2], 2) +\n      'T' +\n      isoParts[1];\n    return result;\n  }\n\n  private static _getNameIndex(\n    calNode: CalendarNodeType,\n    datePart: string,\n    matchGroup: string,\n    mLength: any,\n    style: any,\n    // @ts-ignore\n    matchIndex: number,\n    start1: number,\n    end1: number,\n    start2: string,\n    end2: string,\n    name: string\n  ): number {\n    let index = 0;\n    const monthsFormat = (calNode as any)[datePart][style];\n    if (datePart === 'months') {\n      index = this._getMonthIndex(calNode, matchGroup);\n    } else {\n      index = this._getDayIndex(calNode, matchGroup);\n    }\n    const startName = monthsFormat[mLength][start2];\n    const endName = monthsFormat[mLength][end2];\n    const range = {\n      name: name,\n      value: index,\n      low: start1,\n      high: end1,\n      displayValue: parseInt(matchGroup),\n      displayLow: startName,\n      displayHigh: endName\n    };\n    this._validateRange(range);\n    return index;\n  }\n\n  private static _validateTimePart(\n    matchInt: number,\n    _timeObj: any,\n    objMap: any,\n    timeToken: string\n  ) {\n    const timeObj = _timeObj;\n    timeObj[objMap.timePart] = matchInt;\n    if (timeToken === 'h' || timeToken === 'hh') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'k' || timeToken === 'kk') {\n      timeObj.htoken = timeToken;\n      if (matchInt === 24) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'K' || timeToken === 'KK') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    }\n    const range: RangeType = {\n      name: objMap.timePart,\n      value: timeObj[objMap.timePart],\n      low: objMap.start1,\n      high: objMap.end1,\n      displayValue: matchInt,\n      displayLow: objMap.start2,\n      displayHigh: objMap.end2\n    };\n    this._validateRange(range);\n  }\n\n  // test if the pattern/options is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _dateTimeStyle(resOptions: NativeDateTimeResolvedOptions): number {\n    const isTime =\n      resOptions.hour !== undefined ||\n      resOptions.minute !== undefined ||\n      resOptions.second !== undefined ||\n      resOptions.fractionalSecondDigits !== undefined;\n    const isDate =\n      resOptions.year !== undefined ||\n      resOptions.month !== undefined ||\n      resOptions.day !== undefined ||\n      resOptions.weekday !== undefined;\n    if (isDate && isTime) {\n      return 2;\n    } else if (isTime) {\n      return 1;\n    } else if (isDate) {\n      return 0;\n    }\n    // try predefined style\n    if (resOptions.dateStyle !== undefined && resOptions.timeStyle !== undefined) {\n      return 2;\n    }\n    if (resOptions.timeStyle !== undefined) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // for zh-TW locales the pm symbol can vary depending on the time. We need\n  // to iterate through the pm symbols in order to find a match.\n  private static _matchPMSymbol(cal: CalendarNodeType, matchGroup: string) {\n    const loc = cal.locale;\n    let isPM = false;\n    let i = 0;\n    if (NativeDateTimeConstants._zh_tw_locales.includes(loc)) {\n      const pmSymbols = NativeDateTimeConstants._zh_tw_pm_symbols;\n      for (i = 0; i < pmSymbols.length; i++) {\n        const pmSymbol = pmSymbols[i];\n        if (matchGroup.indexOf(pmSymbol) !== -1) {\n          return true;\n        }\n      }\n    } else {\n      const calPM = cal.dayPeriods.format.wide.pm;\n      isPM = LocalOraI18nUtils.toUpper(matchGroup).indexOf(LocalOraI18nUtils.toUpper(calPM)) !== -1;\n    }\n    return isPM;\n  }\n\n  // exact match parsing for date-time. If it fails, try lenient parse.\n  private static _parseExact(\n    value: string,\n    format: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): any {\n    // remove spaces from era.\n    const eraPart = cal.eras.eraAbbr['1'];\n    const trimEraPart = LocalOraI18nUtils.trimNumber(eraPart);\n    // eslint-disable-next-line no-param-reassign\n    value = value.replace(eraPart, trimEraPart);\n    const getOption = LocalOraI18nUtils.getGetOption(resOptions, 'NativeDateTimeConverter.parse');\n    const lenientParse = getOption('lenientParse', 'string', ['none', 'full'], 'full');\n    const dtStyle = this._dateTimeStyle(resOptions);\n\n    // convert date formats into regular expressions with groupings.\n    // use the regexp to determine the input format and extract the date\n    //  fields.\n    const parseInfo = this._getParseRegExp(format, resOptions);\n    const match: any = new RegExp(parseInfo.regExp).exec(value);\n    if (match === null) {\n      if (lenientParse === 'full') {\n        return this._parseLenient(value, format, resOptions, cal);\n      }\n      this._throwDateFormatMismatch(value, format, dtStyle);\n    }\n    // found a date format that matches the input.\n    const groups = parseInfo.groups;\n    let year = null;\n    let month: any = null;\n    let date = null;\n    let weekDay = null;\n    let hourOffset = '';\n    let tzID = null;\n    let pmHour = undefined;\n    let weekDayName = '';\n    let range: RangeType;\n    const timeObj = {\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisec: 0,\n      htoken: ''\n    };\n    const start2DigitYear = resOptions.twoDigitYearStart || 1950;\n    // iterate the format groups to extract and set the date fields.\n    for (let j = 0, jl = groups.length; j < jl; j++) {\n      const matchGroup = match[j + 1];\n      if (matchGroup) {\n        const current = groups[j];\n        const matchInt = parseInt(matchGroup, 10);\n        const currentGroup = (NativeDateTimeConstants._PROPERTIES_MAP as any)[current];\n\n        switch (currentGroup.token) {\n          case 'months':\n            month = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.mLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              11,\n              '1',\n              '12',\n              'month name'\n            );\n            break;\n          case 'days':\n            weekDayName = matchGroup;\n            weekDay = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.dLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              6,\n              'sun',\n              'sat',\n              'weekday'\n            );\n            break;\n          case 'time':\n            this._validateTimePart(matchInt, timeObj, currentGroup, current);\n            break;\n          case 'dayOfMonth':\n            date = matchInt;\n            break;\n          case 'monthIndex':\n            // Month.\n            month = matchInt - 1;\n            // try lenient parse for date style only\n            if (month > 11 && lenientParse === 'full') {\n              try {\n                return this._parseLenient(value, format, resOptions, cal);\n              } catch (e) {\n                range = {\n                  name: 'month',\n                  value: month,\n                  low: 0,\n                  high: 11,\n                  displayValue: month + 1,\n                  displayLow: 1,\n                  displayHigh: 12\n                };\n                this._validateRange(range);\n              }\n            }\n            break;\n          case 'year':\n            year = this._expandYear(start2DigitYear, matchInt);\n            break;\n          case 'ampm':\n            pmHour = this._matchPMSymbol(cal, matchGroup);\n            break;\n          case 'tzhm':\n            // Time zone hours minutes: -0800\n            hourOffset = matchGroup.substr(-2);\n            hourOffset = matchGroup.substr(0, 3) + ':' + hourOffset;\n            break;\n          case 'tzhsepm':\n            // Time zone hours minutes: -08:00\n            hourOffset = matchGroup;\n            break;\n          case 'tzh':\n            // Time zone hours minutes: -08\n            hourOffset = matchGroup + ':00';\n            break;\n          case 'tzid':\n            // Time zone ID: America/Los_Angeles\n            tzID = matchGroup;\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    const parsedDate = new Date();\n    if (year === null) {\n      year = parsedDate.getFullYear();\n    }\n    // if day and month are unspecified,the defaults are current\n    // day and month.\n    if (month === null && date === null) {\n      month = parsedDate.getMonth();\n      date = parsedDate.getDate();\n    } else if (date === null) {\n      // if day is unspecified, default 1st day of month.\n      date = 1;\n    }\n    parsedDate.setFullYear(year, month, date);\n    // validate month days\n    const MonthDays = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: date,\n      low: 1,\n      high: MonthDays,\n      displayValue: date,\n      displayLow: 1,\n      displayHigh: MonthDays\n    };\n    this._validateRange(range);\n    // if pm designator token was found make sure the hours fit the\n    // 24-hour clock.\n    if (pmHour == true && timeObj.hour < 12) {\n      timeObj.hour += 12;\n    }\n    // when hour is 12 AM and hour cycle is h24, set hour to 00\n    if (\n      pmHour == false &&\n      timeObj.hour == 12 &&\n      (timeObj.htoken == 'k' || timeObj.htoken == 'kk')\n    ) {\n      timeObj.hour = 0;\n    }\n    // use the Date object to set hours, minutes, ... so that it can\n    // adjust the hour correctly in case we are in missing hour during dst\n    // transition, like 2:30 AM\n    parsedDate.setHours(timeObj.hour, timeObj.minute, timeObj.second, timeObj.millisec);\n    const parts = [year, month + 1, date, 0, 0, 0, 0];\n    parts[3] = parsedDate.getHours();\n    parts[4] = parsedDate.getMinutes();\n    parts[5] = parsedDate.getSeconds();\n    parts[6] = parsedDate.getMilliseconds();\n\n    let isoParsedDate = LocalOraI18nUtils.partsToIsoString(parts);\n    if (tzID !== null) {\n      const zoneOffset = this._getTimeZoneOffset(parts, tzID);\n      hourOffset = LocalOraI18nUtils.getTimeStringFromOffset('', zoneOffset, false, true);\n    }\n    if (hourOffset !== '') {\n      isoParsedDate += hourOffset;\n    }\n    // validate year\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    // validate month\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    // validate day range, depending on the month and year\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(parts[0], parts[1] - 1);\n    range = {\n      name: 'day',\n      value: parts[2],\n      low: 1,\n      high: daysInMonth,\n      displayValue: parts[2],\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    // day of week does not match date\n    if (weekDay !== null) {\n      const validateDay = LocalOraI18nUtils.isoToLocalDate(isoParsedDate);\n      if (validateDay && validateDay.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(weekDayName, validateDay.getDate());\n      }\n    }\n    const result = { value: isoParsedDate };\n    return result;\n  }\n\n  // test if the isoStr is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _isoStrDateTimeStyle(isoStr: string): number {\n    const timeIndex = isoStr.indexOf('T');\n    if (timeIndex === -1) {\n      return 0;\n    }\n    if (timeIndex > 0) {\n      return 2;\n    }\n    return 1;\n  }\n\n  /*\n   * Returns the offset of a time zone at a given moment-in-time.\n   *\n   * @param {Object} localeElements - locale data bundle, it also contain the\n   * timezone data.\n   * @param {string} tzName - The IANA time zone name for which we want to get the\n   * offset. If it is the same as the local system's time zone, return the local\n   * system's time zone offset by using Date.getTimezoneOffset() instead of\n   * going through time zone data.\n   * @param {array} parts - An array conataining year, month, day, hour, minute,\n   * second that are used to create The Date object representing the moment-in-time.\n   */\n  private static _getTimeZoneOffset(parts: any, tzName: any) {\n    // if The timeZone in the options is the same as local system's\n    // timezone, use Date.getTimezoneOffset\n    const localTtimeZone = this.getLocalSystemTimeZone();\n    if (localTtimeZone === tzName) {\n      const d = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);\n      const localOffset = d.getTimezoneOffset();\n      return -localOffset;\n    }\n    const dateParts: DateDef = {\n      year: parts[0],\n      month: parts[1],\n      date: parts[2],\n      hours: parts[3],\n      minutes: parts[4]\n    };\n    const offset = getISODateOffset(dateParts, tzName);\n    return offset;\n  }\n\n  private static _getAdjustedOffset(timezone: any, isoStrInfo: any) {\n    const parts: Array<number> = isoStrInfo.isoStrParts;\n    return this._getTimeZoneOffset(parts, timezone);\n  }\n\n  private static _adjustHours(isoStrInfo: any, options: NativeDateTimeResolvedOptions) {\n    const value: Array<number> = isoStrInfo.isoStrParts;\n    const isoStrFormat = isoStrInfo.format;\n    let origOffset = 0;\n    switch (isoStrFormat) {\n      case NativeDateTimeConstants._OFFSET:\n        const tzParts = this._parseTimezoneOffset(isoStrInfo.timeZone);\n        const hoursOffset = tzParts[0];\n        const minOffset = tzParts[1];\n        origOffset = hoursOffset * 60 + (hoursOffset < 0 ? -minOffset : minOffset);\n        break;\n      case NativeDateTimeConstants._ZULU:\n        origOffset = 0;\n        break;\n      default:\n        break;\n    }\n    let newOffset = this._getAdjustedOffset(options.timeZone, isoStrInfo);\n    newOffset -= origOffset;\n    // target time zone might have switched to dst before orig timezone, or\n    // orig time zone might have switched to dst before target timezone.\n    // Need to get the correct offset at target time zone. This happens when\n    // we are very close to after target or orig time zones switched to dst.\n    const newDate = new Date(value[0], value[1] - 1, value[2], value[3], value[4], value[4]);\n    newDate.setHours(value[3] + ((newOffset / 60) << 0), newOffset % 60);\n    const newDateIso = LocalOraI18nUtils.dateToLocalIso(newDate);\n    const newDateIsoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(newDateIso);\n    newOffset = this._getAdjustedOffset(options.timeZone, newDateIsoStrInfo);\n    newOffset -= origOffset;\n    // Do the offset math through the Date object.\n    const adjustD = new Date(\n      Date.UTC(value[0], value[1] - 1, value[2], value[3], value[4], value[5])\n    );\n    const adjustedMin = adjustD.getUTCMinutes() + newOffset;\n    // eslint-disable-next-line no-bitwise\n    adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n    value[0] = adjustD.getUTCFullYear();\n    value[1] = adjustD.getUTCMonth() + 1;\n    value[2] = adjustD.getUTCDate();\n    value[3] = adjustD.getUTCHours();\n    value[4] = adjustD.getUTCMinutes();\n    value[5] = adjustD.getUTCSeconds();\n  }\n\n  // Returns a time-only, date-only or date-time ISO string based on dtStyle.\n  private static _createISOStrParts(dtStyle: number, d: Array<any>): string {\n    let ms: any = 0;\n    let val = '';\n    switch (dtStyle) {\n      // Date only\n      case 0:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2);\n        break;\n      // Time only\n      case 1:\n        val =\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n      // Date-Time\n      default:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2) +\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n    }\n    return val;\n  }\n\n  private static _getParseISOStringOffset(tzName: string, parts: Array<number>): string {\n    const offset = this._getTimeZoneOffset(parts, tzName);\n    return LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n  }\n\n  private static _createParseISOStringFromDate(\n    dtStyle: number,\n    isoStrInfo: any,\n    options: NativeDateTimeResolvedOptions\n  ): string {\n    const getOption = LocalOraI18nUtils.getGetOption(options, 'NativeDateTimeConverter.parse');\n    const isoFormat = getOption(\n      'isoStrFormat',\n      'string',\n      [\n        NativeDateTimeConstants._ZULU,\n        NativeDateTimeConstants._OFFSET,\n        NativeDateTimeConstants._INVARIANT,\n        NativeDateTimeConstants._LOCAL,\n        NativeDateTimeConstants._AUTO\n      ],\n      NativeDateTimeConstants._AUTO\n    );\n    const parts = isoStrInfo.isoStrParts;\n    const tzName = options.timeZone;\n    let val = this._createISOStrParts(dtStyle, parts);\n    // do not include timezone if date-only\n    if (dtStyle === 0) {\n      return val;\n    }\n    switch (isoFormat) {\n      case NativeDateTimeConstants._OFFSET:\n      case NativeDateTimeConstants._AUTO:\n        val += this._getParseISOStringOffset(tzName, parts);\n        break;\n      case NativeDateTimeConstants._LOCAL:\n        // if iso string is date-time, consider LOCAL as OFFSET\n        if (dtStyle === 2) {\n          val += this._getParseISOStringOffset(tzName, parts);\n        }\n        break;\n      case NativeDateTimeConstants._ZULU:\n        let adjustedMin = 0;\n        adjustedMin = -this._getTimeZoneOffset(parts, tzName);\n        if (adjustedMin !== 0) {\n          // Do the offset math through date object.\n          const adjustD = new Date(\n            Date.UTC(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5], parts[6])\n          );\n          adjustedMin = adjustD.getUTCMinutes() + adjustedMin;\n          // eslint-disable-next-line no-bitwise\n          adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n          parts[0] = adjustD.getUTCFullYear();\n          parts[1] = adjustD.getUTCMonth() + 1;\n          parts[2] = adjustD.getUTCDate();\n          parts[3] = adjustD.getUTCHours();\n          parts[4] = adjustD.getUTCMinutes();\n          parts[5] = adjustD.getUTCSeconds();\n          val = this._createISOStrParts(dtStyle, parts);\n        }\n        val += 'Z';\n        break;\n      default:\n        break;\n    }\n    return val;\n  }\n\n  /*\n   * Returns the current date at the specified timeZone. If timeZone is\n   * null, return current date of the local system.\n   */\n  public static getTimeZoneCurrentDate(tzName: string | null): string {\n    const options: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      day: '2-digit',\n      month: '2-digit'\n    };\n    if (tzName) {\n      options.timeZone = tzName;\n    }\n    const cnv = Intl.DateTimeFormat('en-US', options);\n    const fmt = cnv.format(new Date()); // fmt looks something like 03/05/2020\n    const parts = fmt.split('/');\n    const result = parts[2] + '-' + parts[0] + '-' + parts[1];\n    return result;\n  }\n\n  /*\n   * Returns the current offset of the specified timeZone.\n   */\n  public static getTimeZoneCurrentOffset(timezone: string, timeOnlyIsoString?: string): number {\n    const d = new Date();\n    const localDateTimeIsoString = LocalOraI18nUtils.dateToLocalIso(d);\n    let dateTimeIso;\n    // Add the time to the date instead of using the current time.\n    if (timeOnlyIsoString && timeOnlyIsoString.startsWith('T')) {\n      const datePart = localDateTimeIsoString.split('T')[0];\n      dateTimeIso = datePart + timeOnlyIsoString;\n    }\n    const isoStrInfo: any = LocalOraI18nUtils.getISOStrFormatInfo(\n      dateTimeIso ?? localDateTimeIsoString\n    );\n    return this._getAdjustedOffset(timezone, isoStrInfo);\n  }\n\n  /*\n   * Returns the local system's time zone.\n   */\n  public static getLocalSystemTimeZone(): string {\n    if (!localSystemTimeZone) {\n      const intlCnv = new Intl.DateTimeFormat('en-US');\n      localSystemTimeZone = intlCnv.resolvedOptions().timeZone;\n    }\n    return localSystemTimeZone;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarUtils } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\nimport { warn } from '../utils/UNSAFE_logger';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeParserImpl } from './NativeParserImpl';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\n/**\n * Create an Intl.DateTimeFormat from the options.\n */\nexport const getFormatter = (options: NativeDateTimeOptions) => {\n  return new Intl.DateTimeFormat(options.locale, options);\n};\n\n/**\n * Get the resolved options from the Intl.DateTimeFormat instance, plus any custom options used by our implementation.\n */\nexport const getResolvedOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeOptions\n): NativeDateTimeResolvedOptions => {\n  const resOptions = formatter.resolvedOptions();\n  const isoStrFormat = options.isoStrFormat ?? 'auto';\n  const twoDigitYearStart = options.twoDigitYearStart ?? 1950;\n  const lenientParse = options.lenientParse ?? 'full';\n  const patternFromOptions = getPatternFromOptions(formatter, resOptions);\n  return { ...resOptions, isoStrFormat, twoDigitYearStart, lenientParse, patternFromOptions };\n};\n\n/**\n * Create an Intl.DateTimeFormat that can merge in the year in the desired format during the call to 'format'.\n * This is useful if you always want year: 'numeric' for dateStyle: 'short' even if\n * in some locales dateStyle: 'short' yields a 2-digit year. 2-digit years are ambiguous.\n */\nexport const getYearFormatter = (\n  options: NativeDateTimeOptions,\n  resOptions: NativeDateTimeResolvedOptions\n) => {\n  let formatter: Intl.DateTimeFormat | null = null;\n  // Set up the yearFormatter if dateStyle is short and the dateStyleShortYear option is defined.\n  // If we do not add numberingSystem/calendar, then Intl.DateTimeFormat defaults to the locale's\n  // numberingSystem, and that is not what JET uses.\n  if (options.dateStyle === 'short' && options.dateStyleShortYear) {\n    formatter = new Intl.DateTimeFormat(options.locale, {\n      year: options.dateStyleShortYear,\n      numberingSystem: resOptions.numberingSystem,\n      calendar: resOptions.calendar,\n      timeZone: resOptions.timeZone\n    });\n  }\n  return formatter;\n};\n\n/**\n * Merge in the year in the desired format rather than whatever the locale default is for dateStyle: 'short'.\n */\nexport const formatWithYearFormat = (\n  formatInstance: Intl.DateTimeFormat,\n  yearInstance: Intl.DateTimeFormat,\n  value: Date\n) => {\n  // first get the formatted numeric year\n  const yearParts = yearInstance.formatToParts(value);\n  const formattedYear = yearParts.find((part) => part.type === 'year')?.value;\n  // next get the formatToParts of the formatInstance and substitute in formattedYear.\n  const parts = formatInstance.formatToParts(value);\n  return parts.reduce((acc, part) => {\n    if (part.type === 'year') {\n      return acc + (formattedYear ?? part.value);\n    }\n    return acc + part.value;\n  }, '');\n};\n\n/**\n * Formats a date time string based on the given options.\n */\nexport const formatDateTimeWithOptions = (options: NativeDateTimeOptions, value: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resOptions);\n  return formatDateTime(intlFormatter, yearFormatter, resOptions.timeZone, value);\n};\n\n/**\n * Formats a date time string using Intl.DateTimeFormat.\n */\nexport const formatDateTime = (\n  intlFormatter: Intl.DateTimeFormat,\n  yearFormatter: Intl.DateTimeFormat | null,\n  timeZone: string,\n  value: string\n) => {\n  const isoStr = normalizeIsoString(timeZone, value);\n  const isoStrDate = new Date(isoStr);\n  return yearFormatter\n    ? formatWithYearFormat(intlFormatter, yearFormatter, isoStrDate)\n    : intlFormatter.format(isoStrDate);\n};\n\n/**\n * Parses a string into an iso string based on the given options.\n */\nexport const parseDateTimeWithOptions = (options: NativeDateTimeOptions, str: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  return parseDateTime(options.locale, intlFormatter, resOptions, str);\n};\n\n/**\n * Parses the formatted string, and returns an iso string.\n * @returns an iso string\n * @throws Error if undefined, null, or '' or not an iso string, or if something went wrong in the call to parse.\n */\nexport const parseDateTime = (\n  locale: string,\n  formatter: Intl.DateTimeFormat,\n  resOptions: NativeDateTimeResolvedOptions,\n  str: string\n) => {\n  if (str === undefined || str === null || str === '') {\n    throw new FormatParseError('The parse value cannot be empty.', {\n      cause: { code: 'emptyParseValue' }\n    });\n  }\n  const cal = CalendarUtils.getCalendar(locale, resOptions.calendar);\n  const pattern = getPatternFromOptions(formatter, resOptions);\n  const result = NativeParserImpl.parseImpl(str, pattern, resOptions, cal);\n  const parsed = result.value;\n  if (parsed) {\n    if (result.warning) {\n      warn('The value ' + str + ' was leniently parsed to represent a date ' + parsed);\n    }\n  }\n  return parsed;\n};\n\n/**\n * Checks if it is a valid iso string.\n * Also fixes up the iso string if needed, i.e. if local and timezone are specified in the options.\n * @param timeZone\n * @param value\n * @returns\n * @throws Error if undefined, null, or '' or if it is an invalid iso string.\n */\nexport const normalizeIsoString = (timeZone: string, value: string) => {\n  if (value === undefined || value === null || value === '') {\n    throw new FormatParseError('The format value cannot be empty.', {\n      cause: { code: 'emptyFormatValue' }\n    });\n  }\n\n  if (value.startsWith('T')) {\n    // Intl Object takes Date object as parameter. new Date() throws an\n    // exception with time only ISO string. Prepend current date to time\n    // only iso string.\n    let curDate = '';\n    if (timeZone) {\n      // if options contain a timeZone, get the current date at this time zone\n      curDate = NativeParserImpl.getTimeZoneCurrentDate(timeZone);\n    } else {\n      // get the current date of the local system\n      curDate = LocalOraI18nUtils.dateToLocalIso(new Date()).split('T')[0];\n    }\n    value = curDate + value;\n  } else if (value.indexOf('T') === -1) {\n    value = value + 'T00:00:00';\n  }\n\n  // test if value is a valid ISO string\n  const exe = LocalOraI18nUtils._ISO_DATE_REGEXP.exec(value);\n  if (!exe) {\n    const e = new FormatParseError('The format value must be a valid iso string.', {\n      cause: { code: 'invalidISOString', parameterMap: { isoStr: value } }\n    });\n    throw e;\n  }\n  // If value is local ISO string and timeZone is specified in options, adjust\n  // offset to avoid time zone conversion from local system's timezone to target timezone\n  if (timeZone) {\n    // Also test if timeZone in the options is the same as local system time zone\n    let islocalTimeZone = false;\n    const localTimeZone = NativeParserImpl.getLocalSystemTimeZone();\n    if (localTimeZone === timeZone) {\n      islocalTimeZone = true;\n    }\n    const timePart = value.substring(value.indexOf('T'));\n    const isLocalValue =\n      timePart.indexOf('Z') === -1 && timePart.indexOf('+') === -1 && timePart.indexOf('-') === -1;\n    if (isLocalValue && !islocalTimeZone) {\n      const parts = LocalOraI18nUtils.IsoStrParts(value);\n      const dateParts: DateDef = {\n        year: parts[0],\n        month: parts[1],\n        date: parts[2],\n        hours: parts[3],\n        minutes: parts[4]\n      };\n      const offset = getISODateOffset(dateParts, timeZone);\n      value = value + LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n    }\n  }\n  //if ISO string time zone offset is hh, replace it with hh:00 so that new Date() does not fail\n  value = value.replace(/(T.*?[+-]..$)/, '$1:00');\n  return value;\n};\n\nconst getPatternFromOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeResolvedOptions\n) => {\n  const isoSTr = '2000-01-02T00:00:00';\n  const date = new Date(isoSTr);\n  let pattern = '';\n  let optVal = '';\n  let token: any = null;\n  let dtokenMap: any = null;\n  let ttokenMap: any = null;\n  let dateStyle = false;\n  let timeStyle = false;\n  if (options.dateStyle !== undefined) {\n    dtokenMap = NativeDateTimeConstants._dateTimeFormats.dateStyle;\n    dtokenMap = dtokenMap[options.dateStyle];\n    dateStyle = true;\n  }\n  if (options.timeStyle !== undefined) {\n    ttokenMap = NativeDateTimeConstants._dateTimeFormats.timeStyle;\n    ttokenMap = ttokenMap[options.timeStyle];\n    timeStyle = true;\n  }\n  const tokenMap = NativeDateTimeConstants._tokenMap;\n  // eslint-disable-next-line array-callback-return\n  formatter.formatToParts(date).map(({ type, value }) => {\n    // TODO: Intl.DateTimeFormatPartType type does not have 'fractionalSecond' even though it is in the api.\n    // so to workaround getting a typescript error, I'm setting as string here.\n    // Fix when the typescript for Intl.DateTimeFormat gets fixed.\n    switch (type as string) {\n      case 'literal':\n        token = value.replace(NativeDateTimeConstants._ALPHA_REGEXP, \"'$1'\");\n        break;\n      case 'dayPeriod':\n        token = 'a';\n        break;\n      case 'hour':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        let ish12 = options.hour12;\n        if (ish12 === undefined) {\n          ish12 = false;\n        }\n        // take hourCycle into consideration\n        if (options.hourCycle) {\n          token = token.replace(\n            NativeDateTimeConstants._HOUR12_REGEXP,\n            NativeDateTimeConstants._hourCycleMap[options.hourCycle]\n          );\n        }\n        // h12 takes precedence over hourCycle\n        if (ish12 === true) {\n          token = token.replace(NativeDateTimeConstants._HOUR12_REGEXP, 'h');\n        }\n        break;\n      case 'month':\n        // some locales have month as numeric for medium style and some have month\n        // as medium style check the value to get accurate pattern\n        if (dateStyle) {\n          if (isNaN(+value)) {\n            token = dtokenMap.month_m;\n          } else {\n            token = dtokenMap.month_s;\n          }\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'year':\n      case 'day':\n      case 'weekday':\n        if (dateStyle) {\n          token = dtokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'minute':\n      case 'second':\n      case 'timeZoneName':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'era':\n        optVal = (options as any)[type] || 'short';\n        token = (tokenMap as any)[type][optVal];\n        break;\n      case 'fractionalSecond':\n        token = options.fractionalSecondDigits;\n        token = (tokenMap as any)[type][token];\n        break;\n      default:\n        break;\n    }\n    pattern += token;\n  });\n  return pattern;\n};\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  formatDateTime,\n  getFormatter,\n  getResolvedOptions,\n  getYearFormatter,\n  parseDateTime\n} from './formatParse';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\n\n/**\n * This function is used to retrieve 'format'and 'parse' methods for formatting or parsing date,\n * time, or datetime values according to the provided options. The options may include:\n *\n * Using the standard date, datetime and time format lengths defined by Unicode CLDR; these\n * include the dateStyle and timeStyle properties (full | long | medium | short).\n *\n * Using options defined by the ECMA 402 Specification, including the properties year,\n * month, day, hour, minute, second, weekday, era, timeZoneName, hour12, timeZone.\n *\n * Passing the BCP47Locale is the only required option. If no other options are specified,\n * the default is to use the 'short' format length for the provided locale.\n *\n * Once the function has been called with a set of options, there is no need to call it again unless\n * you want to change the options being used to format and parse, or the locale.\n */\nexport function getFormatParse(options: NativeDateTimeOptions) {\n  const intlFormatter = getFormatter(options);\n  const resolvedOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resolvedOptions);\n\n  const format = (value: Parameters<typeof formatDateTime>[3]) =>\n    formatDateTime(intlFormatter, yearFormatter, resolvedOptions.timeZone, value);\n  const parse = (str: Parameters<typeof parseDateTime>[3]) =>\n    parseDateTime(options.locale, intlFormatter, resolvedOptions, str);\n\n  return { format, parse, resolvedOptions, formatter: intlFormatter };\n}\n"],"names":["CalendarUtils","_getDayPeriods","locale","calendar","date","Date","getDayPeriodsFromFormatToParts","formatter","eraPart","formatToParts","find","value","type","formatterLocale","getFormatterLocale","Intl","DateTimeFormat","hour","hour12","amValue","setHours","format","wide","am","pm","_getEras","eras","era","start","cal","eraNarrow","eraAbbr","eraName","getEraFromFormatToParts","eraLenArray","eraMap","narrow","short","long","i","length","j","eraLenName","options","year","month","day","eraForLength","eraObj","_fillMonthAndDays","widthVal","isStandAlone","dates","getMonthFromFormatToParts","formatParts","monthPart","getWeekdayFromFormatToParts","weekdayPart","calMonthFormat","calDayFormat","index","dayIndexVal","_weekdaysFormatMap","weekday","undefined","monthFormat","dayFormat","_getFormatMonthAndDays","calMonths","calDays","types","_monthNamesFormatMap","monthDayObjForWidth","myMonthObj","Object","assign","myDayObj","myMonthFormatObj","myDayFormatObj","monthsNode","daysNode","_getStandAloneDays","dayObjForWidth","myDayStandAloneObj","_getStandAloneMonths","monthObjForWidth","myMonthStandAloneObj","getCalendar","calendars","dayPeriodsObj","erasObj","standAloneMonths","standAloneDays","exceptionLocales","includes","monthsDaysNodeObj","monthsNodes","daysNodes","dayPeriods","months","days","formatterCache","Map","getISODateOffset","timeZone","d","UTC","hours","minutes","offset","original","asUTC","originalMins","utcMinutes","delta","_getOffset","_applyTimezoneToDate","adjustment","setTime","getTime","_compareDates","formattedUTC","timezone","get","minute","second","hourCycle","set","_getConverter","localDate","localTime","split","trim","parseInt","date1","date2","NativeDateTimeConstants","_YEAR_AND_DATE_REGEXP","_YMD_REGEXP","_TIME_REGEXP","_TIME_FORMAT_REGEXP","_YEAR_REGEXP","_MONTH_REGEXP","_DAY_REGEXP","_WEEK_DAY_REGEXP","_HOUR_REGEXP","_MINUTE_REGEXP","_SECOND_REGEXP","_FRACTIONAL_SECOND_REGEXP","_AMPM_REGEXP","_WORD_REGEXP","_ESCAPE_REGEXP","_TOKEN_REGEXP","_ZULU","_LOCAL","_AUTO","_INVARIANT","_OFFSET","_ALNUM_REGEXP","_NON_DIGIT_REGEXP","_NON_DIGIT_OPT_REGEXP","_STR_REGEXP","_TWO_DIGITS_REGEXP","_THREE_DIGITS_REGEXP","_FOUR_DIGITS_REGEXP","_SLASH_REGEXP","_PROPERTIES_MAP","MMM","token","style","mLen","matchIndex","key","regExp","MMMM","MMMMM","LLL","LLLL","LLLLL","E","dLen","EE","EEE","EEEE","EEEEE","c","cc","ccc","cccc","ccccc","h","timePart","start1","end1","start2","end2","hh","K","KK","H","HH","k","kk","m","mm","s","ss","S","SS","SSS","getPartIdx","dd","M","MM","L","LL","y","yy","yyyy","a","z","v","zz","zzz","zzzz","Z","ZZ","ZZZ","X","XX","XXX","VV","G","GG","GGG","GGGG","GGGGG","FRACTIONAL_SECOND_MAP","_tokenMap","numeric","fractionalSecond","timeZoneName","_dateTimeFormats","dateStyle","full","month_s","month_m","medium","timeStyle","_ALPHA_REGEXP","_HOUR12_REGEXP","_hourCycleMap","h12","h23","h11","h24","_zh_tw_locales","_zh_tw_pm_symbols","regexTrim","regexTrimNumber","regexTrimRightZeros","zeros","_ISO_DATE_REGEXP","_ISO_DATE_ONLY_REGEXP","isDateOnlyIsoString","test","startsWith","pattern","indexOf","replace","trimRightZeros","trimNumber","toUpper","join","toUpperCase","padZeros","num","isNegative","substr","zeroPad","str","count","left","result","l","_throwInvalidISOStringRange","isoStr","name","displayValue","displayLow","displayHigh","RangeError","cause","code","parameterMap","minValue","maxValue","propertyName","_throwInvalidISOStringSyntax","Error","dateToLocalIso","_date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isLeapYear","getDaysInMonth","IsoStrParts","isoString","splitted","tIndex","today","isBC","datetime","slice","dateSplitted","val","nbDays","milliSecSplitted","timeSplitted","tVal","getGetOption","getOptionCaller","property","values","defaultValue","toLowerCase","_toBoolean","String","Number","expectedValues","push","msg","rangeError","errorInfo","errorCode","propertyValue","propertyValueValid","caller","partsToIsoString","parts","isoToLocalDate","setFullYear","_isoToLocalDateIgnoreTimezone","getISOStrFormatInfo","res","dateTime","isoStrParts","exe","exec","isoStrLen","timeZoneLen","substring","getTimeStringFromOffset","prefix","reverseSign","alwaysMinutes","absOffset","Math","abs","floor","sign","localSystemTimeZone","NativeParserImpl","parseImpl","resOptions","dtStyle","parsedIsoStr","isoStrInfo","LocalOraI18nUtils._ISO_DATE_REGEXP","this","_isoStrDateTimeStyle","_dateTimeStyle","_parseExact","LocalOraI18nUtils.getISOStrFormatInfo","_adjustHours","_createParseISOStringFromDate","warning","isoStrFormat","_appendPreOrPostMatch","preMatch","strings","quoteCount","escaped","il","charAt","_validateRange","range","low","high","_throwInvalidDateFormat","isDate","isTime","samplePattern","SyntaxError","_throwWeekdayMismatch","FormatParseError","_throwDateFormatMismatch","errorCodeType","_parseTimezoneOffset","_offset","offsetParts","Array","_expandYear","start2DigitYear","ambiguousTwoDigitYear","_arrayIndexOfMonthOrDay","monthsDaysData","userInput","trimUserInput","toUpperTrimmedNoPeriod","keys","valueFromData","trimValueFromData","trimUserInputNumber","numberPartFromData","isInteger","trimItem","LocalOraI18nUtils.toUpper","LocalOraI18nUtils.trim","_getDayIndex","calNode","ret","calDaysFmt","calDaysStdAlone","abbreviated","_getMonthIndex","calMonthsFmt","calMonthsStdAlone","_getParseRegExp","expFormat","regexp","groups","match","lastIndex","add","_getTokenIndex","arr","_parseLenienthms","timepart","dtype","idx","msec","_matchPMSymbol","_getWeekdayName","calDaysStandAlone","dayKeys","dName","RegExp","_parseLenientyMEd","isDateTime","tokenIndexes","sort","b","n1","n2","yearIndex","foundDayIndex","dayIndex","foundYear","foundDay","tokenMatch","intToken","daysInMonth","LocalOraI18nUtils.getDaysInMonth","twoDigitYearStart","parsedDate","weekDay","getDay","LocalOraI18nUtils.dateToLocalIso","_parseLenientyMMMEd","origValue","calMonthsStandAlone","foundMatch","reverseMonth","mName","monthKeys","unshift","isNaN","dRegExp","_parseLenient","LocalOraI18nUtils.IsoStrParts","gregParts","isoParts","LocalOraI18nUtils.padZeros","_getNameIndex","datePart","matchGroup","mLength","monthsFormat","startName","endName","_validateTimePart","matchInt","_timeObj","objMap","timeToken","timeObj","htoken","fractionalSecondDigits","loc","isPM","pmSymbols","pmSymbol","calPM","trimEraPart","LocalOraI18nUtils.trimNumber","lenientParse","LocalOraI18nUtils.getGetOption","getOption","parseInfo","pmHour","hourOffset","tzID","weekDayName","millisec","jl","current","currentGroup","e","MonthDays","isoParsedDate","LocalOraI18nUtils.partsToIsoString","LocalOraI18nUtils.getTimeStringFromOffset","_getTimeZoneOffset","validateDay","LocalOraI18nUtils.isoToLocalDate","timeIndex","tzName","getLocalSystemTimeZone","getTimezoneOffset","_getAdjustedOffset","origOffset","tzParts","hoursOffset","minOffset","newOffset","newDate","newDateIsoStrInfo","adjustD","adjustedMin","getUTCMinutes","setUTCHours","getUTCHours","getUTCFullYear","getUTCMonth","getUTCDate","getUTCSeconds","_createISOStrParts","ms","LocalOraI18nUtils.trimRightZeros","_getParseISOStringOffset","isoFormat","getTimeZoneCurrentDate","getTimeZoneCurrentOffset","timeOnlyIsoString","localDateTimeIsoString","dateTimeIso","intlCnv","resolvedOptions","formatWithYearFormat","formatInstance","yearInstance","yearParts","formattedYear","part","reduce","acc","normalizeIsoString","curDate","islocalTimeZone","getPatternFromOptions","optVal","dtokenMap","ttokenMap","tokenMap","map","ish12","intlFormatter","getFormatter","patternFromOptions","getResolvedOptions","yearFormatter","dateStyleShortYear","numberingSystem","getYearFormatter","isoStrDate","formatDateTime","parse","parsed","warn","parseDateTime"],"mappings":"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"}