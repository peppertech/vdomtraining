{"version":3,"file":"useTextDimensions-b37344b4.js","sources":["../../src/hooks/PRIVATE_useTextDimensions/textDimensionsUtils.ts","../../src/hooks/PRIVATE_useTextDimensions/useTextDimensions.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nexport type Font = {\n  fontStyle?: string;\n  fontVariant?: 'normal' | 'small-caps';\n  fontWeight?: string;\n  fontStretch?:\n    | 'normal'\n    | 'ultra-condensed'\n    | 'extra-condensed'\n    | 'condensed'\n    | 'semi-condensed'\n    | 'semi-expanded'\n    | 'expanded'\n    | 'extra-expanded'\n    | 'ultra-expanded';\n  fontSize?: string;\n  lineHeight?: string;\n  fontFamily?: string;\n  letterSpacing?: string;\n  wordSpacing?: string;\n  fontVariantNumeric?: string;\n};\n\nexport type TextDimensions = {\n  /**\n   * x position assuming the text is aligned to x = 0.\n   * In almost all cases this is 0, or close to 0.\n   */\n  x: number;\n  /**\n   * y positioning assuming the text baseline is aligned to y = 0\n   * i.e. this is the (negative) distance from the bounding box top\n   * to the baseline.\n   */\n  y: number;\n  /**\n   * Width of the text in pixels.\n   */\n  width: number;\n  /**\n   * Height of the text in pixles.\n   */\n  height: number;\n};\n\nexport type MeasurementBackend =\n  /**\n   * Use Canvas 2D for geting text dimensions\n   */\n  | 'canvas'\n  /**\n   * Use HTML for getting text width and height. Use SVG for getting text x and y.\n   */\n  | 'htmlSvg'\n  /**\n   * Use HTML for getting text width and height. Use Canvas 2D for getting text x and y.\n   */\n  | 'htmlCanvas'\n  /**\n   * Use SVG for geting text dimensions\n   */\n  | 'svg';\n\n// Text dimensions cache for each measurement backend.\n// Note that all consumers of this util within an app shares this cache.\nconst textDimensionsCache: Record<MeasurementBackend, Record<string, TextDimensions>> = {\n  canvas: {},\n  htmlSvg: {},\n  htmlCanvas: {},\n  svg: {}\n};\n\n// Represents the computed styles of the text's parent.\n// This is referred to as the \"base styles\" throughout this file.\nlet baseStyle: Required<Font> = {\n  fontStyle: 'normal',\n  fontVariant: 'normal',\n  fontWeight: 'normal',\n  fontStretch: 'normal',\n  fontSize: 'medium',\n  lineHeight: 'normal',\n  fontFamily: '',\n  letterSpacing: 'normal',\n  wordSpacing: 'normal',\n  fontVariantNumeric: 'normal'\n};\n\n// font shorthand only supports font-variant CSS Level 2 (Revision 1), i.e. only\n// 'normal' or 'small-caps'\nconst LEGAL_FONT_VARIANT = new Set(['normal', 'small-caps']);\n// font shorthand only supports single keyword value subset of fontStretch\nconst LEGAL_FONT_STRETCH = new Set([\n  'normal',\n  'ultra-condensed',\n  'extra-condensed',\n  'condensed',\n  'semi-condensed',\n  'semi-expanded',\n  'expanded',\n  'extra-expanded',\n  'ultra-expanded'\n]);\n\n// Representative text used for determining the text baseline location for a given font.\nconst REPRESENTATIVE_TEXT = 'MW';\n\n/**\n * Merges the given font with the base styles.\n * @param font The font to merge.\n * @returns The merged font.\n */\nconst mergeDefaultStyle = (font?: Font) => {\n  if (!font) return { ...baseStyle };\n  // We can't just do \"return { ...baseStyle, ...font }\"\n  // because if something is explicitly undefined in \"font\",\n  // then we want to use the value from \"baseStyle\" instead:\n  return {\n    fontStyle: font.fontStyle ?? baseStyle.fontStyle,\n    fontVariant: font.fontVariant ?? baseStyle.fontVariant,\n    fontWeight: font.fontWeight ?? baseStyle.fontWeight,\n    fontStretch: font.fontStretch ?? baseStyle.fontStretch,\n    fontSize: font.fontSize ?? baseStyle.fontSize,\n    lineHeight: font.lineHeight ?? baseStyle.lineHeight,\n    fontFamily: font.fontFamily ?? baseStyle.fontFamily,\n    letterSpacing: font.letterSpacing ?? baseStyle.letterSpacing,\n    wordSpacing: font.wordSpacing ?? baseStyle.wordSpacing,\n    fontVariantNumeric: font.fontVariantNumeric ?? baseStyle.fontVariantNumeric\n  };\n};\n\n/**\n * Converts the given font into a font CSS shorthand string.\n * @param font The target font.\n * @returns The equivalent font CSS shorthand string.\n */\nconst toFontString = (font: Font) => {\n  const { fontStyle, fontVariant, fontWeight, fontStretch, fontSize, lineHeight, fontFamily } =\n    font;\n  // include 'px' if fontSize is just a number\n  const fontSizeString = !Number.isNaN(Number(fontSize)) ? `${fontSize}px` : fontSize;\n  return `${fontStyle} ${fontVariant} ${fontWeight} ${fontStretch} ${fontSizeString}/${lineHeight} ${fontFamily}`;\n};\n\n/**\n * Constructs the cache key uniquely derived from the given textString and font.\n * @param textString The text string.\n * @param font The font.\n * @returns The cache key.\n */\nconst getCacheKey = (textString: string, font: Font) => {\n  return (\n    textString +\n    toFontString(font) +\n    font.letterSpacing +\n    font.wordSpacing +\n    font.fontVariantNumeric\n  );\n};\n\n/**\n * Determines whether the given CSS value is equivalent to 'normal.\n * @param value The value.\n * @returns Whether the value is equivalent to 'normal'.\n */\nconst isNormalSpacing = (value: string) => {\n  return value === 'normal' || value === '0px';\n};\n\n/**\n * Determines the most suitable measurement backend given the browser and the font.\n * @param clientBrowser The browser.\n * @param font The font.\n * @returns The most suitable measurement backend.\n */\nexport const getBackend = (\n  clientBrowser: 'chrome' | 'edge' | 'firefox' | 'safari' | 'unknown',\n  font?: Font\n): MeasurementBackend => {\n  if (clientBrowser === 'unknown') {\n    return 'htmlSvg';\n  }\n  const { letterSpacing, wordSpacing, fontVariantNumeric } = mergeDefaultStyle(font);\n  const isLetterSpacingNormal = isNormalSpacing(letterSpacing);\n  const isWordSpacingNormal = isNormalSpacing(wordSpacing);\n  const isFontVariantNumericNormal = fontVariantNumeric === 'normal';\n  const isFontVariantNumericInherited = fontVariantNumeric === baseStyle.fontVariantNumeric;\n  if (\n    isLetterSpacingNormal &&\n    isWordSpacingNormal &&\n    isFontVariantNumericNormal &&\n    isFontVariantNumericInherited\n  ) {\n    return 'canvas';\n  }\n  switch (clientBrowser) {\n    // Firefox <canvas> does not support letterSpacing, wordSpacing, or fontVariantNumeric\n    // even if attached to the DOM.\n    case 'firefox':\n      return 'htmlSvg';\n    // Safari <canvas> does not support letterSpacing or wordSpacing, even if attached to the DOM.\n    // Chrome and Edge <canvas> context supports letterSpacing and wordSpacing, but only CSS lengths,\n    // e.g. 'normal' is not supported. They're also considered experimental technology right now.\n    // so we'll use 'htmlCanvas' backend to be safe.\n    // All three support fontVariantNumeric inheritance if the canvas is attached to the DOM.\n    case 'safari':\n    case 'chrome':\n    case 'edge':\n      return isLetterSpacingNormal && isWordSpacingNormal && isFontVariantNumericInherited\n        ? 'canvas'\n        : 'htmlCanvas';\n    default:\n      return 'htmlSvg';\n  }\n};\n\n/**\n * Sets the base style to the computed style of the given node.\n * @param referenceNode The target node.\n */\nexport const computeBaseStyle = (\n  referenceNode: HTMLCanvasElement | HTMLDivElement | SVGSVGElement\n) => {\n  const computedStyle = getComputedStyle(referenceNode);\n  baseStyle = {\n    fontStyle: computedStyle.fontStyle,\n    fontVariant: computedStyle.fontVariantCaps as Required<Font>['fontVariant'],\n    fontWeight: computedStyle.fontWeight,\n    fontStretch: computedStyle.fontStretch as Required<Font>['fontStretch'],\n    fontSize: computedStyle.fontSize,\n    lineHeight: computedStyle.lineHeight,\n    fontFamily: computedStyle.fontFamily,\n    letterSpacing: computedStyle.letterSpacing,\n    wordSpacing: computedStyle.wordSpacing,\n    fontVariantNumeric: computedStyle.fontVariantNumeric\n  };\n  if (!baseStyle.fontVariant || !LEGAL_FONT_VARIANT.has(baseStyle.fontVariant)) {\n    baseStyle.fontVariant = 'normal';\n  }\n  if (!baseStyle.fontStretch || !LEGAL_FONT_STRETCH.has(baseStyle.fontStretch)) {\n    baseStyle.fontStretch = 'normal';\n  }\n};\n\n/**\n * Computes the text dimensions of the given string with the given font\n * using Canvas 2D.\n * Note the following font properties support:\n *   - font*:\n *       - Supports whatever the font CSS shorthand supports,\n *         which is basically everything we care about, except fontVariant and fontStretch values are more limited;\n *         see LEGAL_FONT_VARIANT and LEGAL_FONT_STRETCH.\n *   - letterSpacing:\n *       - Chrome and Edge supports CSS lengths only. Everything else is ignored.\n *       - Ignored and not supported in Safari and Firefox.\n *   - wordSpacing: same as letterSpacing.\n *   - fontVariantNumeric:\n *       - Ignored and not supported in Firefox.\n *       - In Chrome/Edge/Safari, the inherited (parent's) fontVariantNumeric is used.\n *         (So specifying a different fontVariantNumeric in the given font has no effect).\n * @param canvasCtx The canvas 2D context.\n * @param textString The target text string.\n * @param font The target text's font.\n * @returns The target text's dimensions.\n */\nexport const getCanvasTextDimensions = (\n  canvasCtx: CanvasRenderingContext2D,\n  textString: string,\n  font?: Font\n): TextDimensions => {\n  const fullFont = mergeDefaultStyle(font);\n  const cacheKey = getCacheKey(textString, fullFont);\n  const cachedDims = textDimensionsCache.canvas[cacheKey];\n  if (cachedDims) return cachedDims;\n\n  const fontString = toFontString(fullFont);\n  canvasCtx.font = fontString;\n  // Note: letterSpacing and wordSpacing only supported on Chrome and Edge currently,\n  // and only CSS lengths supported.\n  // This is a no-op in other browsers.\n  /* eslint-disable */\n  // @ts-ignore\n  canvasCtx.letterSpacing = '0px'; // Default any invalid values set in the next line\n  // @ts-ignore\n  canvasCtx.letterSpacing = fullFont.letterSpacing;\n  // @ts-ignore\n  canvasCtx.wordSpacing = '0px'; // Default any invalid values set in the next line\n  // @ts-ignore\n  canvasCtx.wordSpacing = fullFont.wordSpacing;\n  /* eslint-enable */\n  const textMetrics = canvasCtx.measureText(textString);\n  const dims = {\n    x: 0,\n    y: -textMetrics.fontBoundingBoxAscent,\n    width: textMetrics.width,\n    height: textMetrics.fontBoundingBoxAscent + textMetrics.fontBoundingBoxDescent\n  };\n\n  textDimensionsCache.canvas[cacheKey] = dims;\n  return dims;\n};\n\n/**\n * Computes the text dimensions of the given string with the given font\n * using SVG.\n * This is well supported across all browsers, but is generally less performant\n * compared to using an HTML or Canvas.\n * @param container The SVG container element.\n * @param textString The target text string.\n * @param font The target text's font.\n * @returns The target text's dimensions.\n */\nexport const getSvgTextDimensions = (\n  container: SVGSVGElement,\n  textString: string,\n  font?: Font\n): TextDimensions => {\n  const fullFont = mergeDefaultStyle(font);\n  const cacheKey = getCacheKey(textString, fullFont);\n  const cachedDims = textDimensionsCache.svg[cacheKey];\n  if (cachedDims) return cachedDims;\n\n  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n  text.setAttribute('font-style', fullFont.fontStyle);\n  text.setAttribute('font-variant', fullFont.fontVariant);\n  text.setAttribute('font-weight', fullFont.fontWeight);\n  text.setAttribute('font-stretch', fullFont.fontStretch);\n  text.setAttribute('font-size', fullFont.fontSize);\n  text.setAttribute('font-family', fullFont.fontFamily);\n  text.setAttribute('letter-spacing', fullFont.letterSpacing);\n  text.setAttribute('word-spacing', fullFont.wordSpacing);\n  text.style.fontVariantNumeric = fullFont.fontVariantNumeric;\n  text.textContent = textString;\n  container.appendChild(text);\n  const bbox = text.getBBox();\n  const dims = {\n    x: bbox.x,\n    y: bbox.y,\n    width: bbox.width,\n    height: bbox.height\n  };\n  container.innerHTML = '';\n\n  textDimensionsCache.svg[cacheKey] = dims;\n  return dims;\n};\n\n/**\n * Computes the width and height of the given string with the given font using HTML.\n * This is well supported across all browsers.\n * To match the support of the Canvas backend, this method also only supports\n * the font values that the font CSS shorthand supports.\n * @param container The container element.\n * @param textString The target text string.\n * @param font The target text's font.\n * @returns The target text's width and height.\n */\nconst getHtmlTextSize = (container: HTMLDivElement, textString: string, font?: Font) => {\n  const fullFont = mergeDefaultStyle(font);\n  const fontString = toFontString(fullFont);\n  const span = document.createElement('span');\n  span.style.font = fontString;\n  span.style.whiteSpace = 'nowrap';\n  span.style.letterSpacing = fullFont.letterSpacing;\n  span.style.wordSpacing = fullFont.wordSpacing;\n  span.style.fontVariantNumeric = fullFont.fontVariantNumeric;\n  span.textContent = textString;\n  container.appendChild(span);\n  const size = {\n    width: span.offsetWidth,\n    height: span.offsetHeight\n  };\n  container.innerHTML = '';\n  return size;\n};\n\n/**\n * Computes the dimensions of a representative text with the given font and measurement backend.\n * @param options The measurement backend.\n * @param font The target font.\n * @returns The representative text's dimensions.\n */\nconst getRepresentativeTextDimensions = (\n  options:\n    | { backend: 'svg'; container: SVGSVGElement }\n    | { backend: 'canvas'; ctx: CanvasRenderingContext2D },\n  font?: Font\n) => {\n  let dimensions: TextDimensions;\n  switch (options.backend) {\n    case 'svg':\n      dimensions = getSvgTextDimensions(options.container, REPRESENTATIVE_TEXT, font);\n      break;\n    case 'canvas':\n      dimensions = getCanvasTextDimensions(options.ctx, REPRESENTATIVE_TEXT, font);\n      break;\n  }\n  return {\n    x: dimensions.x,\n    y: dimensions.y,\n    width: dimensions.width / REPRESENTATIVE_TEXT.length,\n    height: dimensions.height\n  };\n};\n\n/**\n * Computes the text width and height of the given string with the given font\n * using HTML. Due to limitations of HTML, the x and y values are computed using a different specified backend.\n * Note that for the x and y computation backend:\n *   - Canvas backend is supported by Chrome/Edge/Safari, but not Firefox.\n *   - SVG backend is supported by all browsers but is generally less performant.\n * @param container The container element.\n * @param baselineMeasureOptions The options for the backend to use for computing the x and y portion of the dimensions.\n * @param textString The target text string.\n * @param font The target text's font.\n * @returns The target text's dimensions.\n */\nexport const getHtmlTextDimensions = (\n  container: HTMLDivElement,\n  baselineMeasureOptions: Parameters<typeof getRepresentativeTextDimensions>[0],\n  textString: string,\n  font?: Font\n): TextDimensions => {\n  const fullFont = mergeDefaultStyle(font);\n  const cacheKey = getCacheKey(textString, fullFont);\n  const cache =\n    baselineMeasureOptions.backend === 'svg'\n      ? textDimensionsCache.htmlSvg\n      : textDimensionsCache.htmlCanvas;\n  const cachedDims = cache[cacheKey];\n  if (cachedDims) return cachedDims;\n\n  const { width, height } = getHtmlTextSize(container, textString, font);\n  const { x, y } = getRepresentativeTextDimensions(baselineMeasureOptions, font);\n  const dims = { x, y, width, height };\n\n  cache[cacheKey] = dims;\n  return dims;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useState, useLayoutEffect, useRef, useMemo } from 'preact/hooks';\nimport {\n  Font,\n  TextDimensions,\n  MeasurementBackend,\n  getBackend,\n  computeBaseStyle,\n  getCanvasTextDimensions,\n  getSvgTextDimensions,\n  getHtmlTextDimensions\n} from './textDimensionsUtils';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\n\ntype UseTextDimensionsOptions = {\n  backend?: MeasurementBackend | 'auto';\n};\n\nexport type GetTextDimensionsType = (textString: string, font?: Font) => TextDimensions;\n\nconst clientBrowser = getClientHints().browser;\n\nconst useTextDimensions = ({ backend = 'auto' }: UseTextDimensionsOptions = {}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const htmlRef = useRef<HTMLDivElement>(null);\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  const [measureFunction, setMeasureFunction] =\n    useState<(textString: string, font?: Font) => TextDimensions>();\n\n  const backendConfig = useMemo(() => {\n    const canvasContent = <canvas ref={canvasRef} style={{ display: 'none' }} />;\n    const htmlContent = <div ref={htmlRef} />;\n    const svgContent = (\n      <svg ref={svgRef} style={{ display: 'block', width: '0px', height: '0px' }} />\n    );\n\n    const config = {\n      canvas: {\n        refs: [canvasRef],\n        measureContent: canvasContent,\n        measureFunction: (textString: string, font?: Font): TextDimensions => {\n          const canvas = canvasRef.current;\n          const ctx = canvas?.getContext('2d');\n          if (!canvas || !ctx) return { x: -1, y: -1, width: -1, height: -1 };\n          return getCanvasTextDimensions(ctx, textString, font);\n        }\n      },\n      htmlSvg: {\n        refs: [htmlRef, svgRef],\n        measureContent: (\n          <div>\n            {htmlContent}\n            {svgContent}\n          </div>\n        ),\n        measureFunction: (textString: string, font?: Font): TextDimensions => {\n          if (!htmlRef.current || !svgRef.current) return { x: -1, y: -1, width: -1, height: -1 };\n          return getHtmlTextDimensions(\n            htmlRef.current,\n            { backend: 'svg', container: svgRef.current },\n            textString,\n            font\n          );\n        }\n      },\n      htmlCanvas: {\n        refs: [htmlRef, canvasRef],\n        measureContent: (\n          <div>\n            {htmlContent}\n            {canvasContent}\n          </div>\n        ),\n        measureFunction: (textString: string, font?: Font): TextDimensions => {\n          const canvas = canvasRef.current;\n          const ctx = canvas?.getContext('2d');\n          if (!htmlRef.current || !canvas || !ctx) return { x: -1, y: -1, width: -1, height: -1 };\n          return getHtmlTextDimensions(\n            htmlRef.current,\n            { backend: 'canvas', ctx },\n            textString,\n            font\n          );\n        }\n      },\n      svg: {\n        refs: [svgRef],\n        measureContent: svgContent,\n        measureFunction: (textString: string, font?: Font): TextDimensions => {\n          if (!svgRef.current) return { x: -1, y: -1, width: -1, height: -1 };\n          return getSvgTextDimensions(svgRef.current, textString, font);\n        }\n      }\n    };\n    if (backend === 'auto') {\n      return {\n        refs: [htmlRef, canvasRef],\n        measureContent: (\n          <div>\n            {canvasContent}\n            {htmlContent}\n            {svgContent}\n          </div>\n        ),\n        measureFunction: (textString: string, font?: Font): TextDimensions => {\n          const measurementBackend = getBackend(clientBrowser, font);\n          return config[measurementBackend].measureFunction(textString, font);\n        }\n      };\n    }\n    return config[backend];\n  }, [backend]);\n\n  useLayoutEffect(() => {\n    if (!backendConfig.refs[0].current) return;\n    computeBaseStyle(backendConfig.refs[0].current);\n    // Ensure all fonts are loaded before any measurements are made\n    document.fonts.ready.then(() => {\n      setMeasureFunction(() => backendConfig.measureFunction);\n    });\n  }, [backendConfig]);\n\n  return {\n    textMeasureContent: backendConfig.measureContent,\n    getTextDimensions: measureFunction\n  };\n};\n\nexport { useTextDimensions };\n"],"names":["textDimensionsCache","canvas","htmlSvg","htmlCanvas","svg","baseStyle","fontStyle","fontVariant","fontWeight","fontStretch","fontSize","lineHeight","fontFamily","letterSpacing","wordSpacing","fontVariantNumeric","LEGAL_FONT_VARIANT","Set","LEGAL_FONT_STRETCH","REPRESENTATIVE_TEXT","mergeDefaultStyle","font","toFontString","Number","isNaN","getCacheKey","textString","isNormalSpacing","value","getCanvasTextDimensions","canvasCtx","fullFont","cacheKey","cachedDims","fontString","textMetrics","measureText","dims","x","y","fontBoundingBoxAscent","width","height","fontBoundingBoxDescent","getSvgTextDimensions","container","text","document","createElementNS","setAttribute","style","textContent","appendChild","bbox","getBBox","innerHTML","getHtmlTextDimensions","baselineMeasureOptions","cache","backend","span","createElement","whiteSpace","size","offsetWidth","offsetHeight","getHtmlTextSize","options","dimensions","ctx","getRepresentativeTextDimensions","clientBrowser","getClientHints","browser","canvasRef","useRef","htmlRef","svgRef","measureFunction","setMeasureFunction","useState","backendConfig","useMemo","canvasContent","_jsx","ref","display","htmlContent","svgContent","config","refs","measureContent","current","getContext","_jsxs","children","measurementBackend","isLetterSpacingNormal","isWordSpacingNormal","isFontVariantNumericNormal","isFontVariantNumericInherited","getBackend","useLayoutEffect","referenceNode","computedStyle","getComputedStyle","fontVariantCaps","has","computeBaseStyle","fonts","ready","then","textMeasureContent","getTextDimensions"],"mappings":"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"}