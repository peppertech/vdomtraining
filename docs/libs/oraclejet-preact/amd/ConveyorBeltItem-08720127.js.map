{"version":3,"file":"ConveyorBeltItem-08720127.js","sources":["../../src/UNSAFE_ConveyorBelt/ConveyorBelt.tsx","../../src/UNSAFE_ConveyorBelt/ConveyorBeltItem.tsx"],"sourcesContent":["import { ComponentChildren, Ref } from 'preact';\nimport { useEffect, useRef, useState, useCallback, useMemo } from 'preact/hooks';\nimport { BaseButton } from '../UNSAFE_BaseButton';\nimport { ButtonLabelLayout } from '../UNSAFE_ButtonLabelLayout';\nimport { ChevronLeft } from '../UNSAFE_RedwoodIcons/ChevronLeft';\nimport { ChevronRight } from '../UNSAFE_RedwoodIcons/ChevronRight';\nimport { ChevronUp } from '../UNSAFE_RedwoodIcons/ChevronUp';\nimport { ChevronDown } from '../UNSAFE_RedwoodIcons/ChevronDown';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { ConveyorBeltContext } from './ConveyorBeltContext';\nimport { TestIdProps, useTestId } from '../hooks/UNSAFE_useTestId';\nimport { forwardRef, useImperativeHandle } from 'preact/compat';\nimport { ConveyorBeltVariantOptions } from './themes/ConveyorBeltStyles.css';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { ConveyorBeltRedwoodTheme } from './themes/redwood/ConveyorBeltTheme';\n\nexport type ConveyorBeltProps = TestIdProps & {\n  /**\n   * ConveyorBelt Component content\n   */\n  children?: ComponentChildren;\n  /**\n   * Sets the number of pixels that an element's content is scrolled from its initial position.\n   */\n  scrollPosition?: number;\n  /**\n   * Callback that is executed every time conveyor belt is scrolled and the scroll position is changed.\n   * @param value The value is the new scroll position of the conveyor belt.\n   * @returns\n   */\n  onScrollPositionChanged?: (value?: number) => void;\n  /**\n   * Indicates whether overflow content arrows are visible or hidden.\n   * \"auto\" show overflow arrows on desktop, hide on mobile.\n   * \"visible\" always show overflow arrows.\n   * \"hidden\" never show overflow arrows.\n   */\n  arrowVisibility?: 'auto' | 'visible' | 'hidden';\n\n  /**\n   * Specify the orientation of the conveyorBelt.\n   * \"horizontal\" Orient the conveyorBelt horizontally.\n   * \"vertical\" Orient the conveyorBelt vertically.\n   */\n  orientation?: 'horizontal' | 'vertical';\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if runnning on a mobile device, false otherwise\n */\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone';\n}\n\nfunction getOffsetParent(element: HTMLElement) {\n  if (getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent as HTMLElement;\n}\n\nfunction getOffsetLeft(element: HTMLElement, contentContainer?: HTMLElement | null) {\n  let offsetParent = getOffsetParent(element);\n  let offsetLeft = element.offsetLeft;\n\n  while (offsetParent && offsetParent !== contentContainer && offsetParent !== document.body) {\n    offsetLeft = offsetLeft + offsetParent.offsetLeft;\n    offsetParent = getOffsetParent(offsetParent);\n  }\n  return offsetLeft;\n}\n\nfunction getOffsetTop(element: HTMLElement, contentContainer?: HTMLElement | null) {\n  let offsetParent = getOffsetParent(element);\n  let offsetTop = element.offsetTop;\n\n  while (offsetParent !== contentContainer) {\n    if (offsetParent != null) {\n      offsetTop = offsetTop + offsetParent.offsetTop;\n      offsetParent = getOffsetParent(offsetParent);\n    }\n  }\n  return offsetTop;\n}\n\ntype ConveyorItemElement = {\n  element: HTMLElement;\n  isVisible: boolean;\n  isCurrent: boolean;\n  index: number;\n};\n\n// utility hook that calculates which conveyorbelt items are visible inside conveyorbelt viewport\n// and which are hidden\nconst useConveyorElementsVisible = (\n  root: HTMLDivElement,\n  orientation: 'horizontal' | 'vertical',\n  prevBtn?: HTMLDivElement,\n  nextBtn?: HTMLDivElement,\n  direction?: 'ltr' | 'rtl'\n) => {\n  const observerRef = useRef<IntersectionObserver>();\n  const targetsRef = useRef<ConveyorItemElement[]>([]);\n  const [targets] = useState<ConveyorItemElement[]>([]);\n  const addTarget = useCallback(\n    (target: ConveyorItemElement) => {\n      if (targetsRef.current !== null) {\n        targetsRef.current.push(target);\n        targets.push(target);\n      }\n    },\n    [targets]\n  );\n\n  useEffect(() => {\n    if (targets && targets.length > 0 && root) {\n      // IntersectionObserver calls visibility change only when item is\n      // fully visible inside (threshold: 1)\n      // conveyorbelt viewport (root),\n      // taking arrow buttons into the account\n      // and viewport should be smaller by the buttons width (rootMargin)\n      const rootMargin =\n        orientation === 'horizontal'\n          ? direction === 'ltr'\n            ? `0px ${nextBtn ? -nextBtn.offsetWidth : 0}px 0px ${\n                prevBtn ? -prevBtn.offsetWidth : 0\n              }px`\n            : `0px ${prevBtn ? -prevBtn.offsetWidth : 0}px 0px ${\n                nextBtn ? -nextBtn.offsetWidth : 0\n              }px`\n          : `${nextBtn ? -nextBtn.offsetHeight : 0}px 0px ${\n              prevBtn ? -prevBtn.offsetHeight : 0\n            }px 0px`;\n\n      observerRef.current = new IntersectionObserver(onVisibilityChange, {\n        root,\n        rootMargin: rootMargin,\n        threshold: 1\n      });\n      for (const target of targets) {\n        if (target != null) observerRef.current.observe(target.element);\n      }\n    }\n    return () => {\n      for (const target of targets) {\n        if (observerRef.current && target != null) observerRef.current.unobserve(target.element);\n      }\n    };\n  }, [targets, targets.length, root, nextBtn, prevBtn, direction, orientation]);\n\n  // handle visibility changes\n  const onVisibilityChange = (entries: IntersectionObserverEntry[]) => {\n    const newItems: ConveyorItemElement[] = targetsRef.current.map((conveyorItem, index) => {\n      const foundEntry = entries.find((entry) => entry.target === conveyorItem.element);\n      // if visibility changed for the item, change isVisible property,\n      // otherwise just return the original\n      if (foundEntry) {\n        return {\n          element: foundEntry.target as HTMLDivElement,\n          isVisible: foundEntry.isIntersecting,\n          isCurrent: conveyorItem.isCurrent,\n          index: index\n        };\n      } else {\n        return conveyorItem;\n      }\n    });\n    targetsRef.current = newItems;\n  };\n\n  return useMemo(\n    () => ({\n      itemElementsRef: targetsRef,\n      addItem: addTarget\n    }),\n    [targetsRef, addTarget]\n  );\n};\n\nexport type ScrollableHandle = {\n  scrollElementIntoView: (element: HTMLElement) => void;\n};\n\n/**\n * The Conveyor belt component is a container element that manages\n * overflow for its child elements and allows scrolling among them\n */\nexport const ConveyorBelt = forwardRef(\n  (\n    {\n      children,\n      scrollPosition,\n      onScrollPositionChanged,\n      arrowVisibility = 'auto',\n      orientation = 'horizontal',\n      testId\n    }: ConveyorBeltProps,\n    ref: Ref<ScrollableHandle> = null\n  ) => {\n    const [canPaginateNext, setCanPaginateNext] = useState(false);\n    const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);\n    const overflowContainerRef = useRef<HTMLDivElement | null>(null);\n    const contentContainerRef = useRef<HTMLDivElement | null>(null);\n    const nextButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const prevButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const baseRef = useRef<HTMLDivElement | null>(null);\n    const leftRef = useRef<HTMLDivElement | null>(null);\n    const rightRef = useRef<HTMLDivElement | null>(null);\n    const observerRef = useRef<any>(null);\n    const currentItemRef = useRef<HTMLElement | null>(null);\n    const [buttonsHidden, setButtonsHidden] = useState(\n      (isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden'\n    );\n    const { direction } = useUser();\n    const { itemElementsRef, addItem } = useConveyorElementsVisible(\n      overflowContainerRef.current!,\n      orientation,\n      prevButtonContainerRef.current!,\n      nextButtonContainerRef.current!,\n      direction\n    );\n\n    useImperativeHandle(ref, () => ({\n      scrollElementIntoView: (element: HTMLElement) => {\n        scrollIntoView(element);\n      },\n      scrollPrevious: () => {\n        scrollToPreviousPage();\n      },\n      scrollNext: () => {\n        scrollToNextPage();\n      }\n    }));\n\n    const testIdProps = useTestId(testId);\n    const leftArrowTestIdProps = 'leftArrow' + testId;\n    const rightArrowTestIdProps = 'rightArrow' + testId;\n\n    const { variantClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        orientation\n      }\n    );\n\n    const { variantClasses: contentClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        content: orientation\n      }\n    );\n\n    const { variantClasses: overflowClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        pagination:\n          canPaginateNext && canPaginatePrevious\n            ? 'both'\n            : canPaginateNext\n            ? 'next'\n            : canPaginatePrevious\n            ? 'previous'\n            : 'none',\n        direction,\n        orientation,\n        overflow: orientation,\n        arrowVisibility: buttonsHidden === true ? 'hidden' : 'visible'\n      }\n    );\n\n    const { classes: nextButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        nextButton: orientation,\n        direction\n      }\n    );\n\n    const { classes: previousButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        previousButton: orientation,\n        direction\n      }\n    );\n\n    // utility method to get all conveyorbelt items\n    const _getConveyorItems = () => {\n      const conveyorContentChildren = contentContainerRef.current\n        ? Array.from(contentContainerRef.current.querySelectorAll('[data-oj-conveyorbelt-item]'))\n        : [];\n      if (conveyorContentChildren) {\n        let index = -1;\n        for (const child of conveyorContentChildren) {\n          index++;\n          const element = child as HTMLElement;\n          if (element) {\n            const item = itemElementsRef.current.find((item) => item.element === element);\n            if (item == null) {\n              addItem({\n                element: element!,\n                isVisible: false,\n                index: index,\n                isCurrent: false\n              });\n            }\n          }\n        }\n      }\n    };\n\n    useEffect(() => {\n      _getConveyorItems();\n    });\n\n    const scrollEndHandler = useCallback(() => {\n      if (onScrollPositionChanged)\n        onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);\n    }, [onScrollPositionChanged]);\n\n    useEffect(() => {\n      setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');\n    }, [arrowVisibility]);\n\n    useEffect(() => {\n      if (!overflowContainerRef.current) return;\n      overflowContainerRef.current.scrollTo({\n        left: scrollPosition\n      });\n    }, [scrollPosition]);\n\n    // useEffect hook that calculates when arrow buttons should become visible or hidden\n    // using IntersectionObserver\n    useEffect(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const leftGuard = leftRef.current;\n      const rightGuard = rightRef.current;\n\n      if (overflowContainer && leftGuard && rightGuard) {\n        if (!buttonsHidden) {\n          observerRef.current = new IntersectionObserver(\n            (entries) => {\n              entries.forEach((entry) => {\n                if (entry.target.getAttribute('data-intersection-id') === 'left') {\n                  setCanPaginatePrevious(!entry.isIntersecting);\n                } else {\n                  setCanPaginateNext(!entry.isIntersecting);\n                }\n              });\n            },\n            {\n              root: overflowContainer\n            }\n          );\n          observerRef.current.observe(leftGuard);\n          observerRef.current.observe(rightGuard);\n        }\n        overflowContainer.addEventListener('scrollend', scrollEndHandler);\n      }\n\n      // Clean-up\n      return () => {\n        if (!overflowContainer) return;\n        overflowContainer.removeEventListener('scrollend', scrollEndHandler);\n        observerRef.current?.unobserve(leftGuard);\n        observerRef.current?.unobserve(rightGuard);\n      };\n    }, [buttonsHidden, scrollEndHandler]);\n\n    const scrollIntoView = useCallback(\n      (element: HTMLElement) => {\n        // utility method to check if the element is closer to the end edge of the conveyorbelt\n        const _shouldSnapToTheEndEdge = (\n          ltr: boolean,\n          orientation: 'horizontal' | 'vertical',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let right;\n          let left;\n          let bottom;\n\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            bottom = document.documentElement.clientHeight;\n          } else {\n            const scrollerBounds = scroller.getBoundingClientRect();\n            right = canPaginateNext\n              ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.right;\n            left = canPaginateNext\n              ? scrollerBounds.left - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.left;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? ltr\n              ? bounds.right > right\n              : bounds.left < left\n            : bounds.bottom > bottom;\n        };\n\n        // utility method to check that an element is fully visible inside conveyorbelt\n        const _isElementInsideScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let left;\n          let right;\n          let top;\n          let bottom;\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            top = 0;\n            bottom = document.documentElement.clientHeight;\n          } else {\n            const scrollerBounds = scroller.getBoundingClientRect();\n            left = canPaginatePrevious\n              ? scrollerBounds.left + prevButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.left;\n            right = canPaginateNext\n              ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.right;\n            top = canPaginatePrevious\n              ? scrollerBounds.top + prevButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.top;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? bounds.left <= right &&\n                bounds.right <= right &&\n                bounds.left >= left &&\n                bounds.right >= left\n            : bounds.top <= bottom &&\n                bounds.bottom <= bottom &&\n                bounds.top >= top &&\n                bounds.bottom >= top;\n        };\n\n        const _isElementOverflowingScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          const bounds = elem.getBoundingClientRect();\n          const scrollerBounds = scroller.getBoundingClientRect();\n          let width = scrollerBounds.width;\n          let height = scrollerBounds.height;\n          if (orientation === 'horizontal') {\n            width =\n              canPaginatePrevious && prevButtonContainerRef.current\n                ? width - prevButtonContainerRef.current.offsetWidth\n                : width;\n            width =\n              canPaginateNext && nextButtonContainerRef.current\n                ? width - nextButtonContainerRef.current.offsetWidth\n                : width;\n          } else {\n            height =\n              canPaginatePrevious && prevButtonContainerRef.current\n                ? height - prevButtonContainerRef.current.offsetHeight!\n                : height;\n            height =\n              canPaginateNext && nextButtonContainerRef.current\n                ? height - nextButtonContainerRef.current.offsetHeight!\n                : height;\n          }\n\n          return orientation === 'horizontal' ? bounds.width > width : bounds.height > height;\n        };\n\n        const isElementVisible = _isElementInsideScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (isElementVisible) {\n          return;\n        }\n        const isElementOverflowing = _isElementOverflowingScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n\n        if (!overflowContainerRef.current || !contentContainerRef.current) return;\n        const shouldSnapEnd = _shouldSnapToTheEndEdge(\n          direction === 'ltr',\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (orientation === 'vertical') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              top:\n                getOffsetTop(element, contentContainerRef.current) +\n                element.offsetHeight -\n                overflowContainerRef.current.offsetHeight +\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              top:\n                getOffsetTop(element, contentContainerRef.current) -\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n\n        if (direction === 'ltr') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) +\n                element.offsetWidth -\n                overflowContainerRef.current.offsetWidth +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) -\n                contentContainerRef.current.offsetWidth +\n                overflowContainerRef.current.offsetWidth -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) +\n                element.offsetWidth -\n                contentContainerRef.current.offsetWidth +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      },\n      [canPaginateNext, canPaginatePrevious, direction, orientation]\n    );\n\n    const getNextInvisible = useCallback(() => {\n      const nextInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index >= 1 &&\n          itemElementsRef.current[item.index - 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return nextInvisible?.element;\n    }, [itemElementsRef]);\n\n    const getPreviousInvisible = useCallback(() => {\n      const previousInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index < itemElementsRef.current.length - 1 &&\n          itemElementsRef.current[item.index + 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return previousInvisible?.element;\n    }, [itemElementsRef]);\n\n    // paginates to the previous partially visible or hidden item in the conveyorbelt,\n    // so that it is the last visible of the conveyorbelt view port\n    const scrollToPreviousPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const previousInvisible: HTMLElement | undefined = getPreviousInvisible();\n        if (orientation === 'vertical') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                getOffsetTop(previousInvisible, contentContainerRef.current) +\n                previousInvisible.offsetHeight -\n                overflowContainer.offsetHeight +\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                getOffsetLeft(previousInvisible, contentContainerRef.current) +\n                previousInvisible.offsetWidth -\n                overflowContainer.offsetWidth +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                getOffsetLeft(previousInvisible, contentContainerRef.current) -\n                contentContainerRef.current?.offsetWidth! +\n                overflowContainer.offsetWidth -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getPreviousInvisible]);\n\n    // paginates to the next partially visible or hidden item in the conveyorbelt,\n    // so that it is the first at the start of the conveyorbelt view port\n    const scrollToNextPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const nextInvisible: HTMLElement | undefined = getNextInvisible();\n        if (orientation === 'vertical') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                getOffsetTop(nextInvisible, contentContainerRef.current) -\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0) -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                -(\n                  contentContainerRef.current?.offsetWidth! -\n                  (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0)\n                ) +\n                (nextInvisible?.offsetWidth ?? 0) +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getNextInvisible]);\n\n    const setCurrentItem = useCallback(\n      (node: HTMLElement | null) => {\n        if (currentItemRef.current !== node) {\n          // this logic below is needed to make sure only one item is current\n          const item = itemElementsRef.current.find((item) => item.element === node);\n          const currentItem = itemElementsRef.current.find((item) => item.isCurrent === true);\n          if (item === currentItem || !item) return;\n          if (currentItem) currentItem.isCurrent = false;\n          item.isCurrent = true;\n\n          currentItemRef.current = node;\n          if (node) scrollIntoView(node);\n        }\n      },\n      [itemElementsRef, scrollIntoView]\n    );\n\n    const onFocus = useCallback(\n      (event: FocusEvent) => {\n        if (baseRef.current?.isEqualNode(event.target as HTMLElement)) {\n          return;\n        }\n        if (itemElementsRef.current.length > 0) {\n          const item = itemElementsRef.current.find((item) => item.element.contains(event.target as Node));\n          if (item) {\n            scrollIntoView(item.element)\n          } \n        } else {\n          scrollIntoView(event.target as HTMLElement);\n        }\n      },\n      [scrollIntoView, itemElementsRef]\n    );\n\n    const previousButtonStyle = clsx([styles.buttonContainer, previousButtonClasses]);\n\n    const nextButtonStyle = clsx([styles.buttonContainer, nextButtonClasses]);\n\n    return (\n      <ConveyorBeltContext.Provider value={{ setCurrentItem }}>\n        <div\n          onFocus={onFocus}\n          ref={baseRef}\n          className={clsx([styles.conveyorStyle, variantClasses])}\n          {...testIdProps}>\n          {canPaginatePrevious && !buttonsHidden && (\n            <div ref={prevButtonContainerRef} class={previousButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToPreviousPage()}\n                aria-hidden={true}\n                testId={leftArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronLeft />\n                      ) : (\n                        <ChevronRight />\n                      )\n                    ) : (\n                      <ChevronUp />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n          <div\n            className={clsx([styles.overflowContainer, overflowClasses])}\n            ref={overflowContainerRef}\n            tabIndex={-1}>\n            <div\n              className={clsx([styles.contentContainer, variantClasses, contentClasses])}\n              ref={contentContainerRef}>\n              <div\n                data-intersection-id=\"left\"\n                ref={leftRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n              {children}\n              <div\n                data-intersection-id=\"right\"\n                ref={rightRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n            </div>\n          </div>\n          {canPaginateNext && !buttonsHidden && (\n            <div ref={nextButtonContainerRef} class={nextButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToNextPage()}\n                aria-hidden={true}\n                testId={rightArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronRight />\n                      ) : (\n                        <ChevronLeft />\n                      )\n                    ) : (\n                      <ChevronDown />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n        </div>\n      </ConveyorBeltContext.Provider>\n    );\n  }\n);\n","import { ComponentChildren } from 'preact';\nimport { useConveyorBeltItem } from './useConveyorBeltItem';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\n\ntype ConveyorBeltItemProps = {\n  /**\n   * The ConveyorBeltItem content\n   */\n  children?: ComponentChildren;\n  /**\n   * Specifies the current item which should be scrolled into view\n   */\n  isCurrent?: boolean;\n};\n/**\n * A wrapper component for one conveyor belt item/child element.\n * It takes care of correctly mark the child components as conveyor belt items.\n * @param param0 ConveyorBeltItemProps\n * @returns\n */\nexport const ConveyorBeltItem = ({ children, isCurrent }: ConveyorBeltItemProps) => {\n  const props = useConveyorBeltItem({\n    isCurrent: isCurrent\n  });\n  return (\n    <div className={clsx([styles.conveyorBeltItemStyle])} {...props}>\n      {children}\n    </div>\n  );\n};\n"],"names":["isMobile","getClientHints","deviceType","getOffsetParent","element","getComputedStyle","position","offsetParent","getOffsetLeft","contentContainer","offsetLeft","document","body","getOffsetTop","offsetTop","ConveyorBelt","forwardRef","children","scrollPosition","onScrollPositionChanged","arrowVisibility","orientation","testId","ref","canPaginateNext","setCanPaginateNext","useState","canPaginatePrevious","setCanPaginatePrevious","overflowContainerRef","useRef","contentContainerRef","nextButtonContainerRef","prevButtonContainerRef","baseRef","leftRef","rightRef","observerRef","currentItemRef","buttonsHidden","setButtonsHidden","direction","useUser","itemElementsRef","addItem","root","prevBtn","nextBtn","targetsRef","targets","addTarget","useCallback","target","current","push","useEffect","length","rootMargin","offsetWidth","offsetHeight","IntersectionObserver","onVisibilityChange","threshold","observe","unobserve","entries","newItems","map","conveyorItem","index","foundEntry","find","entry","isVisible","isIntersecting","isCurrent","useMemo","useConveyorElementsVisible","useImperativeHandle","scrollElementIntoView","scrollIntoView","scrollPrevious","scrollToPreviousPage","scrollNext","scrollToNextPage","testIdProps","useTestId","leftArrowTestIdProps","rightArrowTestIdProps","variantClasses","useComponentTheme","ConveyorBeltRedwoodTheme","contentClasses","content","overflowClasses","pagination","overflow","classes","nextButtonClasses","nextButton","previousButtonClasses","previousButton","conveyorContentChildren","Array","from","querySelectorAll","child","item","_getConveyorItems","scrollEndHandler","scrollLeft","scrollTo","left","overflowContainer","leftGuard","rightGuard","forEach","getAttribute","addEventListener","removeEventListener","isElementVisible","elem","scroller","right","top","bottom","documentElement","clientWidth","clientHeight","scrollerBounds","getBoundingClientRect","bounds","_isElementInsideScrollerBounds","isElementOverflowing","width","height","_isElementOverflowingScrollerBounds","shouldSnapEnd","ltr","_shouldSnapToTheEndEdge","behavior","getNextInvisible","nextInvisible","getPreviousInvisible","previousInvisible","scrollAmount","scrollTop","setCurrentItem","node","currentItem","onFocus","event","isEqualNode","contains","previousButtonStyle","clsx","styles","buttonContainer","nextButtonStyle","_jsx","ConveyorBeltContext","Provider","value","_jsxs","className","conveyorStyle","jsx","class","BaseButton","elementDetails","type","isFocusable","styling","size","variant","onAction","ButtonLabelLayout","display","startIcon","ChevronLeft","SvgChevronLeft","ChevronRight","ChevronUp","tabIndex","style","minWidth","minHeight","ChevronDown","SvgChevronDown","props","useConveyorBeltItem","classNames","conveyorBeltItemStyle"],"mappings":"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"}