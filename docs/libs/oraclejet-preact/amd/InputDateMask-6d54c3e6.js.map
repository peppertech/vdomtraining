{"version":3,"file":"InputDateMask-6d54c3e6.js","sources":["../../src/UNSAFE_InputDateMask/DateSegment.tsx","../../src/UNSAFE_InputDateMask/LiteralSegment.tsx","../../src/UNSAFE_InputDateMask/dateReducer.ts","../../src/UNSAFE_InputDateMask/useDateFieldHandlers.ts","../../src/UNSAFE_InputDateMask/DateField.tsx","../../src/UNSAFE_InputDateMask/useDateField.ts","../../src/UNSAFE_InputDateMask/InputDateMaskContext.ts","../../src/UNSAFE_InputDateMask/InputDateMask.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport { AriaAttributesSignalExcluded } from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateFieldAction } from './dateReducer';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { EditableDateSegment } from './types';\nimport { isBackspaceOrDelete, isSelectAll } from '#utils/PRIVATE_keyboardUtils';\nimport { isNumberOnlyString } from '#utils/PRIVATE_dayUtils';\nimport { segmentStyles } from './themes/SegmentStyles.css';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype AriaProps = Pick<\n  AriaAttributesSignalExcluded,\n  'aria-label' | 'aria-valuemax' | 'aria-valuemin' | 'aria-valuenow' | 'aria-valuetext'\n>;\n\ntype Props = AriaProps & {\n  /** A ref that is provided for the first segment in a date field. */\n  inputRef?: RefObject<HTMLDivElement>;\n\n  /**\n   * True if the segment is complete in the sense that it contains a complete valid value.\n   * For instance, entering '0' and then '1-9' is considered a complete value for month and day.\n   * Also true if typing any additional digit would cause the segment value to exceed the max.\n   */\n  isComplete?: boolean;\n\n  /**\n   * True if the segment is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment is highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the segment is invalid.\n   */\n  isInvalid?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   */\n  isRequired?: boolean;\n\n  /**\n   * True if the segment is selected.\n   */\n  isSelected?: boolean;\n\n  /**\n   * Placeholder displayed when the segment has no display value.\n   */\n  placeholder?: string;\n\n  /**\n   * The text to display for this segment.\n   */\n  text?: string;\n\n  /**\n   * The segment of a calendar date which is being represented, i.e. the month, day, or year.\n   */\n  type: EditableDateSegment;\n\n  /**\n   * Callback invoked when a change to the segment is requested via user action, such as typing\n   * a new value or pressing the Backspace or Delete keys.\n   */\n  onChange?: (action: DateFieldAction) => void;\n};\n\n// Used to disable browser cut and paste, which don't really work with segments (copy is fine).\nconst preventDefaultHandler = (e: Event) => {\n  e.preventDefault();\n};\n\nconst isIos = () => getClientHints().platform === 'ios';\n\n/**\n * A DateSegment renders a part of a calendar date, e.g. the day, month, or year.\n * It can be used as a spinbutton to step or spin its value.\n */\nexport const DateSegment = ({\n  'aria-label': ariaLabel,\n  'aria-valuemax': ariaValueMax,\n  'aria-valuemin': ariaValueMin,\n  'aria-valuenow': ariaValueNow,\n  'aria-valuetext': ariaValueText,\n  inputRef,\n  isComplete,\n  isDisabled,\n  isHidden,\n  isHighlighted,\n  isInvalid,\n  isRequired,\n  isSelected,\n  onChange,\n  placeholder,\n  text,\n  type\n}: Props) => {\n  const hasDisplayValue = text && text.length > 0;\n  const rootClasses = classNames([\n    segmentStyles.base,\n    isSelected && segmentStyles.selected,\n    isHighlighted && segmentStyles.highlighted\n  ]);\n  const placeholderClasses = classNames([\n    segmentStyles.placeholder,\n    isHidden || hasDisplayValue ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const emptySegmentValueText = translations.inputDateMask_empty_segment();\n\n  // If a ref was passed in, use it, otherwise get a ref.\n  const sRef = useRef<HTMLDivElement>(null);\n  const segmentRef = inputRef ?? sRef;\n\n  const hasLeadingZero = useRef<boolean>(false);\n  const { locale } = useUser();\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        isDisabled ||\n        event.key === 'Tab' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight' ||\n        event.key === 'Enter' ||\n        isSelectAll(event)\n      ) {\n        // Let the event pass through.\n        return;\n      }\n\n      if (isHighlighted) {\n        // If date is selected, ignore edits and let backspace/delete pass through to clear.\n        if (isBackspaceOrDelete(event) || event.key === 'Backspace') {\n          return;\n        }\n      } else if (event.key === '0' && (isComplete || text === undefined)) {\n        // Typing '0' is considered a leading zero if the segment is complete, in which case\n        // the user is typing a new value, or if there is no current value.\n        hasLeadingZero.current = true;\n      } else if (isNumberOnlyString(event.key)) {\n        onChange?.({\n          actionType: 'updateSegment',\n          data: { type, text: event.key, hasLeadingZero: hasLeadingZero.current, locale }\n        });\n        hasLeadingZero.current = false;\n      } else if (isBackspaceOrDelete(event) || event.key === 'Backspace') {\n        // Android sends Backspace as event.key, not event.code, so check for it.\n        onChange?.({ actionType: 'clearSegment', data: { type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowUp') {\n        onChange?.({ actionType: 'step', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowDown') {\n        onChange?.({ actionType: 'step', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageUp') {\n        onChange?.({ actionType: 'page', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageDown') {\n        onChange?.({ actionType: 'page', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'Home') {\n        onChange?.({ actionType: 'goToHome', data: { locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'End') {\n        onChange?.({ actionType: 'goToEnd', data: { locale, type } });\n        hasLeadingZero.current = false;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    },\n    [isComplete, isDisabled, isHighlighted, locale, onChange, text, type]\n  );\n\n  // Used to focus the segment when isSelected is true.\n  useEffect(() => {\n    if (isSelected) {\n      segmentRef.current?.focus();\n    }\n  }, [isSelected, segmentRef]);\n\n  // This attribute is used to distinguish between segments when clicked (see DateField.tsx).\n  const customDataAttribute = { 'data-segment': [type] };\n\n  // If ariaValueText is undefined, substitute a string that indicates the segment is empty.\n  // If ariaValueNow and ariaValueText represent the same value, omit the value text; this\n  // is the same as what we do in NumberInputText.\n  const valueText =\n    ariaValueText === undefined\n      ? emptySegmentValueText\n      : ariaValueNow?.toString() === ariaValueText\n      ? undefined\n      : ariaValueText;\n\n  return (\n    // Introduce a div wrapper around the contentEditable element to prevent it from grabbing focus.\n    // https://stackoverflow.com/questions/34354085/clicking-outside-a-contenteditable-div-stills-give-focus-to-it\n    // JET-64874: We change the segment's role to \"textbox\" on iOS to work around a VoiceOver bug.\n    <div>\n      <div\n        ref={segmentRef}\n        role={isIos() ? 'textbox' : 'spinbutton'}\n        aria-disabled={isDisabled}\n        aria-invalid={isInvalid || undefined}\n        aria-label={ariaLabel}\n        aria-required={isRequired}\n        aria-valuemin={isIos() ? undefined : ariaValueMin}\n        aria-valuemax={isIos() ? undefined : ariaValueMax}\n        aria-valuenow={isIos() ? undefined : ariaValueNow}\n        aria-valuetext={isIos() ? undefined : valueText}\n        autocapitalize=\"off\"\n        autocorrect=\"off\"\n        class={rootClasses}\n        contentEditable={!isDisabled}\n        {...customDataAttribute}\n        enterkeyhint={isDisabled ? undefined : 'done'}\n        inputMode={isDisabled ? 'none' : 'numeric'}\n        onCut={preventDefaultHandler}\n        onKeyDown={onKeyDown}\n        onPaste={preventDefaultHandler}\n        spellcheck={false}\n        tabIndex={isSelected ? 0 : -1}>\n        <span aria-hidden=\"true\" class={placeholderClasses} {...customDataAttribute}>\n          {placeholder}\n        </span>\n        {text}\n      </div>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { segmentStyles } from './themes/SegmentStyles.css';\n\ntype Props = {\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment should be highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the literal is part of a date placeholder, such as mm/dd/yyyy.\n   * If the date is partially specified or complete, this is false.\n   */\n  isPlaceholder?: boolean;\n\n  /**\n   * The text to display for this segment.\n   */\n  text: string;\n};\n\n/**\n * LiteralSegment is used to represent a literal separator in a calendar date,\n * such as the '/' in 11/29/2023.\n */\nexport const LiteralSegment = ({ isHidden, isHighlighted, isPlaceholder, text }: Props) => {\n  const spanClasses = classNames([\n    segmentStyles.literalBase,\n    isPlaceholder && segmentStyles.placeholder,\n    isHighlighted && segmentStyles.highlighted,\n    isHidden ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  return (\n    <span aria-hidden=\"true\" class={spanClasses}>\n      {text}\n    </span>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DateFieldState, DateSegmentState } from './useDateField';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { CalendarDate, EditableDateSegment, IsoMonth } from './types';\nimport { getMonthName, getTodayAsCalendarDate } from '#utils/PRIVATE_dayUtils';\nimport { getDaysInMonth, getMonthsInYear, MAX_ISO_YEAR } from '#utils/UNSAFE_calendarDateUtils';\n\ntype DateFieldActionData = Partial<DateSegmentState> & {\n  direction?: 'increase' | 'decrease';\n  hasLeadingZero?: boolean;\n  locale?: BCP47Locale;\n};\n\ntype DateFieldAction = {\n  actionType:\n    | 'clearDate'\n    | 'clearSegment'\n    | 'commit'\n    | 'goToEnd'\n    | 'goToHome'\n    | 'page'\n    | 'selectDateOrSegment'\n    | 'selectFirst'\n    | 'selectNext'\n    | 'selectPrevious'\n    | 'selectSegment'\n    | 'step'\n    | 'updateSegment';\n  data?: DateFieldActionData;\n};\n\ntype ResetAction = {\n  actionType: 'reset';\n  data: DateFieldState;\n};\n\ntype DateReducerAction = DateFieldAction | ResetAction;\n\n/**\n * Reducer function for updating DateFieldState per the specified DateFieldAction.\n * @param state\n * @param action\n */\nconst dateReducer = (state: DateFieldState, action: DateReducerAction) => {\n  // On mount, the reducer is initialized with initial state derived from the DateField's value.\n  // If that value is changed programmatically afterwards, the only way to push that update\n  // into the reducer is to define a \"reset\" action.\n  if (action.actionType === 'reset') {\n    return action.data;\n  }\n\n  const segmentType = action.data?.type!;\n  const segmentState = findSegment(state.segments, segmentType);\n\n  switch (action.actionType) {\n    case 'clearDate': {\n      const updatedSegments = selectFirst(clearDate(state.segments), state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'clearSegment': {\n      const updatedSegment = clearSegment(segmentState);\n      return createDateFieldState(state, segmentType, updatedSegment);\n    }\n    case 'commit': {\n      const updatedSegments = clearSelectionAndComplete(state.segments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'goToEnd': {\n      const updatedSegment = goToEnd(\n        segmentType,\n        segmentState,\n        state.segments,\n        action.data?.locale!\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'goToHome': {\n      const updatedSegment = goToHome(\n        segmentType,\n        segmentState,\n        state.segments,\n        action.data?.locale!\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'page': {\n      const direction = action.data?.direction;\n      const locale = action.data?.locale!;\n      const updatedSegment = doStepOrPage(\n        segmentType,\n        segmentState,\n        state.segments,\n        'page',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'selectDateOrSegment': {\n      return selectDateOrSegment(state);\n    }\n    case 'selectFirst': {\n      const updatedSegments = selectFirst(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectNext': {\n      const updatedSegments = selectNext(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectPrevious': {\n      const updatedSegments = selectPrevious(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectSegment': {\n      const updatedSegments = selectSegment(state.segments, segmentType);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'step': {\n      const direction = action.data?.direction;\n      const locale = action.data?.locale!;\n      const updatedSegment = doStepOrPage(\n        segmentType,\n        segmentState,\n        state.segments,\n        'step',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'updateSegment': {\n      const updatedSegment = updateSegment(segmentType, segmentState, action, state.segments);\n      return createDateFieldState(state, segmentType, updatedSegment);\n    }\n    default: {\n      throw new Error('Unknown action type');\n    }\n  }\n};\n\nconst stringToNumber = (s: string) => +s;\nconst numberToString = (n: number) => n.toString();\nconst withinRange = (n: number, min: number, max: number) => n >= min && n <= max;\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n// A segment is considered complete if appending a zero to the current value causes it\n// to exceed the max. For instance, if you type 2-9 into month or 4-9 into day, the\n// segment is complete because you can't type any more digits and have it be a valid value.\nconst isSegmentComplete = (val: number, max: number) => {\n  const num = stringToNumber(numberToString(val) + '0');\n  return num > max;\n};\n\n// A date is considered complete if all of its segments have values.\nconst isDateComplete = (allSegments: DateSegmentState[]) => {\n  return allSegments.every((seg) => seg.text && seg.text.length > 0);\n};\n\n// A date is considered a partial date if at least one segment has a value.\nconst isPartialDate = (allSegments: DateSegmentState[]) => {\n  return allSegments.some((seg) => seg['aria-valuenow'] !== undefined);\n};\n\n// Construct a calendar date that reflects the values of each segment.\n// If none of the segments have a value, return undefined.\nconst createCalendarDateFromSegments = (segments: DateSegmentState[]) => {\n  const hasAnySegmentWithAValue = isPartialDate(segments);\n  if (!hasAnySegmentWithAValue) {\n    return undefined;\n  }\n\n  // This returns something that looks like [ {month: 12}, {day: 25}, {year: 2020} ].\n  // Note: we use the aria-valuenow to get the current value as a number (not string).\n  const segmentValues = segments.map((seg) => {\n    return { [seg.type]: seg['aria-valuenow'] };\n  });\n\n  // Iterate over segmentValues and spread each value to get {month: 12, day:25, year: 2020}.\n  const iterator = segmentValues.values();\n  let cd: CalendarDate = {};\n  for (const segValue of iterator) {\n    cd = { ...cd, ...segValue };\n  }\n  return cd;\n};\n\n// Find the current value for year.\nconst getYearValue = (segments: DateSegmentState[]) => {\n  const yearState = findSegment(segments, 'year');\n  return yearState['aria-valuenow'];\n};\n\n// Find the current value for month.\nconst getMonthValue = (segments: DateSegmentState[]) => {\n  const monthState = findSegment(segments, 'month');\n  return monthState['aria-valuenow'] as IsoMonth;\n};\n\n// Determine the aria-valuetext for the given month, which includes the month name.\nconst getMonthAria = (locale: BCP47Locale, month: IsoMonth, year: number | undefined) => {\n  const monthName = getMonthName(locale, month, year ?? '*', 'long');\n  return `${month} - ${monthName}`;\n};\n\n// Return a copy of the ordered segments array.\nconst getOrderedSegments = (currentState: DateFieldState) => {\n  return [...currentState.orderedSegments];\n};\n\n// Replace the updated segment and return a new DateSegmentState[].\nconst replaceDateSegment = (\n  existingSegments: DateSegmentState[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState\n) => {\n  return existingSegments.map((seg) => (seg.type === updatedSegmentType ? updatedSegment : seg));\n};\n\n// Return a new DateSegmentState[] that reflects changes across all segments.\n// When you change the month this can affect the day, for instance.\nconst createDateSegmentStates = (\n  existingSegments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance: boolean\n) => {\n  const modifiedSegments = replaceDateSegment(existingSegments, updatedSegmentType, updatedSegment);\n  let updatedSegments = modifiedSegments;\n\n  if (updatedSegmentType === 'month' || updatedSegmentType === 'year') {\n    // If month was changed, update the day as needed; this includes adjusting the\n    // day value if it now exceeds the max number of days in the month.\n    // If year was changed, that can also affect the max number of days (if month is February).\n    const daySeg = findSegment(modifiedSegments, 'day');\n    if (daySeg) {\n      const monthValue =\n        updatedSegmentType == 'month'\n          ? (updatedSegment['aria-valuenow'] as IsoMonth)\n          : getMonthValue(modifiedSegments);\n      const yearValue =\n        updatedSegmentType === 'year'\n          ? updatedSegment['aria-valuenow']\n          : getYearValue(modifiedSegments);\n      const dayMax = getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n      const currentDay = daySeg['aria-valuenow'];\n      const dayValue = !!currentDay && currentDay > dayMax ? dayMax : currentDay;\n      const dayValueStr = !!dayValue ? numberToString(dayValue) : undefined;\n      const updatedDaySeg = {\n        ...daySeg,\n        'aria-valuemax': dayMax,\n        'aria-valuenow': dayValue,\n        'aria-valuetext': dayValueStr,\n        text: dayValueStr\n      };\n      updatedSegments = replaceDateSegment(modifiedSegments, 'day', updatedDaySeg);\n    }\n  }\n\n  // If the updatedSegment is complete, automatically select the next segment.\n  updatedSegments =\n    updatedSegment.isComplete && autoAdvance\n      ? selectNext(updatedSegments, orderedSegments)\n      : updatedSegments;\n\n  return updatedSegments;\n};\n\n// Construct a new DateFieldState from a set of updated segments.\nconst createDateFieldStateFromSegments = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[]\n) => {\n  return {\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected: currentState.isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\n// Construct a new DateFieldState given an updated segment, which may affect other segments.\nconst createDateFieldState = (\n  currentState: DateFieldState,\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance = true\n): DateFieldState => {\n  const updatedSegments = createDateSegmentStates(\n    currentState.segments,\n    currentState.orderedSegments,\n    updatedSegmentType,\n    updatedSegment,\n    autoAdvance\n  );\n\n  return createDateFieldStateFromSegments(currentState, updatedSegments);\n};\n\n// Return a new copy of the segment with the value cleared.\nconst clearSegment = (segmentState: DateSegmentState) => {\n  return {\n    ...segmentState,\n    'aria-valuetext': undefined,\n    'aria-valuenow': undefined,\n    text: undefined,\n    isComplete: false\n  };\n};\n\n// Return a new copy of segments with all values cleared and aria-valuemax adjusted.\nconst clearDate = (segments: DateSegmentState[]) => {\n  return segments.map((segmentState) => {\n    const cleared = clearSegment(segmentState);\n    const valueMax =\n      cleared.type === 'year'\n        ? MAX_ISO_YEAR\n        : cleared.type === 'month'\n        ? getMonthsInYear('*')\n        : getDaysInMonth('*', '*');\n    return { ...cleared, 'aria-valuemax': valueMax };\n  });\n};\n\n// Return a new copy of the segment with updated values.\nconst updateSegment = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  action: DateFieldAction,\n  segments: DateSegmentState[]\n) => {\n  const actionText = action.data?.text!;\n  const hasLeadingZero = action.data?.hasLeadingZero;\n  const locale = action.data?.locale!;\n  const minValue = segmentState['aria-valuemin']!;\n  const maxValue = segmentState['aria-valuemax']!;\n  const wasComplete = segmentState.isComplete;\n\n  // If the segment was already complete, replace any existing text with actionText.\n  // Otherwise append actionText onto existing text to get the requested string.\n  // For instance if the existing text is '1' and actionText (i.e. that the user typed)\n  // is '2' then requestedValStr is '12'.\n  const requestedValStr = wasComplete ? actionText : segmentState.text + actionText;\n\n  // If the requested value is out of range, discard the existing text/value and only\n  // keep the new one. Check if the segment is complete.\n  const requestedVal = stringToNumber(requestedValStr);\n  const inRange = withinRange(requestedVal, minValue, maxValue);\n  const newValStr = inRange ? requestedValStr : actionText;\n  const newVal = inRange ? requestedVal : stringToNumber(actionText);\n  const isComplete =\n    isSegmentComplete(newVal, maxValue) || (!!hasLeadingZero && segmentType !== 'year');\n\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete\n  };\n};\n\n// Return a new DateSegmentState[] where the specified segment is selected, all others cleared.\nconst selectSegment = (segments: DateSegmentState[], segmentType: EditableDateSegment) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: seg.type === segmentType ? true : false };\n  });\n};\n\n// Return a new DateSegmentState[] where the first segment is selected.\nconst selectFirst = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  return selectSegment(segments, orderedSegments[0]);\n};\n\n// Find the index of the selected segment in the ordered list; return -1 if there is no selection.\nconst getSelectedSegmentIndex = (\n  segments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[]\n) => {\n  const sel = segments.find((seg) => seg.isSelected === true);\n  return sel === undefined ? -1 : orderedSegments.findIndex((type) => type === sel.type);\n};\n\n// Convenience function to mark the selected segment complete.\nconst markSelectedSegmentComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => (seg.isSelected ? { ...seg, isComplete: true } : seg));\n};\n\n// Select the segment following the one that is currently selected.\nconst selectNext = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  const max = orderedSegments.length - 1;\n\n  // If we're already at the last position, do nothing. Note if nothing was currently selected\n  // then selectedIndex is -1. The first segment will be selected.\n  return selectedIndex === max\n    ? segments\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex + 1]);\n};\n\n// Select the segment prior to the one that is currently selected.\nconst selectPrevious = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  return selectedIndex === 0\n    ? segments\n    : selectedIndex === -1\n    ? selectFirst(segments, orderedSegments)\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex - 1]);\n};\n\n// Return a new DateSegmentState[] where all segments are unselected and any values are\n// marked complete. We want to do this when the user commits the DateField value (on blur).\nconst clearSelectionAndComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false, isComplete: !!seg.text };\n  });\n};\n\n// Return a new DateSegmentState[] where all segments are unselected.\nconst clearSelection = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false };\n  });\n};\n\n// Return a new DateFieldState where the entire date is selected if the date is complete,\n// or the first segment is selected.\nconst selectDateOrSegment = (currentState: DateFieldState) => {\n  if (currentState.isCompleteDate) {\n    return createDateFieldStateWithSelectedDate(\n      currentState,\n      clearSelection(currentState.segments),\n      true\n    );\n  } else {\n    const updatedSegments = selectFirst(currentState.segments, currentState.orderedSegments);\n    return createDateFieldStateFromSegments(currentState, updatedSegments);\n  }\n};\n\n// Create a new DateFieldState from the updatedSegments and isDateSelected params.\nconst createDateFieldStateWithSelectedDate = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[],\n  isDateSelected: boolean\n) => {\n  return {\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\nconst YEAR_HOME_VALUE = 1900;\nconst YEAR_END_VALUE = 2100;\n\n// If a segment is empty, use today's date as a starting point for any step or page action.\nconst getDefaultSegmentValue = (segmentType: EditableDateSegment) => {\n  const { year: yearDefault, month: monthDefault, day: dayDefault } = getTodayAsCalendarDate();\n  const defaults = { year: yearDefault, month: monthDefault, day: dayDefault };\n  return defaults[segmentType];\n};\n\n// Get the minimum value for the segment.\nconst getHomeSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_HOME_VALUE : segmentState['aria-valuemin']!;\n};\n\n// Get the maximum value for the segment (for year, this is YEAR_END_VALUE).\nconst getEndSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_END_VALUE : segmentState['aria-valuemax']!;\n};\n\n// Return the result of stepping currentValue in the requested direction, taking into account min and max.\nconst getSteppedSegmentValue = (\n  currentValue: number,\n  direction: DateFieldActionData['direction'],\n  min: number,\n  max: number\n) => {\n  const newValue =\n    direction === 'increase'\n      ? currentValue + 1 > max\n        ? min\n        : currentValue + 1\n      : currentValue - 1 < min\n      ? max\n      : currentValue - 1;\n  return newValue;\n};\n\n// Return the result of paging the value up or down, taking into account min and max.\nconst getPagedSegmentValue = (\n  currentValue: number,\n  direction: DateFieldActionData['direction'],\n  min: number,\n  max: number,\n  segmentType: EditableDateSegment\n) => {\n  const step = segmentType === 'month' ? 2 : segmentType === 'year' ? 5 : 7;\n  const newValue =\n    direction === 'increase'\n      ? currentValue + step > max\n        ? (currentValue + step) % max\n        : currentValue + step\n      : currentValue - step < min\n      ? currentValue - step + max\n      : currentValue - step;\n  return newValue;\n};\n\n// Create a new segment with an updated value from a keyboard action such as step, page, Home, or End.\nconst createSegmentFromKeyboardAction = (\n  newVal: number,\n  locale: BCP47Locale,\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[]\n) => {\n  const newValStr = numberToString(newVal);\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  // After any keyboard action, the value is complete so that if the user types anything,\n  // it will replace the stepped value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete: true\n  };\n};\n\n// Set the segment to its minimum value.\nconst goToHome = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getHomeSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Set the segment to its maximum value.\nconst goToEnd = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getEndSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Step or page a segment's value.\nconst doStepOrPage = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  type: 'step' | 'page',\n  direction: DateFieldActionData['direction'],\n  locale: BCP47Locale\n) => {\n  const valueNow = segmentState['aria-valuenow'];\n  const min = segmentState['aria-valuemin']!;\n  const max = segmentState['aria-valuemax']!;\n  const newValue =\n    valueNow === undefined\n      ? getDefaultSegmentValue(segmentType)\n      : type === 'page'\n      ? getPagedSegmentValue(valueNow, direction, min, max, segmentType)\n      : getSteppedSegmentValue(valueNow, direction, min, max);\n\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\nexport { dateReducer, getMonthAria, numberToString, stringToNumber };\nexport type { DateFieldAction, DateFieldActionData };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, RefObject } from 'preact';\nimport { Dispatch, MutableRef, useCallback, useEffect, useRef } from 'preact/hooks';\nimport { calendarDatesAreDifferent } from '#utils/PRIVATE_dayUtils';\nimport { DateFieldAction } from './dateReducer';\nimport { DateFieldState } from './useDateField';\nimport { CalendarDate, EditableDateSegment } from './types';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { isBackspaceOrDelete, isSelectAll } from '#utils/PRIVATE_keyboardUtils';\nimport { InputDateMask } from './InputDateMask';\nimport { useDoubleTap } from '#hooks/UNSAFE_useDoubleTap';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype Props = {\n  dateResetRef: MutableRef<boolean>;\n  direction: 'ltr' | 'rtl';\n  dispatch: Dispatch<DateFieldAction>;\n  groupRef?: RefObject<HTMLDivElement>;\n  isDisabled?: boolean;\n  isFocused?: boolean;\n  isInputFocused?: boolean;\n  onCommit: InputDateMaskProps['onCommit'];\n  onInput: InputDateMaskProps['onInput'];\n  state: DateFieldState;\n  value?: CalendarDate;\n};\n\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\n/**\n * A hook that creates various handlers and manages effects for a DateField.\n */\nconst useDateFieldHandlers = ({\n  dateResetRef,\n  direction,\n  dispatch,\n  groupRef,\n  isDisabled,\n  isFocused,\n  isInputFocused,\n  onCommit,\n  onInput,\n  state,\n  value: currentValue\n}: Props) => {\n  const { tabbableModeProps } = useTabbableMode();\n  const { tabIndex: tabbableModeIndex } = tabbableModeProps;\n  const anySegmentSelected = state.segments.some((segment) => !!segment.isSelected);\n\n  // If any segment is selected, it is contenteditable=true and it has the focus. If you shift-Tab, you will\n  // land on the outer div (DateField) first meaning it takes 2 shift-tab keys to get the previous element.\n  // To prevent this, if any segment is selected the tabindex on the div is set to -1.\n  // We also need to set tabindex to -1 for the disabled case, since we are dealing with a div instead\n  // of an intrinsic input and have to handle it directly.\n  const updatedTabIndex = tabbableModeIndex === -1 || anySegmentSelected || isDisabled ? -1 : 0;\n\n  // Keep track of the last changed and last committed date values.\n  const lastDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  const lastCommittedDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  // Keep track whether the date was cleared.\n  const dateClearedRef = useRef<boolean>(false);\n  const lastFocusedRef = useRef<boolean>(!!isFocused);\n\n  // If the value was programmatically changed (see useDateField.ts), then update the\n  // last changed and last committed date refs to stay in sync.\n  // currentValue is the controlled value passed from the parent.\n  if (dateResetRef.current) {\n    lastDateRef.current = currentValue;\n    lastCommittedDateRef.current = currentValue;\n  }\n\n  // Handle requested segment changes by calling the reducer dispatch function.\n  const onChange = useCallback(\n    (action: DateFieldAction) => {\n      dispatch(action);\n    },\n    [dispatch]\n  );\n\n  // If the user clicked on a segment, dispatch a request to select it.\n  // If they clicked on the date field itself, select the first segment.\n  const onClick = useCallback(\n    (e: Event) => {\n      const segmentType = (e.target as HTMLElement).getAttribute(\n        'data-segment'\n      ) as EditableDateSegment;\n      !!segmentType\n        ? dispatch({ actionType: 'selectSegment', data: { type: segmentType } })\n        : dispatch({ actionType: 'selectFirst' });\n    },\n    [dispatch]\n  );\n\n  // If complete, select the date.\n  const selectAll = useCallback(\n    (isGroupFocus = true) => {\n      if (state.isCompleteDate) {\n        dispatch({ actionType: 'selectDateOrSegment' });\n        // Focus can end up in different places depending on if the user selected a segment\n        // first (via click or arrow key), and then did select all. To make shift-tabbing\n        // consistent in all cases, set focus to the group when selecting the date.\n        isGroupFocus && groupRef?.current?.focus();\n      }\n    },\n    [dispatch, groupRef, state.isCompleteDate]\n  );\n\n  const onDoubleClick = useCallback(() => {\n    selectAll();\n  }, [selectAll]);\n\n  const onDoubleTap = useCallback(\n    (e: Event) => {\n      const segmentType = (e.target as HTMLElement).getAttribute(\n        'data-segment'\n      ) as EditableDateSegment;\n\n      // Only do select all if a segment was double tapped, which means the\n      // mobile keyboard will stay up.\n      !!segmentType && selectAll(false);\n    },\n    [selectAll]\n  );\n\n  const doubleTapHandlers = useDoubleTap({ onDoubleTap: onDoubleTap, onSingleTap: onClick });\n\n  // Handle arrow key navigation between segments. If no segment is currently selected, then select the first one.\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        (direction === 'ltr' && event.key === 'ArrowLeft') ||\n        (direction === 'rtl' && event.key === 'ArrowRight')\n      ) {\n        // Select the previous segment when pressing Left arrow (or Right arrow in rtl).\n        dispatch({ actionType: 'selectPrevious' });\n        event.stopPropagation();\n      } else if (\n        (direction === 'ltr' && event.key === 'ArrowRight') ||\n        (direction === 'rtl' && event.key === 'ArrowLeft')\n      ) {\n        // Select the next segment when pressing Right arrow (or Left arrow in rtl).\n        dispatch({ actionType: 'selectNext' });\n        event.stopPropagation();\n      } else if (\n        (isBackspaceOrDelete(event) || event.key === 'Backspace') &&\n        state.isDateSelected\n      ) {\n        // Clear the entire date.\n        dispatch({ actionType: 'clearDate' });\n        dateClearedRef.current = true;\n        // Kill the event to prevent weird issue with placeholders getting deleted on iOS only.\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      } else if (isSelectAll(event)) {\n        selectAll();\n        event.preventDefault();\n        event.stopPropagation();\n      } else if (event.key === 'Enter') {\n        // Hitting Enter commits any changes.\n        if (calendarDatesAreDifferent(lastCommittedDateRef.current, lastDateRef.current)) {\n          // Call onCommit only if the value is different.\n          onCommit?.({ value: lastDateRef.current });\n          lastCommittedDateRef.current = lastDateRef.current;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n    [direction, dispatch, onCommit, selectAll, state.isDateSelected]\n  );\n\n  // Blurring commits the date value; clear any selected segments and mark non-empty segments as complete.\n  useEffect(() => {\n    if (lastFocusedRef.current && !isFocused) {\n      dispatch({ actionType: 'commit' });\n      if (calendarDatesAreDifferent(lastCommittedDateRef.current, lastDateRef.current)) {\n        // Call onCommit only if the value is different.\n        onCommit?.({ value: lastDateRef.current });\n        lastCommittedDateRef.current = lastDateRef.current;\n      }\n    }\n    lastFocusedRef.current = !!isFocused;\n  }, [dispatch, isFocused, onCommit]);\n\n  // If you try to call onInput from onChange directly it doesn't work. The value of\n  // state.currentDate is from the current render, not the render *after* the dispatch.\n  // So wait for the state to finish updating.\n  useEffect(() => {\n    if (\n      calendarDatesAreDifferent(lastDateRef.current, state.currentDate) &&\n      !dateResetRef.current\n    ) {\n      const frozenDate =\n        state.currentDate !== undefined\n          ? Object.freeze({ ...state.currentDate })\n          : state.currentDate;\n      onInput({ value: frozenDate });\n      lastDateRef.current = frozenDate;\n    }\n    dateResetRef.current = false;\n  }, [onInput, state.currentDate, dateResetRef]);\n\n  // The following is a simplified version of how we detect keyboard vs. mouse focus\n  // in the useCollectionFocusRing hook. If the user tabs onto the field, we want to\n  // automatically select the first segment.\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerDownTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const onPointerDown = () => {\n    recentPointerRef.current = true;\n    clearTimeout(pointerDownTimerRef.current);\n\n    pointerDownTimerRef.current = setTimeout(() => {\n      recentPointerRef.current = false;\n    }, 200);\n  };\n\n  useEffect(() => {\n    // If we receive focus that is *not* due to the user clicking in the field, i.e. the user\n    // tabbed onto the field, then select the first segment.\n    // Note: we cannot check isFocused because it includes the ? icon in compact UAD, and we don't\n    // want the date selected when the help icon is focused.\n    isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'selectFirst' });\n\n    // If we lose focus due to the keyboard, i.e. shift-tabbing onto the compact UAD help icon,\n    // then 'commit' which will clear any selected segments.\n    !isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'commit' });\n    recentPointerRef.current = false;\n  }, [dispatch, isInputFocused]);\n\n  const handlers = isMobile()\n    ? { ...doubleTapHandlers, onKeyDown }\n    : { onClick, onDoubleClick, onKeyDown, onPointerDown };\n\n  return {\n    dateClearedRef,\n    dateFieldHandlers: isDisabled ? {} : handlers,\n    segmentHandlers: isDisabled ? {} : { onChange },\n    tabIndex: updatedTabIndex\n  };\n};\n\nexport { useDateFieldHandlers };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport {\n  AriaAttributesSignalExcluded,\n  HTMLAttributesSignalExcluded\n} from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateSegment } from './DateSegment';\nimport { DateSegmentState } from './useDateField';\nimport { Flex } from '#UNSAFE_Flex';\nimport { HiddenAccessible } from '#UNSAFE_HiddenAccessible';\nimport { InputDateMask } from './InputDateMask';\nimport { LiteralSegment } from './LiteralSegment';\nimport { LiveRegion } from '#UNSAFE_LiveRegion';\nimport { merge } from '#utils/UNSAFE_stringUtils';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { useDateField } from './useDateField';\nimport { useDateFieldHandlers } from './useDateFieldHandlers';\nimport { useFormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { TextFieldInputVariantOptions } from '#UNSAFE_TextField/themes/TextFieldInputStyles.css';\nimport { TextFieldInputRedwoodTheme } from '#UNSAFE_TextField/themes/redwood/TextFieldInputTheme';\nimport type { DatePlaceholders, EditableDateSegment } from './types';\nimport { formatFullCalendarDate } from '#utils/UNSAFE_calendarDateUtils';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype AriaProps = Pick<\n  AriaAttributesSignalExcluded,\n  'aria-describedby' | 'aria-invalid' | 'aria-label' | 'aria-labelledby'\n>;\n\ntype HTMLElementProps = Pick<HTMLAttributesSignalExcluded<HTMLElement>, 'onBlur' | 'onFocus'>;\n\nexport type Props = AriaProps &\n  HTMLElementProps & {\n    /**\n     * A base id prefix.\n     */\n    baseId: string;\n\n    /**\n     * A ref to the element that receives focus when the field's label is clicked,\n     * or when the component is toggled between readonly and enabled. This is the\n     * first segment in the field.\n     */\n    fieldRef?: RefObject<HTMLDivElement>;\n\n    /**\n     * Specifies the smallest date unit that is displayed by the component.\n     * If set to month, only month and year are shown.\n     * If set to day then month, day, and year are shown.\n     */\n    granularity?: InputDateMaskProps['granularity'];\n\n    /**\n     * True if the component has an inside label.\n     */\n    hasInsideLabel?: boolean;\n\n    /**\n     * Specifies for accessibility purposes whether a value is required.\n     */\n    isRequired?: InputDateMaskProps['isRequired'];\n\n    /**\n     * The placeholder masks used by the date field.\n     */\n    masks: DatePlaceholders;\n\n    /**\n     * Specifies how to align text within the field.\n     */\n    textAlign?: InputDateMaskProps['textAlign'];\n\n    /**\n     * The current display value of the component.\n     */\n    value?: InputDateMaskProps['value'];\n\n    /**\n     * The style variant of the component.\n     */\n    variant?: InputDateMaskProps['variant'];\n\n    /**\n     * Callback invoked each time the user changes the value of a segment For example, if the user\n     * types '12' into the month segment, this callback will be called twice to change the month\n     * first to '1' and then '12'.\n     */\n    onInput: InputDateMaskProps['onInput'];\n\n    /**\n     * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n     */\n    onCommit: InputDateMaskProps['onCommit'];\n  };\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n/**\n * Container for Segment children that represent different parts of a date with no time.\n */\nconst DateField = ({\n  'aria-describedby': describedBy,\n  'aria-invalid': ariaInvalid,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  baseId,\n  fieldRef,\n  granularity = 'day',\n  hasInsideLabel,\n  isRequired,\n  masks: dateMasks,\n  onBlur,\n  onCommit,\n  onFocus,\n  onInput,\n  textAlign,\n  value,\n  variant = 'default'\n}: Props) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const announceDateCleared = translations.inputDateMask_date_cleared();\n  const labels = {\n    month: translations.formControl_month(),\n    day: translations.formControl_day(),\n    year: translations.formControl_year()\n  };\n\n  const { direction, locale } = useUser();\n\n  const { isDisabled, isFocused, isInputFocused } = useFormFieldContext();\n  const hasValue = value !== undefined;\n\n  // DateField is similar to TextFieldInput for styling. The main difference\n  // is TextFieldInput renders a textarea or input and DateField renders a div, so the positioning with\n  // padding is different. DateField and TextFieldInput are both the mainContent\n  // of a TextField component.\n  const { classes } = useComponentTheme<TextFieldInputVariantOptions>(TextFieldInputRedwoodTheme, {\n    type: 'notPassword',\n    styleVariant: variant,\n    textarea: 'notTextArea',\n    input: 'notInput',\n    div: 'isDiv',\n    prefix: 'noPrefix',\n    suffix: 'noSuffix',\n    startContent: 'noStartContent',\n    endContent: 'noEndContent',\n    insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',\n    value: hasValue ? 'hasValue' : 'noValue',\n    focused: isFocused ? 'isFocused' : 'notFocused',\n    disabled: isDisabled ? 'isDisabled' : 'notDisabled'\n  });\n\n  const compClasses = classNames([classes]);\n\n  const { state, dispatch, dateResetRef } = useDateField({\n    ariaLabels: labels,\n    dateMasks,\n    granularity,\n    locale,\n    value\n  });\n  const { isDateSelected, isPartialDate, segments: editableSegments } = state;\n  const yearSegment = findSegment(editableSegments, 'year');\n  const monthSegment = findSegment(editableSegments, 'month');\n  const daySegment = granularity === 'day' ? findSegment(editableSegments, 'day') : undefined;\n  const segmentsMap = {\n    year: yearSegment,\n    month: monthSegment,\n    day: daySegment\n  };\n\n  const groupRef = useRef<HTMLDivElement>(null);\n  const { dateClearedRef, dateFieldHandlers, segmentHandlers, tabIndex } = useDateFieldHandlers({\n    dateResetRef,\n    direction,\n    dispatch,\n    groupRef,\n    isDisabled,\n    isFocused,\n    isInputFocused,\n    onCommit,\n    onInput,\n    state,\n    value\n  });\n\n  // Like other form components, don't show placeholders for inside labels unless focused.\n  // This flag causes the segment placeholders to be hidden.\n  const isHidden = value === undefined && hasInsideLabel && !isFocused;\n\n  // If the date is complete, create a hidden accessible region with the full formatted date.\n  const formattedDateStr = !state.isCompleteDate\n    ? ''\n    : formatFullCalendarDate(locale, state.currentDate!, granularity);\n\n  const formattedDateAriaId = `${baseId}-date`;\n  const formattedDateAria = state.isCompleteDate ? (\n    <HiddenAccessible id={formattedDateAriaId}>{formattedDateStr}</HiddenAccessible>\n  ) : undefined;\n  const ariaDescribedBy = state.isCompleteDate\n    ? merge([describedBy, formattedDateAriaId])\n    : describedBy;\n\n  // Add an announcement to the live region if the date was cleared.\n  // Note: we deliberately do not reset dateClearedRef because there are multiple\n  // rerenders after clearing the date and we want to make sure the announcement\n  // has time to be heard.\n  const announceText = dateClearedRef.current ? announceDateCleared : '';\n\n  // firstSegmentType is 'day', 'month', or 'year' and is used to determine\n  // where to put the fieldRef.\n  const firstSegmentType = state.orderedSegments[0];\n\n  return (\n    <div\n      aria-describedby={ariaDescribedBy}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      class={compClasses}\n      onFocusIn={onFocus}\n      onFocusOut={onBlur}\n      ref={groupRef}\n      role=\"group\"\n      tabIndex={tabIndex}\n      {...dateFieldHandlers}>\n      <Flex direction=\"row\" wrap=\"nowrap\" justify={textAlign}>\n        {dateMasks.map(({ type, value: placeholder }) => {\n          const segmentProps = type !== 'literal' ? segmentsMap[type] : {};\n          if (type === 'literal') {\n            return (\n              <LiteralSegment\n                isHidden={isHidden}\n                isHighlighted={isDateSelected}\n                isPlaceholder={!isPartialDate}\n                text={placeholder}></LiteralSegment>\n            );\n          } else {\n            return (\n              <DateSegment\n                inputRef={type === firstSegmentType ? fieldRef : undefined}\n                isDisabled={isDisabled}\n                isInvalid={!!ariaInvalid}\n                isHidden={isHidden}\n                isHighlighted={isDateSelected}\n                isRequired={isRequired}\n                placeholder={placeholder}\n                type={type}\n                {...segmentHandlers}\n                {...segmentProps}></DateSegment>\n            );\n          }\n        })}\n      </Flex>\n      {formattedDateAria}\n      <LiveRegion>{announceText}</LiveRegion>\n    </div>\n  );\n};\n\nexport { DateField, findSegment };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\nimport { useReducer, useRef } from 'preact/hooks';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { DateField } from './DateField';\nimport { CalendarDate, DateGranularity, DatePlaceholders, EditableDateSegment } from './types';\nimport { DateSegment } from './DateSegment';\nimport { dateReducer, getMonthAria, numberToString } from './dateReducer';\nimport { calendarDatesAreDifferent } from '../utils/PRIVATE_dayUtils';\nimport {\n  getDaysInMonth,\n  getMonthsInYear,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH\n} from '../utils/UNSAFE_calendarDateUtils';\n\ntype DateFieldType = ComponentProps<typeof DateField>;\n\ntype useDateFieldProps = {\n  ariaLabels: Record<EditableDateSegment, string>;\n  dateMasks: DatePlaceholders;\n  granularity: DateGranularity;\n  locale: BCP47Locale;\n  value: DateFieldType['value'];\n};\n\ntype DateSegmentState = Readonly<ComponentProps<typeof DateSegment>>;\n\ntype DateFieldState = {\n  readonly currentDate: CalendarDate | undefined;\n  readonly isCompleteDate: boolean;\n  readonly isDateSelected: boolean;\n  readonly isPartialDate: boolean;\n  readonly orderedSegments: EditableDateSegment[];\n  readonly segments: DateSegmentState[];\n};\n\n/**\n * Hook that returns a DateFieldState and a dispatch method to request changes to that state.\n */\nconst useDateField = ({\n  ariaLabels,\n  dateMasks,\n  granularity,\n  locale,\n  value: currentValue\n}: useDateFieldProps) => {\n  // Construct an ordered list of the editable segments, i.e. ['month', 'day', 'year'].\n  const fdm = dateMasks.filter(({ type }) => type !== 'literal');\n  const orderedSegments = fdm.map(({ type }) => type) as EditableDateSegment[];\n\n  // Derive some data from currentValue that will become part of our initial state.\n  const yearValue = currentValue?.year;\n  const monthValue = currentValue?.month;\n  const dayValue = currentValue?.day;\n  const monthMax = getMonthsInYear(yearValue ?? '*');\n  const dayMax = getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n  const isCompleteDate = !!yearValue && !!monthValue && (granularity === 'month' || !!dayValue);\n  const isPartialDate = !!yearValue || !!monthValue || !!dayValue;\n  const yearValueStr = yearValue ? numberToString(yearValue) : undefined;\n  const monthValueStr = monthValue ? numberToString(monthValue) : undefined;\n  const dayValueStr = dayValue ? numberToString(dayValue) : undefined;\n  const monthAria = monthValue ? getMonthAria(locale, monthValue, yearValue) : undefined;\n\n  const daySeg = [\n    {\n      type: 'day' as EditableDateSegment,\n      'aria-label': ariaLabels.day,\n      'aria-valuemin': MIN_ISO_DAY,\n      'aria-valuemax': dayMax,\n      'aria-valuenow': dayValue,\n      'aria-valuetext': dayValueStr,\n      isComplete: !!dayValue,\n      isSelected: false,\n      text: dayValueStr\n    }\n  ];\n\n  // Create state for each editable segment of a date, i.e. year, month, or day.\n  const editableSegments = [\n    {\n      type: 'year' as EditableDateSegment,\n      'aria-label': ariaLabels.year,\n      'aria-valuemin': MIN_ISO_YEAR,\n      'aria-valuemax': MAX_ISO_YEAR,\n      'aria-valuenow': yearValue,\n      'aria-valuetext': yearValueStr,\n      isComplete: !!yearValue,\n      isSelected: false,\n      text: yearValueStr\n    },\n    {\n      type: 'month' as EditableDateSegment,\n      'aria-label': ariaLabels.month,\n      'aria-valuemin': MIN_ISO_MONTH,\n      'aria-valuemax': monthMax,\n      'aria-valuenow': monthValue,\n      'aria-valuetext': monthAria,\n      isComplete: !!monthValue,\n      isSelected: false,\n      text: monthValueStr\n    },\n    ...(granularity === 'day' ? daySeg : [])\n  ];\n\n  // Create the initial state to pass to our reducer.\n  const initialState: DateFieldState = {\n    currentDate: currentValue,\n    isCompleteDate,\n    isDateSelected: false,\n    isPartialDate,\n    orderedSegments,\n    segments: editableSegments\n  };\n\n  const [state, dispatch] = useReducer(dateReducer, initialState);\n\n  // currentValue is the controlled value passed from the parent.\n  const lastValueFromParentRef = useRef<CalendarDate | undefined>(currentValue);\n  const dateResetRef = useRef<boolean>(false);\n\n  // If a new value is being pushed from the parent, and that value differs from\n  // the current value of the reducer, then this is a programmatic update\n  // and we need to call 'reset' to update the reducer state. Otherwise, the only\n  // time the reducer state is updated from the value is on mount.\n  if (calendarDatesAreDifferent(lastValueFromParentRef.current, currentValue)) {\n    lastValueFromParentRef.current = currentValue;\n    if (calendarDatesAreDifferent(currentValue, state.currentDate)) {\n      dispatch({ actionType: 'reset', data: initialState });\n      dateResetRef.current = true;\n    }\n  }\n\n  return { dateResetRef, dispatch, state };\n};\n\nexport { useDateField };\nexport type { DateFieldState, DateSegmentState };\n","import { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\ntype InputDateMaskContextProps = {\n  isInputDatePickerParent: boolean;\n  isDropdownOpen: boolean;\n};\n\n/**\n * Context used to indicate when the component is being used in\n * composition within some parent, such as InputDatePicker.\n */\nconst InputDateMaskContext = createContext<InputDateMaskContextProps>({\n  isInputDatePickerParent: false,\n  isDropdownOpen: false\n});\n\nconst useInputDateMaskContext = () => useContext(InputDateMaskContext);\n\nexport { InputDateMaskContext, useInputDateMaskContext };\nexport type { InputDateMaskContextProps };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, Ref, RefObject } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useCallback, useImperativeHandle, useMemo, useRef } from 'preact/hooks';\n\nimport { AriaAttributesSignalExcluded } from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport type { CalendarDate, DatePlaceholders } from './types';\nimport {\n  CompactUserAssistance,\n  InlineUserAssistance,\n  UserAssistanceDensityType\n} from '#UNSAFE_UserAssistance';\nimport { DateField } from './DateField';\nimport { FormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { getDatePlaceholderMasks, formatShortCalendarDate } from '#utils/UNSAFE_calendarDateUtils';\nimport { translateCustomMasks } from '#utils/PRIVATE_dayUtils';\nimport { Label } from '#UNSAFE_Label';\nimport { ReadonlyTextField, ReadonlyTextFieldInput, TextField } from '#UNSAFE_TextField';\nimport { Size } from '#utils/UNSAFE_size';\nimport { TextFieldContent } from '#UNSAFE_TextField/TextFieldContent';\nimport type { TestIdProps } from '#hooks/UNSAFE_useTestId';\nimport type { TextProps } from '#utils/UNSAFE_interpolations/text';\nimport { useFocusableTextField, FocusableHandle } from '#hooks/UNSAFE_useFocusableTextField';\nimport { useFormContext } from '#hooks/UNSAFE_useFormContext';\nimport { useInputDateMaskContext } from './InputDateMaskContext';\nimport { useTextField } from '#hooks/UNSAFE_useTextField';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport { LayoutColumnSpan } from '../utils/UNSAFE_styles/Layout';\n\ntype InlineUserAssistanceProps = ComponentProps<typeof InlineUserAssistance>;\n\ntype TextFieldContentProps = ComponentProps<typeof TextFieldContent>;\n\ntype Props = TestIdProps & {\n  /**\n   * The ID of an element (or space separated IDs of multiple elements) that\n   * describes the input.\n   */\n  'aria-describedby'?: AriaAttributesSignalExcluded['aria-describedby'];\n\n  /**\n   * Text to provide guidance to help the user understand what data to enter.\n   */\n  assistiveText?: InlineUserAssistanceProps['assistiveText'];\n\n  /**\n   * Specifies how many columns to span in a FormLayout with direction === 'row'\n   */\n  columnSpan?: LayoutColumnSpan;\n\n  /**\n   * Use this property to provide content for the end slot, such as a calendar icon.\n   */\n  endContent?: TextFieldContentProps['endContent'];\n\n  /**\n   * Specifies the smallest date unit that is displayed by the component.\n   * If set to month, only month and year are shown.\n   * If set to day then month, day, and year are shown.\n   */\n  granularity?: 'month' | 'day';\n\n  /**\n   * Help source URL associated with the component.\n   */\n  helpSourceLink?: InlineUserAssistanceProps['helpSourceLink'];\n\n  /**\n   * Custom text to be rendered for the <code>helpSourceLink</code>.\n   */\n  helpSourceText?: InlineUserAssistanceProps['helpSourceText'];\n\n  /**\n   * Specifies whether the component is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Specifies whether the component is readonly.\n   */\n  isReadonly?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   *\n   * Setting this property to <code>false</code> means that a value is not required to be\n   * committed by the user. Setting this property to <code>true</code> means that a value\n   * is required to be committed by the user.\n   */\n  isRequired?: boolean;\n\n  /**\n   * Specifies whether to show an indicator on screen that a value is required, for example\n   * before the user has committed a value.\n   */\n  isRequiredShown?: InlineUserAssistanceProps['isRequiredShown'];\n\n  /**\n   * Specifies the label associated with the field.\n   */\n  label: string;\n\n  /**\n   * Specifies where the label is positioned relative to the field.\n   */\n  labelEdge?: 'inside' | 'start' | 'top' | 'none';\n\n  /**\n   * Specifies the width of the label when <code>labelEdge</code> is <code>\"start\"</code>.\n   */\n  labelStartWidth?: Size;\n\n  /**\n   * A ref to the component field. This can be used when you are composing with InputDateMask\n   * and need to provide an anchor ref to a floating component.\n   */\n  mainFieldRef?: RefObject<HTMLDivElement>;\n\n  /**\n   * If specified, overrides the locale specific order of the individual date segments as\n   * well as the locale specific separator. The value of each placeholder is only used\n   * when the type is 'literal', otherwise it is replaced with a translated placeholder\n   * for month, day, or year. If masks are specified and granularity = day, then the\n   * placeholders must include month, day, and year. If granularity = month, then the\n   * placeholders must include month and year, but not day.\n   */\n  masks?: DatePlaceholders;\n\n  /**\n   * Messages to show on screen that are associated with the component.\n   */\n  messages?: InlineUserAssistanceProps['messages'];\n\n  /**\n   * Specifies how to align text within the field.\n   */\n  textAlign?: TextProps['textAlign'];\n\n  /**\n   * Specifies the density of the user assistance presentation. It can be set to:\n   * <ul>\n   * <li><code>'efficient'</code>: Show inline and reserve space to prevent layout reflow when user\n   * assistance text is displayed.</li>\n   * <li><code>'reflow'</code>: Show inline. Layout will reflow when text is displayed.</li>\n   * <li><code>'compact'</code>: Messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like a popup for the messages, and a required icon to indicate Required. </li>\n   * </ul>\n   */\n  userAssistanceDensity?: UserAssistanceDensityType;\n\n  /**\n   * The current display value of the component.\n   */\n  value?: CalendarDate;\n\n  /**\n   * The style variant of the component.\n   */\n  variant?: 'default' | 'embedded';\n\n  /**\n   * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n   */\n  onCommit?: (detail: ValueUpdateDetail<CalendarDate>) => void;\n\n  /**\n   * Callback invoked each time the user changes the value of a segment For example, if the user\n   * types '12' into the month segment, this callback will be called twice to change the month\n   * first to '1' and then '12'.\n   */\n  onInput: (detail: ValueUpdateDetail<CalendarDate>) => void;\n};\n\n/**\n * An InputDateMask allows you to edit the month, day, and year fields of a calendar date.\n */\nexport const InputDateMask = forwardRef(\n  (\n    {\n      'aria-describedby': ariaDescribedBy,\n      assistiveText,\n      columnSpan,\n      endContent,\n      granularity = 'day',\n      helpSourceLink,\n      helpSourceText,\n      isDisabled: propIsDisabled,\n      isReadonly: propIsReadonly,\n      isRequired,\n      isRequiredShown,\n      label,\n      labelEdge: propLabelEdge,\n      labelStartWidth: propLabelStartWidth,\n      mainFieldRef,\n      messages,\n      masks,\n      testId,\n      textAlign: propTextAlign,\n      userAssistanceDensity: propUserAssistanceDensity,\n      value,\n      variant,\n      onCommit,\n      onInput\n    }: Props,\n    ref?: Ref<FocusableHandle>\n  ) => {\n    const {\n      isDisabled: isFormDisabled,\n      isReadonly: isFormReadonly,\n      labelEdge: formLabelEdge,\n      labelStartWidth: formLabelStartWidth,\n      textAlign: formTextAlign,\n      userAssistanceDensity: formUserAssistanceDensity\n    } = useFormContext();\n    // default to FormContext values if component properties are not specified\n    const isDisabled = propIsDisabled ?? isFormDisabled;\n    const isReadonly = propIsReadonly ?? isFormReadonly;\n    const labelEdge = propLabelEdge ?? formLabelEdge;\n    const labelStartWidth = propLabelStartWidth ?? formLabelStartWidth;\n    const textAlign = propTextAlign ?? formTextAlign;\n    const userAssistanceDensity = propUserAssistanceDensity ?? formUserAssistanceDensity;\n    const enabledElementRef = useRef<HTMLDivElement>(null);\n    const readonlyElementRef = useRef<HTMLDivElement>(null);\n\n    const {\n      focusProps,\n      isFocused,\n      methods: focusMethods\n    } = useFocusableTextField<HTMLDivElement, HTMLDivElement>({\n      isDisabled,\n      isReadonly,\n      enabledElementRef,\n      readonlyElementRef\n    });\n\n    useImperativeHandle(ref!, () => focusMethods, [focusMethods]);\n\n    const { isDropdownOpen, isInputDatePickerParent } = useInputDateMaskContext();\n    const isComponentFocused = isFocused || (isInputDatePickerParent && isDropdownOpen);\n\n    const {\n      baseId,\n      formFieldContext,\n      inputProps,\n      labelProps: origLabelProps,\n      textFieldProps,\n      userAssistanceProps\n    } = useTextField({\n      ariaDescribedBy,\n      helpSourceLink,\n      helpSourceText,\n      isDisabled,\n      isFocused: isComponentFocused,\n      isReadonly,\n      isRequiredShown,\n      labelEdge,\n      messages,\n      styleVariant: variant,\n      userAssistanceDensity,\n      value\n    });\n\n    // When using a div with role=group (i.e. DateField), you need aria-labelledby instead of a\n    // for-id association with a label. Remove forId and id and use aria-labelledby instead.\n    const { forId, ...labelProps } = origLabelProps;\n    const { id, ...dateFieldProps } = inputProps;\n    const ariaLabelledBy = labelProps.id;\n    // Because we don't use for-id, clicking the label does not automatically focus the field.\n    // We have to do it manually.\n    const onClick = useCallback(() => {\n      enabledElementRef.current?.focus();\n    }, [enabledElementRef]);\n\n    const labelComp =\n      labelEdge !== 'none' ? (\n        <Label {...(!isDisabled && !isReadonly ? { onClick } : {})} {...labelProps}>\n          {label}\n        </Label>\n      ) : undefined;\n\n    const fieldLabelProps = {\n      label: labelEdge !== 'none' ? labelComp : undefined,\n      labelEdge: labelEdge !== 'none' ? labelEdge : undefined,\n      labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined\n    };\n\n    const ariaLabel = labelEdge === 'none' ? label : undefined;\n    const hasInsideLabel = label !== undefined && labelEdge === 'inside';\n    const isInlineDensity =\n      userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow';\n\n    const inlineUserAssistance = isInlineDensity ? (\n      isDisabled || isReadonly ? (\n        // save space for user assistance if density is 'efficient', even though we don't\n        // render user assistance for disabled or readonly fields\n        userAssistanceDensity !== 'efficient' ? undefined : (\n          <InlineUserAssistance\n            userAssistanceDensity={userAssistanceDensity}\n            {...userAssistanceProps}\n          />\n        )\n      ) : (\n        <InlineUserAssistance\n          assistiveText={assistiveText}\n          fieldLabel={label}\n          helpSourceLink={helpSourceLink}\n          helpSourceText={helpSourceText}\n          messages={messages}\n          isRequiredShown={isRequiredShown}\n          userAssistanceDensity={userAssistanceDensity}\n          {...userAssistanceProps}\n        />\n      )\n    ) : undefined;\n\n    const aRef = useRef<HTMLDivElement>(null);\n    const anchorRef = mainFieldRef ?? aRef;\n\n    const compactUserAssistance =\n      userAssistanceDensity === 'compact' ? (\n        <CompactUserAssistance\n          anchorRef={anchorRef}\n          messages={messages}\n          assistiveText={assistiveText}\n          {...userAssistanceProps}\n        />\n      ) : undefined;\n\n    const { locale } = useUser();\n\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n    const monthPlaceholder = translations.inputDateMask_monthPlaceholder();\n    const dayPlaceholder = translations.inputDateMask_dayPlaceholder();\n    const yearPlaceholder = translations.inputDateMask_yearPlaceholder();\n\n    // The DatePlaceholders type already ensures the masks contain the right placeholders,\n    // for either full calendar dates or month-year dates. This check ensures the masks,\n    // if provided, match the granularity. E.g. for granularity=month, you should pass\n    // month and year placeholders, and a separator.\n    if (\n      masks &&\n      ((granularity === 'day' && masks.length !== 5) ||\n        (granularity === 'month' && masks.length !== 3))\n    ) {\n      throw new Error('Specified masks must match the granularity');\n    }\n\n    const dateMasks = useMemo(() => {\n      // Determine the locale specific placeholder masks and separators in the correct order\n      // for the locale, unless a custom set of masks was passed in. Each mask represents a\n      // placeholder for a segment of a date (i.e. mm/dd/yyyy). Memoize because we shouldn't\n      // need to recreate this data often.\n      const placeholderMasks = masks\n        ? translateCustomMasks(masks, monthPlaceholder, dayPlaceholder, yearPlaceholder)\n        : getDatePlaceholderMasks(\n            locale,\n            granularity,\n            monthPlaceholder,\n            dayPlaceholder,\n            yearPlaceholder\n          );\n\n      return placeholderMasks;\n    }, [masks, locale, granularity, dayPlaceholder, monthPlaceholder, yearPlaceholder]);\n\n    if (isReadonly) {\n      return (\n        <FormFieldContext.Provider value={formFieldContext}>\n          <ReadonlyTextField\n            role=\"presentation\"\n            columnSpan={columnSpan}\n            compactUserAssistance={compactUserAssistance}\n            inlineUserAssistance={inlineUserAssistance}\n            onBlur={focusProps.onFocusOut}\n            onFocus={focusProps.onFocusIn}\n            ref={anchorRef}\n            testId={testId}\n            mainContent={\n              <ReadonlyTextFieldInput\n                aria-describedby={dateFieldProps['aria-describedby']}\n                aria-label={ariaLabel}\n                aria-labelledby={labelProps.id}\n                as=\"div\"\n                elementRef={readonlyElementRef}\n                textAlign={textAlign}\n                value={\n                  value === undefined ? '' : formatShortCalendarDate(value, granularity, dateMasks)\n                }\n                hasEmptyLabel={label === '' && labelEdge === 'none'}\n                hasInsideLabel={hasInsideLabel}\n              />\n            }\n            {...fieldLabelProps}></ReadonlyTextField>\n        </FormFieldContext.Provider>\n      );\n    }\n\n    // The main content inside TextField is a DateField (not TextFieldInput) in this case.\n    // We reuse the TextField building blocks and hooks, but recompose them.\n    const mainContent = (\n      <DateField\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        baseId={baseId}\n        fieldRef={enabledElementRef}\n        granularity={granularity}\n        hasInsideLabel={labelComp !== undefined && labelEdge === 'inside'}\n        isRequired={isRequired}\n        masks={dateMasks}\n        onCommit={onCommit}\n        onInput={onInput}\n        textAlign={textAlign}\n        value={value}\n        {...dateFieldProps}\n      />\n    );\n\n    return (\n      <FormFieldContext.Provider value={formFieldContext}>\n        <TextField\n          columnSpan={columnSpan}\n          compactUserAssistance={compactUserAssistance}\n          endContent={endContent}\n          inlineUserAssistance={inlineUserAssistance}\n          mainContent={mainContent}\n          onBlur={focusProps.onFocusOut}\n          onFocus={focusProps.onFocusIn}\n          mainFieldRef={anchorRef}\n          testId={testId}\n          {...textFieldProps}\n          {...fieldLabelProps}\n        />\n      </FormFieldContext.Provider>\n    );\n  }\n);\n"],"names":["preventDefaultHandler","e","preventDefault","isIos","getClientHints","platform","DateSegment","ariaLabel","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","inputRef","isComplete","isDisabled","isHidden","isHighlighted","isInvalid","isRequired","isSelected","onChange","placeholder","text","type","hasDisplayValue","length","rootClasses","classNames","segmentStyles","base","selected","highlighted","placeholderClasses","hidden","notHidden","emptySegmentValueText","useTranslationBundle","inputDateMask_empty_segment","sRef","useRef","segmentRef","hasLeadingZero","locale","useUser","onKeyDown","useCallback","event","key","isSelectAll","isBackspaceOrDelete","undefined","isNumberOnlyString","actionType","data","current","direction","stopPropagation","useEffect","focus","customDataAttribute","valueText","toString","_jsx","children","_jsxs","ref","role","autocapitalize","autocorrect","class","contentEditable","enterkeyhint","inputMode","onCut","onPaste","spellcheck","tabIndex","jsx","LiteralSegment","isPlaceholder","spanClasses","literalBase","dateReducer","state","action","segmentType","segmentState","findSegment","segments","updatedSegments","selectFirst","clearDate","orderedSegments","createDateFieldStateWithSelectedDate","updatedSegment","clearSegment","createDateFieldState","clearSelectionAndComplete","goToEnd","goToHome","doStepOrPage","selectDateOrSegment","selectNext","selectPrevious","selectSegment","updateSegment","Error","stringToNumber","s","numberToString","n","find","segment","isDateComplete","allSegments","every","seg","isPartialDate","some","createCalendarDateFromSegments","iterator","map","values","cd","segValue","getYearValue","getMonthAria","month","year","getMonthName","getOrderedSegments","currentState","replaceDateSegment","existingSegments","updatedSegmentType","createDateSegmentStates","autoAdvance","modifiedSegments","daySeg","monthValue","yearValue","dayMax","getDaysInMonth","currentDay","dayValue","dayValueStr","updatedDaySeg","createDateFieldStateFromSegments","currentDate","isCompleteDate","isDateSelected","cleared","valueMax","MAX_ISO_YEAR","getMonthsInYear","actionText","minValue","maxValue","requestedValStr","requestedVal","inRange","max","newValStr","newVal","val","isSegmentComplete","getSelectedSegmentIndex","sel","findIndex","markSelectedSegmentComplete","selectedIndex","createSegmentFromKeyboardAction","newValue","getHomeSegmentValue","getEndSegmentValue","valueNow","min","yearDefault","monthDefault","day","dayDefault","getTodayAsCalendarDate","getDefaultSegmentValue","currentValue","step","getPagedSegmentValue","getSteppedSegmentValue","useDateFieldHandlers","dateResetRef","dispatch","groupRef","isFocused","isInputFocused","onCommit","onInput","value","tabbableModeProps","useTabbableMode","tabbableModeIndex","anySegmentSelected","updatedTabIndex","lastDateRef","lastCommittedDateRef","dateClearedRef","lastFocusedRef","onClick","target","getAttribute","selectAll","isGroupFocus","onDoubleClick","onDoubleTap","doubleTapHandlers","useDoubleTap","onSingleTap","stopImmediatePropagation","calendarDatesAreDifferent","frozenDate","Object","freeze","recentPointerRef","pointerDownTimerRef","handlers","deviceType","isMobile","onPointerDown","clearTimeout","setTimeout","dateFieldHandlers","segmentHandlers","DateField","describedBy","ariaInvalid","ariaLabelledBy","baseId","fieldRef","granularity","hasInsideLabel","masks","dateMasks","onBlur","onFocus","textAlign","variant","translations","announceDateCleared","inputDateMask_date_cleared","labels","formControl_month","formControl_day","formControl_year","useFormFieldContext","hasValue","classes","useComponentTheme","TextFieldInputRedwoodTheme","styleVariant","textarea","input","div","prefix","suffix","startContent","endContent","insideLabel","focused","disabled","compClasses","ariaLabels","filter","monthMax","yearValueStr","monthValueStr","monthAria","MIN_ISO_DAY","initialState","MIN_ISO_YEAR","MIN_ISO_MONTH","useReducer","lastValueFromParentRef","useDateField","editableSegments","segmentsMap","formattedDateStr","formatFullCalendarDate","formattedDateAriaId","formattedDateAria","HiddenAccessible","id","ariaDescribedBy","merge","announceText","firstSegmentType","jsxs","onFocusIn","onFocusOut","Flex","wrap","justify","segmentProps","LiveRegion","InputDateMaskContext","createContext","isInputDatePickerParent","isDropdownOpen","useInputDateMaskContext","useContext","InputDateMask","forwardRef","assistiveText","columnSpan","helpSourceLink","helpSourceText","propIsDisabled","isReadonly","propIsReadonly","isRequiredShown","label","labelEdge","propLabelEdge","labelStartWidth","propLabelStartWidth","mainFieldRef","messages","testId","propTextAlign","userAssistanceDensity","propUserAssistanceDensity","isFormDisabled","isFormReadonly","formLabelEdge","formLabelStartWidth","formTextAlign","formUserAssistanceDensity","useFormContext","enabledElementRef","readonlyElementRef","focusProps","methods","focusMethods","useFocusableTextField","useImperativeHandle","isComponentFocused","formFieldContext","inputProps","labelProps","origLabelProps","textFieldProps","userAssistanceProps","useTextField","forId","dateFieldProps","labelComp","Label","fieldLabelProps","inlineUserAssistance","InlineUserAssistance","fieldLabel","aRef","anchorRef","compactUserAssistance","CompactUserAssistance","monthPlaceholder","inputDateMask_monthPlaceholder","dayPlaceholder","inputDateMask_dayPlaceholder","yearPlaceholder","inputDateMask_yearPlaceholder","useMemo","translateCustomMasks","getDatePlaceholderMasks","FormFieldContext","Provider","ReadonlyTextField","mainContent","ReadonlyTextFieldInput","as","elementRef","formatShortCalendarDate","hasEmptyLabel","TextField"],"mappings":"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"}