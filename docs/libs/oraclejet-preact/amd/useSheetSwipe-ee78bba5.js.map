{"version":3,"file":"useSheetSwipe-ee78bba5.js","sources":["../../src/UNSAFE_Sheet/useSheetSwipe.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevpageX: number;\n  prevpageY: number;\n  elementScrollTop: number;\n};\n/*This \"private\" hook will live until we end up stating a final decision on useSwipe hook.\nFor that hook to work, element that use it has to set touch-action:none;, since pointer events\nare canceled once a touch action is going to be handled by the browser. This works for most\nof the components that don't scroll. But if the component scroll, there is a need for the browser to \nhandle scroll which is imposible with a hook just using pointer events.\n\nUpdate 11/6/23:\nNishad's team is going to confirm if other comps that will use useSwipe need mouse interactions. If they need it,\nwe can either have a flag to use pointer or touch events or two separated hooks. If they don't need mouse interactions,\nwe could start using useSwipe with touch events instead.\n*/\nexport function useSheetSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevpageX: 0,\n    prevpageY: 0,\n    elementScrollTop: 0\n  });\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevpageX: 0,\n      prevpageY: 0,\n      elementScrollTop: 0\n    };\n  }, []);\n\n  const onTouchStart = useCallback(\n    (e: TouchEvent) => {\n      const touchobj = e.changedTouches[0];\n      if (!ref.current.pointerDownId) {\n        ref.current = {\n          pointerDownId: touchobj.identifier,\n          startTime: e.timeStamp,\n          prevpageX: touchobj.pageX,\n          prevpageY: touchobj.pageY,\n          elementScrollTop: (e.currentTarget as HTMLElement).scrollTop\n        };\n      } else {\n        clearSwipe();\n      }\n    },\n    [clearSwipe]\n  );\n\n  const onTouchEnd = useCallback(\n    (ev: TouchEvent) => {\n      const touchobj = ev.changedTouches[0];\n      if (touchobj.identifier === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            touchobj.pageY - ref.current.prevpageY > threshold &&\n            Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&\n            ref.current.elementScrollTop === 0\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe, clearSwipe, maximumTime, tolerance]\n  );\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onTouchStart,\n        onTouchEnd,\n        ontouchcancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n"],"names":["onSwipe","threshold","maximumTime","tolerance","isDisabled","ref","useRef","pointerDownId","startTime","prevpageX","prevpageY","elementScrollTop","clearSwipe","useCallback","current","onTouchStart","e","touchobj","changedTouches","identifier","timeStamp","pageX","pageY","currentTarget","scrollTop","onTouchEnd","ev","Math","abs","direction","swipeProps","ontouchcancel"],"mappings":"8EA6CM,SACJA,GACAC,UAAEA,EAAY,GAAEC,YAAEA,EAAc,IAAGC,UAAEA,EAAY,GAAEC,WAAEA,GAAa,GAAwB,CACxFH,UAAW,GACXC,YAAa,IACbC,UAAW,GACXC,YAAY,IAGd,MAAMC,EAAMC,EAAAA,OAAmB,CAC7BC,cAAe,EACfC,UAAW,KACXC,UAAW,EACXC,UAAW,EACXC,iBAAkB,IAGdC,EAAaC,EAAAA,aAAY,KAC7BR,EAAIS,QAAU,CACZP,cAAe,KACfC,UAAW,EACXC,UAAW,EACXC,UAAW,EACXC,iBAAkB,EACnB,GACA,IAEGI,EAAeF,eAClBG,IACC,MAAMC,EAAWD,EAAEE,eAAe,GAC7Bb,EAAIS,QAAQP,cASfK,IARAP,EAAIS,QAAU,CACZP,cAAeU,EAASE,WACxBX,UAAWQ,EAAEI,UACbX,UAAWQ,EAASI,MACpBX,UAAWO,EAASK,MACpBX,iBAAmBK,EAAEO,cAA8BC,UAItD,GAEH,CAACZ,IAGGa,EAAaZ,eAChBa,IACC,MAAMT,EAAWS,EAAGR,eAAe,GAC/BD,EAASE,aAAed,EAAIS,QAAQP,eAClCF,EAAIS,QAAQN,WAAakB,EAAGN,UAAYf,EAAIS,QAAQN,UAAYN,GAEhEe,EAASK,MAAQjB,EAAIS,QAAQJ,UAAYT,GACzC0B,KAAKC,IAAIX,EAASI,MAAQhB,EAAIS,QAAQL,YAAcN,GACnB,IAAjCE,EAAIS,QAAQH,kBAEZX,IAAU,CAAE6B,UAAW,SAK7BjB,GAAY,GAEd,CAACX,EAAWD,EAASY,EAAYV,EAAaC,IAYhD,MAAO,CACL2B,WAViB1B,EACf,CAAE,EACF,CAEEW,eACAU,aACAM,cAAenB,GAMvB"}