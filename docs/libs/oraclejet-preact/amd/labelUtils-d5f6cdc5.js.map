{"version":3,"file":"labelUtils-d5f6cdc5.js","sources":["../../src/PRIVATE_Axis/utils/axisDefaults.ts","../../src/PRIVATE_Axis/utils/labelUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const AXIS_DEFAULTS = {\n  titleGap: 6,\n  labelGap: 6\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition } from '../../utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '../../utils/UNSAFE_visTypes/common';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { VisTextStyle, isHeightOverlap, isWidthOverlap } from '../../utils/UNSAFE_visUtils';\nimport { GetTextDimensionsType, TextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\nimport { getTextInfo } from '../../PRIVATE_VisSVGText';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\n\n/**\n * Calculates the number of skips between axis labels and the dimensions of unskipped labels.\n * @param labels The labels to render.\n * @param getLabelInfo The function that returns dimension of given label.\n * @param isHoriz Whether the axis is horizontal.\n * @param numOfSafeSkips The no of labels to skip safely.\n * @returns\n */\nexport function skipLabelsUniform(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n  },\n  isHoriz: boolean,\n  isRotated: boolean,\n  autoTruncate: boolean,\n  isWrapAllowed: boolean,\n  numOfSafeSkips?: number\n) {\n  let numOfSkips = numOfSafeSkips || 0;\n  let dimsA: TextDimensions;\n  let dimsB: TextDimensions;\n  const labelsInfo = [getLabelInfo(labels[0], 0, isRotated, autoTruncate, isWrapAllowed)];\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n\n  let indexA = 0;\n  let indexB = numOfSkips + 1;\n  while (indexB < labels.length) {\n    const labelsInfoA =\n      labelsInfo[indexA] ||\n      getLabelInfo(labels[indexA], indexA, isRotated, autoTruncate, isWrapAllowed);\n    dimsA = labelsInfoA.dims;\n    if (!labelsInfo[indexA]) {\n      labelsInfo[indexA] = labelsInfoA;\n    }\n    const labelsInfoB =\n      labelsInfo[indexB] ||\n      getLabelInfo(labels[indexB], indexB, isRotated, autoTruncate, isWrapAllowed);\n    dimsB = labelsInfoB.dims;\n    if (!labelsInfo[indexB]) {\n      labelsInfo[indexB] = labelsInfoB;\n    }\n\n    if (isOverlapping(dimsA, dimsB)) {\n      numOfSkips += 1;\n      indexA = 0;\n      indexB = numOfSkips + 1;\n    } else {\n      indexA = indexB;\n      indexB = indexA + numOfSkips + 1;\n    }\n  }\n  return { numOfSkips, labelsInfo };\n}\n\n/**\n * Greedily skip labels. We will skip next label if it overlaps with the previous one.\n * This might not result in uniformly spaced labels.\n * @param labels\n * @param getLabelInfo\n * @param isHoriz\n * @returns\n */\nexport function skipLabelsGreedy(\n  labels: string[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    lines: string[];\n    didNotFit: boolean;\n  },\n  isHoriz: boolean,\n  wrapText?: boolean\n) {\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n  let currentInfo = getLabelInfo(labels[0], 0, false, false, !!wrapText);\n  const renderedLabels = [\n    {\n      text: currentInfo.text,\n      lines: [currentInfo.text],\n      index: 0,\n      lineProps: [currentInfo.dims],\n      dims: currentInfo.dims\n    }\n  ];\n  let maxWidth = currentInfo.dims.width;\n  let maxHeight = currentInfo.dims.height;\n  for (let j = 1; j < labels.length; j++) {\n    if (!labels[j]) continue;\n    const labelInfo = getLabelInfo(labels[j], j, false, false, !!wrapText);\n    if (!isOverlapping(currentInfo.dims, labelInfo.dims)) {\n      currentInfo = labelInfo;\n      renderedLabels.push({\n        text: labelInfo.text,\n        lines: [labelInfo.text],\n        index: j,\n        dims: labelInfo.dims,\n        lineProps: [labelInfo.dims]\n      });\n\n      maxWidth = Math.max(maxWidth, labelInfo.dims.width);\n      maxHeight = Math.max(maxHeight, labelInfo.dims.height);\n    }\n  }\n  return { tickLabels: renderedLabels, maxWidth, maxHeight };\n}\n\nexport function getDataAxisLabelsInfo(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n  },\n  isHoriz: boolean\n) {\n  const { numOfSkips, labelsInfo } = skipLabelsUniform(\n    labels,\n    getLabelInfo,\n    isHoriz,\n    false,\n    false,\n    false,\n    0\n  );\n\n  const tickLabels = [];\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let isLabelTruncated = false;\n\n  for (let i = 0; i < labels.length; i += numOfSkips + 1) {\n    maxWidth = Math.max(maxWidth, labelsInfo[i].dims.width);\n    maxHeight = Math.max(maxHeight, labelsInfo[i].dims.height);\n    isLabelTruncated = isLabelTruncated || labelsInfo[i].isTruncated;\n    tickLabels.push({\n      text: labelsInfo[i].text,\n      lines: labelsInfo[i].lines,\n      index: i,\n      dims: labelsInfo[i].dims,\n      lineProps: labelsInfo[i].lineProps\n    });\n  }\n  return {\n    maxWidth,\n    maxHeight,\n    numOfSkips,\n    isLabelTruncated,\n    tickLabels\n  };\n}\n\nexport function getGroupAxisLabelsInfo(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n    dataProps?: Record<string, string | undefined>;\n  },\n  isHoriz: boolean,\n  autoRotate: boolean,\n  wrapText: boolean,\n  numOfSafeSkips?: number\n) {\n  let isRotated = false;\n\n  /**\n   * 1.First calculate dims of all the labels in horizontal position without\n   *   restriction and calculate the num of skips.\n   * 2.Check if the labels overlap, and hence if we have to skip some labels to\n   *   avoid overlap.\n   * 3.If we had to skip some labels and if wrapping the text is allowed, try\n   *   again horizontally with wrap enabled.\n   * 4.Check again if the labels overlap, or if some text got truncated.Truncation is\n   *   undesirable at this step if rotation is enabled.\n   * 5.If rotation is enabled, rotate the labels and check for overlap again.\n   * 6.After all the steps above, choose the setting that result in minimum number of skips.\n   */\n\n  let { numOfSkips, labelsInfo } = skipLabelsUniform(\n    labels,\n    getLabelInfo,\n    isHoriz,\n    false,\n    false,\n    false,\n    numOfSafeSkips\n  );\n  if (numOfSkips > 0 && wrapText && isHoriz) {\n    const wrapAllowedLabels = skipLabelsUniform(\n      labels,\n      getLabelInfo,\n      isHoriz,\n      false,\n      false,\n      true,\n      numOfSafeSkips\n    );\n\n    const isNotValid = wrapAllowedLabels.labelsInfo.some(\n      (info) => info.isTruncated || info.didNotFit\n    );\n\n    if (!isNotValid && wrapAllowedLabels.numOfSkips < numOfSkips) {\n      numOfSkips = wrapAllowedLabels.numOfSkips;\n      labelsInfo = wrapAllowedLabels.labelsInfo;\n    }\n  }\n\n  if (numOfSkips > 0 && autoRotate) {\n    const skipInfoRotated = skipLabelsUniform(\n      labels,\n      getLabelInfo,\n      isHoriz,\n      true,\n      true,\n      false,\n      numOfSafeSkips\n    );\n    if (skipInfoRotated.numOfSkips < numOfSkips) {\n      numOfSkips = skipInfoRotated.numOfSkips;\n      labelsInfo = skipInfoRotated.labelsInfo;\n      isRotated = true;\n    }\n  }\n\n  const tickLabels = [] as (TextProps & { index: number })[];\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  for (let i = 0; i < labels.length; i += numOfSkips + 1) {\n    maxWidth = Math.max(maxWidth, labelsInfo[i].dims.width);\n    maxHeight = Math.max(maxHeight, labelsInfo[i].dims.height);\n    tickLabels[i] = {\n      text: labelsInfo[i].text,\n      lines: labelsInfo[i].lines,\n      index: i,\n      dims: labelsInfo[i].dims,\n      lineProps: labelsInfo[i].lineProps,\n      isRotated,\n      isTruncated: labelsInfo[i].isTruncated\n    };\n  }\n\n  return {\n    maxWidth,\n    maxHeight,\n    isRotated,\n    numOfSkips,\n    tickLabels\n  };\n}\n\nexport function updateLabelsDims(\n  maxWidth: number,\n  maxHeight: number,\n  renderedLabelsInfo: any[],\n  getAxisPos: (index: number) => number,\n  availSpace: Dimension,\n  position: AxisPosition\n) {\n  renderedLabelsInfo.forEach((info) => {\n    info.lines.forEach((_: any, index: number) => {\n      const dim = info.lineProps[index];\n      let x: number;\n      let y: number;\n      if (position === 'left') {\n        x = availSpace.x + maxWidth;\n        y = getAxisPos(info.index);\n      } else if (position === 'right') {\n        x = availSpace.x + availSpace.width - maxWidth;\n        y = getAxisPos(info.index);\n      } else if (position === 'top') {\n        x = getAxisPos(info.index);\n        y = availSpace.y + maxHeight - dim.height / 2;\n      } else {\n        x = getAxisPos(info.index);\n        y = availSpace.y + availSpace.height - maxHeight + dim.height / 2 + dim.height * index;\n      }\n      dim.x = x;\n      dim.y = y;\n    });\n\n    const textDim = info.dims;\n\n    let x: number;\n    let y: number;\n    if (position === 'left') {\n      x = availSpace.x + maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'right') {\n      x = availSpace.x + availSpace.width - maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'top') {\n      x = getAxisPos(info.index);\n      y = availSpace.y + maxHeight - textDim.height / 2;\n    } else {\n      x = getAxisPos(info.index);\n      y = availSpace.y + availSpace.height - maxHeight + textDim.height / 2;\n    }\n    textDim.x = x;\n    textDim.y = y;\n  });\n}\n\n/**\n * Updates the given available space after labels are rendered.\n * @param availSpace The avaialable space.\n * @param position The position of the axis.\n * @param maxWidth The maximum width of rendered labels.\n * @param maxHeight The maxium height of the rendered labels.\n */\nexport function updateAvailableSpace(\n  availSpace: Dimension,\n  position: AxisPosition,\n  maxWidth: number,\n  maxHeight: number\n) {\n  if (position == 'left') {\n    availSpace.x += maxWidth;\n    availSpace.width -= maxWidth;\n  } else if (position === 'right') {\n    availSpace.x -= maxWidth;\n  } else if (position === 'top') {\n    availSpace.y += maxHeight;\n    availSpace.height -= maxHeight;\n  } else {\n    availSpace.height -= maxHeight;\n  }\n}\n\n/**\n * Returns the enclosing rect for the label of given dimension.\n * @param dims The dimension\n * @param axisPosition The position of the axis.\n * @returns\n */\nexport function getEnclosingRectDims(dims: Dimension, axisPosition: AxisPosition) {\n  let x: number;\n  let y: number;\n\n  if (axisPosition === 'left') {\n    x = dims.x - dims.width;\n    y = dims.y - dims.height / 2;\n  } else if (axisPosition === 'right') {\n    x = dims.x;\n    y = dims.y - dims.height / 2;\n  } else {\n    x = dims.x - dims.width / 2;\n    y = dims.y - dims.height / 2;\n  }\n  const width = dims.width;\n  const height = dims.height;\n\n  return { x, y, width, height };\n}\n\n/**\n * Retuns the unaligned label dimensions that can be used by skipLabels.\n * @returns\n */\nexport function getTickLabelInfo(\n  coord: number,\n  label: string | undefined,\n  labelStyle: VisTextStyle,\n  isHoriz: boolean,\n  isRotated: boolean,\n  isWrapAllowed: boolean,\n  allowTruncate: boolean,\n  maxWidth: number,\n  maxHeight: number,\n  availSpace: Dimension,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!getTextDimensions || !label) {\n    return {\n      text: '',\n      dims: { width: 0, height: 0, x: 0, y: 0 },\n      isTruncated: false,\n      lines: [],\n      didNotFit: false,\n      lineProps: []\n    };\n  }\n\n  const gap = AXIS_DEFAULTS.labelGap;\n  const availWidth = isRotated ? maxHeight : isWrapAllowed ? maxWidth - gap : maxWidth;\n\n  let width: number, height: number;\n  let isTruncated = false;\n  let lines: string[] = [];\n  let dims: Dimension[] = [];\n  let lineHeight: number;\n  let didNotFit = false;\n\n  const mxHeight = isWrapAllowed ? maxHeight : Infinity;\n\n  if (allowTruncate || isWrapAllowed) {\n    const textInfo = getTextInfo(\n      label,\n      labelStyle,\n      availWidth,\n      mxHeight,\n      isWrapAllowed,\n      getTextDimensions\n    );\n    width = textInfo.width;\n    height = textInfo.height;\n    lines = textInfo.lines;\n    dims = textInfo.dims;\n    isTruncated = textInfo.isTruncated;\n    lineHeight = textInfo.lineHeight;\n    didNotFit = textInfo.didNotFit;\n  } else {\n    dims = [getTextDimensions(label, labelStyle)];\n    width = dims[0].width;\n    height = dims[0].height;\n    lines = [label];\n    isTruncated = false;\n    lineHeight = height;\n  }\n\n  const _labelWidth = isRotated ? height : width;\n  const _labelHeight = isRotated ? width : height;\n\n  const labelWidth = isHoriz ? _labelWidth + gap : _labelWidth;\n  const labelHeight = isHoriz ? _labelHeight : _labelHeight + gap;\n  return {\n    text: label,\n    lines,\n    lineProps: dims.map((dim, i) => ({\n      x: isHoriz ? coord - dim.width / 2 : availSpace.x,\n      width: isRotated ? dim.height : dim.width,\n      height: isRotated ? dim.width : dim.height,\n      y: isHoriz ? availSpace.y + lineHeight * i : coord + dim.height / 2\n    })),\n    isTruncated,\n    didNotFit,\n    dims: {\n      x: isHoriz ? coord - labelWidth / 2 : availSpace.x,\n      width: labelWidth,\n      height: labelHeight,\n      y: isHoriz ? availSpace.y : coord + labelHeight / 2\n    }\n  };\n}\n"],"names":["AXIS_DEFAULTS","titleGap","labelGap","skipLabelsUniform","labels","getLabelInfo","isHoriz","isRotated","autoTruncate","isWrapAllowed","numOfSafeSkips","dimsA","dimsB","numOfSkips","labelsInfo","isOverlapping","isWidthOverlap","isHeightOverlap","indexA","indexB","length","labelsInfoA","dims","labelsInfoB","tickLabels","maxWidth","maxHeight","isLabelTruncated","i","Math","max","width","height","isTruncated","push","text","lines","index","lineProps","axisPosition","x","y","autoRotate","wrapText","wrapAllowedLabels","some","info","didNotFit","skipInfoRotated","coord","label","labelStyle","allowTruncate","availSpace","getTextDimensions","gap","availWidth","lineHeight","mxHeight","Infinity","textInfo","getTextInfo","_labelWidth","_labelHeight","labelWidth","labelHeight","map","dim","currentInfo","renderedLabels","j","labelInfo","renderedLabelsInfo","getAxisPos","position","forEach","_","textDim"],"mappings":"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"}