{"version":3,"file":"TextFieldInput-ba4e508c.js","sources":["../../src/UNSAFE_TextField/TextFieldInput.tsx"],"sourcesContent":["import { Ref } from 'preact';\nimport { useRef, useLayoutEffect } from 'preact/hooks';\nimport { useAccessibleContext } from '#hooks/UNSAFE_useAccessibleContext';\nimport { useFormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useTextFieldInputHandlers } from '../hooks/UNSAFE_useTextFieldInputHandlers';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport type { TextProps } from '#utils/UNSAFE_interpolations/text';\nimport { textInterpolations } from '#utils/UNSAFE_interpolations/text';\nimport { mergeInterpolations } from '#utils/UNSAFE_mergeInterpolations';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport { isInputPlaceholderShown } from './TextFieldUtils';\nimport {\n  AriaAttributesSignalExcluded,\n  HTMLAttributesSignalExcluded\n} from '#utils/UNSAFE_attributeUtils';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { TextFieldInputVariantOptions } from './themes/TextFieldInputStyles.css';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '#resources/nls/bundle';\nimport { TextFieldInputRedwoodTheme } from './themes/redwood/TextFieldInputTheme';\n\nconst interpolations = [...Object.values(textInterpolations)];\n\nconst styleInterpolations = mergeInterpolations<Props>(interpolations);\n\n// The WHATWG forms spec specifies the following input types that support setSelectedRange\nconst supportsSetSelection = ['text', 'search', 'url', 'tel', 'password', 'textarea'];\n\ntype Autocomplete = 'off' | 'on' | string;\n\ntype OrigPickedPropsFromInput = Pick<\n  HTMLAttributesSignalExcluded<HTMLInputElement>,\n  'autofocus' | 'id' | 'placeholder' | 'required' | 'role' | 'spellcheck' | 'type'\n>;\ntype RenamedPropsFromInput = Omit<\n  OrigPickedPropsFromInput,\n  'autofocus' | 'readonly' | 'required'\n> & {\n  autoFocus?: OrigPickedPropsFromInput['autofocus'];\n  isRequired?: OrigPickedPropsFromInput['required'];\n};\ntype InputProps = {\n  as?: 'input';\n  type?: Pick<HTMLAttributesSignalExcluded<HTMLInputElement>, 'type'>['type'];\n  rows?: never;\n  inputRef?: Ref<HTMLInputElement>;\n  hasPrefix?: boolean;\n  hasSuffix?: boolean;\n};\n\ntype TextAreaProps = {\n  as: 'textarea';\n  type?: never;\n  rows?: number;\n  inputRef?: Ref<HTMLTextAreaElement>;\n  hasPrefix?: never;\n  hasSuffix?: never;\n};\n\ntype FocusProps = Pick<HTMLAttributesSignalExcluded<HTMLElement>, 'onBlur' | 'onFocus'>;\n\ntype UniqueProps = InputProps | TextAreaProps;\n\ntype AriaProps = Pick<\n  AriaAttributesSignalExcluded,\n  | 'aria-autocomplete'\n  | 'aria-controls'\n  | 'aria-describedby'\n  | 'aria-expanded'\n  | 'aria-invalid'\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-valuemax'\n  | 'aria-valuemin'\n  | 'aria-valuenow'\n  | 'aria-valuetext'\n>;\n\ntype Props = UniqueProps &\n  TextProps &\n  RenamedPropsFromInput &\n  AriaProps &\n  FocusProps & {\n    autoComplete?: Autocomplete;\n    // TODO: Should we expose has* props like these or should we pass this info\n    // via FormFieldContext?  (from review on 3/8/22)\n    currentCommitValue?: string;\n    hasEmptyLabel?: boolean;\n    hasEndContent?: boolean;\n    hasInsideLabel?: boolean;\n    hasStartContent?: boolean;\n    value?: string;\n    variant?: 'default' | 'embedded';\n    onInput?: (detail: ValueUpdateDetail<string>) => void;\n    onCommit?: (detail: ValueUpdateDetail<string>) => void;\n    onKeyDown?: (event: KeyboardEvent) => void;\n    onKeyUp?: (event: KeyboardEvent) => void;\n  };\n\n/**\n * Merge multiple ids into a space-separated list\n * @param ids The ids to be merged\n * @returns The space separated string of ids\n */\nfunction mergeIDs(...ids: (string | undefined)[]) {\n  return ids.filter(Boolean).join(' ') || undefined;\n}\n\nexport const TextFieldInput = ({\n  as = 'input',\n  'aria-autocomplete': ariaAutoComplete,\n  'aria-controls': ariaControls,\n  'aria-describedby': ariaDescribedBy,\n  'aria-expanded': ariaExpanded,\n  'aria-invalid': ariaInvalid,\n  'aria-label': ariaLabel,\n  'aria-labelledby': inputLabelledBy,\n  'aria-valuemax': ariaValueMax,\n  'aria-valuemin': ariaValueMin,\n  'aria-valuenow': ariaValueNow,\n  'aria-valuetext': ariaValueText,\n  autoComplete,\n  autoFocus,\n  currentCommitValue,\n  hasEmptyLabel,\n  hasEndContent = false,\n  hasInsideLabel = false,\n  hasPrefix = false,\n  hasStartContent = false,\n  hasSuffix = false,\n  id,\n  inputRef,\n  placeholder,\n  isRequired,\n  role,\n  rows,\n  spellcheck,\n  type,\n  value = '',\n  variant = 'default',\n  onInput,\n  onCommit,\n  onKeyDown,\n  onKeyUp,\n  onBlur,\n  onFocus,\n  ...props\n}: Props) => {\n  const { isDisabled, isFocused, isLoading, isReadonly } = useFormFieldContext();\n  const { class: styleInterpolationClasses } = styleInterpolations(props);\n  const hasValue = value !== '';\n  const isTextArea = as === 'textarea';\n  const isInput = as === 'input';\n  const isPassword = type === 'password';\n  const renderPrefix = !isDisabled && hasPrefix;\n  const renderSuffix = !isDisabled && hasSuffix;\n  const myPlaceholder = isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused)\n    ? placeholder\n    : undefined;\n\n  const { classes } = useComponentTheme<TextFieldInputVariantOptions>(TextFieldInputRedwoodTheme, {\n    type: isPassword ? 'isPassword' : 'notPassword',\n    styleVariant: variant,\n    textarea: isTextArea ? 'isTextArea' : 'notTextArea',\n    input: isInput ? 'isInput' : 'notInput',\n    div: 'notDiv',\n    prefix: renderPrefix ? 'hasPrefix' : 'noPrefix',\n    suffix: renderSuffix ? 'hasSuffix' : 'noSuffix',\n    startContent: hasStartContent ? 'hasStartContent' : 'noStartContent',\n    endContent: hasEndContent ? 'hasEndContent' : 'noEndContent',\n    insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',\n    value: hasValue ? 'hasValue' : 'noValue',\n    focused: isFocused ? 'isFocused' : 'notFocused',\n    disabled: isDisabled ? 'isDisabled' : 'notDisabled'\n  });\n\n  const inputClasses = classNames([classes, styleInterpolationClasses]);\n  const Comp = as || 'input';\n\n  // ref to hold the text selection to restore.\n  const selectionRef = useRef({\n    start: 0,\n    end: 0\n  });\n\n  const textFieldInputHandlers = useTextFieldInputHandlers({\n    currentCommitValue,\n    // Enter should not commit for textarea.\n    isCommitOnEnter: as === 'input',\n    value,\n    onInput,\n    onCommit,\n    onKeyDown,\n    selectionRef\n  });\n  const handlers = mergeProps(textFieldInputHandlers, { onBlur, onFocus });\n  // the implicit default for tabindex on an input is 0, so do not explicitly set it.\n  // JET-52914 - Implement Tabbable mode API contract in InputText\n  // if not tabbable, spread tabbableModeProps on component\n  const { isTabbable, tabbableModeProps } = useTabbableMode();\n  // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it\n  // works across browsers and versions  (from review on 3/11/22)\n\n  // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input,\n  // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other\n  // kinds of labels, this helps to ensure we don't override a meaningful label.\n  const { UNSAFE_ariaLabelledBy } = useAccessibleContext();\n  const ariaLabelledBy = hasEmptyLabel\n    ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)\n    : inputLabelledBy;\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const loadingAriaLabel = translations.formControl_loading();\n\n  // Restore the saved selection when the value changes.  See JET-62763 for info on why this is needed.\n  useLayoutEffect(() => {\n    // This should never be a function in this case, This is here because of the Ref type.\n    if (typeof inputRef !== 'function') {\n      const inpElem = inputRef?.current;\n      // only set the selection range if the element has focus\n      // only set the selection range on supported types.\n      if (\n        document.activeElement === inpElem &&\n        inpElem &&\n        supportsSetSelection.includes(inpElem.type)\n      ) {\n        inpElem.setSelectionRange(selectionRef.current.start, selectionRef.current.end);\n      }\n    }\n  }, [value, inputRef]);\n\n  return (\n    <Comp\n      aria-autocomplete={ariaAutoComplete}\n      aria-controls={ariaControls}\n      aria-describedby={ariaDescribedBy}\n      aria-expanded={ariaExpanded}\n      aria-invalid={ariaInvalid}\n      aria-label={isLoading ? loadingAriaLabel : ariaLabel ? ariaLabel : undefined}\n      aria-labelledby={ariaLabelledBy}\n      aria-required={isRequired ? true : undefined}\n      aria-valuemax={ariaValueMax}\n      aria-valuemin={ariaValueMin}\n      aria-valuenow={ariaValueNow}\n      aria-valuetext={ariaValueText}\n      autocomplete={autoComplete}\n      autofocus={autoFocus}\n      class={inputClasses}\n      disabled={isDisabled}\n      id={id}\n      onKeyUp={onKeyUp}\n      placeholder={myPlaceholder}\n      readonly={isReadonly}\n      // @ts-ignore\n      ref={inputRef}\n      role={role}\n      rows={rows}\n      spellcheck={spellcheck}\n      type={type}\n      value={value}\n      {...handlers}\n      {...(!isTabbable && tabbableModeProps)}\n    />\n  );\n};\n"],"names":["interpolations","Object","values","textInterpolations","styleInterpolations","mergeInterpolations","supportsSetSelection","as","ariaAutoComplete","ariaControls","ariaDescribedBy","ariaExpanded","ariaInvalid","ariaLabel","inputLabelledBy","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","autoComplete","autoFocus","currentCommitValue","hasEmptyLabel","hasEndContent","hasInsideLabel","hasPrefix","hasStartContent","hasSuffix","id","inputRef","placeholder","isRequired","role","rows","spellcheck","type","value","variant","onInput","onCommit","onKeyDown","onKeyUp","onBlur","onFocus","props","isDisabled","isFocused","isLoading","isReadonly","useFormFieldContext","class","styleInterpolationClasses","hasValue","isTextArea","isInput","isPassword","renderPrefix","renderSuffix","myPlaceholder","isInputPlaceholderShown","undefined","classes","useComponentTheme","TextFieldInputRedwoodTheme","styleVariant","textarea","input","div","prefix","suffix","startContent","endContent","insideLabel","focused","disabled","inputClasses","classNames","Comp","selectionRef","useRef","start","end","textFieldInputHandlers","useTextFieldInputHandlers","isCommitOnEnter","handlers","mergeProps","isTabbable","tabbableModeProps","useTabbableMode","UNSAFE_ariaLabelledBy","useAccessibleContext","ariaLabelledBy","ids","filter","Boolean","join","mergeIDs","loadingAriaLabel","useTranslationBundle","formControl_loading","useLayoutEffect","inpElem","current","document","activeElement","includes","setSelectionRange","_jsx","autocomplete","autofocus","readonly","ref"],"mappings":"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"}