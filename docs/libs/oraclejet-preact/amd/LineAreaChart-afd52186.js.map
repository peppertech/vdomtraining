{"version":3,"file":"LineAreaChart-afd52186.js","sources":["../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_visSVGUtils/AreaUtils.ts","../../src/UNSAFE_LineAreaChart/AreaSeries.tsx","../../src/UNSAFE_Chart/Markers.tsx","../../src/UNSAFE_LineAreaChart/LineSeries.tsx","../../src/UNSAFE_LineAreaChart/LineAreaChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { MarkerShapes } from '../../UNSAFE_SvgShapes';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { curveThroughPoints } from '../PRIVATE_visSVGUtils/PathUtils';\nimport { ChartItem } from '../../UNSAFE_Chart/chart.types';\nimport { Scale } from '../../UNSAFE_Chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '../../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getStraightAreaPath, getCurveAreaPath } from '../PRIVATE_visSVGUtils/AreaUtils';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\nimport { LineAreaItem } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { Group } from '../../UNSAFE_Axis/axis.types';\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: 'straight' | 'curved',\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean\n) {\n  if (areaType === 'straight') {\n    return getStraightAreaPath(lineSegmentCoords, bottomCoords);\n  }\n  return getCurveAreaPath(\n    lineSegmentCoords,\n    bottomCoords,\n    false,\n    isHoriz ? 'mh' : 'mv',\n    isBottomSegmentCurved\n  );\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: 'straight' | 'curved',\n  isHoriz: boolean\n) {\n  if (lineType === 'straight') {\n    return lineSegmentCoords.join(' ');\n  }\n  return curveThroughPoints(lineSegmentCoords, false, isHoriz ? 'mh' : 'mv');\n}\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends ChartItem<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    const prevSeries = series[seriesIndex - 1];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      if (seriesIndex) {\n        currentSeries[groupIndex] = item.value + prevSeries[groupIndex];\n      } else {\n        currentSeries[groupIndex] = item.value;\n      }\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<K extends string | number, D extends ChartItem<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      currentSeries[groupIndex] = item.value;\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      if (isMarkerDisplayed) {\n        // TODO: settle on one visual for selected markers: \n        // Selected effect when markers are turned on\n        fill = itemColor || seriesColor;\n        outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        // Selected effect when markers are not turned on\n        fill = rgb(colorSchemeVars.palette.neutral[0]);\n        if (isHovered || isFocused) {\n          stroke = itemColor || seriesColor;\n        } else {\n          stroke = rgb(colorSchemeVars.palette.neutral[130]);\n        }\n      }\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<K extends string | number, D extends LineAreaItem<K>>(\n  yScale: Scale,\n  xScale: Scale,\n  data: number[],\n  startIndex: number,\n  endIndex: number,\n  isHorizontal: boolean,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    const item = data[groupIndex];\n\n    if (!item || (isLog && item <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    const x = isHorizontal\n      ? yScale.transform(item)\n      : getGroupCenterCoord(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        );\n    const y = isHorizontal\n      ? getGroupCenterCoord(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        )\n      : yScale.transform(item);\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point } from './LineUtils';\nimport { curveThroughPoints } from './PathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getStraightAreaPath(lineSegmentCoords: Point[], bottomCoords: Point[]) {\n  // Create the path data string\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    pathData =\n      lineSegmentCoords\n        .map((lineSegmentCoord, index) => {\n          return `${index === 0 ? 'M' : 'L'} ${lineSegmentCoord[0]} ${lineSegmentCoord[1]}`;\n        })\n        .join(' ') +\n      [...bottomCoords]\n        .reverse()\n        .map((bottomCoord) => {\n          return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n        })\n        .join(' ') +\n      'Z';\n  }\n  return pathData;\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForArea } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { Scale } from '../UNSAFE_Chart';\n\ntype AreaSeriesProps = {\n  yScale: Scale;\n  color: ColorProps['color'];\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  isLog: boolean;\n  areaColorOpacity: number;\n  lineSegmentCoords: Point[][];\n  bottomCoords?: Point[];\n  isHighlighted: boolean;\n  isBottomSegmentCurved: boolean;\n  seriesIndex: number;\n};\n\nexport function AreaSeries({\n  yScale,\n  lineType = 'straight',\n  color,\n  isHorizontal,\n  isLog,\n  areaColorOpacity,\n  lineSegmentCoords,\n  bottomCoords,\n  isHighlighted,\n  isBottomSegmentCurved,\n  seriesIndex\n}: AreaSeriesProps) {\n  const style = {\n    fill: color,\n    opacity: (isHighlighted ? 1 : 0.3) * areaColorOpacity,\n    pointerEvents: areaColorOpacity !== 1 ? 'none' : 'all'\n  };\n\n  return (\n    <>\n      {lineSegmentCoords.map((lineSegmentCoords: Point[]) => {\n        let baseCoords;\n        if (bottomCoords) {\n          // custom bottom coords. eg: top of last series in stacked area\n          baseCoords = bottomCoords;\n        } else {\n          // TODO: make this more generic when we support apps setting baseline\n          // for log assume domain min is the baseline, otherwise use 0 baseline\n          const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);\n          baseCoords = isHorizontal\n            ? ([\n                [baselineCoord, lineSegmentCoords[0][1]],\n                [baselineCoord, lineSegmentCoords[lineSegmentCoords.length - 1][1]]\n              ] as Point[])\n            : ([\n                [lineSegmentCoords[0][0], baselineCoord],\n                [lineSegmentCoords[lineSegmentCoords.length - 1][0], baselineCoord]\n              ] as Point[]);\n        }\n        const cmds = getCmdsForArea(\n          lineSegmentCoords,\n          baseCoords,\n          lineType,\n          isHorizontal,\n          isBottomSegmentCurved\n        );\n        return (\n          <path d={cmds} style={style} data-oj-series-index={seriesIndex} data-oj-object={'area'} />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { LineAreaItem } from '../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { Marker, MarkerShapes, MARKER_PADDING } from '../UNSAFE_SvgShapes';\nimport { getGroupCenterCoord } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { Group } from '../UNSAFE_Axis/axis.types';\nimport { ChartSeries, Scale } from '.';\nimport { getMarkerFillAndStroke } from '../utils/PRIVATE_chartUtils/utils';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaLabel } from '../utils/PRIVATE_chartUtils/accUtils';\nimport { supportsMobileScreenReader } from '../utils/UNSAFE_visUtils';\n\nconst MARKER_DEFAULT_SIZE = 10;\ntype MarkersProps<K, D> = {\n  yScale: Scale;\n  xScale: Scale;\n  startIndex: number;\n  endIndex: number;\n  seriesIndex: number;\n  series: ChartSeries<K, D>;\n  markerType: MarkerShapes;\n  data: number[];\n  color: ColorProps['color'];\n  groups: Group[];\n  focusedItemIndex?: number;\n  isSelectionEnabled: boolean;\n  hoveredItemIndex?: number;\n  selectedIds?: Set<string | number>;\n  hiddenIds?: Set<string | number>;\n  activeId?: string;\n  orientation: 'horizontal' | 'vertical';\n  isDrillEnabled: boolean;\n  isLog: boolean;\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined;\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency';\n};\n\nexport function Markers<K extends string | number, D extends LineAreaItem<K>>({\n  yScale,\n  xScale,\n  color,\n  seriesIndex,\n  startIndex,\n  endIndex,\n  hiddenIds,\n  selectedIds,\n  orientation,\n  isLog,\n  data,\n  markerType,\n  getDataItem,\n  focusedItemIndex,\n  hoveredItemIndex,\n  isDrillEnabled,\n  activeId,\n  isSelectionEnabled,\n  timeAxisType,\n  series,\n  groups\n}: MarkersProps<K, D>) {\n  const isHoriz = orientation === 'horizontal';\n  const items = [];\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex++) {\n    const item = getDataItem(seriesIndex, groupIndex);\n    const value = data[groupIndex];\n    if (!item || hiddenIds?.has(item.id) || (isLog && value <= 0)) {\n      continue;\n    }\n    const x = isHoriz\n      ? yScale.transform(value)\n      : getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType);\n    const y = isHoriz\n      ? getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType)\n      : yScale.transform(value);\n    const isFocused = focusedItemIndex === groupIndex;\n    const isHovered = hoveredItemIndex === groupIndex;\n    const isSelected = !!selectedIds?.has(item.id!);\n    const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);\n    const { fill, stroke, outerStroke } = getMarkerFillAndStroke(\n      !!item.isMarkerDisplayed,\n      isSelectionEnabled,\n      isHovered,\n      isFocused,\n      isSelected,\n      color,\n      item.markerColor\n    );\n    const itemMarkerType = item.isMarkerDisplayed ? item.markerType || markerType : markerType;\n    const isActive = isFocused || isHovered;\n    const ariaLabel =\n      supportsMobileScreenReader || isActive\n        ? getItemAriaLabel(\n            translations,\n            series.name || series.id.toString(),\n            groups[groupIndex].name || groups[groupIndex].id,\n            item.value,\n            isSelectionEnabled,\n            isSelected,\n            isDrillable,\n            item.accessibleLabel\n          )\n        : undefined;\n\n    const dataInfo = {\n      'data-oj-series-index': seriesIndex,\n      'data-oj-group-index': groupIndex,\n      'data-oj-object': 'item',\n      id: isActive ? activeId : undefined,\n      role: ariaLabel ? 'img' : undefined,\n      'aria-label': ariaLabel\n    };\n\n    const markerSize = (item.markerSize || MARKER_DEFAULT_SIZE) + 2 * MARKER_PADDING;\n    items.push(\n      <Marker\n        type={itemMarkerType}\n        tx={x}\n        ty={y}\n        isInteractive={isDrillable || isSelectionEnabled}\n        scale={1}\n        fill={fill}\n        stroke={stroke}\n        outerStroke={outerStroke}\n        width={markerSize}\n        height={markerSize}\n        dataInfo={dataInfo}\n        preserveRectAspectRatio\n      />\n    );\n  }\n  return <>{items}</>;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForLine } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { rgba } from '../UNSAFE_Theme';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { styles } from '../UNSAFE_Chart/themes/ChartStyles.css';\nimport { Property } from 'csstype';\n\ntype LineSeriesProps = {\n  color: ColorProps['color'];\n  lineStyle?: 'dotted' | 'dashed' | 'solid';\n  lineColor?: Property.Color;\n  lineWidth?: number;\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  lineSegmentCoords: Point[][];\n  isHighlighted: boolean;\n  seriesIndex: number;\n};\n\nexport function LineSeries({\n  color,\n  isHorizontal,\n  lineType = 'straight',\n  lineColor,\n  lineStyle,\n  lineWidth = 3,\n  isHighlighted,\n  lineSegmentCoords,\n  seriesIndex\n}: LineSeriesProps) {\n  const style = {\n    stroke: lineColor || color,\n    strokeDasharray: lineStyle === 'dotted' ? 3 : lineStyle === 'dashed' ? 6 : undefined,\n    strokeWidth: lineWidth,\n    fill: rgba(colorSchemeVars.palette.neutral[0], 0)\n  };\n\n  return (\n    <>\n      {lineSegmentCoords.map((value: Point[]) => {\n        const cmds = getCmdsForLine(value, lineType, isHorizontal);\n        return lineType === 'straight' ? (\n          <polyline\n            points={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        ) : (\n          <path\n            d={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\nimport { findNearestDataPoint } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from './AreaSeries';\nimport { getCumulativeSeries, getMarkers, getSeriesData } from '../utils/PRIVATE_chartUtils/utils';\nimport { Markers } from '../UNSAFE_Chart/Markers';\nimport { getLineAreaChartNavUtil } from '../utils/PRIVATE_chartUtils/navUtils';\nimport { Chart, Scale } from '../UNSAFE_Chart';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getColorRamp } from '../utils/UNSAFE_visUtils';\nimport { LineSeries } from './LineSeries';\nimport { TimeAxisProps } from '../UNSAFE_Axis/axis.types';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '../utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\n\nconst AXIS_OFFSET = 0.2;\n\n/**\n * The Line Area Chart displays information graphically using lines and filled areas, making relationships among the data easier to understand.\n */\nexport function LineAreaChart<K extends string | number, D extends LineAreaItem<K>>({\n  width = '100%',\n  height = '448px',\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  type = 'line',\n  ...props\n}: LineAreaChartProps<K, D>) {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  const renderedSeries = isStacked\n    ? getCumulativeSeries(series.length, groups.length, getDataItem, hiddenSet, isLog)\n    : getSeriesData(series?.length, groups?.length, getDataItem, hiddenSet, isLog);\n\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number) => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    };\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    return getLineAreaChartNavUtil(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale) => {\n    return (seriesIndex: number, groupIndex: number) => {\n      const value = renderedSeries[seriesIndex][groupIndex];\n      const x = isHoriz ? yScale.transform(value) : xScale.transform(groupIndex);\n      const y = isHoriz ? xScale.transform(groupIndex) : yScale.transform(value);\n      return { x, y, height: 0, width: 0 };\n    };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint(\n      series,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet\n    );\n  };\n  const markers = getMarkers();\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const AREA_OPACITY = type === 'lineWithArea' ? 0.5 : 1;\n  const isAreaRendered = type === 'area' || type === 'lineWithArea';\n  const isContrastLineNeeded = type === 'area';\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedIds}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      series={series}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      renderGridLinesInFront={isAreaRendered}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      offset={AXIS_OFFSET}\n      isRtl={isRtl}\n      {...props}>\n      {({ xStartIndex, xEndIndex, xScale, yScale, activeId, focusedItemInfo, hoveredItemInfo }) => {\n        return (\n          <>\n            {renderedSeries.map((lineAreaSeries, index) => {\n              if (lineAreaSeries.length === 0) {\n                /* TODO: need a better way to handle when a series is hidden. */\n                return;\n              }\n              const seriesItem = series[index];\n              const lineSegmentCoords: Point[][] = getLineAreaSegments(\n                yScale,\n                xScale,\n                lineAreaSeries,\n                xStartIndex,\n                xEndIndex,\n                isHoriz,\n                isLog,\n                groups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                seriesItem.lineType === 'curved' &&\n                isStacked &&\n                renderedSeries.length > 1 &&\n                index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined || highlightedSet.has(seriesItem.id);\n              return (\n                <>\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={yScale}\n                      lineType={seriesItem.lineType}\n                      color={seriesItem.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={AREA_OPACITY}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={\n                        isStacked && index != 0 ? allLineSegmentCoords[index - 1] : undefined\n                      }\n                      lineSegmentCoords={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  <LineSeries\n                    lineType={seriesItem.lineType}\n                    /* TODO: confirm with UX if this is contrastLine (changes depending on dark/light mode) or always white. \n                        It's always white in legacy.*/\n                    lineColor={\n                      isContrastLineNeeded ? colorSchemeVars.dvt.contrastLine : seriesItem.lineColor\n                    }\n                    /* The area generated in legacy are bit apart and not touching when stacked. Preact areas are a bit closer than legacy when curved. \n                      Increased the contrast linewidth (to 2.5 from legacy 1.25) to give legacy visual treatment.\n                      TODO: investivage why legacy areas are not touching. maybe we want to do the same in preact svg utils that\n                      generates this curve.\n                     */\n                    lineWidth={\n                      isContrastLineNeeded ? (isStacked ? 2.5 : 1.25) : seriesItem.lineWidth\n                    }\n                    lineStyle={seriesItem.lineStyle}\n                    color={seriesItem.lineColor || colors[index % colors.length]}\n                    lineSegmentCoords={lineSegmentCoords}\n                    isHorizontal={isHoriz}\n                    isHighlighted={isHighlighted}\n                    seriesIndex={index}\n                  />\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (\n                      <Markers\n                        yScale={yScale}\n                        xScale={xScale}\n                        groups={groups}\n                        series={seriesItem}\n                        timeAxisType={timeAxisType}\n                        data={lineAreaSeries}\n                        color={\n                          seriesItem.lineColor ||\n                          seriesItem.areaColor ||\n                          colors[index % colors.length] /* TODO : make checks smarter. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        selectedIds={selectedSet}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n            {isStacked &&\n              renderedSeries.map((lineAreaSeries, index) => {\n                if (lineAreaSeries.length === 0) {\n                  /* TODO: need a better way to handle when a series is hidden.*/\n                  return;\n                }\n                const seriesItem = series[index];\n                return (\n                  <Markers\n                    yScale={yScale}\n                    series={series[index]}\n                    xScale={xScale}\n                    groups={groups}\n                    timeAxisType={timeAxisType}\n                    data={lineAreaSeries}\n                    color={\n                      seriesItem.lineColor || seriesItem.areaColor || colors[index % colors.length] // TODO : make checks smarter.\n                    }\n                    seriesIndex={index}\n                    startIndex={xStartIndex}\n                    endIndex={xEndIndex}\n                    markerType={markers[index % markers.length]}\n                    orientation={orientation}\n                    isLog={isLog}\n                    activeId={activeId}\n                    getDataItem={getDataItem}\n                    selectedIds={selectedSet}\n                    focusedItemIndex={\n                      focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                        ? focusedItemInfo.groupIndex\n                        : undefined\n                    }\n                    hoveredItemIndex={\n                      hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                        ? hoveredItemInfo.groupIndex\n                        : undefined\n                    }\n                    isSelectionEnabled={selectionMode === 'single' || selectionMode === 'multiple'}\n                    isDrillEnabled={drilling === 'on'}\n                  />\n                );\n              })}\n          </>\n        );\n      }}\n    </Chart>\n  );\n}\n"],"names":["getCmdsForArea","lineSegmentCoords","bottomCoords","areaType","isHoriz","isBottomSegmentCurved","pathData","length","map","lineSegmentCoord","index","join","reverse","bottomCoord","getStraightAreaPath","connectWithLine","splineType","curveThroughPoints","getCurveAreaPath","getMarkerFillAndStroke","isMarkerDisplayed","isSelectionEnabled","isHovered","isFocused","isSelected","seriesColor","itemColor","fill","stroke","outerStroke","rgb","colorSchemeVars","palette","neutral","rgba","AreaSeries","yScale","lineType","color","isHorizontal","isLog","areaColorOpacity","isHighlighted","seriesIndex","style","opacity","pointerEvents","_jsx","baseCoords","baselineCoord","transform","domain","cmds","d","MARKER_DEFAULT_SIZE","Markers","xScale","startIndex","endIndex","hiddenIds","selectedIds","orientation","data","markerType","getDataItem","focusedItemIndex","hoveredItemIndex","isDrillEnabled","activeId","timeAxisType","series","groups","items","translations","useTranslationBundle","groupIndex","item","value","has","id","x","getGroupCenterCoord","y","isDrillable","drilling","markerColor","itemMarkerType","isActive","ariaLabel","supportsMobileScreenReader","getItemAriaLabel","name","toString","accessibleLabel","undefined","dataInfo","role","markerSize","MARKER_PADDING","push","jsx","Marker","type","tx","ty","isInteractive","scale","width","height","preserveRectAspectRatio","_Fragment","Fragment","children","LineSeries","lineColor","lineStyle","lineWidth","strokeDasharray","strokeWidth","getCmdsForLine","points","className","styles","dimmed","highlightedIds","hideAndShowBehavior","yAxis","isStacked","selectionMode","props","direction","useUser","isRtl","hiddenSet","Set","selectedSet","highlightedSet","colors","getColorRamp","renderedSeries","numSeries","numGroups","currentSeries","prevSeries","getCumulativeSeries","getSeriesData","renderedGetDataItem","markers","xAxis","AREA_OPACITY","isAreaRendered","isContrastLineNeeded","allLineSegmentCoords","Chart","findNearest","findNearestDataPoint","offset","dataWidth","getDataItemPos","renderGridLinesInFront","getNavUtil","getLineAreaChartNavUtil","getGapRatio","xStartIndex","xEndIndex","focusedItemInfo","hoveredItemInfo","_jsxs","jsxs","lineAreaSeries","seriesItem","segments","currentPath","getLineAreaSegments","areaColor","dvt","contrastLine","isFocusVisible","isCurrent"],"mappings":"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"}