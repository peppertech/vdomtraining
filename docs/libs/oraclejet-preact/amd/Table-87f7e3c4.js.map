{"version":3,"file":"Table-87f7e3c4.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeleton.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/utils/TableThemeUtils.ts","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableTooltipUtils.ts","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/TableContextMenu.tsx","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableFocusUtils.ts","../../src/PRIVATE_Table/hooks/useContextMenu.ts","../../src/PRIVATE_Table/hooks/useTruncationTooltip.tsx","../../src/PRIVATE_Table/hooks/useFocusHandling.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableNavigationUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/usePointerHandling.ts","../../src/PRIVATE_Table/utils/TableSortUtils.ts","../../src/PRIVATE_Table/hooks/useScrollHandling.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/hooks/useKeyboardHandling.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/hooks/useSizingManager.ts","../../src/PRIVATE_Table/Table.tsx","../../src/PRIVATE_Table/hooks/useDataManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  isRendered: boolean;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, isRendered, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width:${columnWidth}px;`;\n  };\n\n  return isRendered ? (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Size } from '../utils/UNSAFE_size';\nimport { dimensionInterpolations } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\n\nconst dimensions = ['height', 'width'] as const;\n//This type has StyleInterpolationProps with the height prop made required.\ntype TableSkeletonProps = {\n  isHighContrast: boolean;\n  height?: Size;\n  width?: Size;\n};\n\n// Create an array [dimensionInterpolations['height'], dimensionInterpolations['width']]\nconst skeletonDimensionInterpolation = Array.from(dimensions, (x) => dimensionInterpolations[x]);\nconst interpolations = [...Object.values(skeletonDimensionInterpolation)];\nconst SkeletonInterpolations = mergeInterpolations<TableSkeletonProps>(interpolations);\n\n/**\n * TableSkeleton component allows the appropriate skeleton to be rendered based on the\n * property values\n **/\nexport function TableSkeleton({ ...props }: TableSkeletonProps) {\n  const skeletonStyles = props.isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const classes = classNames([skeletonStyles.bar]);\n\n  const skeletonDimensions = SkeletonInterpolations({ width: '100%', ...props });\n  return <div style={skeletonDimensions} class={classes} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TableSkeleton } from './TableSkeleton';\n\ntype SkeletonRowProps = {\n  tableId: string;\n  colspan: number;\n  hasTabIndex: boolean;\n  isShowFocusRing: boolean;\n  isPendingLayout?: boolean;\n  isLoadMore?: boolean;\n  isHighContrast: boolean;\n};\n\n/**\n * TableSkeletonRow renders a set of 'loading' skeletons.\n **/\nexport function TableSkeletonRow({\n  tableId,\n  colspan,\n  hasTabIndex,\n  isShowFocusRing,\n  isPendingLayout = false,\n  isLoadMore = false,\n  isHighContrast\n}: SkeletonRowProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const cellClassArray = [skeletonStyles.cell];\n  if (isShowFocusRing) {\n    cellClassArray.push(skeletonStyles.focus);\n  }\n  const cellClasses = classNames(cellClassArray);\n  const innerCellClasses = classNames([skeletonStyles.innerCell]);\n  const rowClasses = classNames([skeletonStyles.row, skeletonStyles.rowHeight]);\n  const firstRowClasses = isPendingLayout\n    ? classNames([skeletonStyles.row, skeletonStyles.headerHeight])\n    : rowClasses;\n\n  const accCellContent = (\n    <div style={'width:1px;height:0px;overflow:hidden;'}>{translations.collection_loading()}</div>\n  );\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} role={'row'}>\n      <td\n        class={cellClasses}\n        colSpan={colspan}\n        role={'gridcell'}\n        tabIndex={hasTabIndex ? 0 : -1}\n        data-oj-cell-type={isPendingLayout ? 'pending' : isLoadMore ? 'loadMore' : 'loading'}\n        {...(isPendingLayout\n          ? { 'data-oj-table-pending-cell': tableId }\n          : isLoadMore\n          ? { 'data-oj-table-load-more-cell': tableId }\n          : { 'data-oj-table-loading-cell': tableId })}\n        data-oj-table-focusable={tableId}>\n        <div class={innerCellClasses}>\n          {accCellContent}\n          {[...Array(isLoadMore ? 3 : 25)].map((_element, index) => (\n            <div class={index === 0 ? firstRowClasses : rowClasses}>\n              <TableSkeleton height=\"4x\" isHighContrast={isHighContrast} />\n            </div>\n          ))}\n        </div>\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { backgroundStyles, textAlignStyles, verticalAlignStyles } from '../themes/Table.css';\nimport { CellStyles, tableCellStyles, tableCellStylesHC } from '../themes/TableCellStyles.css';\nimport {\n  FooterCellStyles,\n  tableFooterCellStyles,\n  tableFooterCellStylesHC,\n  footerPreviousInteractiveBorderStart,\n  footerPreviousInteractiveBorderStartHC,\n  footerPreviousInteractiveBorderStartNoPadding,\n  footerPreviousInteractiveBorderStartNoPaddingHC,\n  footerPreviousPseudoHoverBorderStart,\n  footerPreviousPseudoHoverBorderStartHC,\n  footerPreviousPseudoHoverBorderStartNoPadding,\n  footerPreviousPseudoHoverBorderStartNoPaddingHC\n} from '../themes/TableFooterCellStyles.css';\nimport {\n  HeaderCellStyles,\n  tableHeaderCellStyles,\n  tableHeaderCellStylesHC,\n  headerPreviousInteractiveBorderStart,\n  headerPreviousInteractiveBorderStartHC,\n  headerPreviousInteractiveBorderStartNoPadding,\n  headerPreviousInteractiveBorderStartNoPaddingHC,\n  headerPreviousPseudoHoverBorderStart,\n  headerPreviousPseudoHoverBorderStartHC,\n  headerPreviousPseudoHoverBorderStartNoPadding,\n  headerPreviousPseudoHoverBorderStartNoPaddingHC\n} from '../themes/TableHeaderCellStyles.css';\nimport { CellPadding, CurrentRowVariant } from '../../UNSAFE_TableView';\n\ntype DataCellThemingProps = {\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  isFirstRowIndex: boolean;\n  isFinalRowIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasLastHorizontalGridline: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  isSticky: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  isActive: boolean;\n  isHover: boolean;\n  isPseudoHover: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  variant?: CurrentRowVariant;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a data cell.\n */\nexport const getDataCellClassArray = ({\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  isFirstRowIndex,\n  isFinalRowIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasLastHorizontalGridline,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  isSticky,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  isActive,\n  isHover,\n  isPseudoHover,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  horizontalAlignment,\n  verticalAlignment,\n  variant,\n  padding\n} : DataCellThemingProps) => {\n  const cellStyles = isHighContrast ? tableCellStylesHC : tableCellStyles;\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const {\n    isTopPadding,\n    isBottomPadding,\n    isStartPadding,\n    isEndPadding\n  } = _getPaddingInfo(padding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Interaction styling logic\n  if (isRowSelectionEnabled) {\n    if (isActive) {\n      classArray.push(cellStyles.active);\n    } else if (isHover) {\n      classArray.push(cellStyles.hover);\n    } else if (isPseudoHover) {\n      classArray.push(cellStyles.pseudoHover);\n    }\n  }\n  if (variant === 'highlight') {\n    classArray.push(cellStyles.rowHighlight);\n  }\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n\n  // Selected Rows and Horizontal Gridline styling logic\n  let hasBackground = false;\n  if (isRowSelected) {\n    hasBackground = true;\n    classArray.push(cellStyles.selected);\n  }\n  if (isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) {\n    classArray.push(cellStyles.horizontalSelectedGridTop);\n    classArray.push(isTopPadding\n      ? cellStyles.selectedBorderTopPadding\n      : cellStyles.selectedBorderTopNoPadding\n    );\n  } else if (!isFirstRowIndex && hasHorizontalGridlines) {\n    classArray.push(cellStyles.horizontalGridTop);\n    classArray.push(isTopPadding ? cellStyles.borderTopPadding : cellStyles.borderTopNoPadding);\n  } else {\n    classArray.push(isTopPadding ? cellStyles.topSpacerPadding : cellStyles.topSpacerNoPadding);\n  }\n  if (isFinalRowIndex) {\n    classArray.push(cellStyles.lastRow);\n    if (isRowSingleSelection && isRowSelected) {\n      classArray.push(cellStyles.horizontalSelectedGridBottom);\n      classArray.push(isBottomPadding\n        ? cellStyles.selectedBorderBottomPadding\n        : cellStyles.selectedBorderBottomNoPadding\n      );\n    } else if (hasLastHorizontalGridline) {\n      classArray.push(cellStyles.horizontalGridBottom);\n      classArray.push(isBottomPadding\n        ? cellStyles.borderBottomPadding\n        : cellStyles.borderBottomNoPadding\n      );\n    } else {\n      classArray.push(isBottomPadding\n        ? cellStyles.bottomSpacerPadding\n        : cellStyles.bottomSpacerNoPadding\n      );\n    }\n  } else {\n    classArray.push(cellStyles.notLastRow);\n    classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  }\n\n  // Selected Columns and Vertical Gridline styling logic\n  if (isColumnSelected) {\n    if (!hasBackground) {\n      classArray.push(cellStyles.selected);\n      hasBackground = true;\n    }\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFinalColumnIndex\n    );\n  } else {\n    if (!hasBackground) {\n      classArray.push(backgroundStyles.inherit);\n    }\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isPreviousColumnSelected,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasVerticalGridlines\n    );\n  }\n  return classArray;\n};\n\ntype HeaderFooterCellThemingProps = {\n  isHeader: boolean;\n  isActive: boolean;\n  isHover: boolean;\n  isPseudoHover: boolean;\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  isSticky: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  isHighContrast: boolean;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a header or footer cell.\n */\nexport const getHeaderFooterCellClassArray = ({\n  isHeader,\n  isActive,\n  isHover,\n  isPseudoHover,\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  isSticky,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  horizontalAlignment,\n  verticalAlignment,\n  isHighContrast,\n  padding\n}: HeaderFooterCellThemingProps) => {\n  let cellStyles;\n  let previousInteractiveBorderStart;\n  let previousInteractiveBorderStartNoPadding;\n  let previousPseudoHoverBorderStart;\n  let previousPseudoHoverBorderStartNoPadding;\n\n  if (isHeader) {\n    if (isHighContrast) {\n      cellStyles = tableHeaderCellStylesHC;\n      previousInteractiveBorderStart = headerPreviousInteractiveBorderStartHC;\n      previousPseudoHoverBorderStart = headerPreviousPseudoHoverBorderStartHC;\n      previousInteractiveBorderStartNoPadding = headerPreviousInteractiveBorderStartNoPaddingHC;\n      previousPseudoHoverBorderStartNoPadding = headerPreviousPseudoHoverBorderStartNoPaddingHC;\n    } else {\n      cellStyles = tableHeaderCellStyles;\n      previousInteractiveBorderStart = headerPreviousInteractiveBorderStart;\n      previousPseudoHoverBorderStart = headerPreviousPseudoHoverBorderStart;\n      previousInteractiveBorderStartNoPadding = headerPreviousInteractiveBorderStartNoPadding;\n      previousPseudoHoverBorderStartNoPadding = headerPreviousPseudoHoverBorderStartNoPadding;\n    }\n  } else if (isHighContrast) {\n    cellStyles = tableFooterCellStylesHC;\n    previousInteractiveBorderStart = footerPreviousInteractiveBorderStartHC;\n    previousInteractiveBorderStartNoPadding = footerPreviousInteractiveBorderStartNoPaddingHC;\n    previousPseudoHoverBorderStart = footerPreviousPseudoHoverBorderStartHC;\n    previousPseudoHoverBorderStartNoPadding = footerPreviousPseudoHoverBorderStartNoPaddingHC;\n  } else {\n    cellStyles = tableFooterCellStyles;\n    previousInteractiveBorderStart = footerPreviousInteractiveBorderStart;\n    previousInteractiveBorderStartNoPadding = footerPreviousInteractiveBorderStartNoPadding;\n    previousPseudoHoverBorderStart = footerPreviousPseudoHoverBorderStart;\n    previousPseudoHoverBorderStartNoPadding = footerPreviousPseudoHoverBorderStartNoPadding;\n  }\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const {\n    isTopPadding,\n    isBottomPadding,\n    isStartPadding,\n    isEndPadding\n  } = _getPaddingInfo(padding);\n  classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  classArray.push(isTopPadding ? cellStyles.topPadding : cellStyles.topNoPadding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Selected and Vertical Gridline styling logic\n  if (isSelected) {\n    classArray.push(cellStyles.selected);\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFinalColumnIndex\n    );\n  } else {\n    classArray.push(backgroundStyles.inherit);\n    let additionalStyles;\n    if (isColumnSelectionEnabled) {\n      // dynamic start borders for when previous cell has hover / active states\n      additionalStyles = {\n        startInteractivePaddingStyles: [\n          previousInteractiveBorderStart,\n          previousPseudoHoverBorderStart\n        ],\n        startInteractiveNoPaddingStyles: [\n          previousInteractiveBorderStartNoPadding,\n          previousPseudoHoverBorderStartNoPadding\n        ]\n      };\n    }\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isPreviousColumnSelected,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      additionalStyles\n    );\n  }\n\n  // Interaction styling logic\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n  if (isColumnSelectable) {\n    let interactiveStyles;\n    if (isActive) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.activeSelected,\n        notSelectedStyle: cellStyles.active,\n        borderStartStyle: cellStyles.activeBorderStart,\n        borderStartNoPaddingStyle: cellStyles.activeBorderStartNoPadding,\n        borderEndStyle: cellStyles.activeBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.activeBorderEndNoPadding\n      };\n    } else if (isHover) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.hoverSelected,\n        notSelectedStyle: cellStyles.hover,\n        borderStartStyle: cellStyles.hoverBorderStart,\n        borderStartNoPaddingStyle: cellStyles.hoverBorderStartNoPadding,\n        borderEndStyle: cellStyles.hoverBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.hoverBorderEndNoPadding\n      };\n    } else if (isPseudoHover) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.pseudoHoverSelected,\n        notSelectedStyle: cellStyles.pseudoHover,\n        borderStartStyle: cellStyles.pseudoHoverBorderStart,\n        borderStartNoPaddingStyle: cellStyles.pseudoHoverBorderStartNoPadding,\n        borderEndStyle: cellStyles.pseudoHoverBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.pseudoHoverBorderEndNoPadding\n      };\n    }\n    if (interactiveStyles != null) {\n      if (isSelected) {\n        classArray.push(interactiveStyles.selectedStyle);\n      } else {\n        classArray.push(interactiveStyles.notSelectedStyle);\n        if (!isPreviousColumnSelected && (!hasVerticalGridlines || isFirstColumnIndex)) {\n          classArray.push(isStartPadding\n            ? interactiveStyles.borderStartStyle\n            : interactiveStyles.borderStartNoPaddingStyle\n          );\n        }\n        if (isFinalColumnIndex) {\n          classArray.push(isEndPadding\n            ? interactiveStyles.borderEndStyle\n            : interactiveStyles.borderEndNoPaddingStyle\n          );\n        }\n      }\n    }\n  }\n  return classArray;\n};\n\nconst _getPaddingInfo = (padding?: CellPadding) => {\n  const isPaddingDisabled = padding === 'disabled';\n  const isComplexPadding = padding instanceof Object;\n  const isBottomPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.bottom === 'disabled')\n  );\n  const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));\n  const isStartPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.start === 'disabled')\n  );\n  const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));\n  return { isTopPadding, isBottomPadding, isStartPadding, isEndPadding };\n}\n\nconst _applyAlignmentStyling = (\n  classArray: string[],\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center',\n  verticalAlignment: 'top' | 'center' | 'bottom'\n) => {\n  classArray.push(textAlignStyles[horizontalAlignment]);\n  classArray.push(verticalAlignStyles[verticalAlignment]);\n};\n\nconst _applyFocusStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isShowFocusRing: boolean\n) => {\n  if (isShowFocusRing) {\n    classArray.push(cellStyles.focused);\n  }\n};\n\nconst _applyStickyStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isSticky: boolean,\n  isStickyStartEdge: boolean,\n  isStickyEndEdge: boolean,\n  isRtl: boolean\n) => {\n  if (isSticky) {\n    classArray.push(cellStyles.stickyColumn);\n  }\n  if (isStickyStartEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeLeft : cellStyles.stickyEdgeRight);\n  } else if (isStickyEndEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeRight : cellStyles.stickyEdgeLeft);\n  }\n};\n\nconst _applyColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isPreviousColumnSelected: boolean,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  isFirstColumnIndex: boolean,\n  isFinalColumnIndex: boolean,\n  hasVerticalGridlines: boolean,\n  additionalStyles?: {\n    startInteractivePaddingStyles: string[];\n    startInteractiveNoPaddingStyles: string[];\n  }\n) => {\n  if (isPreviousColumnSelected) {\n    classArray.push(cellStyles.verticalSelectedGridStart);\n    classArray.push(isStartPadding\n      ? cellStyles.selectedBorderStartPadding\n      : cellStyles.selectedBorderStartNoPadding\n    );\n  } else if (!isFirstColumnIndex && hasVerticalGridlines) {\n    classArray.push(cellStyles.verticalGridStart);\n    classArray.push(isStartPadding\n      ? cellStyles.borderStartPadding\n      : cellStyles.borderStartNoPadding\n    );\n  } else if (isStartPadding) {\n    classArray.push(cellStyles.startSpacerPadding);\n    if (additionalStyles != null) {\n      classArray.push(...additionalStyles.startInteractivePaddingStyles);\n    }\n  } else {\n    classArray.push(cellStyles.startSpacerNoPadding);\n    if (additionalStyles != null) {\n      classArray.push(...additionalStyles.startInteractiveNoPaddingStyles);\n    }\n  }\n  if (isFinalColumnIndex) {\n    classArray.push(isEndPadding ? cellStyles.endSpacerPadding : cellStyles.endSpacerNoPadding);\n  } else {\n    classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);\n  }\n};\n\nconst _applySelectedColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  isFinalColumnIndex: boolean\n) => {\n  classArray.push(cellStyles.verticalSelectedGridStart);\n  classArray.push(isStartPadding\n    ? cellStyles.selectedBorderStartPadding\n    : cellStyles.selectedBorderStartNoPadding\n  );\n  if (isFinalColumnIndex) {\n    classArray.push(cellStyles.verticalSelectedGridEnd);\n    classArray.push(isEndPadding\n      ? cellStyles.selectedBorderEndPadding\n      : cellStyles.selectedBorderEndNoPadding\n    );\n  } else {\n    classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { FocusableElement } from '../../utils/PRIVATE_tabbableUtils';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: FocusableElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = <K>(element: HTMLElement) => {\n  return (\n    element.dataset['ojKeyType'] === 'number'\n      ? Number(element.dataset['ojKey'])\n      : element.dataset['ojKey']\n  ) as K;\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = <K>(\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > index) {\n    return getRowKey<K>(rowElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const index = Array.prototype.indexOf.call(rowElements, rowElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(rootElement: HTMLElement, tableId: string, rowKey: K) {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let i = 0; i < rowElements.length; i++) {\n    if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n      return i;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = <C>(element: HTMLElement) => {\n  return element.dataset['ojColumnKey'] as C;\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  if (headerElements.length > index) {\n    return getColumnKey(headerElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  const columnElements = rootElement.querySelectorAll(\n    isHeader\n      ? `[data-oj-table-header-cell='${tableId}']`\n      : `[data-oj-table-footer-cell='${tableId}']`\n  );\n  const index = Array.prototype.indexOf.call(columnElements, cellElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K extends string | number, D, C extends string>(\n  element: HTMLElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  cellSelector?: string,\n  onlyAncestors?: boolean\n): ActiveCell<K, C> | undefined {\n  const selectorString =\n    cellSelector != null ? cellSelector : `[data-oj-table-focusable='${tableId}']`;\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(selectorString) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor<K>(cellElement, `[data-oj-table-data-row='${tableId}']`)!,\n          columnKey: getColumnKey<C>(cellElement),\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return { columnKey: getColumnKey<C>(cellElement), type: cellType };\n      } else if (cellType === 'noData' || cellType === 'pending') {\n        return { type: cellType };\n      } else if (cellType === 'loading' || cellType === 'loadMore') {\n        const columnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n        if (columnKey != null) {\n          return { columnKey: columnKey, type: cellType };\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  rootElement: HTMLElement,\n  tableId: string,\n  cell: ActiveCell<K, C> | Cell<K, C>\n): HTMLElement | undefined {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'pending') {\n    // pending skeletons case\n    return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loading') {\n    // loading skeletons case\n    return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loadMore') {\n    // loadMore skeletons case\n    return rootElement.querySelector(`[data-oj-table-load-more-cell='${tableId}']`) as HTMLElement;\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (rootElement: HTMLElement, tableId: string) => {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (rootElement: HTMLElement, tableId: string) => {\n  const footerRowElement = rootElement.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const firstRowElement = rootElement.querySelector(`[data-oj-table-data-row='${tableId}']`);\n  if (firstRowElement != null) {\n    return getRowKey<K>(firstRowElement as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement) as K;\n  }\n  return undefined;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = <K extends string | number, C extends string>(\n  rootElement: HTMLElement,\n  tableId: string\n): ActiveCell<K, C> | undefined => {\n  const firstCellElement = rootElement.querySelector(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (firstCellElement != null) {\n    const firstCellType = getCellType(firstCellElement);\n    if (firstCellType === 'header' || firstCellType === 'footer') {\n      return { columnKey: getColumnKey<C>(firstCellElement), type: firstCellType };\n    } else if (firstCellType === 'noData') {\n      return { type: 'noData' };\n    }\n    return {\n      rowKey: keyExtractor<K>(firstCellElement, `[data-oj-table-data-row='${tableId}']`)!,\n      columnKey: getColumnKey<C>(firstCellElement),\n      type: 'data'\n    };\n  }\n  return undefined;\n};\n\n/**\n * Helper function to get the first or last column key.\n */\nexport const getBoundaryColumnKey = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isFirst: boolean\n) => {\n  if (columnsArray.length > 0) {\n    return isFirst ? columnsArray[0].key : columnsArray[columnsArray.length - 1].key;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the 'pending' layout cell\n */\nexport const getPendingLayoutCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to get the 'noData' cell\n */\nexport const getNoDataCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to determine if the 'loading' cell is present in the Table\n */\nexport const hasLoadingCell = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) != null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (rootElement: HTMLElement, tableId: string) => {\n  return getNoDataCellElement(rootElement, tableId) != null;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getCellType, getElementFromCell, logicalCellExtractor } from './TableDomUtils';\nimport { preventBrowserTooltipStyle } from '../themes/Table.css';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to determine if a given cell contains truncated text.\n */\nexport const hasTruncatedText = (cellElement: HTMLElement) => {\n  if (cellElement.getAttribute('data-oj-table-tooltip') !== 'enabled') {\n    return false;\n  }\n  const innerText = String(cellElement.innerText).trim();\n  if (innerText === '') {\n    return false;\n  }\n\n  const walker = document.createTreeWalker(cellElement, NodeFilter.SHOW_TEXT);\n  while (walker.nextNode()) {\n    const range = new Range();\n    const textNode = walker.currentNode;\n    range.selectNodeContents(textNode);\n    const untruncatedTextLength = range.getBoundingClientRect().width;\n\n    let firstParent = true;\n    let parentElement = textNode.parentElement;\n    while (parentElement != null) {\n      const parentStyles = getComputedStyle(parentElement);\n      if (firstParent) {\n        // only verify truncation status of 'visible' text nodes\n        if (untruncatedTextLength === 0 || parentStyles.visibility === 'hidden') {\n          break;\n        }\n        firstParent = false;\n      }\n      const padding = parseFloat(parentStyles.paddingLeft) + parseFloat(parentStyles.paddingRight);\n      const border = parseFloat(parentStyles.borderLeft) + parseFloat(parentStyles.borderRight);\n      const renderedTextLength = parentElement.getBoundingClientRect().width - padding - border;\n\n      // ensure at least 0.015px difference as browser zoom levels cause false positives due to rounding\n      // smaller than that value (0.01 for example) causes unnecessary tooltips to be shown on headers\n      // larger than that value (0.05 for example) causes actual truncation cases to be missed\n      if (untruncatedTextLength - renderedTextLength > 0.015) {\n        return true;\n      }\n      if (parentElement === cellElement) {\n        break;\n      }\n      parentElement = parentElement.parentElement;\n    }\n  }\n  return false;\n};\n\n/**\n * Helper function to handle updating the Table's tooltip due to a focus navigation gesture.\n */\nexport function handleNavigationTooltipGesture<K, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  cell: ActiveCell<K, C>,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void\n) {\n  hideTooltip(true);\n  if (cell.type === 'data' || cell.type === 'header' || cell.type === 'footer') {\n    const cellElement = getElementFromCell(rootElement, tableId, cell);\n    if (cellElement != null) {\n      showTooltip(cell);\n    }\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer move gesture.\n */\nexport function handleMoveTooltipGesture<K extends string | number, D, C extends string>(\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  event: PointerEvent,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) {\n  let tooltipShown = false;\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    return;\n  }\n  const cellElement = (event.target as HTMLElement).closest(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (cellElement != null) {\n    const type = getCellType(cellElement);\n    if (type === 'data' || type === 'header' || type === 'footer') {\n      showTooltip(logicalCellExtractor<K, D, C>(cellElement, tableId, columnsArray) as Cell<K, C>);\n      tooltipShown = true;\n    }\n  }\n  if (!tooltipShown) {\n    hideTooltip();\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer leave gesture.\n */\nexport const handleLeaveTableTooltipGesture = (\n  rootElement: HTMLDivElement,\n  event: PointerEvent,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) => {\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    // the pointer 'left' the table, but is only over a cell tooltip - in most cases, we want\n    // to just return here as the pointer is still 'over' the table. however, this can also\n    // occur when the pointer is technically outside of the table's bounds, and in that case\n    // we don't actually want to return as we should clear out our cell tooltip as expected\n    const boundingRect = rootElement.getBoundingClientRect();\n    const isOutOfBounds =\n      event.clientX < boundingRect.left ||\n      event.clientX > boundingRect.right ||\n      event.clientY < boundingRect.top ||\n      event.clientY > boundingRect.bottom;\n    if (!isOutOfBounds) {\n      return;\n    }\n  }\n  hideTooltip();\n};\n\n// Pointer Enter handler for elements that need to prevent default browser tooltips\nconst _pointerEnterHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.add(preventBrowserTooltipStyle);\n};\n\n// Pointer Leave handler for elements that need to prevent default browser tooltips\nconst _pointerLeaveHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.remove(preventBrowserTooltipStyle);\n};\n\n/*\n * Props that can be spread on elements that need to prevent default browser tooltips\n */\nexport const preventBrowserTooltipProps = {\n  onPointerEnter: _pointerEnterHandler,\n  onPointerLeave: _pointerLeaveHandler\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport {\n  CurrentRowVariant,\n  DataCellPadding,\n  DataCellTooltip,\n  TableRendererContext,\n  TableRowContext\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { getDataCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  isRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n  padding?: DataCellPadding<K, D>;\n  tooltip?: DataCellTooltip<K, D>;\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? String(rowData[field]) : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  isRowHeader,\n  stickyColumn = 'disabled',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableCellProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  const rowContext: TableRowContext<K, D> = { key: rowKey, data: rowData };\n  const columnPadding = typeof padding === 'function' ? padding(rowContext) : padding;\n  const columnTooltip = typeof tooltip === 'function' ? tooltip(rowContext) : tooltip;\n  const supportsDefaultTooltip = columnTooltip !== 'disabled';\n  const hasLastHorizontalGridline =\n    hasHorizontalGridlines && (hasMore || hasVerticalUnderflow || !hasFooters);\n\n  const cellClasses = classNames(\n    getDataCellClassArray({\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      isFirstRowIndex: rowIndex === 0,\n      isFinalRowIndex,\n      hasVerticalGridlines,\n      hasHorizontalGridlines,\n      hasLastHorizontalGridline,\n      isRowSelected,\n      isPreviousRowSelected,\n      isColumnSelected,\n      isPreviousColumnSelected,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isRowSelectionEnabled,\n      isRowSingleSelection,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      horizontalAlignment,\n      verticalAlignment,\n      variant,\n      padding: columnPadding\n    })\n  );\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={isRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelected ? { 'aria-selected': true } : {})}>\n      {renderer(cellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { tableRowStyles, tableRowStylesHC } from './themes/TableRowStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey, isSameKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K, D, C> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedRowKeys?: Keys<K>;\n  isShowFocusRing: boolean;\n  activeColumnKey?: C;\n  isTabbableMode: boolean;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K, D, C>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  activeColumnKey,\n  isTabbableMode,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  disabledInteractionKeys,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const rowStyles = isHighContrast ? tableRowStylesHC : tableRowStyles;\n  const classArray = [rowStyles.base, isFinalRow ? rowStyles.lastRowHeight : rowStyles.rowHeight];\n  const classes = classNames(classArray);\n\n  const accessibleRowName = (rowIndex + 2).toString();\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n  const selectorRenderer =\n    isRowSelectionEnabled && !isSingleRowSelectionEnabled\n      ? () => {\n          // conversion from 0-based index and adding the header row as it is always rendered\n          return (\n            <Selector\n              aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n              onChange={handleRowSelectorChange}\n              rowKey={rowKey}\n              selectedKeys={selectedRowKeys}\n            />\n          );\n        }\n      : undefined;\n\n  let isPreviousColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 2}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const isActive = columnKey === activeColumnKey;\n        const hasTabIndex = isActive && !isTabbableMode;\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.sticky,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          hasFooters: hasFooters,\n          hasVerticalUnderflow: hasVerticalUnderflow,\n          hasMore: hasMore,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isColumnSelected: isColumnSelected,\n          isPreviousColumnSelected: isPreviousColumnSelected,\n          isShowFocusRing: isShowFocusRing && isActive,\n          hasTabIndex: hasTabIndex,\n          isTabbableMode: isTabbableMode,\n          isRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          variant: variant,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          isRtl: isRtl,\n          isHighContrast: isHighContrast,\n          padding: column.value.padding,\n          tooltip: column.value.tooltip,\n          horizontalAlignment:\n            column.value.alignment?.horizontal != null\n              ? column.value.alignment.horizontal\n              : column.value.horizontalAlignment,\n          verticalAlignment: column.value.alignment?.vertical\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, any, string>[],\n  columnsArray2: TableColumn<string | number, any, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(TableRow, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.tableId === next.tableId &&\n      prev.rowKey === next.rowKey &&\n      prev.rowData === next.rowData &&\n      prev.rowIndex === next.rowIndex &&\n      prev.isFinalRow === next.isFinalRow &&\n      _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n      prev.hasHorizontalGridlines === next.hasHorizontalGridlines &&\n      prev.hasVerticalGridlines === next.hasVerticalGridlines &&\n      (!next.isFinalRow ||\n        (prev.hasFooters === next.hasFooters &&\n          prev.hasVerticalUnderflow === next.hasVerticalUnderflow &&\n          prev.hasMore === next.hasMore)) &&\n      _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n      prev.isSelected === next.isSelected &&\n      prev.isPreviousSelected === next.isPreviousSelected &&\n      prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n      prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n      (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled\n        ? isSameKey(prev.selectedRowKeys, next.selectedRowKeys)\n        : true) &&\n      isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&\n      prev.isShowFocusRing === next.isShowFocusRing &&\n      prev.activeColumnKey === next.activeColumnKey &&\n      prev.isTabbableMode === next.isTabbableMode &&\n      prev.variant === next.variant &&\n      prev.onSelectionChange === next.onSelectionChange &&\n      prev.startStickyEdge === next.startStickyEdge &&\n      prev.endStickyEdge === next.endStickyEdge &&\n      prev.isRtl === next.isRtl &&\n      prev.isHighContrast === next.isHighContrast &&\n      prev.disabledInteractionKeys === next.disabledInteractionKeys\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ComponentChildren, RefObject } from 'preact';\nimport { TableNoDataRendererContext } from '../UNSAFE_TableView';\nimport { useLayoutEffect } from 'preact/hooks';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n  columnsCount: number;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  ariaRowIndex: number;\n  renderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  rootRef,\n  tableId,\n  columnsCount,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  ariaRowIndex,\n  renderer\n}: TableNoDataProps) {\n  const browser = getClientHints().browser;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return translations.collection_noData();\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  // in firefox, table element heights are not stretched unless explicitly set in some cases\n  useLayoutEffect(() => {\n    if (browser === 'firefox') {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        const tableBodyElement = rootElement.querySelector(\n          `[data-oj-table-body='${tableId}']`\n        ) as HTMLElement;\n        const noDataElement = rootElement.querySelector(\n          `[data-oj-table-nodata-cell='${tableId}']`\n        ) as HTMLElement;\n        if (tableBodyElement != null && noDataElement != null) {\n          noDataElement.style.height = '';\n          noDataElement.style.height = `${tableBodyElement.getBoundingClientRect().height}px`;\n        }\n      }\n    }\n  });\n\n  return (\n    <tr aria-rowindex={ariaRowIndex} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n        tabIndex={hasTabIndex ? 0 : -1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        {contentRenderer({ isTabbable: isTabbableMode })}\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment, type RefObject } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { ActiveCell, TableColumn, TableData, ViewportInfo } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  CurrentRowVariant,\n  TableNoDataRendererContext,\n  TableRowContext,\n  TableSelectionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { backgroundStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K, D, C> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  isValidRender: boolean;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  tableData: TableData<K, D>[];\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  isShowFocusRing: boolean;\n  isTabbableMode: boolean;\n  hasMore: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onLoadMore: () => void;\n  activeCell?: ActiveCell<K, C>;\n  currentRowKey?: K;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K, D, C>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isValidRender,\n  getAccessibleRowHeaders,\n  tableData,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  isShowFocusRing,\n  isTabbableMode,\n  hasMore,\n  onLoadMore,\n  activeCell,\n  currentRowKey,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableBodyProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback((context: ItemContext<TableData<K, D>>) => {\n    return {\n      index: context.index,\n      data: context.data.data,\n      key: context.data.metadata\n    };\n  }, []);\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<TableData<K, D>>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsActiveCell = activeCell?.rowKey === rowKey;\n    const activeColumnKey = containsActiveCell ? activeCell.columnKey : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      hasMore: hasMore,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      disabledInteractionKeys: disabledInteractionKeys,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: currentRowKey === rowKey ? currentRowVariant : 'none',\n      isShowFocusRing: isShowFocusRing && containsActiveCell,\n      activeColumnKey: activeColumnKey,\n      isTabbableMode: isTabbableMode,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === tableData.length - 1,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    const isActive = activeCell?.type === 'noData';\n    const hasTabIndex = isActive && !isTabbableMode;\n    return {\n      rootRef: rootRef,\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isShowFocusRing: isShowFocusRing && isActive,\n      hasTabIndex: hasTabIndex,\n      isTabbableMode: isTabbableMode,\n      ariaRowIndex: isValidRender ? 2 : 1,\n      renderer: isValidRender ? noDataRenderer : undefined\n    };\n  };\n\n  const isShowEmptyLoading = tableData.length === 0 && hasMore;\n  const isShowNoData = tableData.length === 0 && !hasMore;\n  const loadMoreViewportConfig = {\n    scroller: () => viewportInfo.viewportConfig.scroller().current\n  };\n\n  return (\n    <tbody class={backgroundStyles.inherit} role={'presentation'} data-oj-table-body={tableId}>\n      {isShowNoData || !isValidRender ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <Fragment>\n          <LoadMoreCollection<TableData<K, D>>\n            data={tableData}\n            loadMoreIndicator={\n              <TableSkeletonRow\n                tableId={tableId}\n                hasTabIndex={\n                  isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore'\n                }\n                colspan={columnsArray.length}\n                isLoadMore={!isShowEmptyLoading}\n                isShowFocusRing={\n                  isShowFocusRing &&\n                  (isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore')\n                }\n                isHighContrast={isHighContrast}\n              />\n            }\n            hasMore={hasMore}\n            onLoadMore={onLoadMore}\n            viewportConfig={loadMoreViewportConfig}>\n            {collectionChildrenFunc}\n          </LoadMoreCollection>\n          <tr\n            style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n            role={'presentation'}\n            data-oj-table-spacer-row={tableId}\n          />\n        </Fragment>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport {\n  CellPadding,\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport {\n  justifyContentStyles,\n  tableHeaderCellTextStyles,\n  tableHeaderSortContainerStyles,\n  tableHeaderSortIconStyles\n} from './themes/Table.css';\nimport { tableHeaderCellStyles } from './themes/TableHeaderCellStyles.css';\nimport { getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { EmbeddedIconButton } from '../PRIVATE_EmbeddedIconButton';\nimport { SortAscendingIcon } from '../PRIVATE_ThemedIcons/SortAscendingIcon';\nimport { SortDescendingIcon } from '../PRIVATE_ThemedIcons/SortDescendingIcon';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  headerText?: string;\n  selectedRowKeys?: Keys<K>;\n  stickyTopOffset?: number;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isShowSortIcon: boolean;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  disabledInteractionKeys?: ('enter' | 'space')[];\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  headerText,\n  stickyTopOffset = 0,\n  stickyColumn = 'disabled',\n  renderer,\n  disabledInteractionKeys,\n  onSelectionChange,\n  isShowSortIcon,\n  sortable = 'disabled',\n  sortDirection,\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableHeaderCellProps<K, C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: true,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isColumnSelectionEnabled,\n      isSelected,\n      isPreviousColumnSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const iconClassArray = [tableHeaderSortIconStyles.base];\n  if (isShowSortIcon) {\n    iconClassArray.push(tableHeaderSortIconStyles.visible);\n  } else {\n    iconClassArray.push(tableHeaderSortIconStyles.hidden);\n  }\n  const iconClasses = classNames(iconClassArray);\n\n  const sortIconRenderer =\n    sortable === 'enabled' || sortDirection != null\n      ? () => (\n          <div class={iconClasses}>\n            <EmbeddedIconButton\n              aria-label={\n                sortable === 'enabled'\n                  ? translations.collection_sortEnabled()\n                  : translations.collection_sortDisabled()\n              }\n              isDisabled={sortable !== 'enabled'}\n              onAction={handleSortGesture}>\n              {sortDirection === 'descending' ? <SortDescendingIcon /> : <SortAscendingIcon />}\n            </EmbeddedIconButton>\n          </div>\n        )\n      : undefined;\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    sortControl: sortIconRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortControl }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <div class={tableHeaderCellTextStyles.base}>\n            <span class={tableHeaderCellStyles.defaultRendererSpan}>{headerText}</span>\n          </div>\n        ) : undefined;\n      if (sortControl != null) {\n        const isIconFirst =\n          horizontalAlignment === 'end' ||\n          (!isRtl && horizontalAlignment === 'right') ||\n          (isRtl && horizontalAlignment === 'left');\n\n        const containerClasses = classNames([\n          tableHeaderSortContainerStyles.base,\n          justifyContentStyles[horizontalAlignment]\n        ]);\n        return (\n          <div class={containerClasses}>\n            {isIconFirst && sortControl()}\n            {text}\n            {!isIconFirst && sortControl()}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer, horizontalAlignment, isRtl]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <th\n      aria-colindex={columnIndex + 1}\n      {...getAriaSelected()}\n      {...getAriaSort()}\n      class={cellClasses}\n      style={`top:${stickyTopOffset}px;`}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'columnheader'}\n      data-oj-cell-type={'header'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-header-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {getHeaderCellRenderer()(headerCellRendererProps)}\n    </th>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { backgroundStyles, tableHeaderRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isForceSortIcons: boolean;\n  hoverColumnKey?: C;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  stickyTopOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  isForceSortIcons,\n  hoverColumnKey,\n  sortCriterion,\n  onSortCriterionChange,\n  stickyTopOffset,\n  startStickyEdge,\n  endStickyEdge,\n  isResizeHover,\n  isRtl,\n  isHighContrast\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let isPreviousColumnSelected = false;\n  return isRendered ? (\n    <thead class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={1}\n        class={rowClasses}\n        role={'row'}\n        style={getStyle()}\n        data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const sortable = column.value.sortable;\n          const hasSortIcon = sortable === 'enabled' || sortDirection != null;\n          const isShowSortIcon =\n            hasSortIcon &&\n            (isForceSortIcons || sortDirection != null || hoverColumnKey === columnKey);\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            stickyTopOffset: stickyTopOffset,\n            stickyColumn: column.value.sticky,\n            isColumnSelectionEnabled: isColumnSelectionEnabled,\n            isSelected: isSelected,\n            isPreviousColumnSelected: isPreviousColumnSelected,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            onSelectionChange: onSelectionChange,\n            isShowSortIcon: isShowSortIcon,\n            sortable: sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.headerPadding,\n            tooltip: column.value.headerTooltip,\n            horizontalAlignment:\n              column.value.headerAlignment?.horizontal != null\n                ? column.value.headerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.headerAlignment?.vertical\n          };\n          isPreviousColumnSelected = isSelected;\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { CellPadding, TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  footerText?: string;\n  stickyBottomOffset?: number;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  disabledInteractionKeys?: ('enter' | 'space')[];\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? footerText : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  stickyBottomOffset = 0,\n  stickyColumn = 'disabled',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  disabledInteractionKeys,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableFooterCellProps<C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: false,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isColumnSelectionEnabled,\n      isSelected,\n      isPreviousColumnSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  const footerCellRendererProps = {\n    key: columnKey,\n    footerText: footerText,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      style={`bottom:${stickyBottomOffset}px;`}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {renderer(footerCellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { backgroundStyles, tableFooterRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  stickyBottomOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  dataRowCount: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedKeys,\n  isColumnSelectionEnabled,\n  disabledInteractionKeys,\n  stickyBottomOffset,\n  startStickyEdge,\n  endStickyEdge,\n  dataRowCount,\n  isRtl,\n  isHighContrast\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n\n  let isPreviousColumnSelected = false;\n  return isRendered ? (\n    <tfoot class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={Math.max(dataRowCount, 1) + 2}\n        class={rowClasses}\n        role={'row'}\n        data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSelected = containsKey(selectedKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyBottomOffset: stickyBottomOffset,\n            stickyColumn: column.value.sticky,\n            isColumnSelectionEnabled: isColumnSelectionEnabled,\n            isSelected: isSelected,\n            isPreviousColumnSelected: isPreviousColumnSelected,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.footerPadding,\n            tooltip: column.value.headerTooltip,\n            horizontalAlignment:\n              column.value.footerAlignment?.horizontal != null\n                ? column.value.footerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.footerAlignment?.vertical\n          };\n          isPreviousColumnSelected = isSelected;\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n  height?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl, height }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    const heightString = height != null ? `height:${height}px;` : '';\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;${heightString}`\n        : `left:${position}px;cursor:col-resize;${heightString}`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\nimport { Menu } from '../UNSAFE_Menu';\nimport { CellContext, TableContextMenuConfig } from '../UNSAFE_TableView';\n\nexport type Props<K extends string | number, D, C extends string> = {\n  contextMenuConfig: TableContextMenuConfig<K, D, C>;\n  contextMenuContext: CellContext<K, D, C>;\n} & Omit<ComponentProps<typeof Menu>, 'children'>;\n\n/**\n * The internal component used to render a custom context menu on the Table\n */\nexport function TableContextMenu<K extends string | number, D, C extends string>({\n  contextMenuConfig,\n  contextMenuContext,\n  ...menuProps\n}: Props<K, D, C>) {\n  const accessibleLabel = contextMenuConfig.accessibleLabel;\n  return (\n    <Menu\n      {...menuProps}\n      {...(accessibleLabel != null && {\n        'aria-label': accessibleLabel\n      })}>\n      {menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext)}\n    </Menu>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { Dispatch, MutableRef } from 'preact/hooks';\nimport { scrollerStyles } from '../themes/Table.css';\nimport { ScrollDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  ColumnWidths,\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition,\n  TableViewportConfig\n} from '../../UNSAFE_TableView';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  scrollbarWidth: number,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && fullColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n\n    if (viewportInfo.isExternalScroller) {\n      const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n      if (scrollerOffsetStart != null) {\n        startOffset = scrollerOffsetStart;\n      }\n      const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n      if (scrollerOffsetEnd != null) {\n        endOffset = scrollerOffsetEnd;\n      }\n    }\n\n    const stickyColumns = getStickyColumnIndicies(columnsArray);\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  rootElement: HTMLDivElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  let topOffset = 0;\n  let bottomOffset = 0;\n\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetTop = viewportInfo.viewportConfig.scrollerOffsetTop;\n    if (scrollerOffsetTop != null) {\n      topOffset = scrollerOffsetTop;\n    }\n    const scrollerOffsetBottom = viewportInfo.viewportConfig.scrollerOffsetBottom;\n    if (scrollerOffsetBottom != null) {\n      bottomOffset = scrollerOffsetBottom;\n    }\n  }\n  topOffset += getScrollerTopOffset(rootElement, tableId);\n  bottomOffset += getScrollerBottomOffset(rootElement, tableId);\n\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    topOffset,\n    bottomOffset,\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    scrollerElement,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  scrollerElement.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(\n    rootElement,\n    scrollerElement,\n    tableId,\n    verticalScrollPosition\n  );\n  scrollerElement.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.sticky !== 'enabled') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(rootElement, scrollerElement, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? scrollerElement.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky !== 'enabled') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft < columnEnd) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? scrollerElement.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, 0)!;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, i)!;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      rootElement,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        rowElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.locationY\n      );\n    }\n  }\n  if (\n    scrollDetail.cell.type === 'data' ||\n    scrollDetail.cell.type === 'header' ||\n    scrollDetail.cell.type === 'footer'\n  ) {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationX != null && !sizingInfo.isInitialRender) {\n      const scrollbarWidth = sizingInfo.boxWidth - sizingInfo.contentWidth;\n      _scrollColumnIntoView(\n        cellElement,\n        scrollerElement,\n        viewportInfo,\n        columnsArray,\n        scrollbarWidth,\n        isRtl,\n        fullColumnWidths,\n        scrollDetail.locationX\n      );\n    }\n  }\n  if (scrollDetail.cell.type === 'loadMore' || scrollDetail.cell.type === 'loading') {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        cellElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.cell.type === 'loading' && scrollDetail.locationY === 'inView'\n          ? 'top'\n          : scrollDetail.locationY\n      );\n    }\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  isHorizontalScroll: boolean\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n    if (scrollerOffsetStart != null) {\n      stickyStartOffset = scrollerOffsetStart;\n    }\n    const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n    if (scrollerOffsetEnd != null) {\n      stickyEndOffset = scrollerOffsetEnd;\n    }\n  }\n\n  const fullColumnWidths = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const width = appliedColumnWidths[columnsArray[i].key];\n    fullColumnWidths.push(width);\n  }\n\n  const stickyIndicies = getStickyColumnIndicies(columnsArray);\n  for (let i = 0; i < stickyIndicies.length; i++) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  for (let i = stickyIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n\n  // only apply sticky edge styling if horizontal overflow is present\n  if (isHorizontalScroll) {\n    updateStickyEdges(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      stickyEdgesState,\n      setStickyEdgesState\n    );\n  } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n    setStickyEdgesState({});\n  }\n}\n\n/**\n * Helper function to get the sticky column indicies.\n */\nexport const getStickyColumnIndicies = <K, D, C>(columnsArray: TableColumn<K, D, C>[]) => {\n  const stickyColumns = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky === 'enabled') {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  scrollLeft?: number\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    const stickyIndicies = getStickyColumnIndicies(columnsArray);\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      for (i = 0; i < stickyIndicies.length; i++) {\n        const currentIndex = stickyIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = scrollerElement.scrollWidth - scrollerElement.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {\n      setStickyEdgesState({ start: startIndex, end: endIndex });\n    }\n  }\n}\n\n/**\n * Helper function to hide a currently shown tooltip once the anchor cell scrolls out of view.\n */\nexport function hideOutOfViewTooltip<K, C, D>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  sizingInfo: SizingInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>,\n  hideTooltip: (isImmediate?: boolean) => void,\n  isRtl: boolean\n) {\n  if (tooltipAnchorRef.current != null) {\n    const verticalOverflowDiff = _getVerticalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      getScrollerTopOffset(rootElement, tableId),\n      getScrollerBottomOffset(rootElement, tableId),\n      sizingInfo.boxHeight! - sizingInfo.contentHeight!\n    );\n    const topOverflowDiff = verticalOverflowDiff.top;\n    const hasTopOverflow = topOverflowDiff >= 0;\n    const bottomOverflowDiff = verticalOverflowDiff.bottom;\n    const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n    if (\n      (hasTopOverflow && Math.abs(topOverflowDiff) > tooltipAnchorRef.current.offsetHeight) ||\n      (hasBottomOverflow && Math.abs(bottomOverflowDiff) > tooltipAnchorRef.current.offsetHeight)\n    ) {\n      hideTooltip(true);\n      return;\n    }\n\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyColumns = getStickyColumnIndicies(columnsArray);\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      startOffset += fullColumnWidths[stickyIndex];\n    }\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      endOffset += fullColumnWidths[stickyIndex];\n    }\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    if (\n      (hasLeftOverflow && Math.abs(leftOverflowDiff) > tooltipAnchorRef.current.offsetWidth) ||\n      (hasRightOverflow && Math.abs(rightOverflowDiff) > tooltipAnchorRef.current.offsetWidth)\n    ) {\n      hideTooltip(true);\n    }\n  }\n}\n\n/**\n * Helper function to reset the scroll position of the scroller element\n */\nexport const resetVerticalScrollPosition = (scrollerElement: HTMLElement) => {\n  scrollerElement.scrollTop = 0;\n};\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (\n  scrollerRef: RefObject<HTMLElement>,\n  config?: TableViewportConfig\n) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return scrollerRef;\n      }\n    }\n  );\n};\n\n/**\n * Helper function to update the scroller element's styling based on overflow status.\n */\nexport const applyOverflowStatus = (\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  contentWidth: number,\n  availableWidth: number,\n  contentHeight: number,\n  availableHeight: number,\n  scrollbarWidth: number,\n  overflowRef: MutableRef<{ isHorizontal: boolean; isVertical: boolean }>,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  // check for at least 0.5px difference to account for browser rounding issues\n  const hasHorizontalOverflow = contentWidth - availableWidth > 0.5;\n  const hasVerticalOverflow = contentHeight - availableHeight > 0.5;\n  if (hasHorizontalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noHorizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.horizontalScroll);\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.horizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.noHorizontalScroll);\n  }\n  if (hasVerticalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noVerticalScroll);\n    scrollerElement.classList.add(scrollerStyles.verticalScroll);\n    scrollerElement.style.paddingInlineEnd = '';\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.verticalScroll);\n    scrollerElement.classList.add(scrollerStyles.noVerticalScroll);\n    scrollerElement.style.paddingInlineEnd = `${scrollbarWidth}px`;\n  }\n  overflowRef.current.isHorizontal = hasHorizontalOverflow;\n  overflowRef.current.isVertical = hasVerticalOverflow;\n  applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n};\n\n/**\n * Helper function to update the undeflow status of the Table based on the spacer element sizing.\n */\nexport const applyUnderflowStatus = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  const spacerRowElement = rootElement.querySelector(\n    `[data-oj-table-spacer-row='${tableId}']`\n  ) as HTMLElement;\n  if (spacerRowElement != null) {\n    setHasVerticalUnderflow(spacerRowElement.offsetHeight > 0);\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getBoundaryColumnKey, getElementFromCell } from './TableDomUtils';\nimport { applyScrollDetail, resetVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport { Cell, CellContext, CellOverride } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to determine if a given active cell represents a 'transient' state.\n */\nexport function isTransientCell<K, C>(activeCell?: ActiveCell<K, C>) {\n  return (\n    activeCell != null &&\n    (activeCell.type === 'loadMore' ||\n      activeCell.type === 'loading' ||\n      activeCell.type === 'pending')\n  );\n}\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(\n  cell1?: ActiveCell<K, C> | Cell<K, C>,\n  cell2?: ActiveCell<K, C> | Cell<K, C>\n) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  if (cell1.type === cell2.type && cell1.rowKey === cell2.rowKey) {\n    // special case the transient 'loading' cell types as column keys are hints used for when a user\n    // navigates back to another region using the keyboard - otherwise we'd go to the first column\n    if (cell1.type === 'loading' || cell1.type === 'loadMore' || cell1.type === 'pending') {\n      return true;\n    }\n    return cell1.columnKey === cell2.columnKey;\n  }\n  return false;\n}\n\nexport function getCellContextFromCell<K extends string | number, D, C extends string>(\n  tableData: TableData<K, D>[],\n  cell?: ActiveCell<K, C>\n) {\n  if (cell?.type === 'data') {\n    for (const rowData of tableData) {\n      if (rowData.metadata === cell.rowKey) {\n        return {\n          rowData: rowData.data,\n          rowKey: cell.rowKey,\n          columnKey: cell.columnKey,\n          type: 'data'\n        } as CellContext<K, D, C>;\n      }\n    }\n  } else if (cell?.type === 'header' || cell?.type === 'footer') {\n    return {\n      columnKey: cell.columnKey,\n      type: cell.type\n    } as CellContext<K, D, C>;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to determine the resulting cell from a cell override.\n */\nfunction _getCellFromCellOverride<K, D, C>(\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n): Cell<K, C> | undefined {\n  let cellType;\n  let cellRowKey;\n  let cellColumnKey;\n  if (cellOverride.rowKey != null) {\n    cellType = 'data';\n    cellRowKey = cellOverride.rowKey;\n    if (cellOverride.columnKey != null) {\n      cellColumnKey = cellOverride.columnKey;\n    } else if (currentCell?.columnKey != null) {\n      cellColumnKey = currentCell.columnKey;\n    } else {\n      cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n    }\n    if (cellColumnKey == null) {\n      return undefined;\n    }\n  } else if (cellOverride.columnKey != null) {\n    cellColumnKey = cellOverride.columnKey;\n    if (cellOverride.type != null) {\n      cellType = cellOverride.type;\n    } else if (currentCell?.type != null && currentCell.type !== 'noData') {\n      cellType = currentCell.type;\n    } else {\n      cellType = 'header';\n    }\n    if (cellType === 'data') {\n      if (currentCell?.rowKey != null) {\n        cellRowKey = currentCell.rowKey;\n      } else if (tableData.length > 0) {\n        cellRowKey = tableData[0].metadata;\n      }\n      if (cellRowKey == null) {\n        return undefined;\n      }\n    }\n  } else if (cellOverride.type != null) {\n    cellType = cellOverride.type;\n    if (cellType !== 'noData') {\n      if (currentCell?.columnKey != null) {\n        cellColumnKey = currentCell.columnKey;\n      } else {\n        cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n      }\n      if (cellColumnKey == null) {\n        return undefined;\n      }\n      if (cellType === 'data') {\n        if (currentCell?.rowKey != null) {\n          cellRowKey = currentCell.rowKey;\n        } else if (tableData.length > 0) {\n          cellRowKey = tableData[0].metadata;\n        }\n        if (cellRowKey == null) {\n          return undefined;\n        }\n      }\n    }\n  } else {\n    return undefined;\n  }\n  return { type: cellType, rowKey: cellRowKey, columnKey: cellColumnKey } as Cell<K, C>;\n}\n\n/**\n * Helper function to determine the resulting cell type from a cell override.\n */\nfunction _getCellTypeFromCellOverride<K, C>(\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n) {\n  if (cellOverride.type != null) {\n    return cellOverride.type;\n  }\n  if (cellOverride.rowKey != null) {\n    return 'data';\n  }\n  // if no type or rowKey was given, a columnKey must have been given\n  if (currentCell?.type != null && currentCell.type !== 'noData') {\n    return currentCell.type;\n  }\n  return 'header';\n}\n\n/**\n * Helper function to apply a current cell override if necessary.\n */\nexport function applyCurrentCellOverride<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isEmbeddedSelect: boolean,\n  isPendingLayout: boolean,\n  isDataLoaded: boolean,\n  isRtl: boolean,\n  currentCellOverride?: CellOverride<K, C>,\n  fullColumnWidths?: number[]\n) {\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  // ensure any new currentCellOverride settings are applied if necessary\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (realizedCell != null) {\n        // override cell was determined - apply the override immediately\n        onActiveCellChanged({ value: realizedCell });\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        if (isEmbeddedSelect) {\n          // scroll 'current-cell-override' vertically into view immediately for embedded select\n          // otherwise, cell will be scrolled into view once the component or cell receives focus\n          if (!isPendingLayout && getElementFromCell(rootElement, tableId, realizedCell) != null) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              viewportInfo,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: realizedCell, locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          } else if (isPendingLayout || !isDataLoaded) {\n            // corresponding element was not found - data is not ready for scrolling\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = true;\n          } else {\n            // corresponding element was not found - value was garbage\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          }\n        } else {\n          // not in an embedded select, so no scrolling should be performed\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        }\n      } else if (!isDataLoaded) {\n        // override cell could not be determined - data is still fetching\n        currencyStatusRef.current.hasPendingCurrentCellOverride = true;\n      } else {\n        // override cell could not be determined - value was garbage\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // override is set to clear the current cell\n      onActiveCellChanged({ value: currentCellOverride });\n      currencyStatusRef.current.currentCellOverride = currentCellOverride;\n      currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n      if (isEmbeddedSelect) {\n        // scroll back to the top for embedded select\n        resetVerticalScrollPosition(scrollerElement);\n      }\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  } else if (currencyStatusRef.current.hasPendingCurrentCellOverrideScroll) {\n    // try and apply any pending scroll from a previous cell override at this time\n    if (currencyStatusRef.current.currentCell != null) {\n      if (\n        !isPendingLayout &&\n        getElementFromCell(rootElement, tableId, currencyStatusRef.current.currentCell) != null\n      ) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: currencyStatusRef.current.currentCell, locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      } else if (!isPendingLayout && isDataLoaded) {\n        // corresponding element was not found - value was garbage\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // there is no longer a current cell to try and scroll to\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  }\n}\n\n/**\n * Helper to determine if the given render state includes the cell specified.\n */\nfunction _renderIncludesCell<K, D, C>(\n  cell: ActiveCell<K, C>,\n  columnsArray: TableColumn<K, D, C>[],\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  hasFooters: boolean\n) {\n  // pending layout is special as other regions exist, but are not yet navigable\n  if (isPendingLayout) {\n    return cell.type === 'pending';\n  }\n  if (cell.type === 'header' || (hasFooters && cell.type === 'footer')) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === cell.columnKey) {\n        return true;\n      }\n    }\n  } else if (tableData.length > 0) {\n    if (cell.type === 'loadMore') {\n      return hasMore;\n    }\n    if (cell.type === 'data') {\n      let isColumnValid = false;\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (columnsArray[i].key === cell.columnKey) {\n          isColumnValid = true;\n          break;\n        }\n      }\n      if (isColumnValid) {\n        for (let i = 0; i < tableData.length; i++) {\n          if (tableData[i].metadata === cell.rowKey) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    return (cell.type === 'loading' && hasMore) || (cell.type === 'noData' && !hasMore);\n  }\n  return false;\n}\n\n/**\n * Helper to get the cell that should currently be a tab stop for the given render state.\n */\nexport function determineActiveCell<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  isEmbeddedSelect: boolean,\n  hasFooters: boolean,\n  currentCellOverride?: CellOverride<K, C>\n): ActiveCell<K, C> | undefined {\n  if (isPendingLayout) {\n    return { type: 'pending' };\n  }\n  // if no columns are specified, it is a special case 'noData' display\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return { type: 'noData' };\n  }\n  // if nothing specifies where focus should go, use the first header cell\n  const defaultFirstCell: ActiveCell<K, C> = {\n    type: 'header',\n    columnKey: firstColumnKey\n  };\n\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (\n        realizedCell != null &&\n        _renderIncludesCell(\n          realizedCell,\n          columnsArray,\n          tableData,\n          hasMore,\n          isPendingLayout,\n          hasFooters\n        )\n      ) {\n        return realizedCell;\n      }\n      // if here, the resulting cell from the override could not be determined or was not valid\n      const overrideCellType = _getCellTypeFromCellOverride(currentCellOverride, currentCell);\n      if (overrideCellType === 'data') {\n        if (tableData.length === 0 && hasMore) {\n          // pending 'data' override when 'loading' skeletons are shown\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        }\n      } else if (overrideCellType === 'noData' && tableData.length === 0 && hasMore) {\n        // pending 'noData' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell?.columnKey as C };\n      }\n    } else if (\n      _renderIncludesCell(\n        defaultFirstCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return defaultFirstCell;\n    } else {\n      return undefined;\n    }\n  }\n\n  // if here, there is no current cell override that can be applied during this render\n  const activeCell = currencyStatusRef.current.activeCell;\n  if (activeCell != null) {\n    if (activeCell.type === 'loadMore') {\n      const initialData = currencyStatusRef.current.loadMoreInitialData;\n      // if loadMore skeletons are no longer shown, or the data has changed, shift to\n      // the next row in the data set if possible - otherwise just the closest row\n      if (tableData.length > 0 && tableData !== initialData) {\n        const rowKey =\n          initialData != null && tableData.length > initialData.length\n            ? tableData[initialData.length].metadata\n            : tableData[tableData.length - 1].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else if (tableData.length === 0) {\n        if (hasMore) {\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        } else {\n          return { type: 'noData' };\n        }\n      }\n    }\n    if (\n      _renderIncludesCell(activeCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n    ) {\n      return activeCell;\n    } else if (activeCell.type === 'loading') {\n      if (currentCell != null && (currentCell.type === 'data' || currentCell.type === 'noData')) {\n        // if the current cell is already set to 'data' or 'noData', and is now available, return it\n        if (\n          _renderIncludesCell(\n            currentCell,\n            columnsArray,\n            tableData,\n            hasMore,\n            isPendingLayout,\n            hasFooters\n          )\n        ) {\n          return currentCell;\n        }\n      }\n      // otherwise, find the first row if available, and try and maintain the columnKey\n      if (tableData.length > 0) {\n        const rowKey = tableData[0].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else {\n        return { type: 'noData' };\n      }\n    }\n  }\n\n  // if here, there is no active cell, or the active cell is no longer valid\n  if (currentCell != null) {\n    if (\n      _renderIncludesCell(\n        currentCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return currentCell;\n    }\n    if (currentCell.type === 'data') {\n      if (tableData.length === 0 && hasMore) {\n        // pending 'data' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell.columnKey };\n      }\n    } else if (currentCell.type === 'noData' && tableData.length === 0 && hasMore) {\n      // pending 'noData' override when 'loading' skeletons are shown\n      return { type: 'loading', columnKey: firstColumnKey };\n    }\n  }\n  if (\n    _renderIncludesCell(\n      defaultFirstCell,\n      columnsArray,\n      tableData,\n      hasMore,\n      isPendingLayout,\n      hasFooters\n    )\n  ) {\n    return defaultFirstCell;\n  }\n  return undefined;\n}\n","import { ComponentProps } from 'preact';\nimport { useCallback, useState, useRef } from 'preact/hooks';\nimport { Menu } from '../../UNSAFE_Menu';\nimport { CellContext, TableContextMenuConfig } from '../../UNSAFE_TableView';\nimport { useContextMenuGesture } from '../../hooks/UNSAFE_useContextMenuGesture';\nimport { ActiveCell, TableData } from '../Table';\nimport { getCellContextFromCell } from '../utils/TableFocusUtils';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 2\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst _initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\nexport const useContextMenu = <K extends string | number, D, C extends string>(\n  tableId: string,\n  tableData: TableData<K, D>[],\n  activeCell?: ActiveCell<K, C>,\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>\n) => {\n  const [contextMenuContext, setContextMenuContext] = useState<CellContext<K, D, C>>();\n  const [menuProps, setMenuProps] = useState<MenuProps>(_initialMenuProps);\n  const currentCellElementRef = useRef<HTMLElement>();\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      if (activeCell != null) {\n        const cellContext = getCellContextFromCell<K, D, C>(tableData, activeCell);\n        if (cellContext != null) {\n          // find the cell element the menu is being launched from\n          const cellElement = (target as HTMLElement).closest(\n            `[data-oj-table-focusable='${tableId}']`\n          ) as HTMLElement;\n          if (cellElement != null) {\n            currentCellElementRef.current = cellElement;\n            const anchorBasedOnGesture = gesture === 'keyboard' ? cellElement : anchor;\n            setContextMenuContext(cellContext);\n            setMenuProps({\n              ...menuPropGestureStates[gesture],\n              anchorRef: { current: anchorBasedOnGesture },\n              isOpen: true\n            });\n          }\n        }\n      }\n    },\n    {\n      isDisabled: !contextMenuConfig\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      // set focus back on the cell that was determined as the initial target\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        currentCellElementRef.current?.focus({ preventScroll: true });\n      }\n      // close the menu\n      setMenuProps({ ..._initialMenuProps });\n    },\n    []\n  );\n\n  return {\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    onClose: handleCloseContextMenu,\n    contextMenuContext: contextMenuContext,\n    contextMenuTriggerProps: triggerProps\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\nimport { useId } from '../../hooks/UNSAFE_useId';\nimport { useColorScheme } from '../../hooks/UNSAFE_useColorScheme';\nimport { useScale } from '../../hooks/UNSAFE_useScale';\nimport { TooltipContent } from '../../hooks/UNSAFE_useTooltip/TooltipContent';\nimport {\n  getGlobalTooltipManager,\n  getWrappedTooltipContent,\n  SHOW_TOOLTIP_DELAY,\n  HIDE_TOOLTIP_DELAY\n} from '../../utils/PRIVATE_tooltipUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { cellComparator } from '../utils/TableFocusUtils';\nimport { hasTruncatedText } from '../utils/TableTooltipUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\ntype UseTruncationTooltipOptions = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n};\n\n// delay small interaction times concerning a tooltip\nconst SMALL_INTERACTION_DELAY = 50;\nconst TABLE_HIDE_TOOLTIP_DELAY = Math.max(\n  Math.min(SHOW_TOOLTIP_DELAY - SMALL_INTERACTION_DELAY, HIDE_TOOLTIP_DELAY),\n  0\n);\n\n/**\n * Hook that manages cell template tooltip interactions on the Table when truncation is present.\n */\nexport function useTruncationTooltip<K, C>({ rootRef, tableId }: UseTruncationTooltipOptions) {\n  const globalTooltipManager = getGlobalTooltipManager();\n\n  const tooltipId = useId();\n\n  const tooltipCellRef = useRef<Cell<K, C>>();\n  const pendingShowTooltipCellRef = useRef<Cell<K, C>>();\n  const tooltipAnchorRef = useRef<HTMLElement>();\n  const tooltipTextRef = useRef<string>();\n  const [tooltipText, setTooltipText] = useState<string>();\n\n  const pointerDownRef = useRef<boolean>(false);\n  const pointerDownTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const showTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  // helper method for clearing the hide tooltip timeout\n  const _clearHideTooltipTimeout = useCallback(() => {\n    clearTimeout(hideTooltipTimeoutRef.current);\n    hideTooltipTimeoutRef.current = undefined;\n  }, []);\n\n  // helper method for clearing the show tooltip timeout\n  const _clearShowTooltipTimeout = useCallback(() => {\n    clearTimeout(showTooltipTimeoutRef.current);\n    showTooltipTimeoutRef.current = undefined;\n    pendingShowTooltipCellRef.current = undefined;\n  }, []);\n\n  // helper method for setting up the show tooltip timeout\n  const _setupShowTooltipTimeout = useCallback(() => {\n    showTooltipTimeoutRef.current = setTimeout(function () {\n      // when showing a tooltip, clear any pending 'clear tooltip timeouts'\n      if (hideTooltipTimeoutRef.current != null) {\n        _clearHideTooltipTimeout();\n      }\n      showTooltipTimeoutRef.current = undefined;\n      const cell = pendingShowTooltipCellRef.current;\n      const rootElement = rootRef.current;\n      if (rootElement != null && cell != null) {\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null && hasTruncatedText(cellElement)) {\n          setTooltipText(String(cellElement.innerText).trim());\n          tooltipAnchorRef.current = cellElement;\n          tooltipCellRef.current = cell;\n        }\n      }\n      pendingShowTooltipCellRef.current = undefined;\n    }, SHOW_TOOLTIP_DELAY);\n  }, [rootRef, tableId, _clearHideTooltipTimeout]);\n\n  // helper method for setting up the hide tooltip timeout\n  const _setupHideTooltipTimeout = useCallback(() => {\n    hideTooltipTimeoutRef.current = setTimeout(function () {\n      // unlike in the showtooltip timeout logic, we do not want to clear\n      // pending show tooltip timeouts when clearing a tooltip as it could\n      // still be waiting to be shown in another location at this time\n      hideTooltipTimeoutRef.current = undefined;\n      setTooltipText(undefined);\n      tooltipAnchorRef.current = undefined;\n      tooltipCellRef.current = undefined;\n    }, TABLE_HIDE_TOOLTIP_DELAY);\n  }, []);\n\n  // callback method to signal a tooltip is desired on the given cell\n  const showTooltip = useCallback(\n    (anchorCell: Cell<K, C>) => {\n      if (cellComparator(tooltipCellRef.current, anchorCell)) {\n        // if the tooltip is already showing in the right cell, clear all timeouts\n        if (showTooltipTimeoutRef.current != null) {\n          _clearShowTooltipTimeout();\n        }\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        return;\n      }\n      if (showTooltipTimeoutRef.current == null) {\n        // if no tooltip is already pending, start a new tooltip timeout\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      } else if (!cellComparator(pendingShowTooltipCellRef.current, anchorCell)) {\n        // if a different tooltip is already pending, start a new tooltip timeout\n        _clearShowTooltipTimeout();\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      }\n      if (tooltipCellRef.current != null && hideTooltipTimeoutRef.current == null) {\n        // if the tooltip is showing on a different cell, ensure a hide timeout is setup\n        _setupHideTooltipTimeout();\n      }\n    },\n    [\n      _setupShowTooltipTimeout,\n      _setupHideTooltipTimeout,\n      _clearShowTooltipTimeout,\n      _clearHideTooltipTimeout\n    ]\n  );\n\n  // callback method to signal the current tooltip is no longer desired\n  const hideTooltip = useCallback(\n    (isImmediate?: boolean) => {\n      // ignore hide tooltip calls if due to focus loss from a pointer down on the tooltip itself\n      if (pointerDownRef.current) {\n        return;\n      }\n      if (showTooltipTimeoutRef.current != null) {\n        _clearShowTooltipTimeout();\n      }\n      if (isImmediate) {\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        setTooltipText(undefined);\n        tooltipAnchorRef.current = undefined;\n        tooltipCellRef.current = undefined;\n      } else if (hideTooltipTimeoutRef.current == null) {\n        _setupHideTooltipTimeout();\n      }\n    },\n    [_setupHideTooltipTimeout, _clearShowTooltipTimeout, _clearHideTooltipTimeout]\n  );\n\n  // Pointer move handler for the tooltip.\n  const _pointerMoveHandler = useCallback((_event: PointerEvent) => {\n    if (showTooltipTimeoutRef.current != null) {\n      clearTimeout(showTooltipTimeoutRef.current);\n      showTooltipTimeoutRef.current = undefined;\n      pendingShowTooltipCellRef.current = undefined;\n    }\n    if (hideTooltipTimeoutRef.current != null) {\n      clearTimeout(hideTooltipTimeoutRef.current);\n      hideTooltipTimeoutRef.current = undefined;\n    }\n  }, []);\n\n  // Pointer leave handler for the tooltip.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const targetElement = event.relatedTarget as HTMLElement;\n      if (targetElement != null && targetElement.closest(`#${tableId}`) != null) {\n        return;\n      }\n      hideTooltip();\n    },\n    [tableId, hideTooltip]\n  );\n\n  // Pointer down handler for the tooltip.\n  const _pointerDownHandler = useCallback((_event: PointerEvent) => {\n    pointerDownRef.current = true;\n    if (pointerDownTimeoutRef.current != null) {\n      clearTimeout(pointerDownTimeoutRef.current);\n    }\n    pointerDownTimeoutRef.current = setTimeout(function () {\n      pointerDownRef.current = false;\n      pointerDownTimeoutRef.current = undefined;\n    }, SMALL_INTERACTION_DELAY);\n  }, []);\n\n  // handles logic involving competing tooltips managed outside of the TableView.\n  // make sure this check runs BEFORE the rendered content is created below\n  const isOpenOverrideRef = useRef<boolean>(true);\n  if (tooltipText != null && tooltipText !== tooltipTextRef.current) {\n    isOpenOverrideRef.current = true;\n  }\n\n  const tooltipPointerProps = {\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler\n  };\n\n  // avoid applying undefined text after initial render completes as it can appear\n  // while the tooltip is going through its closing animation and looks broken\n  const renderRawContent = (\n    <TooltipContent\n      {...tooltipPointerProps}\n      id={tooltipId}\n      isOpen={isOpenOverrideRef.current}\n      isDatatip={false}>\n      {tooltipText != null ? tooltipText : tooltipTextRef.current}\n    </TooltipContent>\n  );\n\n  // make sure these are in sync AFTER the rendered content is created above - this helps ensure\n  // that empty text does not show up while the tooltip is going through a closing animation.\n  tooltipTextRef.current = tooltipText;\n\n  // offsets attempt to show the tooltip without overlapping content of nearby cells\n  const scale = useScale();\n  let mainAxisOffset = -8;\n  let crossAxisOffset = -14;\n  if (scale === 'md') {\n    mainAxisOffset = -7;\n    crossAxisOffset = -12;\n  } else if (scale === 'sm') {\n    mainAxisOffset = -6;\n    crossAxisOffset = -11;\n  }\n  const currentColorScheme = useColorScheme();\n  const tooltipContent =\n    tooltipAnchorRef.current != null\n      ? getWrappedTooltipContent(\n          renderRawContent,\n          'tooltip',\n          currentColorScheme,\n          tooltipAnchorRef as RefObject<HTMLElement>,\n          'end-top',\n          { mainAxis: mainAxisOffset, crossAxis: crossAxisOffset }\n        )\n      : undefined;\n\n  const destroyCallback = useCallback(() => {\n    hideTooltip(true);\n  }, [hideTooltip]);\n\n  useEffect(() => {\n    if (isOpenOverrideRef.current && tooltipAnchorRef.current != null) {\n      globalTooltipManager.register(destroyCallback);\n    } else {\n      globalTooltipManager.unregister(destroyCallback);\n    }\n  }, [tooltipAnchorRef, destroyCallback, tooltipText, globalTooltipManager]);\n\n  return { tooltipContent, tooltipId, showTooltip, hideTooltip, tooltipAnchorRef };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState, MutableRef } from 'preact/hooks';\nimport {\n  getElementContainsFunc,\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../../utils/PRIVATE_collectionUtils';\nimport {\n  FocusableElement,\n  allTabbableElements,\n  getActiveElement,\n  getBodyElement,\n  isTabbableElement\n} from '../../utils/PRIVATE_tabbableUtils';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getCellType, getElementFromCell, logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  applyCurrentCellOverride,\n  cellComparator,\n  determineActiveCell,\n  isTransientCell\n} from '../utils/TableFocusUtils';\nimport { applyScrollDetail } from '../utils/TableScrollUtils';\nimport { handleNavigationTooltipGesture } from '../utils/TableTooltipUtils';\nimport { Cell, CellOverride, CurrentCellDetail } from '../../UNSAFE_TableView';\n\ntype UseFocusHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  cellSupportsTabbable: (cell: ActiveCell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isEmbeddedSelect: boolean;\n  isDataLoaded: boolean;\n};\n\n// constant timeout values for delays following a input gesture until enabling focus rings\nconst MOUSE_FOCUS_SHIFT_TIMEOUT = 100;\nconst TOUCH_FOCUS_SHIFT_TIMEOUT = 200;\n\n// constant event.key values that trigger focus ring logic\nconst NAVIGATION_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape',\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End',\n  'PageUp',\n  'PageDown'\n];\n\n// constant event.key values that trigger 'scroll to current' logic\nconst SCROLL_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape'\n];\n\n/**\n * Hook that manages focus interactions on the Preact Table\n */\nexport function useFocusHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isRtl,\n  tableData,\n  hasMore,\n  hasFooters,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  cellSupportsTabbable,\n  fullColumnWidths,\n  currentCellOverride,\n  onPersistCurrentCell,\n  showTooltip,\n  hideTooltip,\n  isPendingLayout,\n  isEmbeddedSelect,\n  isDataLoaded\n}: UseFocusHandlingProps<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // tracks focus loss during render cycle for potential focus recapture cases\n  const isRenderCycle = useRef<boolean>(true);\n  isRenderCycle.current = true;\n  const blurredRenderCycleElementRef = useRef<FocusableElement | null>(null);\n  const isPendingLayoutFocusRef = useRef<boolean>(false);\n\n  // track current 'focus info' state\n  const hasFocusRef = useRef<boolean>(false);\n  const [isTabbableMode, setIsTabbableMode] = useState<boolean>(false);\n  const [isShowFocusRing, setIsShowFocusRing] = useState<boolean>(false);\n\n  // track pointer down information\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isShowFocusRingOverrideRef = useRef<boolean | null>(null);\n\n  // track the active and current cell information\n  const [activeCell, setActiveCell] = useState<ActiveCell<K, C> | undefined>(undefined);\n  const currencyStatusRef = useRef<CurrencyStatus<K, D, C>>({\n    hasPendingCurrentCellOverride: false,\n    hasPendingCurrentCellOverrideScroll: false\n  });\n\n  const currentActiveCell = determineActiveCell<K, D, C>(\n    columnsArray,\n    currencyStatusRef,\n    tableData,\n    hasMore,\n    isPendingLayout,\n    isEmbeddedSelect,\n    hasFooters,\n    currentCellOverride\n  );\n\n  // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately\n  const onActiveCellChanged = useMemo(() => {\n    return (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => {\n      const newActiveCell = detail.value;\n      if (!cellComparator(currencyStatusRef.current.activeCell, newActiveCell)) {\n        setActiveCell(newActiveCell);\n        currencyStatusRef.current.activeCell = newActiveCell;\n        if (!isTransientCell(newActiveCell)) {\n          const newCurrentCell = newActiveCell as Cell<K, C>;\n          // only update current cell when 'active' is not one of the transient 'skeleton' regions\n          if (onPersistCurrentCell != null) {\n            onPersistCurrentCell({ value: newCurrentCell });\n          }\n          currencyStatusRef.current.currentCell = newCurrentCell;\n\n          // make sure pending current cell override states are updated on current changed\n          if (newCurrentCell != null) {\n            currencyStatusRef.current.previousEmbeddedSelectCurrentCell = newCurrentCell;\n          }\n          currencyStatusRef.current.currentCellOverride = currentCellOverride;\n          currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        } else if (newActiveCell?.type === 'loadMore') {\n          currencyStatusRef.current.loadMoreInitialData = tableData;\n        }\n        if (!isSelectionExtension) {\n          selectionExtensionElementRef.current = undefined;\n        }\n      }\n    };\n  }, [currentCellOverride, tableData, onPersistCurrentCell, selectionExtensionElementRef]);\n\n  // Helper function to set the Table's focus tracking state to reflect that it is inactive.\n  const _setAsInactive = useCallback(() => {\n    hasFocusRef.current = false;\n    isPendingLayoutFocusRef.current = false;\n\n    setIsTabbableMode(false);\n    setIsShowFocusRing(false);\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Helper function to set the Table's focus tracking state to reflect that one of its cells has focus.\n  const _enableNavigationMode = useCallback(\n    (cell: ActiveCell<K, C>, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(false);\n        const focusRingState =\n          isShowFocusRingOverrideRef.current !== null\n            ? isShowFocusRingOverrideRef.current\n            : !recentPointerRef.current;\n        setIsShowFocusRing(focusRingState);\n        if (focusRingState) {\n          handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip);\n        }\n        if (!recentPointerRef.current && !skipScrollCellIntoView) {\n          applyScrollDetail(\n            rootElement,\n            scrollerElement,\n            viewportInfo,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: cell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n        onActiveCellChanged({ value: cell });\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths,\n      showTooltip,\n      hideTooltip\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that it is tabbable.\n  const _enableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>, isKeyboard?: boolean, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(true);\n        if (!isKeyboard) {\n          setIsShowFocusRing(false);\n          onActiveCellChanged({ value: cell });\n          if (!recentPointerRef.current && !skipScrollCellIntoView) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              viewportInfo,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: cell, locationX: 'inView', locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that a user has\n  // exited tabbable mode via the keyboard (esc or 'F2')\n  const _disableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null) {\n          cellElement.focus({ preventScroll: true });\n        } else {\n          rootElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    [rootRef, tableId]\n  );\n\n  const notifyFocusFromPointer = useCallback(\n    (isTouch: boolean) => {\n      if (pointerTimerRef.current != null) {\n        clearTimeout(pointerTimerRef.current);\n      }\n      recentPointerRef.current = true;\n      pointerTimerRef.current = setTimeout(\n        () => {\n          recentPointerRef.current = false;\n        },\n        isTouch ? TOUCH_FOCUS_SHIFT_TIMEOUT : MOUSE_FOCUS_SHIFT_TIMEOUT\n      );\n    },\n    []\n  );\n\n  // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown\n  // on desktop devices should not result in a focus ring being shown on the focused element\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (isShowFocusRing) {\n        setIsShowFocusRing(false);\n      }\n      if (event.pointerType !== 'touch') {\n        notifyFocusFromPointer(false);\n      }\n    },\n    [isShowFocusRing, notifyFocusFromPointer]\n  );\n\n  // PointerUp handler for the outer Table. Focus transfers that occur following a pointerup\n  // on any type of device should not result in a focus ring being shown on the focused element\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      notifyFocusFromPointer(event.pointerType === 'touch');\n    },\n    [notifyFocusFromPointer]\n  );\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'active'.\n  // If an 'active' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'active'.\n  const _onFocusHandler = (event: FocusEvent) => {\n    hasFocusRef.current = true;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null) {\n      // don't scroll active into view if previous blur was due to window focus loss\n      const skipScrollCellIntoView = blurFromWindowRef.current || isPendingLayout;\n      blurFromWindowRef.current = false;\n\n      const targetElement = event.target as HTMLElement;\n      if (targetElement === rootElement || targetElement === scrollerElement) {\n        if (currentActiveCell != null) {\n          _enableNavigationMode(currentActiveCell, skipScrollCellIntoView);\n        }\n      } else {\n        const cell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n        if (cell != null) {\n          if (getCellType(targetElement) != null) {\n            // handle individual focusable regions receiving focus\n            _enableNavigationMode(cell, skipScrollCellIntoView);\n          } else {\n            _enableTabbableMode(cell, false, skipScrollCellIntoView);\n          }\n        }\n      }\n    }\n    isShowFocusRingOverrideRef.current = null;\n  };\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _onBlurHandler = useCallback(\n    (event: FocusEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        if (event.target === document.activeElement) {\n          // save focus ring state so it's set once focus comes back\n          isShowFocusRingOverrideRef.current = isShowFocusRing;\n        }\n        const relatedTarget = event.relatedTarget as Element;\n        const isUnknownRelatedTarget = relatedTarget == null;\n        blurFromWindowRef.current = isUnknownRelatedTarget;\n        if (isUnknownRelatedTarget || !getElementContainsFunc(rootElement, true)(relatedTarget)) {\n          _setAsInactive();\n          if (isRenderCycle.current) {\n            // store element that loses focus during a render cycle for recapturing focus logic\n            blurredRenderCycleElementRef.current = event.target as FocusableElement;\n          }\n        }\n      }\n    },\n    [rootRef, isShowFocusRing, _setAsInactive]\n  );\n\n  // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys\n  // Esc, F2, Enter, and Tab. It also ensures the active cell is scrolled into view on any key\n  const _onKeyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const isNavigationKey = NAVIGATION_KEYS.indexOf(event.key) > -1;\n        if (isNavigationKey) {\n          if (pointerTimerRef.current != null) {\n            clearTimeout(pointerTimerRef.current);\n          }\n          pointerTimerRef.current = null;\n          recentPointerRef.current = false;\n        }\n        if (isPendingLayout) {\n          if (isNavigationKey) {\n            setIsShowFocusRing(true);\n          }\n        } else if (activeCell != null) {\n          if (cellSupportsTabbable(activeCell)) {\n            if (event.key === 'F2') {\n              if (isTabbableMode) {\n                _disableTabbableMode(activeCell);\n              } else {\n                _enableTabbableMode(activeCell, true);\n              }\n            } else if (event.key === 'Esc' || event.key === 'Escape') {\n              // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n              _disableTabbableMode(activeCell);\n            } else if (event.key === 'Enter' && !isTabbableMode) {\n              _enableTabbableMode(activeCell, true);\n            }\n          }\n          if (!isTabbableMode) {\n            if (isNavigationKey) {\n              setIsShowFocusRing(true);\n            }\n            if (SCROLL_KEYS.indexOf(event.key) > -1) {\n              applyScrollDetail(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef.current,\n                { cell: activeCell, locationX: 'inView', locationY: 'inView' },\n                isRtl,\n                fullColumnWidths\n              );\n            }\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      isTabbableMode,\n      activeCell,\n      cellSupportsTabbable,\n      fullColumnWidths,\n      isPendingLayout,\n      _enableTabbableMode,\n      _disableTabbableMode\n    ]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onStartFocusTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null && activeCell != null) {\n        handleEnterActionableMode(\n          detail.hasFocusWithin && getCellType(detail.activeElement) == null,\n          allTabbableElements(\n            getElementFromCell(rootElement, tableId, activeCell) as FocusableElement\n          ),\n          (value?: ActiveCell<K, D>) => {\n            setIsTabbableMode(value != undefined);\n          }\n        );\n      }\n    },\n    [rootRef, activeCell, tableId]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusStartEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(true, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusEndEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(false, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Ensure focus is properly set at the completion of every render cycle\n  // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE\n  useEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null) {\n      // ensure current-cell-override is up to date on each render\n      applyCurrentCellOverride(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        tableData,\n        columnsArray,\n        sizingInfoRef,\n        currencyStatusRef,\n        onActiveCellChanged,\n        isEmbeddedSelect,\n        isPendingLayout,\n        isDataLoaded,\n        isRtl,\n        currentCellOverride,\n        fullColumnWidths\n      );\n\n      const blurredRenderCycleElement = blurredRenderCycleElementRef.current;\n      blurredRenderCycleElementRef.current = null;\n      isRenderCycle.current = false;\n\n      const activeElement = getActiveElement(rootElement);\n      // if we were tracking focus during the render cycle, ensure we recapture focus if needed\n      if (\n        blurredRenderCycleElement != null &&\n        activeElement === getBodyElement(rootElement) &&\n        (!getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||\n          !isTabbableElement(blurredRenderCycleElement, true))\n      ) {\n        rootElement.focus({ preventScroll: true });\n        return;\n      }\n      if (hasFocusRef.current) {\n        if (\n          currentActiveCell != null &&\n          cellComparator(activeCell, currencyStatusRef.current.activeCell)\n        ) {\n          // ensure real browser focus is on the correct cell element\n          const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n          if (cellElement != null) {\n            // cell is valid, so set focus on it if needed\n            if (\n              (!isTabbableMode && activeElement !== cellElement) ||\n              (isTabbableMode && !getElementContainsFunc(cellElement, true)(activeElement))\n            ) {\n              cellElement.focus({ preventScroll: true });\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return {\n    focusHandlingProps: {\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onFocus: _onFocusHandler,\n      onBlur: _onBlurHandler,\n      onKeyDown: _onKeyDownHandler\n    },\n    activeCell,\n    onActiveCellChanged,\n    currentCell: currencyStatusRef.current.currentCell,\n    currentActiveCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { ActiveCell, TableColumn, TableData } from '../Table';\nimport { RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to get the row action context from a pointer or keyboard event\n */\nfunction _getRowActionGestureContext<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  let rowKey: K | null;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(rootElement, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      return {\n        key: rowKey,\n        data: tableData[rowIndex].data\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  const rowActionContext = _getRowActionGestureContext(\n    rootElement,\n    tableId,\n    tableData,\n    targetElement,\n    targetCell\n  );\n  if (rowActionContext != null) {\n    onRowAction({ context: rowActionContext, target: targetElement });\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper function to determine if a pointer or keyboard event should trigger a sort action gesture\n */\nfunction _isSortActionGesture<K, D, C>(columnsArray: TableColumn<K, D, C>[], columnKey: C) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      return column.value.sortable === 'enabled';\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a sort action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  if (_isSortActionGesture(columnsArray, columnKey)) {\n    let sortDirection;\n    if (sortCriterion != null) {\n      for (const criterion of sortCriterion) {\n        if (criterion.key === columnKey) {\n          sortDirection = criterion.sortDirection;\n          break;\n        }\n      }\n    }\n    const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n    onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    return true;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  getBoundaryColumnKey,\n  getElementFromCell,\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport { cellComparator } from './TableFocusUtils';\nimport { applyScrollDetail, getVerticalScrollPosition } from './TableScrollUtils';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void,\n  isPrevious: boolean,\n  isExtendSelectionGesture: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'noData') {\n    const newColumnKey = firstColumnKey;\n    if (isPrevious) {\n      newCell = { columnKey: newColumnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: newColumnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loading') {\n    if (isPrevious) {\n      newCell = { columnKey: initialCell.columnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loadMore') {\n    if (isPrevious) {\n      const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      }\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType !== 'pending') {\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        rootElement,\n        currentRowKey,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        // if adjacent row has no children, it is the 'buffer' row used for height sizing\n        if (adjacentRowElement != null && adjacentRowElement.children.length > 0) {\n          const rowKey = getRowKey<K>(adjacentRowElement);\n          if (rowKey != null) {\n            newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n            onActiveCellChanged({ value: newCell }, isExtendSelectionGesture);\n          } else if (!isExtendSelectionGesture) {\n            newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n            if (getElementFromCell(rootElement, tableId, newCell) != null) {\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        } else if (!isExtendSelectionGesture && isPrevious) {\n          newCell = { columnKey: initialCell.columnKey, type: 'header' };\n          onActiveCellChanged({ value: newCell });\n        } else if (!isExtendSelectionGesture && hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      } else if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else if (hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else {\n          newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n          if (getElementFromCell(rootElement, tableId, newCell) != null) {\n            onActiveCellChanged({ value: newCell });\n          } else {\n            const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n            if (rowKey != null) {\n              newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n              onActiveCellChanged({ value: newCell });\n            } else {\n              newCell = { columnKey: initialCell.columnKey, type: 'header' };\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  if (initialCell.type !== 'noData' && initialCell.type !== 'pending') {\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > 0) {\n      const verticalScrollPosition = getVerticalScrollPosition(\n        rootElement,\n        scrollerElement,\n        tableId\n      );\n      const verticalRowIndex = getRowIndexForRowKey(\n        rootElement,\n        tableId,\n        verticalScrollPosition.rowKey!\n      );\n      let targetRowIndex;\n      if (isPrevious) {\n        if (verticalScrollPosition.offsetY === 0) {\n          targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n        } else {\n          targetRowIndex = verticalRowIndex!;\n        }\n      } else {\n        const scrollerRect = scrollerElement.getBoundingClientRect();\n        const scrollbarHeight =\n          sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n        const scrollerBottom =\n          scrollerRect.bottom + getScrollerBottomOffset(rootElement, tableId) + scrollbarHeight;\n        targetRowIndex = verticalRowIndex!;\n        while (rowElements.length > targetRowIndex + 1) {\n          targetRowIndex += 1;\n          const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n          if (elementBottom > scrollerBottom) {\n            break;\n          }\n        }\n      }\n      const newRowKey = getRowKeyForRowIndex<K>(rootElement, tableId, targetRowIndex);\n      if (newRowKey != null) {\n        const newCell: ActiveCell<K, C> = {\n          rowKey: newRowKey,\n          columnKey: initialCell.columnKey,\n          type: 'data'\n        };\n        if (newRowKey !== initialCell.rowKey) {\n          onActiveCellChanged({ value: newCell });\n        }\n        if (!cellComparator(initialCell, newCell)) {\n          hideTooltip(true);\n        }\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: newCell, locationX: 'inView', locationY: isPrevious ? 'bottom' : 'top' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  includeRows: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const newKey = getBoundaryColumnKey<K, D, C>(columnsArray, isPrevious);\n  if (newKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    if (includeRows) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        const newRowKey = isPrevious\n          ? getFirstFocusableRowKey<K>(rootElement, tableId)\n          : getLastFocusableRowKey<K>(rootElement, tableId);\n        if (newRowKey != null) {\n          newCell = { rowKey: newRowKey, columnKey: newKey, type: 'data' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { applyScrollDetail } from './TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { TableSelectionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isMultiSelectGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n  if (newRowKey != null) {\n    if (selectionMode?.row === 'single' || selectionMode?.row === 'multiple') {\n      const isMultiSelectRowGesture = isMultiSelectGesture || isDropDownSelection;\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectRowGesture && selectionMode.row === 'multiple') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectRowGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = targetElement.closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          rootElement,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isMultiSelectGesture && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isMultiSelectGesture) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> },\n  previousEndIndex?: number\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple') {\n      selectedRows = isDropDownSelection ? selectedRows : (emptyKeys as Keys<K>);\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // for dropdown selection gesture is additive except for rows added from previous gesture\n        if (isDropDownSelection && previousEndIndex != null) {\n          if (previousEndIndex > endIndex) {\n            for (let i = previousEndIndex; i > endIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex < startIndex) {\n            for (let i = previousEndIndex; i < startIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // for dropdown selection gesture is additive except for rows added from previous gesture\n        if (isDropDownSelection && previousEndIndex != null) {\n          if (previousEndIndex < endIndex) {\n            for (let i = previousEndIndex; i < endIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex > startIndex) {\n            for (let i = previousEndIndex; i > startIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (\n    ((selectionMode?.row === 'multiple' && activeCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (activeCell.type === 'header' || activeCell.type === 'footer'))) &&\n    targetCell?.type === activeCell.type\n  ) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      const isRow = targetCell.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            activeCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            targetCellElement.parentElement as HTMLElement\n          ) != null\n        );\n      } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n        const isHeader = targetCell.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader) !=\n            null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (targetCell != null) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      if (\n        ((selectionMode?.row === 'multiple' && targetCell.type === 'data') ||\n          (selectionMode?.column === 'multiple' &&\n            (targetCell.type === 'header' || targetCell.type === 'footer'))) &&\n        targetCell.type === activeCell.type\n      ) {\n        let startIndex;\n        let endIndex;\n        let previousEndIndex;\n        let endElement;\n        const isRow = targetCell.type === 'data';\n        if (isRow) {\n          endElement = targetCellElement.parentElement as HTMLElement;\n          const startElement =\n            isDropDownSelection && selectionExtensionElementRef.current != null\n              ? selectionExtensionElementRef.current\n              : (activeCellElement.parentElement as HTMLElement);\n          startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n          endIndex = getRowIndexForRowElement(rootElement, tableId, endElement);\n          const previousElement = isDropDownSelection\n            ? (activeCellElement.parentElement as HTMLElement)\n            : selectionExtensionElementRef.current;\n          if (previousElement != null) {\n            previousEndIndex = getRowIndexForRowElement(rootElement, tableId, previousElement);\n          }\n        } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n          const isHeader = targetCell.type === 'header';\n          endElement = targetCellElement;\n          startIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            activeCellElement,\n            isHeader\n          );\n          endIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            targetCellElement,\n            isHeader\n          );\n        }\n        if (startIndex != null && endIndex != null) {\n          if (!isRow || !isDropDownSelection) {\n            selectionExtensionElementRef.current = endElement;\n          } else {\n            if (selectionExtensionElementRef.current == null) {\n              selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n            }\n            onActiveCellChanged({ value: targetCell }, true);\n            targetCellElement.focus({ preventScroll: true });\n          }\n          _applyRangeSelection(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            startIndex,\n            endIndex,\n            isRow,\n            onSelectionChange,\n            isDropDownSelection,\n            selectionMode,\n            selected,\n            previousEndIndex\n          );\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  targetElement: HTMLElement,\n  isPrevious: boolean,\n  activeCell: ActiveCell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n  if (activeCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isRow = activeCell.type === 'data';\n    const isHeader = activeCell.type === 'header';\n    if (isRow) {\n      startElement =\n        isDropDownSelection && selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : (activeCellElement.parentElement as HTMLElement);\n      startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n    } else {\n      startElement = activeCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(\n        rootElement,\n        tableId,\n        startElement,\n        isHeader\n      );\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let previousEndIndex;\n      let extendedElement;\n      const cursorElement =\n        isDropDownSelection && isRow\n          ? (activeCellElement.parentElement as HTMLElement)\n          : selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        previousEndIndex = isRow\n          ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n          : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          if (!isDropDownSelection || !isRow) {\n            selectionExtensionElementRef.current = extendedElement;\n          } else if (selectionExtensionElementRef.current == null) {\n            selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n          }\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          rootElement,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          isDropDownSelection,\n          selectionMode,\n          selected,\n          previousEndIndex\n        );\n      }\n\n      // scroll 'extensionElement' into view if focus is not shifted\n      if (!isRow || !isDropDownSelection) {\n        const extensionElement =\n          selectionExtensionElementRef.current != null\n            ? selectionExtensionElementRef.current\n            : activeCellElement;\n        let extensionCell;\n        if (isRow) {\n          const rowKey = keyExtractor<K>(extensionElement, `[data-oj-table-data-row='${tableId}']`);\n          if (rowKey != null) {\n            extensionCell = {\n              type: activeCell.type,\n              rowKey: rowKey,\n              columnKey: activeCell.columnKey\n            };\n          }\n        } else {\n          extensionCell = logicalCellExtractor<K, D, C>(extensionElement, tableId, columnsArray);\n        }\n        if (extensionCell != null) {\n          applyScrollDetail(\n            rootElement,\n            scrollerElement,\n            viewportInfo,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: extensionCell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizeDetail, ColumnWidths } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (fullColumnWidths != null) {\n    if (resizeInfoRef.current.key == null) {\n      _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n    }\n    if (resizeInfoRef.current.key != null) {\n      const rect = scrollerElement.getBoundingClientRect();\n      const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      const resizeColumnWidths = [];\n      for (let i = 0; i < fullColumnWidths.length; i++) {\n        const columnWidth = fullColumnWidths[i];\n        resizeColumnWidths.push(columnWidth as number);\n      }\n      resizeInfoRef.current = {\n        isResizing: true,\n        isResizeHover: true,\n        key: resizeInfoRef.current.key,\n        startX: pointerX,\n        delta: 0,\n        fullColumnWidths: resizeColumnWidths,\n        ignoreClick: resizeInfoRef.current.ignoreClick\n      };\n      if (onColumnResizing != null) {\n        onColumnResizing({\n          key: resizeInfoRef.current.key,\n          delta: 0,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing && fullColumnWidths != null) {\n    const rect = scrollerElement.getBoundingClientRect();\n    const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n    resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n    // handle resize move operation\n    if (onColumnResizing != null) {\n      onColumnResizing({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths\n      });\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const resizeColumnWidths = [];\n      for (const columnWidth of resizeInfoRef.current.fullColumnWidths) {\n        resizeColumnWidths.push(columnWidth);\n      }\n      const rect = scrollerElement.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      onColumnResize({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths\n      });\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = rootElement.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      scrollerElement,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useRef, useState, MutableRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending } from '../../utils/PRIVATE_textSelectionUtils';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  ColumnResizeInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture } from '../utils/TableActionUtils';\nimport { logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport {\n  handleOverColumnHeaderGesture,\n  handleLeaveColumnHeaderGesture\n} from '../utils/TableSortUtils';\nimport {\n  handleLeaveTableTooltipGesture,\n  handleMoveTooltipGesture\n} from '../utils/TableTooltipUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  RowActionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype PointerInfo = {\n  target: EventTarget | null;\n  x: number;\n  y: number;\n}\n\ntype UsePointerHandlingOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths?: ColumnWidths<C>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  activeCell?: ActiveCell<K, C>;\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void;\n  isDropDownSelection: boolean;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isSelectionExtension: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  tooltipId: string;\n};\n\n/**\n * Hook that manages pointer interactions on the Preact Table\n */\nexport function usePointerHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  resizeInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  showTooltip,\n  hideTooltip,\n  tooltipId\n}: UsePointerHandlingOptions<K, D, C>) {\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // tracks the column key for any header being hovered over\n  const [hoverColumnKey, setHoverColumnKey] = useState<C>();\n\n  // tracks the current 'pointer over' element for comparison during 'click' event handling to\n  // prevent screen readers from triggering undesired selection gestures from simulated events\n  const pointerInfoRef = useRef<PointerInfo>();\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId);\n        if (onColumnResizing != null) {\n          if (!resizeInfoRef.current.isResizing) {\n            handleOverResizeRegionGesture(\n              rootElement,\n              tableId,\n              event,\n              columnsArray,\n              resizeInfoRef,\n              isRtl\n            );\n          } else if (scrollerElement != null && appliedColumnWidths != null) {\n            handleColumnResizingGesture(\n              scrollerElement,\n              event,\n              appliedColumnWidths,\n              resizeInfoRef,\n              isRtl,\n              fullColumnWidths,\n              onColumnResizing\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      fullColumnWidths,\n      onColumnResizing,\n      showTooltip,\n      hideTooltip,\n      tooltipId\n    ]\n  );\n\n  // Pointer over handler for the outer Table.\n  const _pointerOverHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleOverColumnHeaderGesture(tableId, event, setHoverColumnKey, hoverColumnKey);\n      }\n    }, [\n      rootRef,\n      tableId,\n      hoverColumnKey\n    ]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        const targetElement = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          activeCell != null &&\n          event.shiftKey &&\n          isRangeSelectionGesture(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            activeCell,\n            selectionMode\n          )\n        ) {\n          // prevent focus change on selection extension gesture\n          if (!getIsSelectionPending()) {\n            event.preventDefault();\n          }\n        } else if (\n          scrollerElement != null &&\n          appliedColumnWidths != null &&\n          handleColumnResizeStartGesture(\n            rootElement,\n            scrollerElement,\n            tableId,\n            event,\n            columnsArray,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          )\n        ) {\n          // prevent focus change on column resize gesture\n          event.preventDefault();\n          resizeInfoRef.current.ignoreClick = true;\n        } else if (logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray) == null) {\n          // prevent focus shift when interacting with 'non-focusable' regions (ie - scrollbar)\n          event.preventDefault();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      activeCell,\n      selectionMode,\n      onTableSelectionChange,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleColumnResizeEndGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleLeaveColumnHeaderGesture(setHoverColumnKey, hoverColumnKey);\n        handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef);\n        handleLeaveTableTooltipGesture(rootElement, event, hideTooltip, tooltipId);\n      }\n      pointerInfoRef.current = undefined;\n    },\n    [rootRef, tableId, resizeInfoRef, hoverColumnKey, hideTooltip, tooltipId]\n  );\n\n  // Pointer enter handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleEnterResizingGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted, and any action events are fired correctly.\n  const _clickHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        // only handle click events that match the latest mouse over/move info to prevent screen readers\n        // from triggering undesired selections due to simulated click events when transferring focus\n        if (\n          event.pointerType !== 'mouse' || (\n            pointerInfoRef.current != null &&\n            pointerInfoRef.current.target === event.target &&\n            Math.abs(pointerInfoRef.current.x - event.clientX) <= 1  &&\n            Math.abs(pointerInfoRef.current.y - event.clientY) <= 1\n          )\n        ) {\n          let isSelectionExtension = false;\n          const platform = getClientHints().platform;\n          const target = event.target as HTMLElement;\n          if (\n            onTableSelectionChange != null &&\n            !resizeInfoRef.current.ignoreClick &&\n            !getIsSelectionPending()\n          ) {\n            if (activeCell != null && event.shiftKey) {\n              isSelectionExtension = handleRangeSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                activeCell,\n                onActiveCellChanged,\n                selectionExtensionElementRef,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n            if (!isSelectionExtension) {\n              handleSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n          }\n          if (\n            onRowAction != null &&\n            !getIsSelectionPending() &&\n            handleRowActionGesture(rootElement, tableId, tableData, onRowAction, target)\n          ) {\n            event.stopPropagation();\n          }\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      tableData,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  return {\n    pointerHandlingProps: {\n      onPointerOver: _pointerOverHandler,\n      onPointerMove: _pointerMoveHandler,\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onPointerLeave: _pointerLeaveHandler,\n      onPointerEnter: _pointerEnterHandler,\n      onClick: _clickHandler\n    },\n    hoverColumnKey\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Dispatch, StateUpdater } from 'preact/hooks';\nimport { getCellType, getColumnKey } from './TableDomUtils';\n\n/**\n * Helper function to handle a hover over a column header region gesture.\n */\nexport function handleOverColumnHeaderGesture<C>(\n  tableId: string,\n  event: PointerEvent,\n  setHoverColumnKey: Dispatch<StateUpdater<C | undefined>>,\n  hoverColumnKey?: C\n) {\n  // only enable sort icon visibility due to mouse events\n  if (event.pointerType === 'mouse') {\n    const cellElement = (event.target as HTMLElement).closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null && getCellType(cellElement) === 'header') {\n      const columnKey = getColumnKey<C>(cellElement);\n      if (columnKey !== hoverColumnKey) {\n        setHoverColumnKey(columnKey);\n      }\n    } else if (hoverColumnKey != null) {\n      setHoverColumnKey(undefined);\n    }\n  }\n}\n\n/**\n * Helper function to handle a mouse leave the table region.\n */\nexport function handleLeaveColumnHeaderGesture<C>(\n  setHoverColumnKey: Dispatch<StateUpdater<C | undefined>>,\n  hoverColumnKey?: C\n) {\n  if (hoverColumnKey != null) {\n    setHoverColumnKey(undefined);\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useLayoutEffect, useRef, MutableRef } from 'preact/hooks';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { LayoutInfo, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  hideOutOfViewTooltip,\n  setHorizontalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseScrollHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  layoutInfo: LayoutInfo;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  fullColumnWidths?: number[];\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages handling scroll events on the Preact Table\n */\nexport function useScrollHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  layoutInfo,\n  sizingInfoRef,\n  columnsArray,\n  stickyEdgesState,\n  setStickyEdgesState,\n  fullColumnWidths,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  tooltipAnchorRef,\n  hideTooltip,\n  isPendingLayout,\n  isRtl\n}: UseScrollHandlingProps<K, D, C>) {\n  const horizontalScrollPositionOverrideRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionOverrideRef = useRef<TableVerticalScrollPosition<K>>();\n\n  // update horizontal and/or vertical scroll position if a new value is provided\n  // NO DEPENDENCY ARRAY AS THIS SHOULD RUN ON EVERY RENDER\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      rootElement != null &&\n      scrollerElement != null &&\n      !isPendingLayout &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      if (horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride) {\n        setHorizontalScrollPosition(\n          scrollerElement,\n          columnsArray,\n          layoutInfo.columnWidthsArray,\n          isRtl,\n          horizontalScrollPositionOverride\n        );\n        horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;\n      }\n      if (verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride) {\n        setVerticalScrollPosition(\n          rootElement,\n          scrollerElement,\n          tableId,\n          verticalScrollPositionOverride\n        );\n        verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;\n      }\n    }\n  });\n\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated\n  // and any out of view tooltips are hidden.\n  const _scrollHandler = useCallback(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        scrollerElement.scrollLeft\n      );\n      hideOutOfViewTooltip(\n        rootElement,\n        scrollerElement,\n        tableId,\n        sizingInfoRef.current,\n        columnsArray,\n        fullColumnWidths,\n        tooltipAnchorRef,\n        hideTooltip,\n        isRtl\n      );\n    }\n  }, [\n    rootRef,\n    viewportInfo,\n    tableId,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths,\n    tooltipAnchorRef,\n    hideTooltip,\n    isRtl\n  ]);\n\n  useLayoutEffect(() => {\n    const isExternalScroller = viewportInfo.isExternalScroller;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    let scrollerEventElement: Element | typeof globalThis;\n    if (isExternalScroller && scrollerElement != null) {\n      if (scrollerElement === document.body || scrollerElement === document.documentElement) {\n        scrollerEventElement = window;\n      } else {\n        scrollerEventElement = scrollerElement;\n      }\n      scrollerEventElement.addEventListener('scroll', _scrollHandler);\n    }\n    return () => {\n      if (isExternalScroller && scrollerEventElement != null) {\n        scrollerEventElement.removeEventListener('scroll', _scrollHandler);\n      }\n    };\n  }, [viewportInfo, _scrollHandler]);\n\n  return viewportInfo.isExternalScroller ? {} : { onScroll: _scrollHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useImperativeHandle, useMemo, useRef, MutableRef } from 'preact/hooks';\nimport { ForwardedRef } from 'preact/compat';\nimport { useCollectionInteractionContext } from '../../hooks/UNSAFE_useCollectionInteractionContext';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  ActiveCell,\n  ColumnResizeInfo,\n  LayoutInfo,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { useContextMenu } from './useContextMenu';\nimport { useTruncationTooltip } from './useTruncationTooltip';\nimport { useFocusHandling } from './useFocusHandling';\nimport { useKeyboardHandling } from './useKeyboardHandling';\nimport { usePointerHandling } from './usePointerHandling';\nimport { useScrollHandling } from './useScrollHandling';\nimport { getHorizontalScrollPosition, getVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  CellOverride,\n  ColumnWidths,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  ColumnResizeDetail,\n  TableContextMenuConfig,\n  TableHorizontalScrollPosition,\n  TableSelectionDetail,\n  TableVerticalScrollPosition,\n  TableViewHandle\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  ref?: ForwardedRef<TableViewHandle<K, C>>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths?: ColumnWidths<C>;\n  layoutInfo: LayoutInfo;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  cellHasRenderer: (cell: ActiveCell<K, C>) => boolean;\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  isPendingLayout: boolean;\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>;\n};\n\nconst _defaultDisabledRowInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  ref,\n  tableId,\n  tableData,\n  hasMore,\n  hasFooters,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  layoutInfo,\n  sizingInfoRef,\n  stickyEdgesState,\n  setStickyEdgesState,\n  cellHasRenderer,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  onColumnResizing,\n  onColumnResize,\n  currentCellOverride,\n  onPersistCurrentCell,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  isPendingLayout,\n  contextMenuConfig\n}: UseInteractionManagerOptions<K, D, C>) {\n  // tracks the current column resize state\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  // handles default tooltip state management\n  const { tooltipContent, tooltipId, tooltipAnchorRef, showTooltip, hideTooltip } =\n    useTruncationTooltip<K, C>({ rootRef, tableId });\n\n  // whether row selection is triggered on 'enter' keypresses in addition to 'spacebar'\n  const isEmbeddedSelect = useCollectionInteractionContext() === 'embedded';\n  const disabledRowInteractionKeys = isEmbeddedSelect\n    ? undefined\n    : _defaultDisabledRowInteractionKeys;\n\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup focus tracking using the useFocusHandling hook\n  const {\n    focusHandlingProps,\n    activeCell,\n    onActiveCellChanged,\n    currentActiveCell,\n    currentCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  } = useFocusHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    isRtl,\n    cellSupportsTabbable: cellHasRenderer,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    currentCellOverride,\n    onPersistCurrentCell,\n    showTooltip,\n    hideTooltip,\n    isPendingLayout,\n    isEmbeddedSelect,\n    isDataLoaded: !hasMore || tableData.length > 0\n  });\n\n  const keyboardHandlingProps = useKeyboardHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    isTabbableMode,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    hideTooltip\n  });\n\n  const { hoverColumnKey, pointerHandlingProps } = usePointerHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    resizeInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    onColumnResizing,\n    onColumnResize,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    showTooltip,\n    hideTooltip,\n    tooltipId\n  });\n\n  const scrollHandlingProps = useScrollHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    layoutInfo,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    tooltipAnchorRef,\n    hideTooltip,\n    isPendingLayout,\n    isRtl\n  });\n\n  const { contextMenuTriggerProps, menuProps, contextMenuContext } = useContextMenu<K, D, C>(\n    tableId,\n    tableData,\n    activeCell,\n    contextMenuConfig\n  );\n\n  const interactionManagerProps = !isPendingLayout\n    ? mergeProps(\n        focusHandlingProps,\n        keyboardHandlingProps,\n        pointerHandlingProps,\n        contextMenuTriggerProps\n      )\n    : focusHandlingProps;\n\n  // setup imperative handle implementation\n  useImperativeHandle(\n    ref!,\n    () => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      return {\n        focus: () => {\n          if (rootElement != null) {\n            if (currentActiveCell != null) {\n              const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n              if (cellElement != null) {\n                cellElement.focus();\n                return;\n              }\n            }\n            // if no current cell element was found, just focus the root element\n            rootElement.focus();\n          }\n        },\n        getHorizontalScrollPosition: () => {\n          if (scrollerElement == null || layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getHorizontalScrollPosition<K, D, C>(\n            scrollerElement,\n            columnsArray,\n            layoutInfo.columnWidthsArray\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (rootElement == null || scrollerElement == null || layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition<K>(rootElement, scrollerElement, tableId);\n        }\n      };\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      currentActiveCell,\n      layoutInfo.isLayoutRequired,\n      layoutInfo.columnWidthsArray\n    ]\n  );\n\n  return {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    hoverColumnKey,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    disabledRowInteractionKeys\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, MutableRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport {\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableNavigationUtils';\nimport { handleSelectionGesture, handleExtendSelectionGesture } from '../utils/TableSelectionUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { RowActionDetail, SortCriterionDetail, TableSelectionDetail } from '../../UNSAFE_TableView';\n\ntype UseKeyboardHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  isTabbableMode: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void;\n  fullColumnWidths?: number[];\n  activeCell?: ActiveCell<K, C>;\n  isDropDownSelection: boolean;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isExtendableSelection: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n};\n\n/**\n * Hook that manages keyboard interactions on the Preact Table\n */\nexport function useKeyboardHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  isTabbableMode,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  hideTooltip\n}: UseKeyboardHandlingProps<K, D, C>) {\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const platform = getClientHints().platform;\n        const keyHandlers: Record<string, () => void> = {\n          ' ': function () {\n            if (activeCell != null) {\n              if (!isTabbableMode) {\n                if (onTableSelectionChange != null && !event.repeat) {\n                  handleSelectionGesture(\n                    rootElement,\n                    tableId,\n                    columnsArray,\n                    getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                    true,\n                    onTableSelectionChange,\n                    isDropDownSelection,\n                    selectionMode,\n                    selected\n                  );\n                }\n                event.preventDefault();\n              }\n              if (\n                onRowAction != null &&\n                !event.repeat &&\n                handleRowActionGesture(\n                  rootElement,\n                  tableId,\n                  tableData,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  activeCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          Enter: function () {\n            if (activeCell != null) {\n              if (activeCell.type === 'data') {\n                if (isDropDownSelection && !isTabbableMode) {\n                  if (onTableSelectionChange != null && !event.repeat) {\n                    handleSelectionGesture(\n                      rootElement,\n                      tableId,\n                      columnsArray,\n                      getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                      true,\n                      onTableSelectionChange,\n                      isDropDownSelection,\n                      selectionMode,\n                      selected\n                    );\n                  }\n                  event.preventDefault();\n                }\n                if (\n                  onRowAction != null &&\n                  !event.repeat &&\n                  handleRowActionGesture(\n                    rootElement,\n                    tableId,\n                    tableData,\n                    onRowAction,\n                    event.target as HTMLElement,\n                    activeCell\n                  )\n                ) {\n                  event.stopPropagation();\n                }\n              } else if (\n                activeCell.type === 'header' &&\n                !isTabbableMode &&\n                !event.repeat &&\n                onSortCriterionChange != null &&\n                handleSortActionGesture(\n                  columnsArray,\n                  activeCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          ArrowUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              let isExtendSelectionGesture = false;\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (!isExtendSelectionGesture || isDropDownSelection) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  true,\n                  isExtendSelectionGesture,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              let isExtendSelectionGesture = false;\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (!isExtendSelectionGesture || isDropDownSelection) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  false,\n                  isExtendSelectionGesture,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowLeft: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  !isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowRight: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          PageUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          PageDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          Home: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          End: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          }\n        };\n        if (Object.keys(keyHandlers).includes(event.key)) {\n          keyHandlers[event.key]();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      tableData,\n      isRtl,\n      isTabbableMode,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      fullColumnWidths,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange,\n      hideTooltip\n    ]\n  );\n\n  return { onKeyDown: _keyDownHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SampledWidths, TableColumn, ViewportInfo } from '../Table';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function applyLayoutColumnWidths<K, D, C extends string>(\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  innerTableElement: HTMLTableElement,\n  widthOffset: number,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  let newColumnWidths;\n  let totalWidth = 0;\n  let widthsArray = [];\n  const tableCols = innerTableElement.querySelectorAll(\n    `[data-oj-table-col='${tableId}']`\n  ) as NodeListOf<HTMLTableColElement>;\n\n  if (isFixed) {\n    newColumnWidths = _getFixedLayoutColumnWidths(availableWidth, columnsArray, staticColumnWidths);\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newColumnWidths[columnsArray[i].key];\n      widthsArray.push(width);\n      totalWidth += width;\n    }\n    _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n    return newColumnWidths;\n  }\n\n  const headerElements = innerTableElement.querySelectorAll(\n    `[data-oj-table-header-cell='${tableId}']`\n  ) as NodeListOf<HTMLElement>;\n\n  newColumnWidths = _getContentsLayoutColumnWidths(\n    innerTableElement,\n    headerElements,\n    sampledColumnWidthsRef,\n    availableWidth,\n    columnsArray,\n    staticColumnWidths\n  );\n  for (let i = 0; i < columnsArray.length; i++) {\n    const width = newColumnWidths[columnsArray[i].key];\n    widthsArray.push(width);\n    totalWidth += width;\n  }\n  _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n\n  if (availableWidth === -1) {\n    // for content sizing, check to see if all space is actually utilized\n    // this supports no width constraint scenarios\n    if (!viewportInfo.isExternalScroller) {\n      availableWidth = scrollerElement.getBoundingClientRect().width - widthOffset;\n    } else {\n      availableWidth = scrollerElement.clientWidth - widthOffset;\n    }\n    if (Math.abs(totalWidth - availableWidth) > 0.005) {\n      newColumnWidths = _getContentsLayoutColumnWidths(\n        innerTableElement,\n        headerElements,\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        staticColumnWidths\n      );\n      totalWidth = 0;\n      widthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        const width = newColumnWidths[columnsArray[i].key];\n        widthsArray.push(width);\n        totalWidth += width;\n      }\n      _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n    }\n  }\n  return newColumnWidths;\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnWidths<K, D, C extends string>(\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalWidth = 0;\n  let pendingTotalWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  const appliedColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalWidth += columnWidth;\n      pendingTotalWidth += columnWidth;\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray.push(columnWidth);\n      appliedColumnWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnWidthsArray.push(undefined);\n      newColumnWidthsArray.push(columnMinWidth);\n      appliedColumnWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalWidth < availableWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnWidths<K, D, C extends string>(\n  innerTableElement: HTMLTableElement,\n  headerElements: NodeListOf<HTMLElement>,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalWidth = 0;\n    let pendingTotalWidth = 0;\n    let totalPreferredWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledWidths = sampledColumnWidthsRef.current;\n    const sampledMinWidthsArray = [];\n    const sampledWeightWidthsArray = [] as number[];\n    const appliedColumnWidthsArray = [];\n    if (sampledWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinWidthsArray.push(sampledWidths.minWidths[columnsArray[i].key]);\n        sampledWeightWidthsArray.push(sampledWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      // when sampledColumnWidths are not populated, table has 'max-content' width applied,\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledWeightWidthsArray.push(sampledWeightWidth);\n        sampledColumnWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightWidth;\n      }\n      // specify 'min-content' width, allowing measurements to represent minimum auto-resizable column widths\n      innerTableElement.style.width = 'min-content';\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledMinWidthsArray.push(sampledMinWidth);\n        sampledColumnWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnWidth;\n        const sampledMinWidth = sampledMinWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinWidth) {\n          columnWidth = minWidth;\n        } else if (maxWidth != null && sampledMinWidth >= maxWidth) {\n          columnWidth = maxWidth;\n        } else {\n          columnWidth = sampledMinWidth;\n        }\n        pendingTotalWidth += columnWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightWidthsArray[i]\n            ? minWidth\n            : sampledWeightWidthsArray[i];\n        sampledWeightWidthsArray[i] = columnWeight;\n        totalPreferredWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnWidthsArray[i] = columnWidth;\n        appliedColumnWidthsArray.push(columnWidth);\n      } else {\n        forcedTotalWidth += forcedWidth;\n        pendingTotalWidth += forcedWidth;\n        totalPreferredWidth += forcedWidth;\n        appliedColumnWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableWidth === -1) {\n      availableWidth = totalPreferredWidth;\n    }\n    if (pendingTotalWidth < availableWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableWidth,\n        totalPreferredWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalWidth,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        sampledWeightWidthsArray,\n        columnMaxWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnWidthsArray: number[]\n) {\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = columnWidthsArray[i];\n  }\n  return columnWidths;\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _updateTableSizing(\n  innerTableElement: HTMLTableElement,\n  tableCols: NodeListOf<HTMLTableColElement>,\n  widthsArray: number[],\n  totalWidth: number\n) {\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i];\n    tableCol.style.width = `${widthsArray[i]}px`;\n  }\n  innerTableElement.style.width = `${totalWidth}px`;\n  innerTableElement.style.tableLayout = 'fixed';\n}\n\n/**\n * Helper function to compare two ColumnWidths instances for equality.\n */\nexport const columnWidthsComparator = <C extends string>(\n  columnWidths1: ColumnWidths<C>,\n  columnWidths2: ColumnWidths<C>\n) => {\n  const keys1 = Object.keys(columnWidths1);\n  const keys2 = Object.keys(columnWidths2);\n  if (keys1.length === keys2.length) {\n    for (const key of keys1) {\n      const columnKey = key as C;\n      if (columnWidths1[columnKey] !== columnWidths2[columnKey]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { useResizeObserver } from '../../hooks/UNSAFE_useResizeObserver';\nimport { Column, Columns, ColumnWidths, TableViewportConfig } from '../../UNSAFE_TableView';\nimport { LayoutInfo, SampledWidths, SizingInfo, TableData } from '../Table';\nimport { applyLayoutColumnWidths, columnWidthsComparator } from '../utils/TableLayoutUtils';\nimport {\n  applyOverflowStatus,\n  applyUnderflowStatus,\n  getViewportConfig,\n  updateStickyColumns,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseSizingManagerProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  scrollerRef: RefObject<HTMLDivElement>;\n  innerTableRef: RefObject<HTMLTableElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  viewportConfig?: TableViewportConfig;\n  layout?: 'contents' | 'fixed' | 'pending';\n  columns: Columns<K, D, C>;\n  columnOrder?: C[];\n  columnWidths?: ColumnWidths<C>;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages column sizing on the Preact Table\n */\nexport function useSizingManager<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  innerTableRef,\n  tableId,\n  tableData,\n  viewportConfig,\n  layout,\n  columns,\n  columnOrder,\n  columnWidths,\n  isRtl\n}: UseSizingManagerProps<K, D, C>) {\n  // state to force a rerender following the initial render where scrollbars are forced\n  const [_isScrollbarSizeKnown, setIsScrollbarSizeKnown] = useState<boolean>(false);\n\n  // column width state information\n  const sampledColumnWidthsRef = useRef<SampledWidths<C>>();\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<ColumnWidths<C>>();\n\n  const [innerTableHeight, setInnerTableHeight] = useState<number | undefined>();\n  const [hasVerticalUnderflow, setHasVerticalUnderflow] = useState<boolean>(false);\n\n  // general table sizing state information\n  const sizingInfoRef = useRef<SizingInfo>({\n    isInitialRender: true,\n    isScrollbarSizeKnown: false\n  });\n  const pendingResizeEntriesRef = useRef<{\n    scroller?: ResizeObserverEntry | undefined;\n    innerTable?: ResizeObserverEntry | undefined;\n  }>({});\n\n  // scrollbar overflow state\n  const overflowRef = useRef<{ isHorizontal: boolean; isVertical: boolean }>({\n    isHorizontal: false,\n    isVertical: false\n  });\n\n  // sticky edge state management\n  const [stickyEdgesState, setStickyEdgesState] = useState<{ start?: number; end?: number }>({});\n\n  // current viewport information\n  const viewportInfo = useMemo(() => {\n    const tableViewportConfig = getViewportConfig(scrollerRef, viewportConfig);\n    return {\n      isExternalScroller: viewportConfig?.scroller() != null,\n      viewportConfig: tableViewportConfig\n    };\n  }, [scrollerRef, viewportConfig]);\n\n  // memoize realized columns array on 'columns' and 'columnOrder'\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [];\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  // determine if a new layout is required\n  let isLayoutRequired = false;\n  const columnWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const appliedWidth = appliedColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (appliedWidth == null || (staticWidth != null && staticWidth !== appliedWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      columnWidthsArray.push(appliedWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n  const layoutInfo = {\n    isLayoutRequired: isLayoutRequired,\n    columnWidthsArray: isLayoutRequired ? undefined : columnWidthsArray\n  } as LayoutInfo;\n\n  // ensure sampled column sizes are cleared if 'columns', 'columnOrder', or 'layout' is updated\n  useLayoutEffect(() => {\n    sampledColumnWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns, columnOrder, layout]);\n\n  // ensure applied column widths are cleared if 'columnWidths' is updated\n  useLayoutEffect(() => {\n    setAppliedColumnWidths(undefined);\n  }, [columnWidths]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    if (\n      layout !== 'pending' &&\n      scrollerElement != null &&\n      innerTableElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      (viewportInfo.isExternalScroller || sizingInfoRef.current.isScrollbarSizeKnown) &&\n      layoutInfo.isLayoutRequired &&\n      columnsArray.length > 0\n    ) {\n      let widthOffset = 0;\n      if (viewportInfo.isExternalScroller) {\n        const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n        if (scrollerOffsetStart != null) {\n          widthOffset += scrollerOffsetStart;\n        }\n        const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n        if (scrollerOffsetEnd != null) {\n          widthOffset += scrollerOffsetEnd;\n        }\n      } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n        widthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n      }\n      const totalWidth = layout === 'fixed' ? sizingInfoRef.current.contentWidth - widthOffset : -1;\n      const newColumnWidths = applyLayoutColumnWidths(\n        scrollerElement,\n        viewportInfo,\n        innerTableElement,\n        widthOffset,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    columnsArray,\n    columnWidths,\n    layout,\n    layoutInfo.isLayoutRequired\n  ]);\n\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      layout !== 'pending' &&\n      rootElement != null &&\n      scrollerElement != null &&\n      appliedColumnWidths != null\n    ) {\n      updateStickyColumns(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        isRtl,\n        columnsArray,\n        appliedColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n      );\n    }\n  }, [\n    tableData,\n    rootRef,\n    viewportInfo,\n    tableId,\n    appliedColumnWidths,\n    columnsArray,\n    layout,\n    stickyEdgesState,\n    isRtl\n  ]);\n\n  // helper method to update the sticky edge styling due to resize events\n  const _updateStickyEdgesFromResize = useCallback(\n    (scrollerElement: HTMLElement) => {\n      if (appliedColumnWidths != null) {\n        if (viewportInfo.isExternalScroller || overflowRef.current.isHorizontal) {\n          // ensure sticky edges are applied correctly if horizontal overflow is present\n          const fullColumnWidths = [];\n          for (let i = 0; i < columnsArray.length; i++) {\n            const width = appliedColumnWidths[columnsArray[i].key];\n            fullColumnWidths.push(width);\n          }\n          updateStickyEdges(\n            scrollerElement,\n            columnsArray,\n            fullColumnWidths,\n            stickyEdgesState,\n            setStickyEdgesState\n          );\n        } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n          // otherwise clear sticky edges if necessary\n          setStickyEdgesState({});\n        }\n      }\n    },\n    [appliedColumnWidths, columnsArray, stickyEdgesState, viewportInfo]\n  );\n\n  // callback function to handle resizes of the scroller and inner table elements\n  const handleResizeCallback = useCallback(() => {\n    let currentEntry = pendingResizeEntriesRef.current.scroller;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    let isOveralSizeHandled = false;\n\n    // handle scroller element resize notification\n    if (\n      currentEntry != null &&\n      rootElement != null &&\n      scrollerElement != null &&\n      innerTableElement != null\n    ) {\n      const newContentWidth = currentEntry.contentBoxSize[0].inlineSize;\n      const newContentHeight = currentEntry.contentBoxSize[0].blockSize;\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n\n      if (newBoxWidth !== 0 || newBoxHeight !== 0) {\n        isOveralSizeHandled = true;\n        let availableWidth;\n        let availableWidthOffset = 0;\n        let defaultScrollbarWidth = 0;\n        if (viewportInfo.isExternalScroller) {\n          const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n          if (scrollerOffsetStart != null) {\n            availableWidthOffset += scrollerOffsetStart;\n          }\n          const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n          if (scrollerOffsetEnd != null) {\n            availableWidthOffset += scrollerOffsetEnd;\n          }\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: false\n            };\n          }\n          availableWidth = newContentWidth - availableWidthOffset;\n        } else {\n          const isInitialRender = sizingInfoRef.current.isInitialRender;\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            availableWidthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            // on the first render that does not specify an external scroller, horizontal and\n            // vertical scrollbars are forced in order to determine default browser sizes\n            availableWidthOffset = newBoxWidth - newContentWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: availableWidthOffset,\n              defaultScrollbarHeight: newBoxHeight - newContentHeight\n            };\n            setIsScrollbarSizeKnown(true);\n          }\n          defaultScrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n          availableWidth = !isInitialRender || layout === 'fixed' ? newContentWidth : -1;\n        }\n        if (columnsArray.length > 0) {\n          let newColumnWidths;\n          if (layout !== 'pending') {\n            newColumnWidths = applyLayoutColumnWidths(\n              scrollerElement,\n              viewportInfo,\n              innerTableElement,\n              availableWidthOffset,\n              tableId,\n              layout === 'fixed',\n              sampledColumnWidthsRef,\n              availableWidth,\n              columnsArray,\n              columnWidths\n            );\n            if (\n              appliedColumnWidths == null ||\n              !columnWidthsComparator(appliedColumnWidths, newColumnWidths)\n            ) {\n              setAppliedColumnWidths(newColumnWidths);\n            } else {\n              newColumnWidths = undefined;\n            }\n          }\n          // ensure scrollbars are applied correctly - a scrollbar could be needed\n          if (viewportInfo.isExternalScroller) {\n            applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n          } else {\n            const innerTableRect = innerTableElement.getBoundingClientRect();\n            applyOverflowStatus(\n              rootElement,\n              scrollerElement,\n              tableId,\n              innerTableRect.width,\n              newContentWidth,\n              innerTableRect.height,\n              newContentHeight,\n              defaultScrollbarWidth,\n              overflowRef,\n              setHasVerticalUnderflow\n            );\n          }\n          if (layout !== 'pending') {\n            if (newColumnWidths != null) {\n              updateStickyColumns(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                isRtl,\n                columnsArray,\n                newColumnWidths,\n                stickyEdgesState,\n                setStickyEdgesState,\n                viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n              );\n            } else {\n              _updateStickyEdgesFromResize(scrollerElement);\n            }\n          }\n        }\n      }\n    }\n    currentEntry = pendingResizeEntriesRef.current.innerTable;\n    if (currentEntry != null) {\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n      // if only an inner table resize occurred, ensure scrollbars are applied correctly\n      if (\n        !isOveralSizeHandled &&\n        rootElement != null &&\n        scrollerElement != null &&\n        columnsArray.length > 0 &&\n        (newBoxWidth !== 0 || newBoxHeight !== 0)\n      ) {\n        if (viewportInfo.isExternalScroller) {\n          applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n        } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n          applyOverflowStatus(\n            rootElement,\n            scrollerElement,\n            tableId,\n            newBoxWidth,\n            sizingInfoRef.current.contentWidth,\n            newBoxHeight,\n            sizingInfoRef.current.contentHeight,\n            sizingInfoRef.current.defaultScrollbarWidth,\n            overflowRef,\n            setHasVerticalUnderflow\n          );\n        }\n        if (layout !== 'pending') {\n          _updateStickyEdgesFromResize(scrollerElement);\n        }\n      }\n      setInnerTableHeight(newBoxHeight);\n    }\n    pendingResizeEntriesRef.current = {};\n  }, [\n    rootRef,\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    layout,\n    columnsArray,\n    columnWidths,\n    appliedColumnWidths,\n    stickyEdgesState,\n    isRtl,\n    _updateStickyEdgesFromResize\n  ]);\n\n  // ensure resize observers have access to the latest state information\n  const handleResizeCallbackRef = useRef<() => void>(handleResizeCallback);\n  handleResizeCallbackRef.current = handleResizeCallback;\n\n  // resize observer callback functions are static to avoid hook re-subscribing each render\n  const staticHandleScrollerResize = useCallback((entry: ResizeObserverEntry) => {\n    // only queue up an animation frame if there isn't one already pending\n    if (\n      pendingResizeEntriesRef.current.scroller == null ||\n      pendingResizeEntriesRef.current.innerTable == null\n    ) {\n      window.requestAnimationFrame(() => {\n        handleResizeCallbackRef.current();\n      });\n    }\n    pendingResizeEntriesRef.current.scroller = entry;\n  }, []);\n  const staticHandleInnerTableResize = useCallback((entry: ResizeObserverEntry) => {\n    // only queue up an animation frame if there isn't one already pending\n    if (\n      pendingResizeEntriesRef.current.scroller == null ||\n      pendingResizeEntriesRef.current.innerTable == null\n    ) {\n      window.requestAnimationFrame(() => {\n        handleResizeCallbackRef.current();\n      });\n    }\n    pendingResizeEntriesRef.current.innerTable = entry;\n  }, []);\n  useResizeObserver(viewportInfo.viewportConfig.scroller(), staticHandleScrollerResize);\n  useResizeObserver(innerTableRef, staticHandleInnerTableResize);\n\n  return {\n    layoutInfo,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    overflowRef\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { JSXInternal } from 'preact/src/jsx';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { Cell, CellOverride, Column, ColumnWidths, TableViewportConfig } from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { TableContextMenu } from './TableContextMenu';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useDataManager } from './hooks/useDataManager';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { useSizingManager } from './hooks/useSizingManager';\nimport { innerTableStyles, scrollerStyles } from './themes/Table.css';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { TableVariantOptions } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type ActiveCell<K, C> =\n  | Cell<K, C>\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loading';\n    }\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loadMore';\n    }\n  | {\n      rowKey?: never;\n      columnKey?: never;\n      type: 'pending';\n    };\n\nexport type ActiveCellDetail<K, C> = {\n  value?: ActiveCell<K, C>;\n};\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type TableData<K, D> = {\n  data: D;\n  metadata: K;\n};\n\nexport type CurrencyStatus<K, D, C> = {\n  activeCell?: ActiveCell<K, C>;\n  currentCell?: Cell<K, C>;\n  currentCellOverride?: CellOverride<K, C>;\n  hasPendingCurrentCellOverride: boolean;\n  hasPendingCurrentCellOverrideScroll: boolean;\n  previousEmbeddedSelectCurrentCell?: Cell<K, C>;\n  loadMoreInitialData?: TableData<K, D>[];\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type ViewportInfo = {\n  isExternalScroller: boolean;\n  viewportConfig: TableViewportConfig;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: true;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    };\n\nexport type LayoutInfo =\n  | {\n      isLayoutRequired: true;\n      columnWidthsArray?: number[];\n    }\n  | {\n      isLayoutRequired: false;\n      columnWidthsArray: number[];\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      fullColumnWidths?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      fullColumnWidths: number[];\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: ActiveCell<K, C> | Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\nconst _disabledHeaderFooterInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Component that renders data in a flat table.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    contextMenuConfig,\n    viewportConfig,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCellOverride,\n    onPersistCurrentCell,\n    currentRowVariant = 'none',\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const testIdProps = useTestId(testId);\n\n  const rootRef = useRef<HTMLDivElement>(null);\n  const scrollerRef = useRef<HTMLDivElement>(null);\n  const innerTableRef = useRef<HTMLTableElement>(null);\n\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const isRtl = direction === 'rtl';\n\n  const { tableData, onTableLoadMore } = useDataManager<K, D>({\n    data,\n    getRowKey,\n    hasMore,\n    onLoadMore\n  });\n\n  const {\n    layoutInfo,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    overflowRef\n  } = useSizingManager<K, D, C>({\n    rootRef,\n    scrollerRef,\n    innerTableRef,\n    tableId,\n    tableData,\n    viewportConfig,\n    layout,\n    columns,\n    columnOrder,\n    columnWidths,\n    isRtl\n  });\n\n  const cellHasRenderer = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      let hasRenderer = false;\n      if (cell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else if (cell.type !== 'loadMore' && cell.type !== 'loading' && cell.type !== 'pending') {\n        for (const column of columnsArray) {\n          if (column.key === cell.columnKey) {\n            if (cell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (cell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (cell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const isPendingLayout = layout === 'pending';\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = hasMore || isPendingLayout ? -1 : tableData.length + (hasFooters ? 2 : 1);\n  const ariaColumnCount = Math.max(columnsArray.length, 1);\n\n  const {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    hoverColumnKey,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    disabledRowInteractionKeys\n  } = useInteractionManager<K, D, C>({\n    rootRef,\n    viewportInfo,\n    ref,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    layoutInfo,\n    sizingInfoRef,\n    stickyEdgesState,\n    setStickyEdgesState,\n    cellHasRenderer,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    onColumnResizing,\n    onColumnResize,\n    currentCellOverride,\n    onPersistCurrentCell,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    isPendingLayout,\n    contextMenuConfig\n  });\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    pendingLayout: isPendingLayout ? 'isPendingLayout' : 'notPendingLayout',\n    showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n    externalScroller: viewportInfo.isExternalScroller ? 'isExternalScroller' : 'notExternalScroller'\n  });\n\n  let scrollerStyle;\n  let scrollerPadding = '';\n  const scrollerClassArray = [scrollerStyles.base];\n  if (viewportInfo.isExternalScroller) {\n    scrollerClassArray.push(scrollerStyles.externalScroller);\n  } else if (!sizingInfoRef.current.isScrollbarSizeKnown) {\n    scrollerClassArray.push(scrollerStyles.forceScroll);\n  } else {\n    if (overflowRef.current.isHorizontal) {\n      scrollerClassArray.push(scrollerStyles.horizontalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noHorizontalScroll);\n    }\n    if (overflowRef.current.isVertical) {\n      scrollerClassArray.push(scrollerStyles.verticalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noVerticalScroll);\n      scrollerPadding = `padding-inline-end: ${sizingInfoRef.current.defaultScrollbarWidth}px;`;\n    }\n  }\n  // hide the table contents when layout is required and otherwise valid\n  if (layoutInfo.isLayoutRequired && columnsArray.length > 0) {\n    scrollerStyle = `${scrollerPadding}opacity:0.001;`;\n  } else {\n    scrollerStyle = scrollerPadding;\n  }\n\n  const scrollerClasses = classNames(scrollerClassArray);\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n\n  const startStickyEdge = stickyEdgesState.start;\n  const endStickyEdge = stickyEdgesState.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' || selectionMode?.row === 'multiple';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n\n  const getTableBodyProps = () => {\n    return {\n      rootRef: rootRef,\n      viewportInfo: viewportInfo,\n      tableId: tableId,\n      isValidRender: columnsArray.length > 0,\n      tableData: tableData,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      activeCell: currentActiveCell,\n      currentRowKey: currentCell?.type === 'data' ? currentCell.rowKey : undefined,\n      currentRowVariant: currentRowVariant,\n      isShowFocusRing: isShowFocusRing,\n      isTabbableMode: isTabbableMode,\n      hasMore: hasMore,\n      onLoadMore: onTableLoadMore,\n      noDataRenderer: noDataRenderer,\n      disabledInteractionKeys: disabledRowInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!layoutInfo.isLayoutRequired) {\n      columnWidthsArray = layoutInfo.columnWidthsArray;\n    } else if (layout === 'fixed') {\n      // default to 100px for each column when layout is not yet available\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = 100;\n      }\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'header' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      isForceSortIcons: layout === 'contents' && layoutInfo.isLayoutRequired,\n      hoverColumnKey: hoverColumnKey,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      isShowFocusRing: isShowFocusRing,\n      stickyTopOffset: viewportInfo.viewportConfig.scrollerOffsetTop,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableFooterProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'footer' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isShowFocusRing: isShowFocusRing,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      stickyBottomOffset: viewportInfo.viewportConfig.scrollerOffsetBottom,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      dataRowCount: tableData.length,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (columnResizingIndicator != null && !layoutInfo.isLayoutRequired) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += layoutInfo.columnWidthsArray[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} height={innerTableHeight} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    if (!layoutInfo.isLayoutRequired) {\n      let totalWidth = 0;\n      for (let i = 0; i < layoutInfo.columnWidthsArray.length; i++) {\n        totalWidth += layoutInfo.columnWidthsArray[i];\n      }\n      return `width:${totalWidth}px;table-layout:fixed;`;\n    } else if (columnsArray.length > 0) {\n      if (layout === 'fixed') {\n        // default to 100px for each column when layout is not yet available\n        return `width:${columnsArray.length * 100}px;table-layout:fixed;`;\n      } else {\n        // shrink table down as much as possible when a 'contents' layout is required, otherwise\n        // the sampled column widths will not reflect the true weight sizes with line-clamping\n        return 'width:max-content;will-change:width;';\n      }\n    }\n    // no columns are present\n    return 'width:100%;';\n  };\n\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const getPendingLayoutSkeletons = () => {\n    return isPendingLayout ? (\n      <div class={skeletonStyles.pendingLayout}>\n        <table role={'presentation'} style={'width:100%;table-layout:fixed;'}>\n          <tbody role={'presentation'}>\n            <TableSkeletonRow\n              tableId={tableId}\n              hasTabIndex={currentActiveCell?.type === 'pending'}\n              colspan={ariaColumnCount}\n              isPendingLayout={true}\n              isShowFocusRing={false}\n              isHighContrast={isHighContrast}\n            />\n          </tbody>\n        </table>\n      </div>\n    ) : undefined;\n  };\n\n  return (\n    <>\n      <div\n        {...testIdProps}\n        ref={rootRef}\n        aria-colcount={ariaColumnCount}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-rowcount={ariaRowCount}\n        {...(selectionMode?.column === 'multiple' || selectionMode?.row === 'multiple'\n          ? { 'aria-multiselectable': true }\n          : {})}\n        class={classes}\n        id={tableId}\n        role={'grid'}\n        tabIndex={currentActiveCell != null ? -1 : 0}\n        {...interactionManagerProps}>\n        <div\n          ref={scrollerRef}\n          class={scrollerClasses}\n          role={'rowgroup'}\n          style={scrollerStyle}\n          tabIndex={-1}\n          {...scrollHandlingProps}>\n          <FocusTracker\n            isDisabled={!isTabbableMode}\n            onFocusStartEdge={onFocusStartEdge}\n            onFocusEndEdge={onFocusEndEdge}\n            onStartTracking={onStartFocusTracking}>\n            <TabbableModeContext.Provider value={{ isTabbable: isTabbableMode }}>\n              <table\n                ref={innerTableRef}\n                aria-hidden={isPendingLayout ? true : undefined}\n                class={tableClasses}\n                role={'presentation'}\n                style={getTableStyle()}\n                data-oj-table-inner-table={tableId}>\n                <TableColGroup {...getTableColGroupProps()} />\n                <TableHeader {...getTableHeaderProps()} />\n                <TableBody {...getTableBodyProps()} />\n                <TableFooter {...getTableFooterProps()} />\n              </table>\n            </TabbableModeContext.Provider>\n            {getTableDragIndicator()}\n          </FocusTracker>\n          {tooltipContent}\n        </div>\n        {getPendingLayoutSkeletons()}\n      </div>\n      {contextMenuConfig != null && contextMenuContext != null && (\n        <TableContextMenu\n          {...menuProps}\n          contextMenuConfig={contextMenuConfig}\n          contextMenuContext={contextMenuContext}\n        />\n      )}\n    </>\n  );\n}) as <K extends string | number, D, C extends string>(\n  p: Props<K, D, C> & { ref?: ForwardedRef<TableViewHandle<K, C>> }\n) => JSXInternal.Element;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useMemo, useRef } from 'preact/hooks';\nimport { TableData } from '../Table';\n\ntype UseDataManagerProps<K, D> = {\n  data?: D[];\n  getRowKey: (data: D) => K;\n  hasMore: boolean;\n  onLoadMore: () => void;\n};\n\n/**\n * Hook that manages data on the Preact Table\n */\nexport function useDataManager<K extends string | number, D>({\n  data,\n  getRowKey,\n  hasMore,\n  onLoadMore\n}: UseDataManagerProps<K, D>) {\n  const tableData = useMemo(() => {\n    const newDataArray =\n      data != null\n        ? data.map((d: D) => {\n            const key = getRowKey(d);\n            return { data: d, metadata: key };\n          })\n        : [];\n    return newDataArray as Array<TableData<K, D>>;\n  }, [data, getRowKey]);\n\n  // debounce loadMore calls to prevent state changes from triggering multiple calls\n  const loadMoreDataRef = useRef<TableData<K, D>[]>();\n  if (!hasMore) {\n    // clear loadMoreData cache once more data is not available\n    loadMoreDataRef.current = undefined;\n  }\n  const onTableLoadMore = useCallback(() => {\n    if (tableData === loadMoreDataRef.current) {\n      return;\n    }\n    loadMoreDataRef.current = tableData;\n    return onLoadMore();\n  }, [tableData, onLoadMore]);\n\n  return { tableData, onTableLoadMore };\n}\n"],"names":["TableColGroup","tableId","isRendered","columnWidthsArray","getColStyle","columnWidth","_jsx","jsx","children","map","style","skeletonDimensionInterpolation","Array","from","x","dimensionInterpolations","interpolations","Object","values","SkeletonInterpolations","mergeInterpolations","TableSkeleton","props","skeletonStyles","isHighContrast","tableSkeletonStylesHC","tableSkeletonStyles","classes","classNames","bar","skeletonDimensions","width","class","TableSkeletonRow","colspan","hasTabIndex","isShowFocusRing","isPendingLayout","isLoadMore","translations","useTranslationBundle","cellClassArray","cell","push","focus","cellClasses","innerCellClasses","innerCell","rowClasses","row","rowHeight","firstRowClasses","headerHeight","accCellContent","collection_loading","LOADMORE_STYLE_CLASS","role","colSpan","tabIndex","_jsxs","_element","index","height","getDataCellClassArray","isFirstColumnIndex","isFinalColumnIndex","isFirstRowIndex","isFinalRowIndex","hasVerticalGridlines","hasHorizontalGridlines","hasLastHorizontalGridline","isRowSelected","isPreviousRowSelected","isColumnSelected","isPreviousColumnSelected","isSticky","isRowSelectionEnabled","isRowSingleSelection","isActive","isHover","isPseudoHover","isStickyStartEdge","isStickyEndEdge","isRtl","horizontalAlignment","verticalAlignment","variant","padding","cellStyles","tableCellStylesHC","tableCellStyles","classArray","base","isTopPadding","isBottomPadding","isStartPadding","isEndPadding","_getPaddingInfo","_applyAlignmentStyling","_applyStickyStyling","active","hover","pseudoHover","rowHighlight","_applyFocusStyling","hasBackground","selected","horizontalSelectedGridTop","selectedBorderTopPadding","selectedBorderTopNoPadding","horizontalGridTop","borderTopPadding","borderTopNoPadding","topSpacerPadding","topSpacerNoPadding","lastRow","horizontalSelectedGridBottom","selectedBorderBottomPadding","selectedBorderBottomNoPadding","horizontalGridBottom","borderBottomPadding","borderBottomNoPadding","bottomSpacerPadding","bottomSpacerNoPadding","notLastRow","bottomPadding","bottomNoPadding","_applySelectedColumnStyling","backgroundStyles","inherit","_applyColumnStyling","getHeaderFooterCellClassArray","isHeader","isColumnSelectionEnabled","isSelected","isColumnSelectable","previousInteractiveBorderStart","previousInteractiveBorderStartNoPadding","previousPseudoHoverBorderStart","previousPseudoHoverBorderStartNoPadding","tableHeaderCellStylesHC","headerPreviousInteractiveBorderStartHC","headerPreviousPseudoHoverBorderStartHC","headerPreviousInteractiveBorderStartNoPaddingHC","headerPreviousPseudoHoverBorderStartNoPaddingHC","tableHeaderCellStyles","headerPreviousInteractiveBorderStart","headerPreviousPseudoHoverBorderStart","headerPreviousInteractiveBorderStartNoPadding","headerPreviousPseudoHoverBorderStartNoPadding","tableFooterCellStylesHC","footerPreviousInteractiveBorderStartHC","footerPreviousInteractiveBorderStartNoPaddingHC","footerPreviousPseudoHoverBorderStartHC","footerPreviousPseudoHoverBorderStartNoPaddingHC","tableFooterCellStyles","footerPreviousInteractiveBorderStart","footerPreviousInteractiveBorderStartNoPadding","footerPreviousPseudoHoverBorderStart","footerPreviousPseudoHoverBorderStartNoPadding","topPadding","topNoPadding","additionalStyles","startInteractivePaddingStyles","startInteractiveNoPaddingStyles","interactiveStyles","selectedStyle","activeSelected","notSelectedStyle","borderStartStyle","activeBorderStart","borderStartNoPaddingStyle","activeBorderStartNoPadding","borderEndStyle","activeBorderEnd","borderEndNoPaddingStyle","activeBorderEndNoPadding","hoverSelected","hoverBorderStart","hoverBorderStartNoPadding","hoverBorderEnd","hoverBorderEndNoPadding","pseudoHoverSelected","pseudoHoverBorderStart","pseudoHoverBorderStartNoPadding","pseudoHoverBorderEnd","pseudoHoverBorderEndNoPadding","isPaddingDisabled","isComplexPadding","bottom","end","start","top","textAlignStyles","verticalAlignStyles","focused","stickyColumn","stickyEdge","stickyEdgeLeft","stickyEdgeRight","verticalSelectedGridStart","selectedBorderStartPadding","selectedBorderStartNoPadding","verticalGridStart","borderStartPadding","borderStartNoPadding","startSpacerPadding","startSpacerNoPadding","endSpacerPadding","endSpacerNoPadding","endPadding","endNoPadding","verticalSelectedGridEnd","selectedBorderEndPadding","selectedBorderEndNoPadding","getCellType","element","dataset","getRowKey","Number","getRowKeyForRowIndex","rootElement","rowElements","querySelectorAll","length","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","cellElement","columnElements","logicalCellExtractor","columnsArray","cellSelector","onlyAncestors","selectorString","startingElement","parentElement","closest","cellType","rowKey","keyExtractor","columnKey","type","getBoundaryColumnKey","getElementFromCell","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerTopOffset","headerRowElement","getBoundingClientRect","getScrollerBottomOffset","footerRowElement","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","isFirst","key","hasNoDataCell","getNoDataCellElement","hasFooterCells","hasTruncatedText","getAttribute","String","innerText","trim","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","nextNode","range","Range","textNode","currentNode","selectNodeContents","untruncatedTextLength","firstParent","parentStyles","getComputedStyle","visibility","parseFloat","paddingLeft","paddingRight","border","borderLeft","borderRight","handleLeaveTableTooltipGesture","event","hideTooltip","tooltipId","targetElement","relatedTarget","boundingRect","clientX","left","right","clientY","preventBrowserTooltipProps","onPointerEnter","target","classList","add","preventBrowserTooltipStyle","onPointerLeave","remove","_defaultCellRenderer","rowData","field","undefined","TableCell","columnIndex","rowIndex","hasFooters","hasVerticalUnderflow","hasMore","isTabbableMode","isRowHeader","renderer","selectorRenderer","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","tooltip","browser","getClientHints","rowContext","data","columnPadding","supportsDefaultTooltip","cellRendererProps","selector","isTabbable","MemoizeTableRow","memo","isFinalRow","rowHeaderColumnKeys","isPreviousSelected","isSingleRowSelectionEnabled","selectedRowKeys","all","keys","Set","activeColumnKey","selectedColumnKeys","disabledInteractionKeys","onSelectionChange","startStickyEdge","endStickyEdge","interactionProps","useInteractionStyle","disabledKeys","rowStyles","tableRowStylesHC","tableRowStyles","lastRowHeight","accessibleRowName","toString","handleRowSelectorChange","detail","value","column","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","containsKey","cellProps","sticky","has","alignment","horizontal","vertical","prev","next","columnsArray1","columnsArray2","i","_areColumnsArraysEquivalent","set1","set2","size","every","isSameKey","TableNoData","rootRef","columnsCount","ariaRowIndex","themeClasses","useComponentTheme","TableNoDataRedwoodTheme","defaultRenderer","showFocusRing","contentRenderer","collection_noData","useLayoutEffect","current","tableBodyElement","noDataElement","TableBody","viewportInfo","isValidRender","getAccessibleRowHeaders","tableData","onLoadMore","activeCell","currentRowKey","currentRowVariant","noDataRenderer","getRowContext","useCallback","context","metadata","isShowEmptyLoading","isShowNoData","loadMoreViewportConfig","scroller","viewportConfig","getNoDataProps","jsxs","Fragment","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsActiveCell","rowProps","TableHeaderCell","headerText","stickyTopOffset","isShowSortIcon","sortable","sortDirection","onSortCriterionChange","selectorAllState","deletedKeys","handleSelectorChange","SelectorAll","collection_selectAllRows","handleSortGesture","iconClassArray","tableHeaderSortIconStyles","visible","hidden","iconClasses","headerCellRendererProps","sortControl","EmbeddedIconButton","collection_sortEnabled","collection_sortDisabled","isDisabled","onAction","SortDescendingIcon","SortAscendingIcon","getHeaderCellRenderer","text","tableHeaderCellTextStyles","defaultRendererSpan","isIconFirst","containerClasses","tableHeaderSortContainerStyles","justifyContentStyles","getAriaSort","TableHeader","activeKey","isForceSortIcons","hoverColumnKey","sortCriterion","isResizeHover","tableHeaderRowStyles","criterion","headerCellProps","selectable","headerRenderer","headerPadding","headerTooltip","headerAlignment","_defaultFooterCellRenderer","footerText","TableFooterCell","stickyBottomOffset","footerCellRendererProps","TableFooter","dataRowCount","tableFooterRowStyles","Math","max","footerCellProps","footerRenderer","footerPadding","footerAlignment","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","heightString","getDragIndicatorStyle","TableContextMenu","contextMenuConfig","contextMenuContext","menuProps","accessibleLabel","Menu","isOpen","itemsRenderer","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","topOffset","bottomOffset","isExternalScroller","scrollerOffsetTop","scrollerOffsetBottom","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","hasTopOverflow","bottomOverflowDiff","hasBottomOverflow","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","applyScrollDetail","sizingInfo","scrollDetail","findElementByKey","locationY","isInitialRender","boxHeight","contentHeight","locationX","columnElement","scrollerOffsetStart","scrollerOffsetEnd","stickyColumns","getStickyColumnIndicies","stickyIndex","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","updateStickyColumns","appliedColumnWidths","stickyEdgesState","setStickyEdgesState","isHorizontalScroll","stickyStartOffset","stickyEndOffset","stickyIndicies","_applyStickyColumnOffset","updateStickyEdges","stickyOffset","isStart","styleProperty","styleValue","j","currentScrollIndex","newScrollPosition","startIndex","currentIndex","endIndex","currentWidth","endOverflow","scrollWidth","clientWidth","resetVerticalScrollPosition","applyOverflowStatus","availableWidth","availableHeight","overflowRef","setHasVerticalUnderflow","hasHorizontalOverflow","hasVerticalOverflow","scrollerStyles","noHorizontalScroll","horizontalScroll","noVerticalScroll","verticalScroll","paddingInlineEnd","isHorizontal","isVertical","applyUnderflowStatus","spacerRowElement","offsetHeight","cellComparator","cell1","cell2","_getCellFromCellOverride","cellOverride","currentCell","cellRowKey","cellColumnKey","_renderIncludesCell","isColumnValid","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","_initialMenuProps","anchorRef","SMALL_INTERACTION_DELAY","TABLE_HIDE_TOOLTIP_DELAY","min","SHOW_TOOLTIP_DELAY","HIDE_TOOLTIP_DELAY","MOUSE_FOCUS_SHIFT_TIMEOUT","TOUCH_FOCUS_SHIFT_TIMEOUT","NAVIGATION_KEYS","SCROLL_KEYS","useFocusHandling","sizingInfoRef","selectionExtensionElementRef","cellSupportsTabbable","currentCellOverride","onPersistCurrentCell","showTooltip","isEmbeddedSelect","isDataLoaded","blurFromWindowRef","useRef","isRenderCycle","blurredRenderCycleElementRef","isPendingLayoutFocusRef","hasFocusRef","setIsTabbableMode","useState","setIsShowFocusRing","recentPointerRef","pointerTimerRef","isShowFocusRingOverrideRef","setActiveCell","currencyStatusRef","hasPendingCurrentCellOverride","hasPendingCurrentCellOverrideScroll","currentActiveCell","firstColumnKey","defaultFirstCell","previousEmbeddedSelectCurrentCell","realizedCell","overrideCellType","_getCellTypeFromCellOverride","initialData","loadMoreInitialData","determineActiveCell","onActiveCellChanged","useMemo","isSelectionExtension","newActiveCell","isTransientCell","newCurrentCell","_setAsInactive","_enableNavigationMode","skipScrollCellIntoView","focusRingState","handleNavigationTooltipGesture","_enableTabbableMode","isKeyboard","_disableTabbableMode","preventScroll","notifyFocusFromPointer","isTouch","clearTimeout","setTimeout","_pointerDownHandler","pointerType","_pointerUpHandler","_onBlurHandler","activeElement","isUnknownRelatedTarget","getElementContainsFunc","_onKeyDownHandler","isNavigationKey","onStartFocusTracking","handleEnterActionableMode","hasFocusWithin","allTabbableElements","onFocusStartEdge","handleWrapActionableFocus","tabbableElements","onFocusEndEdge","useEffect","applyCurrentCellOverride","blurredRenderCycleElement","getActiveElement","getBodyElement","isTabbableElement","focusHandlingProps","onPointerDown","onPointerUp","onFocus","onBlur","onKeyDown","handleRowActionGesture","onRowAction","targetCell","rowActionContext","targetCellElement","_getRowActionGestureContext","handleAdjacentRowGesture","initialCell","isPrevious","isExtendSelectionGesture","newCell","newColumnKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","handlePageRowGesture","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","handleJumpColumnGesture","includeRows","handleSelectionGesture","isMultiSelectGesture","isDropDownSelection","selectionMode","emptyKeys","selectedRows","selectedColumns","isMultiSelectRowGesture","removeKey","addKey","_applyRangeSelection","isRowGesture","previousEndIndex","handleExtendSelectionGesture","activeCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","resizeInfoRef","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","onColumnResize","isResizing","rect","currentX","delta","startX","allColumnWidths","ignoreClick","usePointerHandling","onColumnResizing","onTableSelectionChange","selectionTouchRef","setHoverColumnKey","pointerInfoRef","_pointerMoveHandler","tooltipShown","handleMoveTooltipGesture","handleColumnResizingGesture","handleOverResizeRegionGesture","_pointerOverHandler","handleOverColumnHeaderGesture","shiftKey","isRangeSelectionGesture","getIsSelectionPending","preventDefault","pointerX","resizeColumnWidths","handleColumnResizeStartGesture","_pointerLeaveHandler","handleLeaveColumnHeaderGesture","handleLeaveResizingGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","platform","endElement","previousElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","pointerHandlingProps","onPointerOver","onPointerMove","onClick","useScrollHandling","layoutInfo","horizontalScrollPositionOverride","verticalScrollPositionOverride","tooltipAnchorRef","horizontalScrollPositionOverrideRef","verticalScrollPositionOverrideRef","isLayoutRequired","_scrollHandler","offsetWidth","hideOutOfViewTooltip","scrollerEventElement","body","documentElement","window","addEventListener","removeEventListener","onScroll","_defaultDisabledRowInteractionKeys","useInteractionManager","ref","cellHasRenderer","tooltipContent","globalTooltipManager","getGlobalTooltipManager","useId","tooltipCellRef","pendingShowTooltipCellRef","tooltipTextRef","tooltipText","setTooltipText","pointerDownRef","pointerDownTimeoutRef","showTooltipTimeoutRef","hideTooltipTimeoutRef","_clearHideTooltipTimeout","_clearShowTooltipTimeout","_setupShowTooltipTimeout","_setupHideTooltipTimeout","anchorCell","isImmediate","_event","isOpenOverrideRef","tooltipPointerProps","renderRawContent","TooltipContent","id","isDatatip","scale","useScale","mainAxisOffset","crossAxisOffset","currentColorScheme","useColorScheme","getWrappedTooltipContent","mainAxis","crossAxis","destroyCallback","register","unregister","useTruncationTooltip","useCollectionInteractionContext","disabledRowInteractionKeys","isExtendableSelection","keyboardHandlingProps","_keyDownHandler","keyHandlers","repeat","Enter","_isSortActionGesture","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","includes","useKeyboardHandling","scrollHandlingProps","contextMenuTriggerProps","setContextMenuContext","setMenuProps","currentCellElementRef","triggerProps","useContextMenuGesture","gesture","anchor","cellContext","getCellContextFromCell","anchorBasedOnGesture","handleCloseContextMenu","reason","onClose","useContextMenu","interactionManagerProps","mergeProps","useImperativeHandle","applyLayoutColumnWidths","innerTableElement","widthOffset","isFixed","sampledColumnWidthsRef","staticColumnWidths","newColumnWidths","totalWidth","widthsArray","tableCols","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalWidth","pendingTotalWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","isMaxRuleApplied","_enforceWeightedMinRules","_enforceFixedMinMaxRules","_createColumnWidths","_getFixedLayoutColumnWidths","_updateTableSizing","_getContentsLayoutColumnWidths","columnMinWidthsArray","totalPreferredWidth","totalRemainingWeight","sampledWidths","sampledMinWidthsArray","sampledWeightWidthsArray","minWidths","weightWidths","sampledWeightWidth","sampledMinWidth","forcedWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","newWidth","columnWidths","tableLayout","useSizingManager","scrollerRef","innerTableRef","layout","columns","columnOrder","_isScrollbarSizeKnown","setIsScrollbarSizeKnown","setAppliedColumnWidths","innerTableHeight","setInnerTableHeight","isScrollbarSizeKnown","pendingResizeEntriesRef","tableViewportConfig","config","getViewportConfig","newColumnsArray","entries","appliedWidth","staticWidth","defaultScrollbarWidth","_updateStickyEdgesFromResize","handleResizeCallback","currentEntry","isOveralSizeHandled","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","availableWidthOffset","defaultScrollbarHeight","columnWidths1","columnWidths2","keys1","keys2","columnWidthsComparator","innerTableRect","innerTable","handleResizeCallbackRef","staticHandleScrollerResize","entry","requestAnimationFrame","staticHandleInnerTableResize","useResizeObserver","_defaultSelected","_disabledHeaderFooterInteractionKeys","Table","forwardRef","ariaLabel","ariaLabelledBy","gridlines","columnResizingIndicator","testId","testIdProps","useTestId","direction","forcedColors","useUser","onTableLoadMore","d","loadMoreDataRef","useDataManager","hasRenderer","some","ariaRowCount","ariaColumnCount","TableRedwoodTheme","pendingLayout","externalScroller","scrollerStyle","scrollerPadding","scrollerClassArray","forceScroll","scrollerClasses","tableClasses","innerTableStyles","_Fragment","FocusTracker","onStartTracking","TabbableModeContext","Provider","getTableStyle","getTableColGroupProps","getTableDragIndicator"],"mappings":"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IAAK3kB,GAAgC,MAAd0F,EAAoB,CACzC,IAAI4U,GAA2B,EAET,SAApB5U,EAAWzK,MACXmD,EAAMugB,UACoB,MAA1BX,GACuB,aAAvBpC,GAAehtB,MAEf0tB,GACE9iB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAnb,GACA,EACAkM,EACAkP,EACAoJ,EACArC,EACA7qB,EACA2c,EACAmO,EACAvpB,GAEFioB,GAA2B,GAExBA,IAA4BqB,GAC/BxB,GACE3gB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAjP,EACAmR,GACA,EACAyD,EACAxpB,EACAuN,EACAoP,GAGJrP,EAAM0gB,gBACP,CACF,EACD8F,UAAW,WACT,IAAK5kB,GAAgC,MAAd0F,EAAoB,CACzC,IAAI4U,GAA2B,EAET,SAApB5U,EAAWzK,MACXmD,EAAMugB,UACoB,MAA1BX,GACuB,aAAvBpC,GAAehtB,MAEf0tB,GACE9iB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAnb,GACA,EACAkM,EACAkP,EACAoJ,EACArC,EACA7qB,EACA2c,EACAmO,EACAvpB,GAEFioB,GAA2B,GAExBA,IAA4BqB,GAC/BxB,GACE3gB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAjP,EACAmR,GACA,EACAyD,EACAxpB,EACAuN,EACAoP,GAGJrP,EAAM0gB,gBACP,CACF,EACD+F,UAAW,WACJ7kB,GAAgC,MAAd0F,IAEE,WAApBA,EAAWzK,MAAyC,WAApByK,EAAWzK,OAC5CmD,EAAMugB,UACoB,MAA1BX,GAC0B,aAA1BpC,GAAe/Y,OAqBfsY,GACE3hB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAjP,EACAmR,GACC/lB,EACDA,EACAuN,EACAoP,GA/BF6O,GACE9iB,EACAsS,EACAzG,EACAzZ,EACA0O,EACAqa,EACAnb,GACA,EACAkM,EACAkP,EACAoJ,EACArC,EACA7qB,EACA2c,EACAmO,EACAvpB,GAkBJ+L,EAAM0gB,iBAET,EACDgG,WAAY,WACL9kB,GAAgC,MAAd0F,IAEE,WAAp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"}