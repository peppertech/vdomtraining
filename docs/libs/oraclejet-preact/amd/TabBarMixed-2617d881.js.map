{"version":3,"file":"TabBarMixed-2617d881.js","sources":["../../src/UNSAFE_TabBarMixed/useTabBar.ts","../../src/UNSAFE_TabBarMixed/TabBarMixed.tsx"],"sourcesContent":["import { useState, useRef, useEffect } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport {\n  getPrevNextKey,\n  getFirstVisibleKey,\n  getKey,\n  keyExtractor\n} from '../utils/PRIVATE_collectionUtils';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useId } from '../hooks/UNSAFE_useId';\n\nimport { ComponentProps, ContextType, RefObject } from 'preact';\nimport type { TabBarContext, TabBarLayout } from '../UNSAFE_TabBarCommon';\n\ntype TabBarContextValue = ContextType<typeof TabBarContext>;\n\nexport type UseTabBarOptions = {\n  class?: string;\n  display?: TabBarContextValue['display'];\n  edge?: 'bottom' | 'top';\n  onRemove?: TabBarContextValue['onRemove'];\n  onSelect?: TabBarContextValue['onSelect'];\n  ref?: RefObject<HTMLDivElement>;\n  selection?: TabBarContextValue['selection'];\n  size?: TabBarContextValue['size'];\n  children?: ComponentProps<typeof TabBarLayout>['children'];\n};\n\nconst ITEM_SELECTOR = '[role=\"tab\"]';\nconst REMOVAL_ITEM_SELECTOR = '[data-oj-tabbar-item-remove-icon]';\n\n/**\n * Re-implements UNSAFE_TabBar/TabBar behavior for focus and keyboad handling\n */\nexport function useTabBar(options: UseTabBarOptions) {\n  const {\n    children,\n    class: className,\n    display,\n    edge = 'top',\n    selection,\n    onSelect,\n    onRemove,\n    ref: rootRef = useRef<HTMLDivElement>(null),\n    size\n  } = options;\n\n  const tabId = useId();\n  const [currentKey, setCurrentKey] = useState(selection);\n\n  const tabItemPrefix = tabId + '_';\n\n  /**\n   * A reference to the previous set of tab keys that this tablist\n   * contains before children were re-rendered. In the event the \"current\" tab\n   * is removed and the \"currentKey\" reference is broken, we can redirect\n   * the \"currentKey\" to another tab based on the index of the removed tab.\n   */\n  const prevTabKeys = useRef<(string | number | undefined)[]>();\n\n  useEffect(() => {\n    if (rootRef.current) {\n      const tabKeys = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR)).map((elem) =>\n        getKey(elem as HTMLElement)\n      );\n\n      if (currentKey && !tabKeys.includes(currentKey) && prevTabKeys.current) {\n        setCurrentKey(findNextCurrentKey(currentKey, tabKeys, prevTabKeys.current));\n      }\n      prevTabKeys.current = tabKeys;\n    }\n  }, [children, currentKey]);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n    'ArrowRight',\n    'ArrowLeft'\n  ]);\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) =>\n      onRemove\n        ? extractOnlyItemKey(element, ITEM_SELECTOR, REMOVAL_ITEM_SELECTOR)\n        : keyExtractor(element, ITEM_SELECTOR),\n    false,\n    undefined,\n    undefined,\n    getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR),\n    currentKey,\n    (detail) => setCurrentKey(detail.value)\n  );\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (currentKey && event.key === 'Enter') {\n      onSelect?.({ value: currentKey });\n    }\n    if (currentKey && event.key === 'Delete') {\n      onRemove?.({ value: currentKey });\n    }\n  };\n\n  const onFocus = () => {\n    if (rootRef.current && currentKey === undefined) {\n      const key = getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);\n      if (key) {\n        setCurrentKey(key);\n      }\n    }\n  };\n\n  const eventProps = { onKeyDown, onFocus };\n\n  return {\n    rootProps: mergeProps(\n      {\n        'aria-activedescendant': currentKey ? tabItemPrefix + currentKey : '',\n        'aria-multiselectable': false,\n        class: className,\n        ref: rootRef,\n        role: 'tablist',\n        tabIndex: 0\n      },\n      currentKeyProps,\n      focusRingProps,\n      eventProps\n    ),\n    tabBarContext: {\n      currentKey,\n      display,\n      isEdgeBottom: edge === 'bottom',\n      layout: 'condense',\n      onRemove,\n      onSelect,\n      showFocusRing,\n      selection,\n      size,\n      tabItemPrefix\n    }\n  } as const;\n}\n\n//useCurrentKey use click capture that captures first click, which is on remove button\n//when we remove and sets the item being removed to currentKey. So we should not allow\n//this if click is on remove button\nconst extractOnlyItemKey = (element: HTMLElement, itemSelector: string, itemEliminator: string) => {\n  const tabBarItem = element.closest(itemSelector);\n  const removeButton = element.closest(itemEliminator);\n  return tabBarItem?.contains(removeButton) ? null : keyExtractor(element, itemSelector);\n};\n\nconst findNextCurrentKey = <K>(currentKey: K, currTabs: K[], prevTabs: K[]) => {\n  const index = prevTabs.indexOf(currentKey);\n  if (index > 0) {\n    const nextIndex = index === prevTabs.length - 1 ? index - 1 : index + 1;\n    const nextKey = prevTabs[nextIndex];\n    if (currTabs.indexOf(nextKey) !== -1) {\n      return nextKey;\n    }\n  }\n  // update current key to be the first one if we can't find a suitable next key\n  return currTabs[0];\n};\n","import type { ComponentChildren } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { Ref } from 'preact';\nimport { forwardRef, useImperativeHandle } from 'preact/compat';\nimport { TabBarContext } from '../UNSAFE_TabBarCommon';\nimport { useTabBar } from './useTabBar';\nimport { styles } from './themes/TabBarMixedStyles.css';\n\ntype UseTabBarOptions = Parameters<typeof useTabBar>[0];\n\n/**\n * Component props expected to be pased to **TabBarMixed**.\n *\n * @see {@link TabBarMixed}\n */\ntype TabBarMixedProps<K extends string | number> = {\n  /**\n   * Component children that will be rendered within the **TabBarMixed**\n   * root element.\n   *\n   * It is expected that **TabBarLayout** and **ConveyorBelt** elements are\n   * provided. The same **TabBarItem**, **RemovableTabBarItem**,\n   * and **OverflowTabBarItem** elements should also be used.\n   */\n  children?: ComponentChildren;\n  /**\n   * Callback fired when a tab item is removed.\n   */\n  onRemove?: UseTabBarOptions['onRemove'];\n  /**\n   * Callback fired when a tab item is selected.\n   */\n  onSelect?: UseTabBarOptions['onSelect'];\n  /**\n   * The item key of the selected tab item.\n   */\n  selection?: K;\n  /**\n   * The height of the the tab bar.\n   *\n   * @default \"md\"\n   */\n  size?: UseTabBarOptions['size'];\n};\n\nexport type FocusableHandle = {\n  focus: () => void;\n  blur: () => void;\n};\n\n/**\n * A navigation component that enables horizontal navigation between distinct content with a mixture of static and dynamic tabs.\n *\n * @param {TabBarMixedProps} props TabBarMixed component props.\n * @returns {JSX.Element} TabBarMixed component element.\n */\nexport const TabBarMixed = forwardRef(\n  <K extends string | number>(\n    props: TabBarMixedProps<K>,\n    focusHandleRef?: Ref<FocusableHandle>\n  ) => {\n    const { children, onRemove, onSelect, selection, size } = props;\n\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    const { rootProps, tabBarContext } = useTabBar({\n      class: styles.tabBarBase,\n      edge: 'bottom',\n      onRemove,\n      onSelect,\n      ref: rootRef,\n      selection,\n      size,\n      children\n    });\n\n    //Allows to call focus on rootRef without having to expose it\n    useImperativeHandle(focusHandleRef!, () => ({\n      focus: () => {\n        if (rootRef.current) {\n          rootRef.current.focus();\n        }\n      },\n      blur: () => {\n        if (rootRef.current) {\n          rootRef.current.blur();\n        }\n      }\n    }));\n\n    return (\n      <TabBarContext.Provider value={tabBarContext}>\n        <div {...rootProps}>{children}</div>\n      </TabBarContext.Provider>\n    );\n  }\n);\n"],"names":["ITEM_SELECTOR","extractOnlyItemKey","element","itemSelector","itemEliminator","tabBarItem","closest","removeButton","contains","keyExtractor","findNextCurrentKey","currentKey","currTabs","prevTabs","index","indexOf","nextKey","length","TabBarMixed","forwardRef","props","focusHandleRef","children","onRemove","onSelect","selection","size","rootRef","useRef","rootProps","tabBarContext","options","class","className","display","edge","ref","tabId","useId","setCurrentKey","useState","tabItemPrefix","prevTabKeys","useEffect","current","tabKeys","Array","from","querySelectorAll","map","elem","getKey","includes","showFocusRing","focusRingProps","useCollectionFocusRing","currentKeyProps","useCurrentKey","undefined","getPrevNextKey","detail","value","eventProps","onKeyDown","event","key","onFocus","getFirstVisibleKey","mergeProps","role","tabIndex","isEdgeBottom","layout","useTabBar","styles","tabBarBase","useImperativeHandle","focus","blur","_jsx","TabBarContext","Provider"],"mappings":"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"}