{"version":3,"file":"useTabBar-2c4573fe.js","sources":["../../src/hooks/PRIVATE_useTabBar/useTabBar.ts"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  getPrevNextKeyUsingRef,\n  getFirstVisibleKey,\n  getKey,\n  keyExtractor,\n  findElementByKey\n} from '../../utils/PRIVATE_collectionUtils';\nimport { useCollectionFocusRing } from '../PRIVATE_useCollectionFocusRing';\nimport { useCurrentKey } from '../PRIVATE_useCurrentKey';\nimport { useId } from '../UNSAFE_useId';\n\nimport type { ComponentProps, ContextType, RefObject } from 'preact';\nimport type { TabBarContext, TabBarLayout } from '../../UNSAFE_TabBarCommon';\nimport { useReorderableContext } from '../../hooks/PRIVATE_useReorderable/useReorderableContext';\nimport { Menu } from '../../UNSAFE_Menu';\nimport { TabBarItemContext, TabBarContextMenuConfig } from '../../UNSAFE_TabBarCommon';\nimport { useContextMenuGesture } from '../../hooks/UNSAFE_useContextMenuGesture';\n\ntype TabBarContextValue = ContextType<typeof TabBarContext>;\n\nexport type useTabBarOptions<K extends string | number> = {\n  class?: string;\n  display?: TabBarContextValue['display'];\n  edge?: 'bottom' | 'top';\n  onRemove?: TabBarContextValue['onRemove'];\n  onSelect?: TabBarContextValue['onSelect'];\n  ref?: RefObject<HTMLDivElement>;\n  selection?: TabBarContextValue['selection'];\n  size?: TabBarContextValue['size'];\n  children?: ComponentProps<typeof TabBarLayout>['children'];\n  contextMenuConfig?: TabBarContextMenuConfig<K>;\n};\n\nconst ITEM_SELECTOR = '[role=\"tab\"]';\nconst REMOVABLE_ICON_SELECTOR = '[data-oj-tabbar-item-remove-icon=\"true\"]';\nconst REMOVABLE_ITEM_ATTRIBUTE = 'data-oj-removable';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\n/**\n * Implements TabBar behavior for focus and keyboad handling\n */\nexport function useTabBar<K extends string | number>(options: useTabBarOptions<K>) {\n  const {\n    children,\n    class: className,\n    display,\n    edge = 'top',\n    selection,\n    onSelect,\n    onRemove,\n    ref: userRef,\n    size,\n    contextMenuConfig\n  } = options;\n\n  const internalRef = useRef<HTMLDivElement>(null);\n  const rootRef = userRef || internalRef;\n\n  const tabId = useId();\n  const [currentKey, setCurrentKey] = useState<K | undefined>(selection as K);\n  const [hideTooltip, setHideTooltip] = useState(false);\n\n  const tabItemPrefix = tabId + '_';\n\n  /**\n   * A reference to the previous set of tab keys that this TabBar\n   * contains before children were re-rendered. In the event the \"current\" tab\n   * is removed and the \"currentKey\" reference is broken, we can redirect\n   * the \"currentKey\" to another tab based on the index of the removed tab.\n   */\n  const prevTabKeys = useRef<(string | number | undefined)[]>();\n\n  useEffect(() => {\n    if (rootRef.current) {\n      const tabKeys = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR)).map((elem) =>\n        getKey(elem as HTMLElement)\n      );\n      if (currentKey && !tabKeys.includes(currentKey as K)) {\n        //If prevTabs does not exist set the first visible key as currentKey\n        prevTabKeys.current\n          ? setCurrentKey(findNextValidKey(currentKey, tabKeys, prevTabKeys.current) as K)\n          : setCurrentKey(tabKeys[0] as K);\n      }\n      prevTabKeys.current = tabKeys;\n    }\n  }, [children, currentKey, rootRef]);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n    'ArrowRight',\n    'ArrowLeft',\n    'Home',\n    'End'\n  ]);\n\n  const reorderableContext = useReorderableContext();\n  const { currentKeyProps } = useCurrentKey(\n    (element) =>\n      onRemove\n        ? extractOnlyItemKey(element, ITEM_SELECTOR, REMOVABLE_ICON_SELECTOR)\n        : keyExtractor(element, ITEM_SELECTOR),\n    false,\n    undefined,\n    undefined,\n    getPrevNextKeyUsingRef(rootRef, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKeyUsingRef(rootRef, currentKey, false, ITEM_SELECTOR),\n    currentKey,\n    (detail) => {\n      const key = detail.value as K;\n      setCurrentKey(key);\n      setHideTooltip(false);\n    }\n  );\n\n  useEffect(() => {\n    if (reorderableContext) {\n      reorderableContext.currentItemKey.current = currentKey;\n    }\n  }, [currentKey, reorderableContext]);\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (rootRef.current && currentKey) {\n      if (event.key === 'Home' || event.key === 'End') {\n        const tabBarItemKey = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR), (elem) =>\n          getKey(elem as HTMLElement)\n        );\n        event.preventDefault();\n        setCurrentKey?.(tabBarItemKey[event.key === 'Home' ? 0 : tabBarItemKey.length - 1] as K);\n      }\n      if (event.key === 'Enter' || event.key === ' ') {\n        event.preventDefault();\n        onSelect?.({ value: currentKey });\n      }\n      if (event.key === 'Delete') {\n        const tabBarItem = findElementByKey(\n          rootRef.current,\n          currentKey,\n          ITEM_SELECTOR\n        ) as HTMLElement;\n        if (tabBarItem.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n          onRemove?.({ value: currentKey });\n        }\n      }\n      if (event.key === 'Escape') {\n        setHideTooltip(true);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (rootRef.current && currentKey === undefined) {\n      const key = getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);\n      if (key) {\n        setCurrentKey(key as K);\n      }\n    }\n  };\n\n  const [contextMenuContext, setContextMenuContext] = useState<TabBarItemContext<K>>();\n\n  const [menuProps, setMenuProps] = useState<MenuProps>(initialMenuProps);\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      let anchorBasedOnGesture = anchor;\n      if (gesture === 'keyboard') {\n        //We find the element where the position of the menu is going to be based of\n        const elem = findElementByKey(\n          rootRef.current as HTMLElement,\n          currentKey as K,\n          ITEM_SELECTOR\n        );\n\n        //We set the correct anchor\n        anchorBasedOnGesture = elem ? elem : anchor;\n\n        const context = { itemKey: currentKey };\n\n        setContextMenuContext(context as TabBarItemContext<K>);\n      } else {\n        //We search for the key using the target of the event\n        const key = keyExtractor(target as HTMLElement, ITEM_SELECTOR);\n\n        const context = { itemKey: key };\n\n        setContextMenuContext(context as TabBarItemContext<K>);\n      }\n      setMenuProps({\n        ...menuPropGestureStates[gesture],\n        anchorRef: { current: anchorBasedOnGesture },\n        isOpen: true\n      });\n    },\n    {\n      isDisabled: !contextMenuConfig //If there is no a context menu renderer we disable the hook\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      //Focus has to be set on the current target that was obtained\n      //during context menu gesture when menu is dismissed or item is \"selected\"\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        setCurrentKey(contextMenuContext?.itemKey);\n        rootRef.current?.focus();\n      }\n      // We close the menu.The only prop that matters here is isOpen\n      setMenuProps({ ...initialMenuProps });\n    },\n    [rootRef, contextMenuContext?.itemKey]\n  );\n\n  const eventProps = mergeProps({ onKeyDown, onFocus }, triggerProps);\n\n  return {\n    rootProps: mergeProps(\n      {\n        'aria-activedescendant': currentKey ? tabItemPrefix + currentKey : '',\n        'aria-multiselectable': false,\n        class: className,\n        ref: rootRef,\n        role: 'tablist',\n        tabIndex: 0\n      },\n      currentKeyProps,\n      focusRingProps,\n      eventProps\n    ),\n    tabBarContext: {\n      currentKey,\n      display,\n      isEdgeBottom: edge === 'bottom',\n      layout: 'condense',\n      onRemove,\n      onSelect,\n      showFocusRing,\n      hideTooltip,\n      selection,\n      size,\n      tabItemPrefix\n    },\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    contextMenuContext\n  } as const;\n}\n\n//useCurrentKey use click capture that captures first click, which is on remove button\n//when we remove and sets the item being removed to currentKey. So we should not allow\n//this if click is on remove button\nconst extractOnlyItemKey = (element: HTMLElement, itemSelector: string, itemEliminator: string) => {\n  const tabBarItem = element.closest(itemSelector);\n  if (tabBarItem) {\n    if (tabBarItem.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n      const removeButton = element.closest(itemEliminator);\n      if (removeButton && tabBarItem?.contains(removeButton)) {\n        return null;\n      }\n    }\n    return getKey(tabBarItem as HTMLElement);\n  }\n  return null;\n};\n\nconst findNextValidKey = <K>(currentKey: K, currTabs: K[], prevTabs: K[]) => {\n  const index = prevTabs.indexOf(currentKey);\n  // update current key to be the first one if currentKey is invalid\n  if (index === -1) {\n    return currTabs[0];\n  }\n  let nextIndex = 0;\n  let isLastKey = false;\n  if (index === prevTabs.length - 1) {\n    nextIndex = index - 1;\n    isLastKey = true;\n  } else {\n    nextIndex = index + 1;\n  }\n  while (nextIndex !== index && nextIndex > -1 && nextIndex < prevTabs.length) {\n    const nextKey = prevTabs[nextIndex];\n    if (currTabs.indexOf(nextKey) !== -1) {\n      return nextKey;\n    }\n    isLastKey ? nextIndex-- : nextIndex++;\n  }\n  // update current key to be the first one if we can't find a suitable next key\n  return currTabs[0];\n};\n"],"names":["ITEM_SELECTOR","REMOVABLE_ITEM_ATTRIBUTE","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","initialMenuProps","isOpen","anchorRef","current","extractOnlyItemKey","element","itemSelector","itemEliminator","tabBarItem","closest","hasAttribute","removeButton","contains","getKey","findNextValidKey","currentKey","currTabs","prevTabs","index","indexOf","nextIndex","isLastKey","length","nextKey","options","children","class","className","display","edge","selection","onSelect","onRemove","ref","userRef","size","contextMenuConfig","internalRef","useRef","rootRef","tabId","useId","setCurrentKey","useState","hideTooltip","setHideTooltip","tabItemPrefix","prevTabKeys","useEffect","tabKeys","Array","from","querySelectorAll","map","elem","includes","showFocusRing","focusRingProps","useCollectionFocusRing","reorderableContext","useReorderableContext","currentKeyProps","useCurrentKey","keyExtractor","undefined","getPrevNextKeyUsingRef","detail","key","value","currentItemKey","contextMenuContext","setContextMenuContext","menuProps","setMenuProps","triggerProps","useContextMenuGesture","gesture","anchor","target","anchorBasedOnGesture","findElementByKey","itemKey","isDisabled","handleCloseContextMenu","useCallback","reason","focus","eventProps","mergeProps","onKeyDown","event","tabBarItemKey","preventDefault","onFocus","getFirstVisibleKey","rootProps","role","tabIndex","tabBarContext","isEdgeBottom","layout","onClose"],"mappings":"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"}