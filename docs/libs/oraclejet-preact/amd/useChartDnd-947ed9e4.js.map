{"version":3,"file":"useChartDnd-947ed9e4.js","sources":["../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_visSVGUtils/areaUtils.ts","../../src/hooks/PRIVATE_useChartDnd/useChartDnd.ts","../../src/hooks/PRIVATE_useChartDnd/dndChartUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Dimension, MarkerShapes } from '../UNSAFE_visTypes/common';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { curveThroughPoints } from '../PRIVATE_visSVGUtils/pathUtils';\nimport { Scale, Group, ChartSeriesData, ChartItemData } from '../UNSAFE_visTypes/chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '../../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getStraightAreaPath, getCurveAreaPath } from '../PRIVATE_visSVGUtils/areaUtils';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\n\nconst LABEL_OFFSET = 15;\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: 'straight' | 'curved',\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean\n) {\n  if (areaType === 'straight') {\n    return getStraightAreaPath(lineSegmentCoords, bottomCoords);\n  }\n  return getCurveAreaPath(\n    lineSegmentCoords,\n    bottomCoords,\n    false,\n    isHoriz ? 'mh' : 'mv',\n    isBottomSegmentCurved\n  );\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: 'curved' | 'straight' | 'none',\n  isHoriz: boolean\n) {\n  if (lineType === 'straight') {\n    return lineSegmentCoords.join(' ');\n  }\n  return curveThroughPoints(lineSegmentCoords, false, isHoriz ? 'mh' : 'mv');\n}\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends { value: number; id: K }>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: (number | undefined)[][] = Array(numSeries)\n    .fill(numGroups)\n    .map(() => {\n      return new Array(numGroups);\n    });\n  for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n    let prevValidTotal = undefined;\n    for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (\n        !item ||\n        hiddenIds?.has(item.id) ||\n        (isLog && item.value !== undefined && item.value <= 0)\n      ) {\n        series[seriesIndex][groupIndex] = undefined;\n        continue;\n      }\n\n      if (seriesIndex > 0 && prevValidTotal != null) {\n        const prev = series[seriesIndex - 1][groupIndex];\n        if (prev != null) {\n          series[seriesIndex][groupIndex] = prev + item.value;\n        } else {\n          series[seriesIndex][groupIndex] = prevValidTotal + item.value;\n        }\n      } else {\n        series[seriesIndex][groupIndex] = item.value;\n        prevValidTotal = item.value;\n      }\n    }\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: (number[] | { x: number; y: number }[])[] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] | { x: number; y: number }[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (\n        !item ||\n        hiddenIds?.has(item.id) ||\n        (isLog && item.value !== undefined && item.value <= 0)\n      ) {\n        continue;\n      }\n      currentSeries[groupIndex] =\n        item.value !== undefined ? item.value : { x: item.x! as number, y: item.y! }; // TODO : Need fix for x as number\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      if (isMarkerDisplayed) {\n        // TODO: settle on one visual for selected markers: \n        // Selected effect when markers are turned on\n        fill = itemColor || seriesColor;\n        outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        // Selected effect when markers are not turned on\n        fill = rgb(colorSchemeVars.palette.neutral[0]);\n        if (isHovered || isFocused) {\n          stroke = itemColor || seriesColor;\n        } else {\n          stroke = rgb(colorSchemeVars.palette.neutral[130]);\n        }\n      }\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  yScale: Scale,\n  xScale: Scale,\n  data: (number | undefined)[] | { x: number; y: number }[],\n  startIndex: number,\n  endIndex: number,\n  isHorizontal: boolean,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency',\n  hasXYValues?: boolean\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    let item, value, valueX, valueY;\n    if (hasXYValues) {\n      item = data[groupIndex] as { x: number; y: number };\n      valueX = item?.x;\n      valueY = item?.y;\n    } else {\n      item = data[groupIndex] as number;\n      value = item;\n    }\n    if (item == null || (isLog && value! <= 0 && valueX! <= 0 && valueY! <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    let x, y;\n\n    if (hasXYValues) {\n      x = xScale.transform(valueX!);\n      y = yScale.transform(valueY!);\n    } else {\n      x = isHorizontal\n        ? yScale.transform(value!)\n        : getGroupCenterCoord<K, D>(\n            groups[groupIndex],\n            groupIndex,\n            xScale,\n            getDataItem(seriesIndex, groupIndex)!,\n            timeAxisType\n          );\n      y = isHorizontal\n        ? getGroupCenterCoord<K, D>(\n            groups[groupIndex],\n            groupIndex,\n            xScale,\n            getDataItem(seriesIndex, groupIndex)!,\n            timeAxisType\n          )\n        : yScale.transform(value!);\n    }\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getLabelPosition(\n  labelPosition: 'belowMarker' | 'aboveMarker' | 'beforeMarker' | 'afterMarker' | 'center',\n  tx?: number,\n  ty?: number,\n  labelDims?: Dimension\n) {\n  if (labelPosition === 'aboveMarker') {\n    ty = ty! - LABEL_OFFSET;\n  } else if (labelPosition === 'belowMarker') {\n    ty = ty! + LABEL_OFFSET;\n  } else if (labelPosition === 'afterMarker') {\n    tx = tx! + labelDims?.width! / 2 + LABEL_OFFSET;\n  } else if (labelPosition === 'beforeMarker') {\n    tx = tx! - labelDims?.width! / 2 - LABEL_OFFSET;\n  }\n\n  return { x: tx, y: ty };\n}\n\n// JET-71237 optimize this function\nexport const findSeriesGroupIndexFromId = <K, D>(\n  series: ChartSeriesData<K, D>[],\n  id: K,\n  groups: Group[],\n  getDataItem?: (seriesIndex: number, groupIndex: number) => D | undefined\n) => {\n  for (let i = 0; i < series.length; i++) {\n    for (let j = 0; j < groups.length; j++) {\n      const item = getDataItem && getDataItem(i, j);\n      if (item && (item as unknown as ChartItemData<K>).id === id) {\n        return {\n          seriesIndex: i,\n          groupIndex: j\n        };\n      }\n    }\n  }\n  return {\n    seriesIndex: 0,\n    groupIndex: 0\n  };\n};\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point } from './lineUtils';\nimport { curveThroughPoints } from './pathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getStraightAreaPath(lineSegmentCoords: Point[], bottomCoords: Point[]) {\n  // Create the path data string\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    pathData =\n      lineSegmentCoords\n        .map((lineSegmentCoord, index) => {\n          return `${index === 0 ? 'M' : 'L'} ${lineSegmentCoord[0]} ${lineSegmentCoord[1]}`;\n        })\n        .join(' ') +\n      [...bottomCoords]\n        .reverse()\n        .map((bottomCoord) => {\n          return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n        })\n        .join(' ') +\n      'Z';\n  }\n  return pathData;\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport type { Dispatch, StateUpdater } from 'preact/hooks';\nimport type {\n  ChartDndProps,\n  Group,\n  ChartSeriesData,\n  DragStartDetail,\n  DropDetail,\n  ChartItemData,\n  SelectionDetail\n} from '#utils/UNSAFE_visTypes/chart';\nimport {\n  getChartDragContext,\n  getChartDropContext,\n  isChartDraggable,\n  getDragImageElements\n} from '#hooks/PRIVATE_useChartDnd/dndChartUtils';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { DragImageProps, useDnd } from '#hooks/PRIVATE_useVisDnd';\n\ntype Props<K, D> = {\n  groups: Group[];\n  series: ChartSeriesData<K, D>[];\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined;\n  rootRef: RefObject<HTMLDivElement>;\n  xSpace: Dimension;\n  ySpace: Dimension;\n  plotAreaSpace: Dimension;\n  selectedIds: Set<K>;\n  setDragOver: Dispatch<StateUpdater<{ accepted: boolean | undefined; type: string }>>;\n  setDatatipDisabled: Dispatch<StateUpdater<boolean>>;\n  onSelectionChange?: SelectionDetail<K, D>;\n} & ChartDndProps<D>;\n\nexport const useChartDnd = <K, D extends ChartItemData<K>>({\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  onDragEnter,\n  onDragLeave,\n  onDragOver,\n  onDrop,\n  rootRef,\n  series,\n  selectedIds,\n  groups,\n  getDataItem,\n  groupDraggable,\n  itemsDraggable,\n  xSpace,\n  ySpace,\n  plotAreaSpace,\n  setDragOver,\n  setDatatipDisabled,\n  onSelectionChange\n}: Props<K, D>) => {\n  const draggable = isChartDraggable(series, groups, getDataItem, groupDraggable, itemsDraggable);\n\n  const getDragContext = function (target: HTMLElement, event: DragEvent) {\n    return getChartDragContext<K, D>(\n      target,\n      groups,\n      rootRef,\n      event,\n      selectedIds,\n      series,\n      getDataItem,\n      groupDraggable,\n      itemsDraggable\n    );\n  };\n  const getDropContext = function (event: DragEvent) {\n    const context = getChartDropContext(xSpace, ySpace, plotAreaSpace, event);\n    return context;\n  };\n  const getChartDragImage = function (props: DragImageProps<DragStartDetail<D>>) {\n    return getDragImageElements(rootRef, props.context, props.event);\n  };\n\n  const onPreDndStart = function (context: DragStartDetail<D>) {\n    if (context?.type === 'items') {\n      const items = context.items;\n      const ids = items.map((item) => item.data.id);\n      const data = items.map((item) => item.data);\n      onSelectionChange?.({ ids: [...ids], data: [...data] });\n    }\n  };\n\n  const showDropEffect = function (context: DropDetail) {\n    setDragOver({\n      accepted: true,\n      type: context.type\n    });\n  };\n\n  const showRejectedDropEffect = function (context: DropDetail) {\n    setDragOver({\n      accepted: false,\n      type: context.type\n    });\n  };\n\n  const clearDropEffect = function () {\n    setDragOver({\n      accepted: undefined,\n      type: ''\n    });\n  };\n\n  const { dragProps, dropProps, content } = useDnd<DragStartDetail<D>, DropDetail>({\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragLeave,\n    onDragOver,\n    onDrop,\n    getDragContext,\n    getDropContext,\n    getDragImage: getChartDragImage,\n    onPreDndStart,\n    setDatatipDisabled,\n    showRejectedDropEffect,\n    showDropEffect,\n    clearDropEffect\n  });\n  return {\n    draggable: draggable,\n    dndProps: draggable ? { ...dragProps, ...dropProps } : dropProps,\n    dndContent: content\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport type {\n  Group,\n  DragStartDetail,\n  ChartSeriesData,\n  DropDetail,\n  ChartItemData\n} from '#utils/UNSAFE_visTypes/chart';\nimport { getInfo, inSpace } from '#utils/UNSAFE_visUtils';\nimport type { RefObject } from 'preact';\nimport { findSeriesGroupIndexFromId } from '#utils/PRIVATE_chartUtils/utils';\n\nexport function getChartDragContext<K, D extends ChartItemData<K>>(\n  target: HTMLElement,\n  groups: Group[],\n  rootRef: RefObject<HTMLElement>,\n  event: DragEvent,\n  selectedIds: Set<K>,\n  series: ChartSeriesData<K, D>[],\n  getDataItem?: (seriesIndex: number, groupIndex: number) => D | undefined,\n  groupDraggable?: (group: Group) => 'on' | 'off',\n  itemsDraggable?: (data: D, seriesIndex: number, groupIndex: number) => 'on' | 'off'\n) {\n  //We search for the key using the target of the event\n  const info = getInfo(rootRef, target);\n  const seriesIndex = info ? info.seriesIndex : undefined;\n  const groupIndex = info ? info.groupIndex : undefined;\n  let context;\n  if (\n    seriesIndex !== undefined &&\n    groupIndex !== undefined &&\n    getDataItem?.(seriesIndex, groupIndex)\n  ) {\n    const currentData = getDataItem(seriesIndex, groupIndex)! as D;\n    if (itemsDraggable && itemsDraggable(currentData, seriesIndex, groupIndex) == 'on') {\n      const data = [];\n      if (selectedIds.size > 1 && selectedIds.has(currentData.id)) {\n        const iterator = selectedIds.values();\n        let current = iterator.next().value;\n        while (current !== undefined) {\n          const { seriesIndex, groupIndex } = findSeriesGroupIndexFromId(\n            series,\n            current,\n            groups,\n            getDataItem\n          );\n          data.push({\n            data: getDataItem(seriesIndex, groupIndex),\n            seriesIndex,\n            groupIndex\n          });\n          current = iterator.next().value;\n        }\n      } else {\n        data.push({\n          data: getDataItem(seriesIndex, groupIndex),\n          seriesIndex,\n          groupIndex\n        });\n      }\n      context = {\n        items: data,\n        type: 'items',\n        event\n      } as DragStartDetail<D>;\n    }\n  } else if (groupIndex !== undefined) {\n    if (groupDraggable && groupDraggable(groups[groupIndex])) {\n      context = {\n        group: groups[groupIndex],\n        groupIndex: groupIndex,\n        type: 'xAxisTickLabel',\n        event\n      } as DragStartDetail<D>;\n    }\n  }\n  return context as DragStartDetail<D>;\n}\n\nexport function getChartDropContext(\n  xSpace: Dimension,\n  ySpace: Dimension,\n  plotAreaSpace: Dimension,\n  event: DragEvent\n) {\n  //We search for the key using the target of the event\n  const offSetX = event.offsetX;\n  const offSetY = event.offsetY;\n  let context;\n  if (inSpace(offSetX, offSetY, xSpace)) {\n    context = {\n      type: 'xAxis',\n      x: offSetX - xSpace.x,\n      event\n    };\n  } else if (inSpace(offSetX, offSetY, ySpace)) {\n    context = {\n      type: 'yAxis',\n      y: offSetY - ySpace.y,\n      event\n    };\n  } else if (inSpace(offSetX, offSetY, plotAreaSpace)) {\n    context = {\n      type: 'plotArea',\n      x: offSetX - plotAreaSpace.x,\n      y: offSetY - plotAreaSpace.y,\n      event\n    };\n  }\n  return context as DropDetail;\n}\n\nexport function isChartDraggable<K, D>(\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  groupDraggable?: (group: Group) => 'on' | 'off',\n  itemsDraggable?: (data: D, seriesIndex: number, groupIndex: number) => 'on' | 'off'\n) {\n  if (groupDraggable) {\n    for (let i = 0; i < groups.length; i++) {\n      if (groupDraggable(groups[i]) === 'on') {\n        return true;\n      }\n    }\n  }\n  if (itemsDraggable && getDataItem) {\n    for (let i = 0; i < groups.length; i++) {\n      for (let j = 0; j < series.length; j++) {\n        if (getDataItem(j, i) && itemsDraggable(getDataItem(j, i)!, j, i) === 'on') {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport function getDragImageElements<D>(\n  rootRef: RefObject<Element>,\n  context: DragStartDetail<D>,\n  event: DragEvent\n) {\n  const elems = [];\n  let elem;\n  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n  let width;\n  let height;\n\n  if (context?.type === 'items') {\n    const items = context.items;\n    // only component specific\n    for (let i = 0; i < items.length; i++) {\n      elem = rootRef.current?.querySelector(\n        `[data-oj-series-index=\"${items[i].seriesIndex}\"][data-oj-group-index=\"${items[i].groupIndex}\"]`\n      );\n      if (elem) elems.push(elem);\n    }\n  } else if (context?.type === 'xAxisTickLabel') {\n    elem = rootRef.current?.querySelector(`[data-oj-group-index=\"${context?.groupIndex}\"]`);\n    if (elem) elems.push(elem);\n  }\n  if (elems.length > 0) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    const bboxs = [];\n    for (let i = 0; i < elems.length; i++) {\n      const bbox = (elems[i] as SVGGraphicsElement).getBBox();\n      if (bbox.x < minX) {\n        minX = bbox.x;\n      }\n      if (bbox.x + bbox.width > maxX) {\n        maxX = bbox.x + bbox.width;\n      }\n      if (bbox.y < minY) {\n        minY = bbox.y;\n      }\n      if (bbox.y + bbox.height > maxY) {\n        maxY = bbox.y + bbox.height;\n      }\n      bboxs.push(bbox);\n    }\n    // Call getComputedStyles for font on the rootref\n    const styles = window.getComputedStyle(elems[0].parentElement!);\n    for (let i = 0; i < elems.length; i++) {\n      elem = elems[i];\n      const clone = elem.cloneNode(true) as SVGGraphicsElement;\n      container.appendChild(clone);\n    }\n    container.setAttribute('transform', `translate(${-minX},${-minY})`);\n    container.style.fontSize = styles.getPropertyValue('font-size');\n    container.style.fontFamily = styles.getPropertyValue('font-family');\n    container.style.textAnchor = styles.getPropertyValue('text-anchor');\n    container.style.dominantBaseline = styles.getPropertyValue('dominant-baseline');\n    width = maxX - minX;\n    height = maxY - minY;\n    svg.appendChild(container);\n    return {\n      image: svg,\n      offSetX: event.offsetX - minX,\n      offSetY: event.offsetY - minY,\n      width,\n      height\n    };\n  }\n  return null;\n}\n"],"names":["findSeriesGroupIndexFromId","series","id","groups","getDataItem","i","length","j","item","seriesIndex","groupIndex","lineSegmentCoords","bottomCoords","areaType","isHoriz","isBottomSegmentCurved","pathData","map","lineSegmentCoord","index","join","reverse","bottomCoord","getStraightAreaPath","connectWithLine","splineType","curveThroughPoints","getCurveAreaPath","lineType","numSeries","numGroups","hiddenIds","isLog","Array","fill","prevValidTotal","has","undefined","value","prev","labelPosition","tx","ty","labelDims","width","x","y","yScale","xScale","data","startIndex","endIndex","isHorizontal","timeAxisType","hasXYValues","segments","currentPath","valueX","valueY","push","transform","getGroupCenterCoord","isMarkerDisplayed","isSelectionEnabled","isHovered","isFocused","isSelected","seriesColor","itemColor","stroke","outerStroke","rgb","colorSchemeVars","palette","neutral","rgba","currentSeries","onDragStart","onDrag","onDragEnd","onDragEnter","onDragLeave","onDragOver","onDrop","rootRef","selectedIds","groupDraggable","itemsDraggable","xSpace","ySpace","plotAreaSpace","setDragOver","setDatatipDisabled","onSelectionChange","draggable","isChartDraggable","dragProps","dropProps","content","useDnd","getDragContext","target","event","info","getInfo","context","currentData","size","iterator","values","current","next","items","type","group","getChartDragContext","getDropContext","offSetX","offsetX","offSetY","offsetY","inSpace","getChartDropContext","getDragImage","props","elems","elem","svg","document","createElementNS","container","height","querySelector","minX","Infinity","minY","maxX","maxY","bbox","getBBox","styles","window","getComputedStyle","parentElement","clone","cloneNode","appendChild","setAttribute","style","fontSize","getPropertyValue","fontFamily","textAnchor","dominantBaseline","image","getDragImageElements","onPreDndStart","ids","showRejectedDropEffect","accepted","showDropEffect","clearDropEffect","dndProps","dndContent"],"mappings":"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"}