{"version":3,"file":"PictoChart-551d106b.js","sources":["../../src/UNSAFE_PictoChart/PictoChartContext.tsx","../../src/UNSAFE_PictoChart/PictoChartUtils.tsx","../../src/UNSAFE_PictoChart/PictoChartElement.tsx","../../src/UNSAFE_PictoChart/PictoChartLayoutUtils.ts","../../src/UNSAFE_PictoChart/PictoChartNavUtils.ts","../../src/UNSAFE_PictoChart/useEvents.ts","../../src/UNSAFE_PictoChart/PictoChart.tsx","../../src/UNSAFE_PictoChart/usePictoChartDatatip.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\ntype PictoChartContextValue = {\n  supportsSelection?: boolean;\n};\n\nconst PictoChartContext = createContext<PictoChartContextValue>({} as PictoChartContextValue);\nconst usePictoChartContext = () => useContext(PictoChartContext);\n\nexport { PictoChartContext, usePictoChartContext };\n","import { ComponentChildren } from 'preact';\nimport type {\n  ItemInfo,\n  PictoChartItem,\n  MarkerRendererContext,\n  PictoRendererOptions,\n  DatatipContext\n} from './PictoChart.type';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { MarkerShapes } from '../UNSAFE_SvgShapes';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { rgb } from '../UNSAFE_Theme';\nimport { SvgSymbol } from '../UNSAFE_SvgShapes';\nimport { usePictoChartContext } from './PictoChartContext';\nimport { Property } from 'csstype';\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlightedIds?: K[]) {\n  if (!highlightedIds || highlightedIds.length === 0) {\n    return true;\n  }\n  return new Set(highlightedIds).has(id);\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param selectedIds The set of highlighted item\n */\nexport function isItemSelected<K>(id: K, selectedIds?: K[]) {\n  if (!selectedIds || selectedIds.length === 0) {\n    return false;\n  }\n  return new Set(selectedIds).has(id);\n}\n\n/**\n * Returns the value of the data-oj-item-index attribute for a given element.\n * @param element The HTML element.\n */\nexport function getItemInfo(element: HTMLElement) {\n  const itemIdx = element.dataset['idx'];\n  if (itemIdx === undefined) return;\n\n  return {\n    idx: Number(itemIdx)\n  };\n}\n\n/**\n * Returns the item props for PictoChart.\n * @param item The picto chart item.\n * @param itemId The item index of the item.\n * @param focusedItem The info of currently focused item.\n * @param isReadOnly Whether the picto chart is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param hiddenIds The hidden ids.\n * @param highlightedIds The highlighted ids.\n */\nexport function getItemProps<K, D extends PictoChartItem<K>>(\n  item: D,\n  itemIdx: number,\n  countIdx: number,\n  isReadOnly: boolean,\n  hoveredItem?: ItemInfo,\n  selectedIds?: Array<K>,\n  focusedItem?: ItemInfo,\n  highlightedIds?: Array<K>,\n  activeId?: string\n) {\n  let isCurrent = false;\n  if (!isReadOnly) {\n    const isFocusedItem = !!focusedItem && itemIdx === focusedItem.idx;\n    const isHoveredItem = !!hoveredItem && itemIdx === hoveredItem.idx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem?.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n  const isHighlighted = isItemHighlighted(item.id, highlightedIds);\n  const isSelected = isItemSelected(item.id, selectedIds);\n  const hasSelection = selectedIds && selectedIds.length !== 0;\n\n  return {\n    isCurrent,\n    isHighlighted: isHighlighted,\n    isSelected: isSelected,\n    hasSelection,\n    isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,\n    key: item.id,\n    itemIdx,\n    countIdx,\n    activeId: isCurrent ? activeId : undefined,\n    isReadOnly,\n    item: item\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport function isEqualItem(item1?: ItemInfo, item2?: ItemInfo) {\n  return item1?.idx === item2?.idx;\n}\n\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemIdx Item index\n */\nexport function hasFocusRing(itemInfo: ItemInfo, itemIdx: number) {\n  if (!itemInfo.isFocusVisible) return false;\n  return itemInfo.idx === itemIdx;\n}\n\n/**\n *\n */\nexport function getCountWithTotal(itemCount: number, totalCount: number, translations: BundleType) {\n  const totalWithCountLabel = `${translations?.dataVisualization_labelCountWithTotal({\n    itemCount: itemCount.toString(),\n    totalCount: totalCount.toString()\n  })}`;\n  return totalWithCountLabel;\n}\n\n/**\n * Returns the aria properties for the picto chart.\n * @param isReadOnly { boolean } If the picto chart is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getItemAriaProps(\n  itemCount: number,\n  totalCount: number,\n  supportsSelection: boolean,\n  label?: string,\n  translations?: BundleType,\n  isSelected?: boolean,\n  hasSelection?: boolean,\n  accessibleLabel?: string,\n  activeId?: string\n): {\n  'aria-label'?: HTMLAttributesSignalExcluded['aria-label'];\n  role: HTMLAttributesSignalExcluded['role'];\n  id?: string;\n} {\n  const selectionAriaLabel =\n    !supportsSelection && !hasSelection\n      ? ''\n      : isSelected\n      ? translations?.dataVisualization_stateSelected()\n      : translations?.dataVisualization_stateUnselected();\n\n  const totalWithCountLabel = translations\n    ? getCountWithTotal(itemCount, totalCount, translations)\n    : '';\n\n  return {\n    'aria-label':\n      [\n        accessibleLabel || `${label ? label + ': ' : ''}${totalWithCountLabel}`, // TODO: use a translation string for :\n        selectionAriaLabel\n      ]\n        .filter(Boolean)\n        .join('. ') || undefined,\n    role: 'img',\n    id: activeId\n  };\n}\n\n/**\n * Returns the marker props for SVGSymbol\n */\nexport function getMarkerProps(\n  shape: MarkerShapes,\n  color?: string,\n  isFocused?: boolean,\n  isSelected?: boolean,\n  isCurrent?: boolean,\n  supportsSelection?: boolean\n) {\n  const isHuman = shape === 'human';\n  const applyHover = isFocused || (isCurrent && supportsSelection);\n  const isNoneEqualSides = shape === 'ellipse' || shape === 'rectangle';\n  const outerBorderColor = isSelected\n    ? rgb(colorSchemeVars.palette.neutral[130])\n    : applyHover\n    ? color\n    : undefined;\n\n  return {\n    markerShape: shape,\n    tx: isHuman ? 70 : undefined,\n    ty: isHuman ? 60 : undefined,\n    markerColor: color,\n    borderColor: isSelected || applyHover ? rgb(colorSchemeVars.palette.neutral[0]) : color,\n    outerBorderColor,\n    markerScale: isNoneEqualSides && !outerBorderColor ? 1 : 0.85,\n    setAspectRatioNone: isNoneEqualSides ? true : false\n  };\n}\n\n// Creating component to read the context\nconst PictoRenderer = <K,>({\n  context,\n  markerProps\n}: {\n  context: MarkerRendererContext<K>;\n  markerProps: PictoRendererOptions;\n}) => {\n  const { supportsSelection } = usePictoChartContext();\n  const markerProp = getMarkerProps(\n    markerProps.shape,\n    markerProps.color,\n    context.state.focused,\n    context.state.selected,\n    context.state.hovered,\n    supportsSelection\n  );\n\n  return <SvgSymbol {...markerProp} />;\n};\n\n/**\n * Returns the marker renderer for SVGSymbol\n */\nexport function getPictoDefaultRenderers<K, D extends PictoChartItem<K> = PictoChartItem<K>>(\n  rendererOptions: (data: D) => PictoRendererOptions\n) {\n  return {\n    markerRenderer: (context: MarkerRendererContext<D>) => {\n      const props = rendererOptions(context.data); // TODO: should we add default values\n      return <PictoRenderer context={context} markerProps={props} />;\n    },\n    datatipRenderer: (context: DatatipContext<D>) => {\n      const props = rendererOptions(context.data);\n      return { borderColor: props.color };\n    }\n  };\n}\n\nexport function getTotalCount<K>(items: PictoChartItem<K>[]) {\n  let totalCount = 0;\n  for (let i = 0; i < items.length; i++) {\n    totalCount += items[i].count || 1;\n  }\n  return totalCount;\n}\n\n/**\n * Returns the text for the picto chart datatip.\n * @param items The picto chart items data.\n * @param focusedItem The item currently keyboard focused.\n * @param hoveredItem The item that is currently hovered.\n * @param datatip The datatip.\n */\nexport function getDatatipContent<K, D extends PictoChartItem<K>>(\n  items: D[],\n  getItem: (itemInfo: ItemInfo, items: D[]) => D | undefined,\n  totalCount: number,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo,\n  datatip?: (context: DatatipContext<D>) => {\n    content?: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  },\n  translations?: BundleType\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && items[hoveredItem.idx].id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  let _content, countWithTotal;\n  let _borderColor: string = rgb(colorSchemeVars.palette.neutral[0]);\n  const item = itemInfo && getItem(itemInfo, items);\n  if (item && datatip) {\n    // custom datatip\n    const datatipContext = item && { data: item };\n    const { content, borderColor } = datatip(datatipContext);\n    _content = content;\n    _borderColor = borderColor || _borderColor;\n    countWithTotal = translations\n      ? getCountWithTotal(item.count || 1, totalCount, translations)\n      : '';\n  }\n  return {\n    borderColor: _borderColor,\n    content:\n      _content ||\n      (itemInfo && getItem(itemInfo, items)?.accessibleLabel) ||\n      (itemInfo && getItem(itemInfo, items)?.label + ': ' + countWithTotal) ||\n      countWithTotal\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { styles } from './themes/PictoChartStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaProps } from './PictoChartUtils';\nimport { Ref } from 'preact/hooks';\nimport { PictoChartItem } from './PictoChart.type';\n\nexport type PictoElementProps<K, D extends PictoChartItem<K>> = {\n  item: D;\n  children: ComponentChildren;\n  row: number;\n  column: number;\n  totalCount: number;\n  class?: string;\n  activeId?: string;\n  isHighlighted?: boolean;\n  isSelected?: boolean;\n  hasSelection?: boolean;\n  itemIdx?: number;\n  countIdx?: number;\n  supportsSelection?: boolean;\n  supportsAction?: boolean;\n  translations?: BundleType;\n  focusedItemRef?: Ref<HTMLDivElement>;\n};\n\nconst PictoChartElement = <K, D extends PictoChartItem<K>>(props: PictoElementProps<K, D>) => {\n  const isInteractive = props.supportsSelection || props.supportsAction;\n\n  const { dimmedItemStyle, interactiveItemStyle } = styles;\n\n  const itemClasses = classNames([\n    isInteractive && interactiveItemStyle,\n    !props.isHighlighted && dimmedItemStyle\n  ]);\n  const isFirstElement = props.countIdx === 0;\n  const itemAriaProps =\n    (isFirstElement &&\n      getItemAriaProps(\n        props.item.count || 1,\n        props.totalCount,\n        !!props.supportsSelection,\n        props.item.label,\n        props.translations,\n        props.isSelected,\n        props.hasSelection,\n        props.item.accessibleLabel,\n        props.activeId\n      )) ||\n    {};\n\n  return (\n    <div\n      ref={isFirstElement ? props.focusedItemRef : undefined}\n      id={props.activeId}\n      data-idx={props.itemIdx}\n      data-count-idx={props.countIdx}\n      style={{\n        gridRow: `${props.row + 1} / span ${props.item.rowSpan || 1}`,\n        gridColumn: `${props.column + 1} / span ${props.item.columnSpan || 1}`\n      }}\n      class={itemClasses}\n      {...itemAriaProps}>\n      {props.children}\n    </div>\n  );\n};\n\nexport { PictoChartElement };\n","import type { PictoChartItem } from './PictoChart.type';\nimport { DEFAULT_SIZE } from './themes/PictoChartStyles.css';\n\nconst GAP_RATIO = 0.25;\n\nfunction _ceil(a: number, b: number) {\n  return Math.ceil(a / b) * b;\n}\n\nexport function getFlowingInfo<K, D extends PictoChartItem<K>>(\n  items: D[],\n  isVert: boolean,\n  width: number,\n  height: number,\n  isFlowingWidth: boolean,\n  isFlowingHeight: boolean,\n  colCount?: number,\n  rowCount?: number,\n  colWidth?: number,\n  rowHeight?: number\n) {\n  let numCells = 0;\n  let maxColSpan = 1;\n  let maxRowSpan = 1;\n  let minSpan = Infinity;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const columnSpan = item.columnSpan || 1;\n    const rowSpan = item.rowSpan || 1;\n    if (columnSpan <= 0 || rowSpan <= 0) continue;\n\n    // Compute the maximum columnSpan and rowSpan\n    if (columnSpan > maxColSpan) maxColSpan = columnSpan;\n    if (rowSpan > maxRowSpan) maxRowSpan = rowSpan;\n\n    // Compute minimum span for gap computation\n    if (columnSpan < minSpan) minSpan = columnSpan;\n    if (rowSpan < minSpan) minSpan = rowSpan;\n\n    numCells += columnSpan * rowSpan * (item.count || 1);\n  }\n\n  if (numCells === 0) return {};\n\n  // Default colWidth and rowHeight for flowing layout\n  if (isFlowingWidth || isFlowingHeight) {\n    if (!colWidth) colWidth = rowHeight ? rowHeight : DEFAULT_SIZE;\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  // Default colCount and rowCount for both layouts\n  // We set the default colCount (or rowCount) to be an integer multiple of the maxColSpan (or maxRowSpan) to\n  // ensure that all the items can find a spot to occupy in the mixed sizes case.\n\n  if (!colCount && !rowCount) {\n    // Try to achieve square cells, (width / colCount) = (height / rowCount)\n    if (!isFlowingWidth && !isFlowingHeight) {\n      if (isVert) rowCount = _ceil(Math.sqrt((numCells * height) / width), maxRowSpan);\n      else colCount = _ceil(Math.sqrt((numCells * width) / height), maxColSpan);\n    } else if (!isFlowingWidth) colCount = Math.max(Math.floor(width / (colWidth || 1)), 1);\n    else if (!isFlowingHeight) rowCount = Math.max(Math.floor(height / (rowHeight || 1)), 1);\n    else {\n      if (isVert) rowCount = _ceil(Math.sqrt(numCells), maxRowSpan);\n      else colCount = _ceil(Math.sqrt(numCells), maxColSpan);\n    }\n  }\n\n  // Now only either colCount or rowCount is undefined\n  if (!colCount) colCount = _ceil(numCells / (rowCount || 1), maxColSpan);\n  else if (!rowCount) rowCount = _ceil(numCells / colCount, maxRowSpan);\n\n  const gridGap = GAP_RATIO * minSpan;\n  // Default colWidth and rowHeight for fixed layout\n  if (!isFlowingWidth && !isFlowingHeight) {\n    if (!colWidth)\n      colWidth = rowHeight ? rowHeight : Math.min(width / colCount, height / (rowCount || 1));\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  if (\n    colCount <= 0 ||\n    !rowCount ||\n    rowCount <= 0 ||\n    !colWidth ||\n    colWidth <= 0 ||\n    !rowHeight ||\n    rowHeight <= 0\n  )\n    return {};\n\n  return {\n    calcColCount: colCount,\n    calcRowCount: rowCount,\n    calcColWidth: colWidth ? colWidth - gridGap : colWidth,\n    calcRowHeight: rowHeight ? rowHeight - gridGap : rowHeight,\n    gridGap: gridGap\n  };\n}\n\n/**\n * Returns whether the pictoChart is layout from bottom to top.\n */\nconst isOriginBottom = (origin: string) => {\n  return origin === 'bottomStart' || origin === 'bottomEnd';\n};\n\n/**\n * Returns whether the pictoChart is layout from right to left.\n */\nconst isOriginRight = (origin: string, isRTL: boolean) => {\n  const isEnd = origin === 'topEnd' || origin === 'bottomEnd';\n  return isRTL ? !isEnd : isEnd;\n};\n\n/**\n * Returns whether the cells are available given col, row and columnSpan, rowSpan needed.\n */\nconst areCellsAvailable = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      if (map[row + r][col + c]) return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Occupies the cell in the map given col, row and columnSpan, rowSpan.\n */\nconst occupyCells = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      map[row + r][col + c] = true;\n    }\n  }\n};\n\n/**\n * Returns whether the cells are available given col, row and the colCount and rowCount of the pictochart.\n */\nconst findNextAvailableCell = (\n  map: boolean[][],\n  columnSpan: number,\n  rowSpan: number,\n  colCount: number,\n  rowCount: number,\n  isVert: boolean\n): { row: number; col: number } | undefined => {\n  if (isVert) {\n    // For vertical layout, switch row and col in the computation, and switch the result back\n    const cell = findNextAvailableCell(map, rowSpan, columnSpan, rowCount, colCount, false);\n    return cell ? { col: cell.row, row: cell.col } : undefined;\n  }\n\n  for (let r = 0; r < rowCount - rowSpan + 1; r++) {\n    for (let c = 0; c < colCount - columnSpan + 1; c++) {\n      if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {\n        occupyCells(map, c, r, columnSpan, rowSpan);\n        return { col: c, row: r };\n      }\n    }\n  }\n\n  return;\n};\n\n/**\n * Returns the picto items with row and col of the pictochart.\n */\nexport function generateElementCoords<K, D extends PictoChartItem<K>>(\n  items: D[],\n  row: number,\n  column: number,\n  layoutOrigin: 'topStart' | 'topEnd' | 'bottomStart' | 'bottomEnd',\n  isVert: boolean,\n  isRTL: boolean\n) {\n  const rowCount = row;\n  const colCount = column;\n  const isLayoutBottom = isOriginBottom(layoutOrigin);\n  const isLayoutRight = isOriginRight(layoutOrigin, isRTL);\n\n  const pictoItems = [];\n  const map: boolean[][] = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    map[i] = new Array(colCount).fill(false);\n  }\n\n  for (let i = 0; i < items.length; i++) {\n    const currItem = items[i];\n    let count = 0;\n    const rowSpan = currItem.rowSpan ?? 1;\n    const columnSpan = currItem.columnSpan ?? 1;\n    const totalCount = currItem.count ?? 1;\n\n    while (count < totalCount) {\n      const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);\n      if (cell !== undefined) {\n        pictoItems.push({\n          row: isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row,\n          col: isLayoutRight ? colCount - cell.col - columnSpan : cell.col,\n          countIdx: count,\n          itemIdx: i,\n          item: currItem\n        });\n      }\n      count += 1;\n    }\n  }\n\n  return pictoItems;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ItemInputDetail, ItemInfo, PictoChartItem } from './PictoChart.type';\n\n/**\n * Returns the item based on item info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K, D extends PictoChartItem<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { idx } = itemInfo;\n  return items[idx];\n}\n\n/**\n * Returns the next item's info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getNextItemInfo<K, D extends PictoChartItem<K>>(itemInfo: ItemInfo, items: D[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.min(items.length - 1, idx + 1);\n  return { idx: idx };\n}\n\n/**\n * Returns the previous item's info in a picto chart.\n * @param itemInfo\n * @returns\n */\nfunction getPrevItemInfo(itemInfo: ItemInfo) {\n  let idx = itemInfo.idx;\n\n  idx = Math.max(0, idx - 1);\n  return { idx: idx };\n}\n\n/**\n * Returns utils functions for navigation in a picto chart.\n * @param items\n * @returns\n */\nexport function getPictoChartNavUtils<K, D extends PictoChartItem<K>>(items: D[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemInputDetail<K> => {\n      if (!itemInfo) {\n        return { id: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { id: item ? item.id : undefined };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","import { useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport type { ItemActionDetail, ItemInputDetail, ItemInfo } from './PictoChart.type';\nimport { getItemInfo, isEqualItem } from './PictoChartUtils';\nimport { getRandomId } from '../utils/PRIVATE_visLayoutUtils/LayoutUtils';\n\nexport function useEvents<K>(\n  isInteractive: boolean,\n  getDetailFromInfo: (info?: ItemInfo) => ItemInputDetail<K>,\n  getPrevItemInfo: (info: ItemInfo) => ItemInfo,\n  getNextItemInfo: (info: ItemInfo) => ItemInfo,\n  onItemAction?: (detail: ItemActionDetail<K>) => void,\n  onInput?: (detail: ItemInputDetail<K>) => void\n) {\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo>({ idx: 0 });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo>();\n\n  const activeId = useRef<string>();\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const hoverHandler = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (!isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      if (isInteractive) {\n        setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n        onInput?.(getDetailFromInfo(itemInfo));\n      }\n    }\n  };\n\n  const pointerLeaveHandler = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    if (isInteractive) {\n      onInput?.(getDetailFromInfo());\n    }\n  };\n\n  if (!isInteractive) {\n    return {\n      focusedItemInfo,\n      hoveredItemInfo,\n      // include pointer leave and pointer move for datatip\n      onPointerLeave: pointerLeaveHandler,\n      onPointerMove: hoverHandler\n    };\n  }\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo) {\n    onInput?.(getDetailFromInfo(itemInfo));\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item: ItemInfo) {\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  const triggerOnAction = () => {\n    const { id } = getDetailFromInfo(focusedItemInfo);\n    if (id != null) {\n      onItemAction?.({ id });\n      activeId.current = getRandomId();\n    }\n  };\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (itemInfo != null) {\n      setfocusedItemInfo(itemInfo);\n      const { id } = getDetailFromInfo(itemInfo);\n      if (id != null) {\n        onItemAction?.({ id });\n        activeId.current = getRandomId();\n      }\n    } else onItemAction?.({ id: undefined });\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab':\n        return;\n      case 'ArrowDown': {\n        const nextItemInfo = getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowUp': {\n        const nextItemInfo = getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowRight': {\n        const nextItemInfo = isRtl\n          ? getPrevItemInfo(focusedItemInfo)\n          : getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowLeft': {\n        const nextItemInfo = isRtl\n          ? getNextItemInfo(focusedItemInfo)\n          : getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Enter': {\n        triggerOnAction();\n        cancelEvent(event);\n        break;\n      }\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onInput?.(getDetailFromInfo(undefined));\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    'aria-activedescendant': activeId.current,\n    onPointerUp: pointerUpHandler,\n    onPointerMove: hoverHandler,\n    onKeyUp: keyUpHandler,\n    onKeyDown: keyDownHandler,\n    onPointerLeave: pointerLeaveHandler,\n    onBlur: blurHandler\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { PictoChartElement } from './PictoChartElement';\nimport type { PictoChartItem, PictoChart } from './PictoChart.type';\nimport { baseStyles } from './themes/PictoChartStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { Size, sizeToCSS } from '../utils/UNSAFE_size';\nimport { generateElementCoords, getFlowingInfo } from './PictoChartLayoutUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useSelection } from '../hooks/PRIVATE_useVisSelection';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { getItemInfo, getDatatipContent, getItemProps, getTotalCount } from './PictoChartUtils';\nimport { getPictoChartNavUtils } from './PictoChartNavUtils';\nimport { useEvents } from './useEvents';\nimport { usePictoChartDatatip } from './usePictoChartDatatip';\nimport { useItemFocus } from '../hooks/PRIVATE_useVisEvents';\nimport { PictoChartContext } from './PictoChartContext';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport function PictoChart<\n  K extends string | number,\n  D extends PictoChartItem<K> = PictoChartItem<K>\n>({\n  width,\n  height,\n  columnWidth,\n  rowHeight,\n  items,\n  columnCount,\n  rowCount,\n  layout,\n  layoutOrigin = 'topStart',\n  selectionMode = 'none',\n  highlightedIds = [],\n  hiddenIds = [],\n  selectedIds = [],\n  onItemAction,\n  onItemInput,\n  ...props\n}: PictoChart<K, D>) {\n  //  TODO: investigate if we need to handle empty items for performance reasons.\n  const hasData = items.length !== 0;\n  const filteredItems = items.filter((i) => !hiddenIds?.includes(i.id));\n  const totalCount = getTotalCount(filteredItems);\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const supportsSelection = !!(selectionMode && selectionMode !== 'none');\n  const supportsAction = onItemAction != null;\n  const isReadOnly = !supportsSelection && !supportsAction && onItemInput === null;\n  const { direction } = useUser();\n  const testIdProps = useTestId(props.testId);\n\n  const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getPictoChartNavUtils<\n    K,\n    D\n  >(filteredItems);\n  const { hoveredItemInfo, focusedItemInfo, ...eventsProps } = useEvents<K>(\n    !isReadOnly && hasData,\n    getDetailFromInfo,\n    getPrevItemInfo,\n    getNextItemInfo,\n    onItemAction,\n    onItemInput\n  );\n\n  const idExtracter = (event: Event) => {\n    // return focused item for keyboard event.\n    // eventsProps should have already updated the focused item\n    const info =\n      event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target as HTMLElement);\n    return getDetailFromInfo(info).id;\n  };\n\n  const selectionProps = useSelection<K>({\n    idExtracter,\n    isDrillEnabled: onItemAction != undefined,\n    selection: selectedIds,\n    selectionMode: selectionMode,\n    onChange: props.onSelectionChange\n  });\n\n  const rectangleWidth = columnWidth && parseFloat(columnWidth);\n  const rectangleHeight = rowHeight && parseFloat(rowHeight);\n  const pictoStyleClasses = classNames([baseStyles]);\n  const { focusedItemRef } = useItemFocus(focusedItemInfo);\n  const { content, borderColor } = getDatatipContent(\n    filteredItems,\n    getItem,\n    totalCount,\n    focusedItemInfo,\n    hoveredItemInfo,\n    props.datatip,\n    translations\n  );\n\n  const isFlowingWidth = width === undefined;\n  const isFlowingHeight = height === undefined;\n\n  return (\n    <PictoChartContext.Provider value={{ supportsSelection }}>\n      <TrackResizeContainer\n        width={isFlowingWidth ? 'initial' : (!isFlowingWidth && sizeToCSS(width as Size)) || '0px'}\n        height={\n          isFlowingHeight ? 'initial' : (!isFlowingHeight && sizeToCSS(height as Size)) || '0px'\n        }>\n        {function _(width, height) {\n          const { calcColCount, calcRowCount, calcColWidth, calcRowHeight, gridGap } =\n            getFlowingInfo<K, D>(\n              items,\n              layout === 'vertical',\n              width,\n              height,\n              isFlowingWidth,\n              isFlowingHeight,\n              columnCount,\n              rowCount,\n              rectangleWidth,\n              rectangleHeight\n            );\n\n          const { datatipContent, datatipProps } = usePictoChartDatatip({\n            content,\n            width,\n            borderColor,\n            focusedItemRef,\n            focusedItemInfo\n          });\n\n          if (!calcColCount)\n            // Nothing to render.\n            return null;\n\n          const elements = generateElementCoords(\n            filteredItems,\n            calcRowCount,\n            calcColCount,\n            layoutOrigin,\n            layout === 'vertical',\n            direction === 'rtl'\n          );\n\n          const mergedEventProps = mergeProps(eventsProps, datatipProps, selectionProps);\n          return (\n            <div\n              tabIndex={0}\n              aria-label={props['aria-label']}\n              aria-describedby={props['aria-describedby']}\n              aria-labelledby={props['aria-labelledby']}\n              role=\"application\"\n              style={{\n                width: isFlowingWidth ? 'max-content' : `${width}px`,\n                height: isFlowingHeight ? 'max-content' : `${height}px`,\n                gridTemplateRows: `repeat(${calcRowCount}, ${calcRowHeight}px)`,\n                gridTemplateColumns: `repeat(${calcColCount}, ${calcColWidth}px)`,\n                gap: `${gridGap}px`\n              }}\n              class={pictoStyleClasses}\n              {...testIdProps}\n              {...mergedEventProps}>\n              {elements.map((elt) => {\n                const isFocusedItem = focusedItemInfo.idx === elt.itemIdx;\n                const itemProps = getItemProps(\n                  elt.item,\n                  elt.itemIdx,\n                  elt.countIdx,\n                  isReadOnly,\n                  hoveredItemInfo,\n                  selectedIds,\n                  focusedItemInfo,\n                  highlightedIds,\n                  eventsProps['aria-activedescendant']\n                );\n\n                const context = {\n                  data: elt.item,\n                  state: {\n                    selected: itemProps.isSelected,\n                    focused: itemProps.isFocused,\n                    hovered: itemProps.isCurrent\n                  }\n                };\n\n                return (\n                  <PictoChartElement<K, D>\n                    focusedItemRef={isFocusedItem ? focusedItemRef : undefined}\n                    row={elt.row}\n                    column={elt.col}\n                    supportsSelection={supportsSelection}\n                    supportsAction={supportsAction}\n                    translations={translations}\n                    totalCount={totalCount}\n                    {...itemProps}>\n                    {props.children(context)}\n                  </PictoChartElement>\n                );\n              })}\n              {datatipContent}\n            </div>\n          );\n        }}\n      </TrackResizeContainer>\n    </PictoChartContext.Provider>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Ref } from 'preact/hooks';\nimport type { ItemInfo } from './PictoChart.type';\nimport { calculateOffset, useDatatip } from '../hooks/PRIVATE_useDatatip';\nimport { ComponentChildren } from 'preact';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { Property } from 'csstype';\n\ntype Props = {\n  content?: ComponentChildren;\n  borderColor?: Property.BorderColor;\n  focusedItemInfo: ItemInfo;\n  width: number;\n  focusedItemRef: Ref<HTMLDivElement>;\n};\n\n/**\n * Returns the datatip.\n * @param content The text string for the picto chart item.\n * @param focusedItemRef The ref for focused item node.\n * @param focusedItemInfo The ItemInfo for focused item node.\n * @returns\n */\nexport const usePictoChartDatatip = ({\n  content,\n  borderColor,\n  width,\n  focusedItemRef,\n  focusedItemInfo\n}: Props) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const itemDim = focusedItemRef.current?.getBoundingClientRect();\n  const { datatipContent, datatipProps } = useDatatip({\n    content,\n    placement: 'top-start',\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    offset: calculateOffset(isRtl, width, focusedItemInfo.isCurrent ? itemDim : undefined),\n    borderColor\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n"],"names":["PictoChartContext","createContext","getItemInfo","element","itemIdx","dataset","undefined","idx","Number","getItemProps","item","countIdx","isReadOnly","hoveredItem","selectedIds","focusedItem","highlightedIds","activeId","isCurrent","isFocusedItem","isHoveredItem","isHighlighted","id","length","Set","has","isItemHighlighted","isSelected","isItemSelected","hasSelection","isFocused","hasFocusRing","key","isEqualItem","item1","item2","itemInfo","isFocusVisible","getCountWithTotal","itemCount","totalCount","translations","dataVisualization_labelCountWithTotal","toString","PictoRenderer","context","markerProps","supportsSelection","useContext","markerProp","shape","color","isHuman","applyHover","isNoneEqualSides","outerBorderColor","rgb","colorSchemeVars","palette","neutral","markerShape","tx","ty","markerColor","borderColor","markerScale","setAspectRatioNone","getMarkerProps","state","focused","selected","hovered","_jsx","jsx","SvgSymbol","PictoChartElement","props","isInteractive","supportsAction","dimmedItemStyle","interactiveItemStyle","styles","itemClasses","classNames","isFirstElement","itemAriaProps","label","accessibleLabel","selectionAriaLabel","dataVisualization_stateSelected","dataVisualization_stateUnselected","totalWithCountLabel","filter","Boolean","join","role","getItemAriaProps","count","ref","focusedItemRef","style","gridRow","row","rowSpan","gridColumn","column","columnSpan","class","children","GAP_RATIO","_ceil","a","b","Math","ceil","isOriginBottom","origin","isOriginRight","isRTL","isEnd","areCellsAvailable","map","col","r","c","occupyCells","findNextAvailableCell","colCount","rowCount","isVert","cell","getItem","items","getPictoChartNavUtils","getDetailFromInfo","getPrevItemInfo","max","getNextItemInfo","min","useEvents","onItemAction","onInput","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","sethoveredItemInfo","useRef","direction","useUser","isRtl","cancelEvent","event","preventDefault","stopPropagation","hoverHandler","target","current","getRandomId","pointerLeaveHandler","onPointerLeave","onPointerMove","updatefocusedItemInfo","handleKeyboardInput","onPointerUp","onKeyUp","code","triggerOnAction","onKeyDown","onBlur","width","height","columnWidth","rowHeight","columnCount","layout","layoutOrigin","selectionMode","hiddenIds","onItemInput","hasData","filteredItems","i","includes","getTotalCount","useTranslationBundle","testIdProps","useTestId","testId","eventsProps","selectionProps","useSelection","idExtracter","info","type","isDrillEnabled","selection","onChange","onSelectionChange","rectangleWidth","parseFloat","rectangleHeight","pictoStyleClasses","baseStyles","useItemFocus","content","datatip","isPointerActive","_content","countWithTotal","_borderColor","datatipContext","data","getDatatipContent","isFlowingWidth","isFlowingHeight","Provider","value","TrackResizeContainer","sizeToCSS","calcColCount","calcRowCount","calcColWidth","calcRowHeight","gridGap","colWidth","numCells","maxColSpan","maxRowSpan","minSpan","Infinity","DEFAULT_SIZE","sqrt","floor","getFlowingInfo","datatipContent","datatipProps","itemDim","getBoundingClientRect","useDatatip","placement","anchor","offset","calculateOffset","usePictoChartDatatip","elements","isLayoutBottom","isLayoutRight","pictoItems","Array","fill","currItem","push","generateElementCoords","mergedEventProps","mergeProps","_jsxs","jsxs","tabIndex","gridTemplateRows","gridTemplateColumns","gap","elt","itemProps","rendererOptions","markerRenderer","datatipRenderer"],"mappings":"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"}