{"version":3,"file":"Diagram-14fd94c3.js","sources":["../../src/UNSAFE_Diagram/utils/diagramUtils.ts","../../src/UNSAFE_Diagram/DiagramNodeElement.tsx","../../src/UNSAFE_Diagram/DiagramNodeLayer.tsx","../../src/UNSAFE_Diagram/DiagramLinkElement.tsx","../../src/UNSAFE_Diagram/DiagramLinkLayer.tsx","../../src/UNSAFE_Diagram/DiagramLabel.tsx","../../src/UNSAFE_Diagram/DiagramLabelLayer.tsx","../../src/UNSAFE_Diagram/DiagramLayers.tsx","../../src/UNSAFE_Diagram/DiagramPanZoomContainer.tsx","../../src/UNSAFE_Diagram/utils/navUtils.ts","../../src/UNSAFE_Diagram/hooks/useDiagramNavigation.ts","../../src/UNSAFE_Diagram/hooks/useEvents.ts","../../src/UNSAFE_Diagram/hooks/useDiagramDatatip.ts","../../src/UNSAFE_Diagram/hooks/usePointerGesture.ts","../../src/UNSAFE_Diagram/utils/panUtils.ts","../../src/UNSAFE_Diagram/hooks/useDragPan.ts","../../src/UNSAFE_Diagram/hooks/useDrag.ts","../../src/UNSAFE_Diagram/utils/zoomUtils.ts","../../src/UNSAFE_Diagram/hooks/usePinch.ts","../../src/UNSAFE_Diagram/hooks/usePinchZoom.ts","../../src/UNSAFE_Diagram/hooks/usePanZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheelZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheel.ts","../../src/UNSAFE_Diagram/DiagramWithDimensions.tsx","../../src/UNSAFE_Diagram/hooks/useDiagramSelection.ts","../../src/UNSAFE_Diagram/Diagram.tsx"],"sourcesContent":["import type {\n  Pan,\n  Zoom,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput,\n  ItemInfo,\n  Bounds,\n  Position,\n  Dimensions,\n  DatatipContext,\n  DiagramLabelStyles,\n  DiagramLabelPosition\n} from '../diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport type { BundleType } from '../../resources/nls/bundle';\nimport type {\n  Font,\n  GetTextDimensionsType,\n  TextDimensions\n} from '../../hooks/PRIVATE_useTextDimensions';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\n\nconst ZOOM_TO_FIT_PADDING = 20;\n/**\n * Returns the pan properties for the diagram.\n */\nexport function getPanProps(props: Pan, contentBounds: Bounds) {\n  return {\n    panning: props.panning ? props.panning : 'off',\n    panDirection: props.panDirection ? props.panDirection : 'any',\n    centerX: props.centerX !== undefined ? props.centerX : contentBounds.w / 2 + contentBounds.x,\n    centerY: props.centerY !== undefined ? props.centerY : contentBounds.h / 2 + contentBounds.y,\n    onPan: props.onPan\n  };\n}\n\n/**\n * Returns the zoom properties for the diagram.\n */\nexport function getZoomProps(props: Zoom, width: number, height: number, contentBounds: Bounds) {\n  const minZoom = props.minZoom ? props.minZoom : getZoomToFitZoom(width, height, contentBounds);\n  const maxZoom = props.maxZoom !== undefined ? props.maxZoom : 1;\n  const zoom = props.zoomValue ? props.zoomValue : getZoomToFitZoom(width, height, contentBounds);\n  return {\n    zooming: props.zooming ? props.zooming : 'off',\n    // default value of 0 indicates zoom-to-fit level\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    // zoom value of 0 will default to zoom to fit\n    zoomValue: constrainZoom(zoom, minZoom, maxZoom),\n    onZoom: props.onZoom\n  };\n}\n\n/**\n * Constructs the json object to be passed into the layout function\n */\nexport function constructLayoutJSON<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodes: D1[],\n  nodeItems: Map<K1, D1>,\n  linkItems: Map<K2, D2>,\n  dimensions: Dimensions[],\n  width: number,\n  height: number,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const labelDims: Map<K1 | K2, TextDimensions> = new Map();\n  const nodeKeys = Array.from(nodeItems.keys());\n  for (const id of nodeKeys) {\n    const item = nodeItems.get(id as K1);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const linkKeys = Array.from(linkItems.keys());\n  for (const id of linkKeys) {\n    const item = linkItems.get(id as K2);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const getLabelDimensions = function (data: D1 | D2) {\n    return labelDims.get(data.id);\n  };\n  const getNodeDimensions = function (data: D1) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (data.id === nodes[i].id) {\n        return dimensions[i];\n      }\n    }\n    return dimensions[0];\n  };\n\n  return {\n    layoutJSON: {\n      getNodeDimensions: getNodeDimensions,\n      getLabelDimensions: getLabelDimensions,\n      componentSize: {\n        width: width,\n        height: height\n      }\n    },\n    labelDims: labelDims\n  };\n}\n\n/**\n * Deconstructs the output of the layout function\n */\nexport function deconstructLayoutJSON<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2>\n>(layoutJSON: L, nodeData: D1[], linkData: D2[]) {\n  const nodes = layoutJSON.nodes;\n  const links = layoutJSON.links;\n  const positions: Position[] = [];\n  const nodeLabelPos: (DiagramLabelPosition | undefined)[] = [];\n  const linkLabelPos: DiagramLabelPosition[] = [];\n  let hasNodeLabels = false;\n  let hasLinkLabels = false;\n  let node, link;\n  for (let i = 0; i < nodeData.length; i++) {\n    node = nodes[nodeData[i].id];\n    positions.push(node.position);\n    if (node.label) hasNodeLabels = true;\n    nodeLabelPos.push(node.label);\n  }\n  if (links) {\n    for (let i = 0; i < linkData.length; i++) {\n      link = links[linkData[i].id];\n      if (link.label) hasLinkLabels = true;\n      linkLabelPos.push(link.label);\n    }\n  }\n  return {\n    nodePoints: positions,\n    nodeLabelPos: hasNodeLabels ? nodeLabelPos : undefined,\n    linkLabelPos: hasLinkLabels ? linkLabelPos : undefined\n  };\n}\n\n/**\n * Merges the node points into the dimensions\n */\nexport function mergeDimensions(dimensions: Dimensions[], nodePoints: Position[]) {\n  const newBounds: Bounds[] = [];\n  for (let i = 0; i < dimensions.length; i++) {\n    const point = nodePoints[i];\n    const dim = dimensions[i];\n    newBounds.push({ x: point.x, y: point.y, w: dim.w, h: dim.h });\n  }\n  return newBounds;\n}\n\n/**\n * Returns the text for the diagram datatip.\n */\nexport function getDatatipContent<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodesMap: Map<K1, D1>,\n  linksMap: Map<K2, D2>,\n  focusedItem?: ItemInfo<K1, K2>,\n  hoveredItem?: ItemInfo<K1, K2>,\n  datatip?: (detail: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  }\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && hoveredItem.id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  if (itemInfo && datatip) {\n    return datatip(\n      itemInfo.isNode\n        ? { data: nodesMap.get(itemInfo.id as K1) as D1, type: 'node' }\n        : { data: linksMap.get(itemInfo.id as K2) as D2, type: 'link' }\n    );\n  }\n  if (itemInfo) {\n    const text = (\n      itemInfo.isNode ? nodesMap.get(itemInfo.id as K1) : linksMap.get(itemInfo.id as K2)\n    )?.accessibleLabel;\n    return {\n      content: text\n    };\n  }\n  return;\n}\n\n/**\n * Creates a map with key id and value node or link data\n */\nexport function createItemMap<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(items: (D1 | D2)[]) {\n  const itemIdToDataMap = new Map();\n  const itemIdToIndexMap = new Map();\n  const itemIndexToIdMap = new Map();\n  for (let i = 0; i < items.length; i++) {\n    itemIdToDataMap.set(items[i].id, items[i]);\n    itemIdToIndexMap.set(items[i].id, i);\n    itemIndexToIdMap.set(i, items[i].id);\n  }\n  return {\n    itemIdToDataMap,\n    itemIdToIndexMap,\n    itemIndexToIdMap\n  };\n}\n\n/**\n * Filter out links with no start or end nodes\n */\nexport function filterLinksWithNoEndNodes<K2, K1, D1, D2 extends DiagramLinkData<K2, K1>>(\n  links: D2[],\n  nodesMap: Map<K1, D1>\n) {\n  const newLinks: D2[] = [];\n  for (let i = 0; i < links.length; i++) {\n    const link = links[i];\n    if (nodesMap.get(link.startNode) && nodesMap.get(link.endNode)) {\n      newLinks.push(link);\n    }\n  }\n  return newLinks;\n}\n\n/**\n * Pulls out the dimensions from an array of bounds\n */\nexport function getDimensionsFromBounds(bounds: Bounds[]) {\n  const dims: Dimensions[] = [];\n  for (let i = 0; i < bounds.length; i++) {\n    dims.push({ w: bounds[i].w, h: bounds[i].h });\n  }\n  return dims;\n}\n\n/**\n * Returns true if event is a selection event\n */\nexport function isSelectionEvent(event: KeyboardEvent): boolean {\n  if (event.altKey && (event.key === '≥' || event.key === '≤')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns the center position of the node or link\n * For links, draws a straight line between the centers of the start/end node\n * and returns the center of that line\n */\nexport function getFocusedItemBounds<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  bounds: Bounds[],\n  links: D2[],\n  nodeIdToIndexMap: Map<K1, number>,\n  linkIdToIndexMap: Map<K2, number>\n) {\n  if (focusedItemInfo.isNode) {\n    const idx = nodeIdToIndexMap.get(focusedItemInfo.id as K1);\n    // Return the first element if cannot find the Node index\n    return bounds[idx || 0];\n  } else {\n    // Center of a straight line between start/end node centers\n    const link = links[linkIdToIndexMap.get(focusedItemInfo.id as K2) || 0];\n    const startNB = bounds[nodeIdToIndexMap.get(link.startNode) || 0];\n    const endNB = bounds[nodeIdToIndexMap.get(link.endNode) || 0];\n    const startNCenter = { x: startNB.x + startNB.w / 2, y: startNB.y + startNB.h / 2 };\n    const endNCenter = { x: endNB.x + endNB.w / 2, y: endNB.y + endNB.h / 2 };\n    const minX = Math.min(startNCenter.x, endNCenter.x);\n    const minY = Math.min(startNCenter.y, endNCenter.y);\n    return {\n      x: minX,\n      y: minY,\n      w: Math.abs(startNCenter.x - endNCenter.x),\n      h: Math.abs(startNCenter.y - endNCenter.y)\n    };\n  }\n}\n/**\n * Combines the node and link ids into one array\n */\nexport function combineIds<K1, K2>(nodeIds?: K1[], linkIds?: K2[]) {\n  const combinedIds: (K1 | K2)[] = [];\n  if (nodeIds) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      combinedIds.push(nodeIds[i]);\n    }\n  }\n  if (linkIds) {\n    for (let i = 0; i < linkIds.length; i++) {\n      combinedIds.push(linkIds[i]);\n    }\n  }\n  return combinedIds;\n}\n\n/**\n * Returns the bounds of the diagram content\n */\nexport function getContentBounds(nodeBounds: Bounds[], labelBounds?: Bounds): Bounds {\n  if (nodeBounds.length === 0) return { x: 0, w: Infinity, y: 0, h: Infinity };\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims;\n  for (let i = 0; i < nodeBounds.length; i++) {\n    dims = nodeBounds[i];\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  if (labelBounds) {\n    minX = labelBounds.x < minX ? labelBounds.x : minX;\n    minY = labelBounds.y < minY ? labelBounds.y : minY;\n    maxX = labelBounds.x + labelBounds.w > maxX ? labelBounds.x + labelBounds.w : maxX;\n    maxY = labelBounds.y + labelBounds.h > maxY ? labelBounds.y + labelBounds.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\n/**\n * Returns the label bounds\n */\nexport function getAllLabelBounds<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  labelDims: Map<K1 | K2, TextDimensions>,\n  nodes: D1[],\n  links: D2[],\n  nodeLabelPos: (DiagramLabelPosition | undefined)[] = [],\n  linkLabelPos: DiagramLabelPosition[] = [],\n  isRTL: boolean\n) {\n  if (nodeLabelPos.length === 0 && linkLabelPos.length === 0) return undefined;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims, label;\n  for (let i = 0; i < nodeLabelPos.length; i++) {\n    label = nodeLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(nodes[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  for (let i = 0; i < linkLabelPos.length; i++) {\n    label = linkLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(links[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\nfunction getLabelBounds(label: DiagramLabelPosition, dims: TextDimensions, isRTL: boolean) {\n  const labelPos = getLabelPosition(dims, label, isRTL);\n  const isRotating = label.rotationAngle;\n  if (!isRotating) {\n    return { x: labelPos.x, y: labelPos.y, w: dims.width, h: dims.height };\n  } else {\n    // Find the 4 corners of the label bounds relative to the rotation point\n    const rotationPoint = label.rotationPoint\n      ? label.rotationPoint\n      : { x: dims.width / 2, y: dims.height / 2 };\n    const angle = label.rotationAngle!;\n    const topLeft = getCoordsRelToRotPoint({ x: 0, y: 0 }, rotationPoint);\n    const topRight = getCoordsRelToRotPoint({ x: dims.width, y: 0 }, rotationPoint);\n    const bottomLeft = getCoordsRelToRotPoint({ x: 0, y: dims.height }, rotationPoint);\n    const bottomRight = getCoordsRelToRotPoint({ x: dims.width, y: dims.height }, rotationPoint);\n    const rotTopLeft = rotatePoint(topLeft, angle);\n    const rotBotLeft = rotatePoint(bottomLeft, angle);\n    const rotTopRight = rotatePoint(topRight, angle);\n    const rotBotRight = rotatePoint(bottomRight, angle);\n    const points = [rotTopLeft, rotBotLeft, rotTopRight, rotBotRight].map((pos: Position) => {\n      return {\n        x: pos.x + labelPos.x + rotationPoint.x,\n        y: pos.y + labelPos.y + rotationPoint.y\n      };\n    });\n    return getBoundsFromPoints(points);\n  }\n}\n\nfunction getCoordsRelToRotPoint(labelPoint: Position, rotPoint: Position) {\n  return { x: labelPoint.x - rotPoint.x, y: labelPoint.y - rotPoint.y };\n}\n\nfunction rotatePoint(pos: Position, angle: number) {\n  return {\n    x: pos.x * Math.cos(angle) - pos.y * Math.sin(angle),\n    y: pos.x * Math.sin(angle) + pos.y * Math.cos(angle)\n  };\n}\n\nfunction getBoundsFromPoints(points: Position[]) {\n  let minX = points[0].x;\n  let minY = points[0].y;\n  let maxX = points[0].x;\n  let maxY = points[0].y;\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    if (point.x < minX) minX = point.x;\n    else if (point.x > maxX) maxX = point.x;\n    if (point.y < minY) minY = point.y;\n    else if (point.y > maxY) maxY = point.y;\n  }\n  return {\n    x: minX,\n    y: minY,\n    w: maxX - minX,\n    h: maxY - minY\n  };\n}\n\n/**\n * Returns the position of the label\n * @param dimensions\n * @param positionProps\n * @returns position of the label\n */\nexport function getLabelPosition(\n  dimensions: TextDimensions,\n  positionProps: DiagramLabelPosition,\n  isRTL: boolean\n) {\n  const position = positionProps.position;\n  const hAlign = positionProps.hAlign ? positionProps.hAlign : isRTL ? 'right' : 'left';\n  const vAlign = positionProps.vAlign;\n  let x, y;\n  if (hAlign === 'center') {\n    x = position.x - dimensions.width / 2;\n  } else if (hAlign === 'right') {\n    x = position.x - dimensions.width;\n  } else {\n    x = position.x;\n  }\n\n  if (vAlign === 'middle') {\n    y = position.y - dimensions.height / 2;\n  } else if (vAlign === 'bottom') {\n    y = position.y - dimensions.height;\n  } else if (vAlign === 'baseline') {\n    y = position.y + dimensions.y;\n  } else {\n    y = position.y;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\n/**\n * Converts centerX,Y coordinates to panX,Y coordinates\n */\nexport function centerXYToPanXY(\n  centerX: number,\n  centerY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    panX: width / 2 - centerX * zoom,\n    panY: height / 2 - centerY * zoom\n  };\n}\n/**\n * Converts panX,Y coordinates to centerX,Y coordinates\n */\nexport function panXYToCenterXY(\n  panX: number,\n  panY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    centerX: (width / 2 - panX) / zoom,\n    centerY: (height / 2 - panY) / zoom\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n */\nexport function isEqualItem<K1, K2>(item1?: ItemInfo<K1, K2>, item2?: ItemInfo<K1, K2>) {\n  return item1?.id === item2?.id && item1?.isNode === item2?.isNode;\n}\n\n/**\n * Returns the item info of the data-oj-node or data-oj-link attribute for a given element.\n */\nexport function getNavigableInfo<K1, K2>(\n  element: HTMLElement,\n  rootElementRef?: Ref<HTMLDivElement>\n): ItemInfo<K1, K2> {\n  let isNode = false;\n  let elem = element;\n  let navigableId;\n  while (!navigableId) {\n    navigableId = elem.dataset['node'];\n    if (navigableId) {\n      isNode = true;\n    } else {\n      navigableId = elem.dataset['link'];\n    }\n    if (!navigableId) {\n      if (elem.parentElement && elem.parentElement !== rootElementRef?.current) {\n        elem = elem.parentElement;\n      } else {\n        break;\n      }\n    }\n  }\n  return {\n    id: navigableId as K1 | K2,\n    isNode: isNode\n  };\n}\n\n/**\n * Returns the id of the focused item.\n */\nexport function getFocusedItem<K1, K2>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  hoveredItemInfo?: ItemInfo<K1, K2>\n) {\n  let focused;\n  if (focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible) {\n    focused = focusedItemInfo.id;\n  } else if (hoveredItemInfo?.isCurrent) {\n    focused = hoveredItemInfo.id;\n  }\n  return focused;\n}\n\n/**\n * Returns the aria label\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  supportsSelection: boolean,\n  isSelected?: boolean,\n  accessibleLabel?: string\n) {\n  return generateAriaLabel(translations, accessibleLabel || '', {\n    isSelected: !supportsSelection ? undefined : isSelected\n  });\n}\n\n/**\n * Returns the zoom to fit zoom level\n */\nexport function getZoomToFitZoom(width: number, height: number, contentBounds: Bounds) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.h;\n  return Math.min(zoomX, zoomY);\n}\n\n/**\n * Constrains the zoom level\n */\nfunction constrainZoom(zoom: number, minZoom: number, maxZoom: number) {\n  let newZoom = Math.max(minZoom, zoom);\n  newZoom = Math.min(maxZoom, newZoom);\n  return newZoom;\n}\n\n/**\n * Returns the font props for a node or link\n */\nfunction _getFontProps(styles?: DiagramLabelStyles) {\n  const fontProps: Font = {};\n  if (!styles) return fontProps;\n  if (styles.fontFamily) fontProps.fontFamily = styles.fontFamily;\n  if (styles.fontSize) fontProps.fontSize = styles.fontSize;\n  if (styles.fontStyle) fontProps.fontStyle = styles.fontStyle;\n  if (styles.fontWeight) fontProps.fontWeight = styles.fontWeight;\n  return fontProps;\n}\n\n/**\n * Returns the panX, panY, and zoom when zooming and centering an item\n */\nexport function zoomAndCenterItemFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  info: ItemInfo<K1, K2>,\n  linkIdToDataMap: Map<K2, D2>,\n  bounds: Bounds[],\n  nodeIdToIndex: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number\n) {\n  const isNode = info.isNode;\n  let totalBounds;\n  if (isNode) {\n    const nodeIndex = nodeIdToIndex.get(info.id as K1)!;\n    totalBounds = bounds[nodeIndex];\n  } else {\n    const link = linkIdToDataMap.get(info.id as K2)!;\n    const startNodeBounds = bounds[nodeIdToIndex.get(link.startNode)!];\n    const endNodeBounds = bounds[nodeIdToIndex.get(link.endNode)!];\n    const minX = Math.min(startNodeBounds.x, endNodeBounds.x);\n    const minY = Math.min(startNodeBounds.y, endNodeBounds.y);\n    const maxX = Math.max(\n      startNodeBounds.x + startNodeBounds.w,\n      endNodeBounds.x + startNodeBounds.w\n    );\n    const maxY = Math.max(startNodeBounds.y + startNodeBounds.h, endNodeBounds.y + endNodeBounds.h);\n    totalBounds = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n  }\n  return getPanZoomToCenterNode(totalBounds, maxZoom, width, height);\n}\n\n/**\n * Returns the pan and zoom values in order\n * to center a node or link\n */\nfunction getPanZoomToCenterNode(bounds: Bounds, maxZoom: number, width: number, height: number) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / bounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / bounds.h;\n  const zoom = Math.min(zoomX, zoomY, maxZoom);\n  const cX = bounds.w / 2 + bounds.x;\n  const cY = bounds.h / 2 + bounds.y;\n  return { centerX: cX, centerY: cY, zoom: zoom };\n}\n","import type { Position, State, NodeRendererContext } from './diagram.types';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for node component\n */\ntype NodeProps<K1, D1> = {\n  id: K1;\n  position: Position;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  nodeIndex: number;\n  data: D1;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  supportsSelection: boolean;\n};\n\nexport const DiagramNodeElement = <K1, D1>({\n  id,\n  state,\n  previousState,\n  position,\n  activeId,\n  nodeRenderer,\n  onNodeSizeChanged,\n  nodeIndex,\n  data,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: NodeProps<K1, D1>) => {\n  const { nodeStyles, dimmedItemStyle } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const ref = useRef<HTMLDivElement>(null);\n  // TODO JET-62472 change to one resize observer function\n  const optionsRef = useRef({ box: 'border-box' as const });\n  useResizeObserver(\n    ref,\n    useCallback(\n      (entry: ResizeObserverEntry) => {\n        const boxSize = entry.borderBoxSize;\n        const width = boxSize[0].inlineSize;\n        const height = boxSize[0].blockSize;\n        onNodeSizeChanged(width, height, nodeIndex);\n      },\n      [nodeIndex, onNodeSizeChanged]\n    ),\n    optionsRef.current\n  );\n  return (\n    <div\n      ref={ref}\n      key={id}\n      class={classNames([nodeStyles, isDimmed ? dimmedItemStyle : undefined])}\n      data-node={id}\n      role=\"img\"\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      style={{\n        top: position.y,\n        left: position.x\n      }}\n      id={state.focused || state.hovered ? activeId : undefined}>\n      {nodeRenderer(context)}\n    </div>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { States, NodeRendererContext, Bounds, DiagramNodeData } from './diagram.types';\nimport { DiagramNodeElement } from './DiagramNodeElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K1, K2, D1> = {\n  nodes: D1[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeBounds?: Bounds[];\n  supportsSelection: boolean;\n};\n\nexport function DiagramNodeLayer<K1, K2, D1 extends DiagramNodeData<K1>>({\n  nodes,\n  states,\n  previousStates,\n  nodeRenderer,\n  nodeBounds,\n  onNodeSizeChanged,\n  supportsSelection\n}: Props<K1, K2, D1>) {\n  return (\n    <div class={layerStyles}>\n      {nodes.map((node, i) => {\n        // this is for initial render before the layout function so render all nodes at 0,0\n        const position =\n          nodeBounds && nodeBounds[i] ? { x: nodeBounds[i].x, y: nodeBounds[i].y } : { x: 0, y: 0 };\n        const state = {\n          selected: states.selectedNodeIds.includes(node.id),\n          focused: states.focusedId === node.id,\n          hovered: states.hoveredId === node.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedNodeIds.includes(node.id),\n          focused: previousStates.focusedId === node.id,\n          hovered: previousStates.hoveredId === node.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramNodeElement\n            id={node.id}\n            position={position}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(node.id)\n            }\n            activeId={states.activeId}\n            nodeRenderer={nodeRenderer}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeIndex={i}\n            accessibleLabel={node.accessibleLabel}\n            data={node}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n","import type { State, LinkRendererContext } from './diagram.types';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for Link\n */\nexport type LinkProps<K2, D2, L> = {\n  id: K2;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  data: D2;\n  linkRenderer: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  supportsSelection: boolean;\n  layoutOutput: L;\n};\n\nexport const DiagramLinkElement = <K2, D2, L>({\n  id,\n  state,\n  previousState,\n  activeId,\n  data,\n  linkRenderer,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection,\n  layoutOutput\n}: LinkProps<K2, D2, L>) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { dimmedItemStyle, linkStyles } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data,\n    layoutOutput: layoutOutput\n  };\n  return (\n    <g\n      key={id}\n      id={state.focused ? activeId : undefined}\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      data-link={id}\n      role=\"img\"\n      class={classNames([linkStyles, isDimmed && dimmedItemStyle])}>\n      {linkRenderer(context)}\n    </g>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type {\n  States,\n  LinkRendererContext,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport { DiagramLinkElement } from './DiagramLinkElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K2, K1, D2, L> = {\n  links: D2[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  linkRenderer: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  width: number;\n  height: number;\n  supportsSelection: boolean;\n  layoutOutput: L;\n};\n\nexport function DiagramLinkLayer<\n  K2 extends string | number,\n  K1 extends string | number,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({\n  links,\n  states,\n  previousStates,\n  linkRenderer,\n  width,\n  height,\n  supportsSelection,\n  layoutOutput\n}: Props<K2, K1, D2, L>) {\n  return (\n    <svg class={layerStyles} width={width} height={height}>\n      {links.map((link) => {\n        const state = {\n          selected: states.selectedLinkIds.includes(link.id),\n          focused: states.focusedId === link.id,\n          hovered: states.hoveredId === link.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedLinkIds.includes(link.id),\n          focused: previousStates.focusedId === link.id,\n          hovered: previousStates.hoveredId === link.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramLinkElement\n            id={link.id}\n            label={link.label}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(link.id)\n            }\n            activeId={states.activeId}\n            accessibleLabel={link.accessibleLabel}\n            data={link}\n            linkRenderer={linkRenderer}\n            supportsSelection={supportsSelection}\n            layoutOutput={layoutOutput}\n          />\n        );\n      })}\n    </svg>\n  );\n}\n","import type { DiagramLabelPosition, DiagramLabelStyles } from './diagram.types';\nimport { getLabelPosition } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { labelStyles } from './themes/DiagramStyles.css';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { Property } from 'csstype';\n\n/**\n * Props for the label component\n */\ntype LabelProps = {\n  styles?: LabelStyles;\n  text: string;\n  position: DiagramLabelPosition;\n  dimensions: TextDimensions;\n  isRTL: boolean;\n};\n\n/**\n * Label styles\n */\ntype LabelStyles = DiagramLabelStyles & {\n  borderStyle?: Property.BorderStyle;\n};\n\nexport const DiagramLabel = ({ text, position, styles, dimensions, isRTL }: LabelProps) => {\n  const { labelStyle, labelBorderStyle } = labelStyles;\n\n  const labelPosition = getLabelPosition(dimensions, position, isRTL);\n  const labelRotation = getLabelRotation(position);\n  return (\n    <div\n      class={classNames([labelStyle, styles && styles.borderColor && labelBorderStyle])}\n      style={{\n        top: labelPosition.y,\n        left: labelPosition.x,\n        ...styles,\n        ...labelRotation\n      }}>\n      {text}\n    </div>\n  );\n};\n\n/**\n * Returns the label rotation props\n * @param position\n * @returns rotation props\n */\nfunction getLabelRotation(position: DiagramLabelPosition) {\n  const rotationAngle = position.rotationAngle;\n  const rotationPoint = position.rotationPoint;\n  const rotation: {\n    transform?: string;\n    'transform-origin'?: string;\n  } = {};\n  if (rotationAngle) {\n    rotation['transform'] = `rotate(${rotationAngle}deg)`;\n  }\n  if (rotationPoint) {\n    rotation['transform-origin'] = `${rotationPoint.x}px ${rotationPoint.y}px`;\n  }\n  return rotation;\n}\n","import type { DiagramLabelPosition, DiagramNodeData, DiagramLinkData } from './diagram.types';\nimport { DiagramLabel } from './DiagramLabel';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { layerStyles } from './themes/DiagramStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\n\ntype Props<K1, K2, D1, D2> = {\n  labelPosition: (DiagramLabelPosition | undefined)[];\n  itemProps: (D1 | D2)[];\n  labelDimensions: Map<K1 | K2, TextDimensions>;\n};\n\nexport function DiagramLabelLayer<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({ labelPosition, itemProps, labelDimensions }: Props<K1, K2, D1, D2>) {\n  const { direction } = useUser();\n  return (\n    <div class={layerStyles}>\n      {itemProps.map((item, i) => {\n        if (item.label && labelPosition[i]) {\n          return (\n            <DiagramLabel\n              styles={item.labelStyle}\n              text={item.label}\n              position={labelPosition[i]!}\n              dimensions={labelDimensions.get(item.id)!}\n              isRTL={direction === 'rtl'}\n            />\n          );\n        }\n        return undefined;\n      })}\n    </div>\n  );\n}\n","import type {\n  NodeRendererContext,\n  LinkRendererContext,\n  States,\n  Bounds,\n  DiagramLabelPosition,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport { DiagramNodeLayer } from './DiagramNodeLayer';\nimport { DiagramLinkLayer } from './DiagramLinkLayer';\nimport { DiagramLabelLayer } from './DiagramLabelLayer';\nimport { ComponentChildren } from 'preact';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\n\n/**\n * Props for Diagram layers component\n */\ntype DiagramLayersProps<K1, K2, D1, D2, L> = {\n  nodes: D1[];\n  links: D2[];\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  linkRenderer?: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeBounds: Bounds[];\n  // width height are for svg for links\n  width: number;\n  height: number;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeLabelPositions?: (DiagramLabelPosition | undefined)[];\n  linkLabelPositions?: (DiagramLabelPosition | undefined)[];\n  labelDimensions?: Map<K1 | K2, TextDimensions>;\n  supportsSelection: boolean;\n  layoutOutput?: L;\n};\n\nexport function DiagramLayers<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2>\n>({\n  nodes,\n  links,\n  nodeRenderer,\n  linkRenderer,\n  states,\n  previousStates,\n  nodeBounds,\n  onNodeSizeChanged,\n  width,\n  height,\n  nodeLabelPositions,\n  linkLabelPositions,\n  labelDimensions,\n  supportsSelection,\n  layoutOutput\n}: DiagramLayersProps<K1, K2, D1, D2, L>) {\n  return (\n    <>\n      {links.length > 0 && layoutOutput && linkRenderer && width !== Infinity && (\n        <DiagramLinkLayer\n          links={links}\n          states={states}\n          previousStates={previousStates}\n          linkRenderer={linkRenderer}\n          width={width}\n          height={height}\n          supportsSelection={supportsSelection}\n          layoutOutput={layoutOutput}\n        />\n      )}\n      <DiagramNodeLayer\n        nodes={nodes}\n        nodeBounds={nodeBounds}\n        states={states}\n        previousStates={previousStates}\n        nodeRenderer={nodeRenderer}\n        onNodeSizeChanged={onNodeSizeChanged}\n        supportsSelection={supportsSelection}\n      />\n      {labelDimensions ? (\n        <div>\n          {nodeLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={nodeLabelPositions}\n              itemProps={nodes}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n          {links && linkLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={linkLabelPositions}\n              itemProps={links}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n        </div>\n      ) : undefined}\n    </>\n  );\n}\n","import { ComponentChildren } from 'preact';\nimport { centerXYToPanXY } from './utils/diagramUtils';\nimport { panZoomStyles } from './themes/DiagramStyles.css';\n\ntype Props = {\n  centerX: number;\n  centerY: number;\n  zoom: number;\n  width: number;\n  height: number;\n  children: ComponentChildren;\n};\n\nexport function DiagramPanZoomContainer({\n  centerX,\n  centerY,\n  children,\n  zoom,\n  width,\n  height\n}: Props) {\n  const panValues = centerXYToPanXY(centerX, centerY, zoom, width, height);\n  return (\n    <div\n      class={panZoomStyles}\n      style={{\n        //TODO JET-62471 look at using matrices or both in transform instead\n        translate: `${panValues.panX}px ${panValues.panY}px`,\n        transform: `scale(${zoom})`\n      }}>\n      {children}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\n\n/**\n * Navigation direction\n */\nexport type NavDirection = 'right' | 'left' | 'up' | 'down';\n\ntype linkDetailType<K2> = {\n  id: K2;\n  angle: number;\n  distance: number;\n  /**\n   * Ingoing = 1, outgoing = 0\n   */\n  direction: 0 | 1;\n};\n\n/**\n * Returns the node data based on node info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getNodeDetailFromInfo<K1, K2, D1 extends DiagramNodeData<K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  nodes: D1[]\n): D1 | undefined {\n  let node;\n  for (let i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (itemInfo.id === node.id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the link data based on link info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getLinkDetailFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  links: D2[]\n): D2 | undefined {\n  let link;\n  for (let i = 0; i < links.length; i++) {\n    link = links[i];\n    if (itemInfo.id === link.id) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a map with key node id and value node bounds\n */\nexport function createNodeBoundsMap<K1, D1 extends DiagramNodeData<K1>>(\n  nodes: D1[],\n  bounds: Bounds[]\n) {\n  const nodeBounds: Map<K1, Bounds> = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    nodeBounds.set(nodes[i].id, bounds[i]);\n  }\n  return nodeBounds;\n}\n\n/**\n * Utility method that adds sorting attributes of each link to an array\n */\nexport function addSortingAttributes<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, listOfLinks: D2[], nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let angle, distance, direction;\n  const linkDetail: linkDetailType<K2>[] = [];\n  for (let i = 0; i < listOfLinks.length; i++) {\n    const link = listOfLinks[i];\n    angle = _getClockwiseAngle(node, link, nodes, nodeBounds);\n    distance = _getNodesDistance(link, nodes, nodeBounds);\n    direction = _getLinkDirection(node, link);\n    linkDetail.push({ id: link.id, angle: angle, distance: distance, direction: direction });\n  }\n  return linkDetail;\n}\n\n/**\n * Returns a function that compares two link around a given node\n * The links are analyzed by angle, distance from the node and direction. The sorting attributes are added to the links before sorting.\n */\nexport function getLinkComparator<K2>() {\n  return (link1: linkDetailType<K2>, link2: linkDetailType<K2>) => {\n    const { angle: linkAngle1, distance: linkDistance1, direction: linkDirection1 } = link1;\n    const { angle: linkAngle2, distance: linkDistance2, direction: linkDirection2 } = link2;\n    let res = -1;\n\n    if (!_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2) && linkAngle1 > linkAngle2) {\n      res = 1;\n    } else if (_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2)) {\n      //check distance and direction\n      if (linkDistance1 > linkDistance2) {\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 > linkDirection2) {\n        //outgoing to ingoing\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 == linkDirection2) {\n        res = 0;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns navigable links for a given node\n */\nexport function getNavigableLinksForNodeId<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  nodeId: K1,\n  listOfLinks: D2[]\n) {\n  const links: D2[] = [];\n  listOfLinks.forEach((link) => {\n    const startId = link.startNode;\n    const endId = link.endNode;\n\n    if (startId == nodeId || endId == nodeId) links.push(link);\n  });\n  return links;\n}\n\n/**\n * Get the clockwise angle for the link given node as a center\n */\nfunction _getClockwiseAngle<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  //find opposite node\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const oppositeNode = node.id == startNode.id ? endNode : startNode;\n\n  const p1 = _getNodeCenter(node, nodeBounds);\n  const p2 = _getNodeCenter(oppositeNode, nodeBounds);\n  let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n  angle = angle < 0 ? angle + Math.PI * 2 : angle;\n  return angle;\n}\n\n/**\n * Get the distance between start and end nodes for the given link\n */\nfunction _getNodesDistance<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const p1 = _getNodeCenter(startNode, nodeBounds);\n  const p2 = _getNodeCenter(endNode, nodeBounds);\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\n/**\n * Get link direction for the given node.  1 if the node is the end node\n * and 0 if it is the start node\n */\nfunction _getLinkDirection<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2): 0 | 1 {\n  if (link.endNode === node.id) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Get node center\n */\nfunction _getNodeCenter<K1, D1 extends DiagramNodeData<K1>>(node: D1, nodeBounds: Map<K1, Bounds>) {\n  const nodeBB = nodeBounds.get(node.id)!;\n  return { x: nodeBB.x + nodeBB.w / 2, y: nodeBB.y + nodeBB.h / 2 };\n}\n\n/**\n * Calculates the angle weighted by distance\n */\nexport function calcDistanceAngleWeighted(\n  objectBB: Bounds,\n  currentBB: Bounds,\n  direction: NavDirection\n) {\n  // Variables used for calculating penalties when calculating distances between two navigables.\n  const optimalAngle1 = (15 / 180) * Math.PI;\n  const optimalAngle2 = (40 / 180) * Math.PI;\n  const suboptimalAnglePenalty1 = 2; // multiplier to the distance\n  const suboptimalAnglePenalty2 = 6; // multiplier to the distance\n\n  const objCenterX = objectBB.x + objectBB.w / 2;\n  const objCenterY = objectBB.y + objectBB.h / 2;\n\n  const curCenterX = currentBB.x + currentBB.w / 2;\n  const curCenterY = currentBB.y + currentBB.h / 2;\n\n  const x_dist = Math.abs(objCenterX - curCenterX);\n  const y_dist = Math.abs(objCenterY - curCenterY);\n\n  const angle = Math.atan2(y_dist, x_dist);\n\n  let distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n\n  // Angle penalty based on direction\n  if (\n    (angle > optimalAngle1 && (direction == 'right' || direction == 'left')) ||\n    (angle < Math.PI / 2 - optimalAngle1 && (direction == 'up' || direction == 'down'))\n  ) {\n    if (\n      (angle > optimalAngle2 && (direction == 'right' || direction == 'left')) ||\n      (angle < Math.PI / 2 - optimalAngle2 && (direction == 'up' || direction == 'down'))\n    ) {\n      distance *= suboptimalAnglePenalty2;\n    } else {\n      distance *= suboptimalAnglePenalty1;\n    }\n  }\n\n  return distance;\n}\n\n/**\n * Given a direction, is a certain node is a valid destination to navigate to\n */\nexport function isValidDestination(\n  objBB: Bounds,\n  curBB: Bounds,\n  direction: NavDirection,\n  compareCenters: boolean\n) {\n  // compare the centers of the navigable and to be valid, the navigable must be in the right direction\n  // without tolerance\n  if (compareCenters) {\n    const objCenterX = objBB.x + 0.5 * objBB.w;\n    const curCenterX = curBB.x + 0.5 * curBB.w;\n    const objCenterY = objBB.y + 0.5 * objBB.h;\n    const curCenterY = curBB.y + 0.5 * curBB.h;\n\n    switch (direction) {\n      case 'up':\n        return objCenterY < curCenterY;\n      case 'down':\n        return objBB.y > curCenterY;\n      case 'right':\n        return objCenterX > curCenterX;\n      case 'left':\n        return objCenterX < curCenterX;\n      default:\n        break;\n    }\n    return true;\n  }\n\n  switch (direction) {\n    case 'up':\n      return objBB.y < curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'down':\n      return objBB.y > curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'right':\n      return objBB.x > curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    case 'left':\n      return objBB.x < curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    default:\n      break;\n  }\n  return true;\n}\n\n/**\n * Returns true if two nodes are in contact\n */\nexport function calcInContact(objRect: Bounds, curRect: Bounds, direction: NavDirection) {\n  switch (direction) {\n    case 'up':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (curRect.y <= objRect.y + objRect.h ||\n          _areEqualWithinTolerance(curRect.y, objRect.y + objRect.h))\n      );\n    case 'down':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (objRect.y <= curRect.y + curRect.h ||\n          _areEqualWithinTolerance(objRect.y, curRect.y + curRect.h))\n      );\n    case 'right':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (objRect.x <= curRect.x + curRect.w ||\n          _areEqualWithinTolerance(objRect.x, curRect.x + curRect.w))\n      );\n    case 'left':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (curRect.x <= objRect.x + objRect.w ||\n          _areEqualWithinTolerance(curRect.x, objRect.x + objRect.w))\n      );\n    default:\n      break;\n  }\n\n  return false;\n}\n\nfunction _isVerticallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.x >= rect2.x && rect1.x <= rect2.x + rect2.w) ||\n    (rect2.x >= rect1.x && rect2.x <= rect1.x + rect1.w)\n  );\n}\n\nfunction _isHorizontallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.y >= rect2.y && rect1.y <= rect2.y + rect2.h) ||\n    (rect2.y >= rect1.y && rect2.y <= rect1.y + rect1.h)\n  );\n}\n\nfunction _areEqualWithinTolerance(a: number, b: number) {\n  return Math.abs(a - b) <= 0.0000001;\n}\n\nfunction _anglesAreEqualWithinTolerance(a1: number, a2: number) {\n  let res = Math.abs(a1 - a2) <= 0.0000001;\n  if (!res) {\n    res = Math.abs(Math.PI * 2 + Math.min(a1, a2) - Math.max(a1, a2)) <= 0.0000001;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  NavDirection,\n  addSortingAttributes,\n  calcDistanceAngleWeighted,\n  calcInContact,\n  createNodeBoundsMap,\n  getLinkComparator,\n  getNavigableLinksForNodeId,\n  getNodeDetailFromInfo,\n  isValidDestination\n} from '../utils/navUtils';\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\nimport { useRef } from 'preact/hooks';\n\nexport function useDiagramNavigation<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(nodes: D1[], links: D2[], bounds: Bounds[], linkIdToDataMap: Map<K2, D2>) {\n  const currentKeyboardFocusNode = useRef<K1>();\n  const nodeBoundsById = createNodeBoundsMap<K1, D1>(nodes, bounds);\n\n  function getNextNavigableNode(\n    direction: NavDirection,\n    compareCenters: boolean,\n    current?: D1,\n    listOfObjects?: D1[]\n  ) {\n    if (!listOfObjects) return current;\n\n    if (!current) return listOfObjects[0];\n    const currBB = nodeBoundsById.get(current.id);\n    if (!currBB) return listOfObjects[0];\n\n    let nextObject = current; //init to current object\n    let nextDistance = Number.MAX_VALUE;\n\n    // If an object is in contact it overrules all other attributes\n    // Only another in contact object with better attributes will have higher precedence\n    let nextInContact = false;\n\n    // Whether or not the for loop has encountered the current object\n    let hasFoundCurrent = false;\n\n    let object, inContact, distance;\n    for (let i = 0; i < listOfObjects.length; i++) {\n      object = listOfObjects[i];\n\n      if (object === current) {\n        hasFoundCurrent = true;\n        continue;\n      }\n      const objBB = nodeBoundsById.get(object.id);\n      if (!objBB) continue;\n\n      const objBounds = { x: objBB.x, y: objBB.y, w: objBB.w, h: objBB.h };\n      const currBounds = { x: currBB.x, y: currBB.y, w: currBB.w, h: currBB.h };\n      if (!isValidDestination(objBounds, currBounds, direction, compareCenters)) continue;\n\n      inContact = calcInContact(objBounds, currBounds, direction);\n\n      if (nextInContact && !inContact) continue;\n\n      distance = calcDistanceAngleWeighted(objBounds, currBounds, direction);\n\n      if (distance == 0 && !hasFoundCurrent) continue;\n\n      // Make sure incontact flag have highest precedence\n      if (\n        (!nextInContact && inContact) ||\n        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact))\n      ) {\n        nextDistance = distance;\n        nextObject = object;\n        nextInContact = inContact;\n      }\n    }\n    return nextObject;\n  }\n\n  /**\n   * Get next navigavle link depending on direction - clockwise or conter clockwise.\n   * The decision is made based on location of nodes centers rather than link paths or link angles.\n   */\n  function getNextNavigableLink(\n    direction: string,\n    listOfNodes: D1[],\n    currentLink?: D2,\n    listOfLinks?: D2[]\n  ) {\n    if (!listOfLinks) return currentLink;\n\n    if (!currentLink) return listOfLinks[0];\n    const keyboardFocusNode = currentKeyboardFocusNode.current;\n    const nodeId = keyboardFocusNode ? keyboardFocusNode : currentLink.startNode;\n    const node = getNodeDetailFromInfo({ id: nodeId, isNode: true }, listOfNodes);\n\n    if (!node) return currentLink;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    listOfLinks = adjLinks;\n    const linksWithSortingAttributes = addSortingAttributes<K1, K2, D1, D2>(\n      node,\n      listOfLinks,\n      listOfNodes,\n      nodeBoundsById\n    );\n    linksWithSortingAttributes.sort(getLinkComparator());\n    //clockwise direction\n    const bForward = direction == 'down' ? true : false;\n    let index = 0;\n    for (let i = 0; i < linksWithSortingAttributes.length; i++) {\n      const link = linksWithSortingAttributes[i];\n      if (link.id === currentLink.id) {\n        if (bForward) index = i == linksWithSortingAttributes.length - 1 ? 0 : i + 1;\n        else index = i == 0 ? linksWithSortingAttributes.length - 1 : i - 1;\n        break;\n      }\n    }\n    return linksWithSortingAttributes[index];\n  }\n\n  /**\n   * Returns the link detail when a node to link navigation occurs\n   */\n  function navigateFromNodeToLink(listOfLinks: D2[], event: KeyboardEvent, node?: D1) {\n    if (!node) return undefined;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    if (adjLinks.length < 1) return undefined;\n    let link = adjLinks[0];\n    const nodeBB = nodeBoundsById.get(node.id)!;\n    let object, currNode, currNodeBB, currNodeBBCenterX;\n    const nodeCenterX = nodeBB.x + nodeBB.w / 2;\n    currentKeyboardFocusNode.current = node.id;\n    for (let i = 0; i < adjLinks.length; i++) {\n      object = adjLinks[i];\n      currNode = object.startNode === node.id ? object.endNode : object.startNode;\n      currNodeBB = nodeBoundsById.get(currNode);\n      currNodeBBCenterX = currNodeBB!.x + currNodeBB!.w / 2;\n      if (\n        // equivalent of ≤ and ≥\n        (event.altKey && event.code === 'Comma' && currNodeBBCenterX <= nodeCenterX) ||\n        (event.altKey && event.code === 'Period' && currNodeBBCenterX >= nodeCenterX)\n      ) {\n        link = object;\n        break;\n      }\n    }\n    return { id: link.id, isNode: false };\n  }\n\n  /**\n   * Returns the node detail when a link to node navigation occurs\n   */\n  function navigateFromLinkToNode(linkId: K2, event: KeyboardEvent) {\n    const key = event.key;\n    const linkData = linkIdToDataMap.get(linkId)!;\n    const startNodeBB = nodeBoundsById.get(linkData.startNode);\n    const endNodeBB = nodeBoundsById.get(linkData.endNode);\n    if (!startNodeBB || !endNodeBB) return undefined;\n    const startNodeCenterX = startNodeBB.x + startNodeBB.w / 2;\n    const endNodeCenterX = endNodeBB.x + endNodeBB.w / 2;\n    const newNode =\n      (endNodeCenterX > startNodeCenterX && key === 'ArrowRight') ||\n      (endNodeCenterX < startNodeCenterX && key === 'ArrowLeft')\n        ? linkData.endNode\n        : linkData.startNode;\n    return { id: newNode, isNode: true };\n  }\n\n  return {\n    isNode: (itemInfo: ItemInfo<K1, K2>): boolean => {\n      let node, link;\n      for (let i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        link = links[i];\n        if (itemInfo.id === node.id) {\n          return true;\n        }\n        if (itemInfo.id === link.id) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  };\n}\n","import {\n  ItemInfo,\n  ItemHoverDetail,\n  ItemFocusDetail,\n  Bounds,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport { useRef, useState } from 'preact/hooks';\nimport { isEqualItem, getNavigableInfo, zoomAndCenterItemFromInfo } from '../utils/diagramUtils';\nimport { getRandomId } from '../../utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { getNodeDetailFromInfo, getLinkDetailFromInfo } from '../utils/navUtils';\nimport { useDiagramNavigation } from './useDiagramNavigation';\nimport type { NavDirection } from '../utils/navUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\n\nconst DEFAULT_KB_PAN = 15;\nconst DEFAULT_KB_ZOOM = 0.15;\n\nexport function useEvents<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  touchResponse: 'touchStart' | 'touchHold',\n  initNode: D1,\n  nodes: D1[],\n  links: D2[],\n  nodeBounds: Bounds[],\n  linkIdToDataMap: Map<K2, D2>,\n  nodeIdToDataMap: Map<K1, D1>,\n  nodeIdToIndexMap: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number,\n  onItemHover?: (detail: ItemHoverDetail<K1, K2, D1, D2>) => void,\n  onItemFocus?: (detail: ItemFocusDetail<K1, K2, D1, D2>) => void,\n  kbPanCallback?: (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => void,\n  kbZoomCallback?: (props: { dZoom?: number; nZoom?: number }) => void\n) {\n  const {\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  } = useDiagramNavigation<K1, K2, D1, D2>(nodes, links, nodeBounds, linkIdToDataMap);\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo<K1, K2>>({\n    id: initNode.id,\n    isNode: true\n  });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo<K1, K2>>();\n  const activeId = useRef<string>();\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    let eventConsumed = false;\n    // tabbing out of the diagram\n    if (key === 'TAB') {\n      return;\n    }\n    // if this a switch from node to link or vice versa\n    if (isChangeItemType(event)) {\n      const nextItemInfo = focusedItemInfo.isNode\n        ? navigateFromNodeToLink(links, event, getNodeDetailFromInfo(focusedItemInfo, nodes))\n        : navigateFromLinkToNode(focusedItemInfo.id as K2, event);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else if (isNavigationEvent(key)) {\n      const nextItemInfo = handleKeyboardNavigationEvent(key);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else {\n      switch (key) {\n        case 'PageUp': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? -DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : -DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          break;\n        }\n        case 'PageDown': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          eventConsumed = true;\n          break;\n        }\n        case '+':\n        case '=': {\n          kbZoomCallback && kbZoomCallback({ dZoom: DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '-':\n        case '_': {\n          kbZoomCallback && kbZoomCallback({ dZoom: -DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '0': {\n          if (event.ctrlKey && event.altKey) {\n            const { centerX, centerY, zoom } = zoomAndCenterItemFromInfo(\n              focusedItemInfo,\n              linkIdToDataMap,\n              nodeBounds,\n              nodeIdToIndexMap,\n              width,\n              height,\n              maxZoom\n            );\n            kbZoomCallback && kbZoomCallback({ nZoom: zoom });\n            kbPanCallback && kbPanCallback({ nPan: { cx: centerX, cy: centerY } });\n          } else {\n            // zoom to fit\n            kbZoomCallback && kbZoomCallback({});\n            kbPanCallback && kbPanCallback({ center: true });\n          }\n          eventConsumed = true;\n        }\n      }\n    }\n    if (eventConsumed) {\n      cancelEvent(event);\n    }\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onItemFocus?.({ id: undefined, data: undefined });\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  const onHover = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo && !isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo({ ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n      if (itemInfo.isNode) {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'node',\n          data: nodeIdToDataMap.get(itemInfo.id as K1)\n        });\n      } else {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'link',\n          data: linkIdToDataMap.get(itemInfo.id as K2)\n        });\n      }\n    }\n  };\n\n  const onHoverLeave = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    onItemHover?.({ id: undefined, data: undefined });\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo.id != null) {\n      setfocusedItemInfo(itemInfo);\n      activeId.current = getRandomId();\n    }\n  };\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo<K1, K2>) {\n    if (itemInfo.isNode) {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'node',\n        data: nodeIdToDataMap.get(itemInfo.id as K1)\n      });\n    } else {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'link',\n        data: linkIdToDataMap.get(itemInfo.id as K2)\n      });\n    }\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item?: ItemInfo<K1, K2>) {\n    if (!item) return;\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  function isNavigationEvent(key: string) {\n    switch (key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isChangeItemType(event: KeyboardEvent) {\n    const key = event.code;\n    // check if switching from node to link\n    // equivalent of ≤ and ≥\n    if (focusedItemInfo.isNode && event.altKey && (key === 'Period' || key === 'Comma')) {\n      return true;\n      // check if switching from link to node\n    } else if (!focusedItemInfo.isNode && (key === 'ArrowLeft' || key === 'ArrowRight')) {\n      return true;\n    }\n    return false;\n  }\n\n  function handleKeyboardNavigationEvent(key: string) {\n    let direction: NavDirection = 'down';\n    switch (key) {\n      case 'ArrowDown': {\n        direction = 'down';\n        break;\n      }\n      case 'ArrowUp': {\n        direction = 'up';\n        break;\n      }\n      case 'ArrowRight': {\n        direction = 'right';\n        break;\n      }\n      case 'ArrowLeft': {\n        direction = 'left';\n        break;\n      }\n    }\n    if (focusedItemInfo.isNode) {\n      const itemDetail = getNextNavigableNode(\n        direction,\n        true,\n        getNodeDetailFromInfo(focusedItemInfo, nodes),\n        nodes\n      );\n      return itemDetail ? { id: itemDetail.id, isNode: true } : focusedItemInfo;\n    } else {\n      const linkDetail = getLinkDetailFromInfo(focusedItemInfo, links);\n      const itemDetail = getNextNavigableLink(direction, nodes, linkDetail, links);\n      return itemDetail ? { id: itemDetail.id } : { id: focusedItemInfo.id };\n    }\n  }\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    eventsProps: mergeProps(hoverHandlers, {\n      onKeyUp: keyUpHandler,\n      onKeyDown: keyDownHandler,\n      onBlur: blurHandler,\n      onPointerUp: pointerUpHandler\n    })\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  ItemInfo,\n  Bounds,\n  DatatipContext,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport { calculateOffset, useDatatip } from '../../hooks/PRIVATE_useDatatip';\nimport type { Pan } from '../utils/panUtils';\nimport { useUser } from '../../hooks/UNSAFE_useUser';\nimport { getDatatipContent } from '../utils/diagramUtils';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\n\ntype props<K1, K2, D1, D2> = {\n  touchResponse: 'touchStart' | 'touchHold';\n  datatip?: (context: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  };\n  text?: string;\n  focusedItemInfo: ItemInfo<K1, K2>;\n  focusedItemBoundsRef: Ref<Bounds | null>;\n  panState: Pan;\n  zoom: number;\n  width: number;\n  nodesMap: Map<K1, D1>;\n  linksMap: Map<K2, D2>;\n  hoveredItem?: ItemInfo<K1, K2>;\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the diagram item.\n * @param rootRef The ref for root of the diagram.\n * @param focusedItemBoundsRef The ref for focused item bounds.\n * @param focusedItemInfo The ItemInfo for focused item.\n * @returns\n */\nexport const useDiagramDatatip = <\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({\n  touchResponse,\n  datatip,\n  focusedItemBoundsRef,\n  focusedItemInfo,\n  panState,\n  zoom,\n  width,\n  nodesMap,\n  linksMap,\n  hoveredItem\n}: props<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const datatipC = getDatatipContent(nodesMap, linksMap, focusedItemInfo, hoveredItem, datatip);\n\n  const elementBounds = focusedItemInfo?.isCurrent\n    ? {\n        x: focusedItemBoundsRef.current!.x * zoom + panState.panX,\n        y: focusedItemBoundsRef.current!.y * zoom + panState.panY,\n        width: focusedItemBoundsRef.current!.w * zoom,\n        height: focusedItemBoundsRef.current!.h * zoom\n      }\n    : undefined;\n\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatipC?.content,\n    borderColor: datatipC?.borderColor,\n    placement: 'top-start',\n    offset: calculateOffset(isRtl, width, elementBounds),\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    touchResponse\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\n\ntype PointerGesture = {\n  pointers: PointerEvent[];\n};\n\ntype UsePointerGestureOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  numPointers: number;\n  onPointerGestureDown?: (detail: PointerGesture) => void;\n  onPointerGestureMove?: (detail: PointerGesture) => void;\n  onPointerGestureEnd?: (detail: PointerGesture) => void;\n  onExtraneousPointerDown?: (detail: PointerGesture) => void;\n  isDisabled?: boolean;\n};\n\nconst usePointerGesture = ({\n  captureTargetRef,\n  numPointers = 1,\n  onPointerGestureDown,\n  onPointerGestureMove,\n  onPointerGestureEnd,\n  onExtraneousPointerDown,\n  isDisabled = false\n}: UsePointerGestureOptions) => {\n  const activePointers = useRef<PointerEvent[]>([]);\n\n  if (isDisabled) {\n    activePointers.current = [];\n  }\n\n  const onPointerDown = (e: PointerEvent) => {\n    activePointers.current.push(e);\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureDown && onPointerGestureDown({ pointers: activePointers.current });\n    } else if (activePointers.current.length > numPointers) {\n      onExtraneousPointerDown && onExtraneousPointerDown({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (activePointers.current.length === 0) return;\n\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      activePointers.current.forEach((e) =>\n        captureTargetRef.current!.setPointerCapture(e.pointerId)\n      );\n\n      onPointerGestureMove && onPointerGestureMove({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerUp = (e: PointerEvent) => {\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureEnd && onPointerGestureEnd({ pointers: activePointers.current });\n    }\n    activePointers.current.splice(index, 1);\n  };\n\n  const onPointerCancel = onPointerUp;\n  const onPointerLeave = onPointerUp;\n\n  return isDisabled\n    ? {}\n    : {\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onPointerCancel,\n        onPointerLeave\n      };\n};\n\nexport { usePointerGesture };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Bounds, PanState } from '../diagram.types';\nimport { panXYToCenterXY } from './diagramUtils';\nexport type PanBounds = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\n/**\n * The pan values that describes where the diagram content\n * is panned\n */\nexport type Pan = {\n  panX: number;\n  panY: number;\n};\n\nconst constrainPan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panBounds: PanBounds,\n  panDirection: 'x' | 'y' | 'any'\n) => {\n  const panX = panDirection !== 'y' ? nextPan.panX : previousPan.panX;\n  const panY = panDirection !== 'x' ? nextPan.panY : previousPan.panY;\n  return {\n    panX: panX > panBounds.maxX || panX < panBounds.minX ? previousPan.panX : panX,\n    panY: panY > panBounds.maxY || panY < panBounds.minY ? previousPan.panY : panY\n  };\n};\n\nexport const pan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panDirection: 'x' | 'y' | 'any',\n  zoom: number,\n  width: number,\n  height: number,\n  panBounds?: PanBounds,\n  onPanChange?: (detail: PanState) => void\n) => {\n  if (!panBounds) {\n    //On initial render before nodes are rendered\n    return { newPan: { panX: 0, panY: 0 } };\n  }\n  const newPan = constrainPan(previousPan, nextPan, panBounds, panDirection);\n  const isPanChanged = newPan.panX !== previousPan.panX || newPan.panY !== previousPan.panY;\n  const center = panXYToCenterXY(newPan.panX, newPan.panY, zoom, width, height);\n  isPanChanged &&\n    onPanChange &&\n    onPanChange({\n      centerX: center.centerX,\n      centerY: center.centerY\n    });\n  return { newPan };\n};\n\nexport const getPanBounds = (\n  width: number,\n  height: number,\n  elemBounds: Bounds,\n  panType: string,\n  zoom: number,\n  minZoom: number,\n  initPanZoomState: {\n    zoom: number;\n    centerX?: number;\n    centerY?: number;\n  }\n): PanBounds => {\n  const { x, y, w, h } = elemBounds;\n  let minX, maxX, minY, maxY;\n  if (panType === 'centerContent') {\n    minX = width / 2 - (w + x) * zoom;\n    minY = height / 2 - (h + y) * zoom;\n    maxX = width / 2 - x * zoom;\n    maxY = height / 2 - y * zoom;\n  } else {\n    // panType equals fixed\n    const zoomRatio = zoom / minZoom;\n    // Find left corner of the content at min zoom and content is centered\n    const minZoomX = (width - w * minZoom) / 2 - x * minZoom;\n    const minZoomY = (height - h * minZoom) / 2 - y * minZoom;\n    // When we pan all the way to the right, the left corner of displayable area is 0,0 as in min zoom.\n    // When we pan all the way to the left, lets find the corner of the displayable area\n    const leftCornerX = width - width * zoomRatio;\n    const leftCornerY = height - height * zoomRatio;\n    // Now we have everything to calculate pan zoom constraints\n    minX = leftCornerX + minZoomX * zoomRatio;\n    minY = leftCornerY + minZoomY * zoomRatio;\n    maxX = minZoomX * zoomRatio;\n    maxY = minZoomY * zoomRatio;\n  }\n  const initZoom = initPanZoomState.zoom;\n  const initCenterX = initPanZoomState.centerX;\n  const initCenterY = initPanZoomState.centerY;\n  // If an initial panZoomState is set, should expand pan bounds to include it\n  let dx, dy;\n  if (initCenterX) {\n    const boundsX = initCenterX * initZoom - width / 2;\n    if (-boundsX * initZoom < minX) {\n      dx = minX - boundsX * initZoom;\n      minX -= dx;\n      maxX += dx;\n    } else if (-boundsX * initZoom > maxX) {\n      dx = -boundsX * initZoom - maxX;\n      minX -= dx;\n      maxX += dx;\n    }\n  }\n  if (initCenterY) {\n    const boundsY = initCenterY * initZoom - height / 2;\n    if (-boundsY * initZoom < minY) {\n      dy = minY - boundsY * initZoom;\n      minY -= dy;\n      maxY += dy;\n    } else if (-boundsY * initZoom > maxY) {\n      dy = -boundsY * initZoom - maxY;\n      minY -= dy;\n      maxY += dy;\n    }\n  }\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PanState } from '../diagram.types';\n\nimport { Ref, useRef } from 'preact/hooks';\nimport { useDrag } from './useDrag';\nimport { PanBounds, pan } from '../utils/panUtils';\nimport { centerXYToPanXY } from '../utils/diagramUtils';\n/**\n * Options for useDragPan hook\n */\ntype UseDragPanOptions = {\n  panProps: {\n    panning: 'centerContent' | 'fixed' | 'off';\n    centerX: number;\n    centerY: number;\n    panDirection: 'x' | 'y' | 'any';\n    onPan?: (detail: PanState) => void;\n  };\n  captureTargetRef: Ref<HTMLDivElement>;\n  panBounds?: PanBounds;\n  onDragPanStart?: () => void;\n  onDragPanEnd?: () => void;\n  zoom: number;\n  width: number;\n  height: number;\n};\n\nconst useDragPan = ({\n  panProps,\n  captureTargetRef,\n  panBounds,\n  width,\n  height,\n  zoom,\n  onDragPanStart,\n  onDragPanEnd\n}: UseDragPanOptions) => {\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n  const initialPanState = useRef({ panX: 0, panY: 0 });\n  const dragProps = useDrag({\n    captureTargetRef,\n    onDragStart: () => {\n      const panValues = centerXYToPanXY(panProps.centerX, panProps.centerY, zoom, width, height);\n      initialPanState.current = {\n        panX: panValues.panX,\n        panY: panValues.panY\n      };\n      onDragPanStart && onDragPanStart();\n    },\n    onDragMove: ({ dx, dy }) => {\n      const nextPan = {\n        panX: initialPanState.current.panX + dx,\n        panY: initialPanState.current.panY + dy\n      };\n      const { newPan } = pan(\n        prevPanState.current,\n        nextPan,\n        panProps.panDirection,\n        zoom,\n        width,\n        height,\n        panBounds,\n        panProps.onPan\n      );\n      prevPanState.current = newPan;\n    },\n    onDragEnd: ({ originalEvent }) => {\n      // If panning occurred, call preventDefault to prevent selection from occurring\n      if (\n        initialPanState.current.panX !== prevPanState.current.panX ||\n        initialPanState.current.panY !== prevPanState.current.panY\n      )\n        originalEvent.preventDefault();\n      onDragPanEnd && onDragPanEnd();\n    },\n    isDisabled: panProps.panning === 'off'\n  });\n\n  return dragProps;\n};\n\nexport { useDragPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n/**\n * Draggable region\n */\ntype DraggableRegion = {\n  xMin: number;\n  xMax: number;\n  yMin: number;\n  yMax: number;\n};\n\ntype DragDetail = {\n  x: number;\n  y: number;\n  dx: number;\n  dy: number;\n  regionOffsetX: number;\n  regionOffsetY: number;\n  originalEvent: PointerEvent;\n};\n\ntype UseDragOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  draggableRegion?: DraggableRegion;\n  onDragStart?: (detail: Omit<DragDetail, 'dx' | 'dy'>) => void;\n  onDragMove?: (detail: DragDetail) => void;\n  onDragEnd?: (detail: DragDetail) => void;\n  isDisabled?: boolean;\n};\n/**\n * Whether point with coordinates are in the draggable region\n */\nconst inDraggableRegion = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return true;\n  const { xMin, xMax, yMin, yMax } = region;\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\n};\n\n/**\n * Returns region offset\n */\nconst getRegionOffset = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return { regionOffsetX: x, regionOffsetY: y };\n  return { regionOffsetX: x - region.xMin, regionOffsetY: y - region.yMin };\n};\n\nconst useDrag = ({\n  captureTargetRef,\n  draggableRegion,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  isDisabled = false\n}: UseDragOptions) => {\n  const inactiveState = { isDragging: false, x0: -1, y0: -1, regionOffsetX: -1, regionOffsetY: -1 };\n  const dragState = useRef(inactiveState);\n\n  const handlePointerEvent = (e: PointerEvent, cb?: (detail: DragDetail) => void) => {\n    const { isDragging, x0, y0, regionOffsetX, regionOffsetY } = dragState.current;\n    if (!isDragging) return;\n    const x = e.pageX;\n    const y = e.pageY;\n    cb && cb({ x, y, dx: x - x0, dy: y - y0, regionOffsetX, regionOffsetY, originalEvent: e });\n  };\n\n  const dragProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 1, // Only allow 1 pointer dragging\n    onExtraneousPointerDown: () => {\n      dragState.current = inactiveState;\n    },\n    onPointerGestureDown: ({ pointers: [e] }) => {\n      const x = e.pageX;\n      const y = e.pageY;\n      if (e.button !== 0 || !inDraggableRegion(x, y, draggableRegion)) return;\n      const { regionOffsetX, regionOffsetY } = getRegionOffset(x, y, draggableRegion);\n      dragState.current = { isDragging: true, x0: x, y0: y, regionOffsetX, regionOffsetY };\n      onDragStart && onDragStart({ x, y, regionOffsetX, regionOffsetY, originalEvent: e });\n    },\n    onPointerGestureMove: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragMove);\n    },\n    onPointerGestureEnd: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragEnd);\n      dragState.current = inactiveState;\n    }\n  });\n\n  return isDisabled ? {} : dragProps;\n};\n\nexport { useDrag };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const ZOOM_INCREMENT = 0.05;\n\nexport const zoom = (\n  nextZoom: number,\n  zoom: number,\n  minZoom: number,\n  maxZoom: number,\n  onZoomChange?: (detail: { zoomValue: number }) => void\n) => {\n  const newZoom = nextZoom > maxZoom || nextZoom < minZoom ? zoom : nextZoom;\n  const isZoomChanged = newZoom !== zoom;\n  isZoomChanged &&\n    onZoomChange &&\n    onZoomChange({\n      zoomValue: newZoom\n    });\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n\ntype Point = { x: number; y: number };\n\nconst getMidpoint = (p1: Point, p2: Point) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });\nconst getDistance = (p1: Point, p2: Point) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p2.y) ** 2);\n\ntype PinchDetail = {\n  origin: Point;\n  delta: number;\n};\n\ntype UsePinchOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  onPinchZoomStart?: (detail: PinchDetail) => void;\n  onPinchZoomChange?: (detail: PinchDetail) => void;\n  onPinchZoomEnd?: () => void;\n  isDisabled?: boolean;\n};\n\nconst usePinch = ({\n  captureTargetRef,\n  onPinchZoomStart,\n  onPinchZoomChange,\n  onPinchZoomEnd,\n  isDisabled = false\n}: UsePinchOptions) => {\n  const origin = useRef({ x: -1, y: -1 });\n  const prevDistance = useRef(-1);\n  const reset = () => {\n    origin.current = { x: -1, y: -1 };\n    prevDistance.current = -1;\n  };\n\n  if (isDisabled) reset();\n\n  const pinchProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 2, // Pinch gesture requires 2 pointers\n    onPointerGestureDown: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      origin.current = getMidpoint(p1, p2);\n      prevDistance.current = getDistance(p1, p2);\n      onPinchZoomStart &&\n        onPinchZoomStart({\n          origin: origin.current,\n          delta: 0\n        });\n    },\n    onPointerGestureMove: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      const distance = getDistance(p1, p2);\n      const delta = distance - prevDistance.current;\n      prevDistance.current = distance;\n      onPinchZoomChange &&\n        onPinchZoomChange({\n          origin: origin.current,\n          delta\n        });\n    },\n    onPointerGestureEnd: () => {\n      reset();\n      onPinchZoomEnd && onPinchZoomEnd();\n    }\n  });\n\n  return isDisabled ? {} : pinchProps;\n};\n\nexport { usePinch };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref } from 'preact/hooks';\nimport { usePinch } from './usePinch';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UsePinchZoomOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst usePinchZoom = ({\n  captureTargetRef,\n  zooming,\n  minZoom,\n  maxZoom,\n  zoomValue,\n  onZoom\n}: UsePinchZoomOptions) => {\n  const pinchProps = usePinch({\n    captureTargetRef,\n    onPinchZoomChange: ({ delta }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * delta);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return pinchProps;\n};\n\nexport { usePinchZoom };\n","import { Pan, Zoom, Bounds } from '../diagram.types';\nimport { Ref, useState, useRef } from 'preact/hooks';\nimport { useDragPan } from './useDragPan';\nimport { useWheelZoom } from './useWheelZoom';\nimport { usePinchZoom } from './usePinchZoom';\n\nimport {\n  centerXYToPanXY,\n  getPanProps,\n  getZoomProps,\n  getZoomToFitZoom\n} from '../utils/diagramUtils';\nimport { PanBounds, getPanBounds, pan } from '../utils/panUtils';\nimport { zoom } from '../utils/zoomUtils';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\n\nimport { Property } from 'csstype';\n\ntype PanZoomProps = {\n  props: Pan & Zoom;\n  captureTargetRef: Ref<HTMLDivElement>;\n  width: number;\n  height: number;\n  contentBounds: Bounds;\n};\n\nexport const usePanZoom = ({\n  props,\n  captureTargetRef,\n  width,\n  height,\n  contentBounds\n}: PanZoomProps) => {\n  const [cursor, setCursor] = useState<Property.Cursor>();\n  const zoomProps = getZoomProps(props, width, height, contentBounds);\n  const panProps = getPanProps(props, contentBounds);\n  const panBounds = useRef<PanBounds>();\n  const prevZoom = useRef<number>();\n  const panning = useRef<string>();\n  const initPanZoomState = useRef({\n    zoom: props.zoomValue || 0,\n    centerX: props.centerX,\n    centerY: props.centerY\n  });\n  if (\n    contentBounds.w !== Infinity &&\n    (zoomProps.zoomValue !== prevZoom.current || panProps.panning !== panning.current)\n  ) {\n    panBounds.current = getPanBounds(\n      width,\n      height,\n      contentBounds,\n      panProps.panning,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      initPanZoomState.current\n    );\n    prevZoom.current = zoomProps.zoomValue;\n    panning.current = panProps.panning;\n  }\n  const dragPanProps = useDragPan({\n    panProps: panProps,\n    captureTargetRef: captureTargetRef,\n    panBounds: panBounds.current,\n    zoom: zoomProps.zoomValue,\n    width,\n    height,\n    onDragPanStart: () => setCursor('grabbing'),\n    onDragPanEnd: () => setCursor('auto')\n  });\n  //dZoom or nZoom is required\n  const kbZoomCallback = (props: { dZoom?: number; nZoom?: number }) => {\n    const newZoom = props.dZoom\n      ? zoomProps.zoomValue + props.dZoom\n      : getZoomToFitZoom(width, height, contentBounds);\n    zoom(\n      props.nZoom ? props.nZoom : newZoom,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      zoomProps.maxZoom,\n      zoomProps.onZoom\n    );\n  };\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n\n  // dPan or nPan is required\n  const kbPanCallback = (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => {\n    let centerX;\n    let centerY;\n    if (props.center) {\n      centerX = contentBounds.x + contentBounds.w / 2;\n      centerY = contentBounds.y + contentBounds.h / 2;\n    } else if (props.dPan) {\n      centerX = panProps.centerX + props.dPan.dx;\n      centerY = panProps.centerY + props.dPan.dy;\n    } else {\n      centerX = props.nPan!.cx;\n      centerY = props.nPan!.cy;\n    }\n    const panValues = centerXYToPanXY(centerX, centerY, zoomProps.zoomValue, width, height);\n    const { newPan } = pan(\n      prevPanState.current,\n      panValues,\n      panProps.panDirection,\n      zoomProps.zoomValue,\n      width,\n      height,\n      panBounds.current,\n      panProps.onPan\n    );\n    prevPanState.current = newPan;\n  };\n  const wheelZoomProps = useWheelZoom(zoomProps);\n  const pinchZoomProps = usePinchZoom({\n    captureTargetRef,\n    zooming: zoomProps.zooming,\n    minZoom: zoomProps.minZoom,\n    maxZoom: zoomProps.maxZoom,\n    zoomValue: zoomProps.zoomValue,\n    onZoom: zoomProps.onZoom\n  });\n  const panZoomProps = mergeProps(dragPanProps, wheelZoomProps, pinchZoomProps);\n\n  return {\n    panZoomProps,\n    cursor,\n    centerX: panProps.centerX,\n    centerY: panProps.centerY,\n    zoomValue: zoomProps.zoomValue,\n    kbPanCallback: panProps.panning !== 'off' ? kbPanCallback : undefined,\n    kbZoomCallback: zoomProps.zooming !== 'off' ? kbZoomCallback : undefined\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useWheel } from './useWheel';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UseWheelZoomOptions = {\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst useWheelZoom = ({ zooming, minZoom, maxZoom, zoomValue, onZoom }: UseWheelZoomOptions) => {\n  const wheelProps = useWheel({\n    onWheel: ({ deltaY }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * deltaY);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return wheelProps;\n};\n\nexport { useWheelZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ntype WheelDetail = {\n  x: number;\n  y: number;\n  deltaX: number;\n  deltaY: number;\n  ctrlKey: boolean;\n};\n\ntype UseWheelOptions = {\n  onWheel: (detail: WheelDetail) => void;\n  preventDefault?: boolean;\n  isDisabled?: boolean;\n};\n\nconst PX_FACTOR_PER_LINE = 15; // Value used in Toolkit\nconst PX_FACTOR_PER_PAGE = 40; // Value copied from datagrid; this is not handled in Toolkit\n\nconst getNormalizedDelta = (e: WheelEvent) => {\n  const { deltaX, deltaY, deltaMode } = e;\n\n  switch (deltaMode) {\n    case e.DOM_DELTA_PIXEL:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n    case e.DOM_DELTA_LINE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_LINE, deltaY: -deltaY * PX_FACTOR_PER_LINE };\n    case e.DOM_DELTA_PAGE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_PAGE, deltaY: -deltaY * PX_FACTOR_PER_PAGE };\n    default:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n  }\n};\n\nconst useWheel = ({\n  onWheel: onWheelCallback,\n  preventDefault = true,\n  isDisabled = false\n}: UseWheelOptions) => {\n  const onWheel = (e: WheelEvent) => {\n    const { deltaX, deltaY } = getNormalizedDelta(e);\n    if (preventDefault) e.preventDefault();\n    onWheelCallback({\n      x: e.offsetX,\n      y: e.offsetY,\n      deltaX,\n      deltaY,\n      ctrlKey: e.ctrlKey || e.metaKey\n    });\n  };\n  return isDisabled ? {} : { onWheel };\n};\n\nexport { useWheel, PX_FACTOR_PER_LINE };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  DiagramProps,\n  Bounds,\n  DiagramLabelPosition,\n  States,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { DiagramLayers } from './DiagramLayers';\nimport { DiagramPanZoomContainer } from './DiagramPanZoomContainer';\nimport { useEvents } from './hooks/useEvents';\nimport { useDiagramDatatip } from './hooks/useDiagramDatatip';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { usePanZoom } from './hooks/usePanZoom';\nimport { useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useDiagramSelection } from './hooks/useDiagramSelection';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport {\n  constructLayoutJSON,\n  deconstructLayoutJSON,\n  createItemMap,\n  getFocusedItemBounds,\n  mergeDimensions,\n  getDimensionsFromBounds,\n  combineIds,\n  getContentBounds,\n  centerXYToPanXY,\n  filterLinksWithNoEndNodes,\n  getAllLabelBounds\n} from './utils/diagramUtils';\nimport { outerStyles } from './themes/DiagramStyles.css';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '#utils/UNSAFE_stringUtils';\n\ntype DiagramWithDimensionsProps<K1, K2, D1, D2, L> = Omit<\n  DiagramProps<K1, K2, D1, D2, L>,\n  'width' | 'height'\n> & {\n  width: number;\n  height: number;\n};\n\nexport function DiagramWithDimensions<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({\n  nodes = [],\n  links = [],\n  width,\n  height,\n  selectedIds = {},\n  selectionMode = 'none',\n  layout,\n  nodeRenderer,\n  linkRenderer,\n  onSelectionChange,\n  onItemHover,\n  onItemFocus,\n  highlightedIds = {},\n  datatip,\n  ...otherProps\n}: DiagramWithDimensionsProps<K1, K2, D1, D2, L>) {\n  const focusedItemBoundsRef = useRef<Bounds | null>(null);\n  const rootRef = useRef<HTMLDivElement>(null);\n  //TODO JET-62563 change bounds to a MAP\n  const [bounds, setBounds] = useState<Bounds[]>([]);\n  const [combinedLabelBounds, setCombinedLabelBounds] = useState<Bounds>();\n  const { direction } = useUser();\n\n  const diagramNodes = nodes;\n  const nodeMap = createItemMap<K1, K2, D1, D2>(diagramNodes);\n  const nodeIdToDataMap = nodeMap.itemIdToDataMap;\n  const diagramLinks = filterLinksWithNoEndNodes(links, nodeIdToDataMap);\n  const linkMap = createItemMap<K1, K2, D1, D2>(diagramLinks);\n  const linkIdToDataMap = linkMap.itemIdToDataMap;\n  const resizeThrottling = useRef<boolean>(false);\n  const newDimensions = getDimensionsFromBounds(bounds);\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n  const labelDimensions = useRef<Map<K1 | K2, TextDimensions>>(new Map());\n  const nodeLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n  const linkLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n  const layoutOutputRef = useRef<L>();\n\n  const contentBounds = getContentBounds(bounds, combinedLabelBounds);\n  const { panZoomProps, cursor, centerX, centerY, zoomValue, kbPanCallback, kbZoomCallback } =\n    usePanZoom({\n      props: otherProps,\n      captureTargetRef: rootRef,\n      width: width,\n      height: height,\n      contentBounds\n    });\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures:\n      otherProps.zooming === 'on' || (!!otherProps.panning && otherProps.panning !== 'off'),\n    rootRef\n  });\n\n  const { focusedItemInfo, hoveredItemInfo, activeId, eventsProps } = useEvents<K1, K2, D1, D2>(\n    touchResponse,\n    diagramNodes[0],\n    diagramNodes,\n    diagramLinks,\n    bounds,\n    linkIdToDataMap,\n    nodeIdToDataMap,\n    nodeMap.itemIdToIndexMap,\n    width,\n    height,\n    otherProps.maxZoom || 1,\n    onItemHover,\n    onItemFocus,\n    kbPanCallback,\n    kbZoomCallback\n  );\n\n  const { selectionProps, selectionContent } = useDiagramSelection<K1, K2, D1, D2>({\n    selectedIds,\n    selectionMode,\n    nodeMap,\n    linkMap,\n    focusedItemInfo,\n    onSelectionChange,\n    rootRef\n  });\n\n  // This is for the datatip kb position\n  if (focusedItemInfo && bounds.length > 0) {\n    focusedItemBoundsRef.current = getFocusedItemBounds(\n      focusedItemInfo,\n      bounds,\n      diagramLinks,\n      nodeMap.itemIdToIndexMap,\n      linkMap.itemIdToIndexMap\n    );\n  }\n\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = useDiagramDatatip({\n    touchResponse,\n    datatip,\n    focusedItemInfo,\n    focusedItemBoundsRef,\n    panState: centerXYToPanXY(centerX, centerY, zoomValue, width, height),\n    zoom: zoomValue,\n    width: width,\n    nodesMap: nodeIdToDataMap,\n    linksMap: linkIdToDataMap,\n    hoveredItem: hoveredItemInfo\n  });\n\n  const style = {\n    width: width,\n    height: height,\n    cursor: cursor,\n    ...touchResponseStyle\n  };\n\n  const states = useRef<States<K1, K2>>();\n  const previousState = states.current // states.current is previous state\n    ? states.current\n    : {\n        selectedNodeIds: [],\n        selectedLinkIds: [],\n        focusedId: undefined,\n        hoveredId: undefined,\n        activeId: undefined,\n        highlightedIds: [],\n        zoom: 0\n      };\n\n  states.current = {\n    // update states to new state\n    selectedNodeIds: selectedIds.nodes ?? [],\n    selectedLinkIds: selectedIds.links ?? [],\n    focusedId:\n      focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible ? focusedItemInfo.id : undefined,\n    hoveredId: hoveredItemInfo?.isCurrent ? hoveredItemInfo.id : undefined,\n    activeId,\n    highlightedIds: combineIds(highlightedIds.nodes, highlightedIds.links),\n    zoom: zoomValue\n  };\n\n  const mergedEventProps = mergeProps(panZoomProps, eventsProps, selectionProps, datatipProps);\n\n  // Called anytime node changes size\n  const onNodeSizeChanged = (nodeWidth: number, nodeHeight: number, idx: number) => {\n    newDimensions[idx] = { w: nodeWidth, h: nodeHeight };\n    if (resizeThrottling.current) {\n      return;\n    }\n\n    resizeThrottling.current = true;\n    // performs layout at the next available animation frame when all measurements should be ready\n    window.requestAnimationFrame(() => {\n      const { labelDims, layoutJSON } = constructLayoutJSON(\n        diagramNodes,\n        nodeIdToDataMap,\n        linkIdToDataMap,\n        newDimensions,\n        width,\n        height,\n        getTextDimensions\n      );\n      labelDimensions.current = labelDims;\n      const layoutOutput = layout(layoutJSON);\n      const { nodePoints, nodeLabelPos, linkLabelPos } = deconstructLayoutJSON<K1, K2, D1, D2, L>(\n        layoutOutput,\n        diagramNodes,\n        diagramLinks\n      );\n      nodeLabelPosRef.current = nodeLabelPos;\n      linkLabelPosRef.current = linkLabelPos;\n      layoutOutputRef.current = layoutOutput;\n      const nodeBounds = mergeDimensions(newDimensions, nodePoints);\n      setBounds(nodeBounds);\n      const labelBounds = getAllLabelBounds(\n        labelDims,\n        diagramNodes,\n        diagramLinks,\n        nodeLabelPos,\n        linkLabelPos,\n        direction === 'rtl'\n      );\n      setCombinedLabelBounds(labelBounds);\n      resizeThrottling.current = false;\n    });\n  };\n  return (\n    <div\n      ref={rootRef}\n      class={outerStyles}\n      {...mergedEventProps}\n      style={style}\n      tabIndex={0}\n      role=\"application\"\n      aria-label={otherProps['aria-label']}\n      aria-labelledby={otherProps['aria-labelledby']}\n      aria-describedby={merge([otherProps['aria-describedby'], datatipAriaDescribedby])}\n      aria-activedescendant={activeId}>\n      {getTextDimensions ? (\n        <DiagramPanZoomContainer\n          centerX={centerX}\n          centerY={centerY}\n          zoom={zoomValue}\n          width={width}\n          height={height}>\n          <DiagramLayers\n            nodes={diagramNodes}\n            links={diagramLinks}\n            nodeRenderer={nodeRenderer}\n            linkRenderer={linkRenderer}\n            width={width}\n            height={height}\n            nodeBounds={bounds}\n            states={states.current!}\n            previousStates={previousState}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeLabelPositions={nodeLabelPosRef.current}\n            linkLabelPositions={linkLabelPosRef.current}\n            labelDimensions={labelDimensions.current}\n            supportsSelection={\n              selectionMode !== 'none' ||\n              !!(selectedIds?.nodes && selectedIds.nodes.length > 0) ||\n              !!(selectedIds?.links && selectedIds.links.length > 0)\n            }\n            layoutOutput={layoutOutputRef.current}\n          />\n        </DiagramPanZoomContainer>\n      ) : undefined}\n      {textMeasureContent}\n      {datatipContent}\n      {selectionContent}\n    </div>\n  );\n}\n","import { useSelection } from '../../hooks/PRIVATE_useVisSelection';\nimport type { ItemInfo } from '../diagram.types';\nimport { getNavigableInfo } from '../utils/diagramUtils';\nimport { Ref } from 'preact/hooks';\n\ntype SelectionProps<K1, K2, D1, D2> = {\n  selectedIds: {\n    nodes?: K1[];\n    links?: K2[];\n  };\n  selectionMode: 'none' | 'single' | 'multiple';\n  nodeMap: {\n    itemIdToDataMap: Map<K1, D1>;\n    itemIdToIndexMap: Map<K1, number>;\n    itemIndexToIdMap: Map<number, K1>;\n  };\n  linkMap: {\n    itemIdToDataMap: Map<K2, D2>;\n    itemIdToIndexMap: Map<K2, number>;\n    itemIndexToIdMap: Map<number, K2>;\n  };\n  focusedItemInfo: ItemInfo<K1, K2>;\n  onSelectionChange?: (detail: {\n    nodes: K1[];\n    links: K2[];\n    nodeData: (D1 | undefined)[];\n    linkData: (D2 | undefined)[];\n  }) => void;\n  rootRef: Ref<HTMLDivElement>;\n};\n\ntype EncodedNodeId = `N_${number}`;\ntype EncodedLinkId = `L_${number}`;\n\nexport function useDiagramSelection<K1, K2, D1, D2>({\n  selectedIds,\n  selectionMode,\n  nodeMap,\n  linkMap,\n  focusedItemInfo,\n  onSelectionChange,\n  rootRef\n}: SelectionProps<K1, K2, D1, D2>) {\n  const nodeIdToIndexMap = nodeMap.itemIdToIndexMap;\n  const nodeIndexToIdMap = nodeMap.itemIndexToIdMap;\n  const linkIdToIndexMap = linkMap.itemIdToIndexMap;\n  const linkIndexToIdMap = linkMap.itemIndexToIdMap;\n  const encodeNodeId = (id: K1) => `N_${nodeIdToIndexMap.get(id)}` as EncodedNodeId;\n  const decodeNodeId = (id: EncodedNodeId) => nodeIndexToIdMap.get(Number(id.slice(2)));\n  const encodeLinkId = (id: K2) => `L_${linkIdToIndexMap.get(id)}` as EncodedLinkId;\n  const decodeLinkId = (id: EncodedLinkId) => linkIndexToIdMap.get(Number(id.slice(2)));\n\n  const encodedNodesSelection = selectedIds.nodes ? selectedIds.nodes.map(encodeNodeId) : [];\n  const encodedLinksSelection = selectedIds.links ? selectedIds.links.map(encodeLinkId) : [];\n  const encodedSelection = [...encodedNodesSelection, ...encodedLinksSelection];\n  const idExtracter = (event: Event) => {\n    // return encodeNodeId(id) or encodeLinkId(id) depending on node or link selection or undefined if clicked on empty space\n    const info =\n      event.type === 'keyup'\n        ? focusedItemInfo\n        : getNavigableInfo<K1, K2>(event.target as HTMLElement, rootRef);\n    return info.id !== undefined\n      ? info.isNode\n        ? encodeNodeId(info.id as K1)\n        : encodeLinkId(info.id as K2)\n      : undefined;\n  };\n\n  const onEncodedSelectionChange = (detail: { ids: (EncodedNodeId | EncodedLinkId)[] }) => {\n    const newSelectedNodeIds = detail.ids\n      .filter((encId) => encId[0] === 'N')\n      .map((encId) => decodeNodeId(encId as EncodedNodeId)!);\n    const newSelectedLinkIds = detail.ids\n      .filter((encId) => encId[0] === 'L')\n      .map((encId) => decodeLinkId(encId as EncodedLinkId)!);\n\n    const nodeData = newSelectedNodeIds.map((selectedId) => {\n      return nodeMap.itemIdToDataMap.get(selectedId);\n    });\n    const linkData = newSelectedLinkIds.map((selectedId) => {\n      return linkMap.itemIdToDataMap.get(selectedId);\n    });\n    return (\n      onSelectionChange &&\n      onSelectionChange({\n        nodes: newSelectedNodeIds,\n        links: newSelectedLinkIds,\n        nodeData,\n        linkData\n      })\n    );\n  };\n  const getDataById = (id: EncodedNodeId | EncodedLinkId) => {\n    let data;\n    if (id[0] === 'N') {\n      const nodeId = decodeNodeId(id as EncodedNodeId)!;\n      data = nodeMap.itemIdToDataMap.get(nodeId);\n    } else if (id[0] === 'L') {\n      const linkId = decodeLinkId(id as EncodedLinkId)!;\n      data = linkMap.itemIdToDataMap.get(linkId);\n    }\n    return data;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<`N_${number}` | `L_${number}`, D1 | D2>(\n    {\n      selection: encodedSelection,\n      idExtracter,\n      selectionMode,\n      getDataById,\n      onChange: onEncodedSelectionChange\n    }\n  );\n\n  return { selectionContent, selectionProps };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  DiagramProps,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { dimensionStyle } from './themes/DiagramStyles.css';\nimport { DiagramWithDimensions } from './DiagramWithDimensions';\n\n/**\n * Diagrams are used to display a set of nodes and the links between them.\n */\nexport function Diagram<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({ width, height, ...otherProps }: DiagramProps<K1, K2, D1, D2, L>) {\n  return otherProps.nodes && otherProps.nodes.length > 0 ? (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(width, height) => <DiagramWithDimensions width={width} height={height} {...otherProps} />}\n    </TrackResizeContainer>\n  ) : null;\n}\n"],"names":["ZOOM_TO_FIT_PADDING","createItemMap","items","itemIdToDataMap","Map","itemIdToIndexMap","itemIndexToIdMap","i","length","set","id","combineIds","nodeIds","linkIds","combinedIds","push","getLabelBounds","label","dims","isRTL","labelPos","getLabelPosition","rotationAngle","rotationPoint","x","width","y","height","angle","topLeft","getCoordsRelToRotPoint","topRight","bottomLeft","bottomRight","points","minX","minY","maxX","maxY","point","w","h","getBoundsFromPoints","rotatePoint","map","pos","labelPoint","rotPoint","Math","cos","sin","dimensions","positionProps","position","hAlign","vAlign","centerXYToPanXY","centerX","centerY","zoom","panX","panY","isEqualItem","item1","item2","isNode","getNavigableInfo","element","rootElementRef","navigableId","elem","dataset","parentElement","current","getItemAriaLabel","translations","supportsSelection","isSelected","accessibleLabel","generateAriaLabel","undefined","getZoomToFitZoom","contentBounds","zoomX","zoomY","min","constrainZoom","minZoom","maxZoom","newZoom","max","_getFontProps","styles","fontProps","fontFamily","fontSize","fontStyle","fontWeight","zoomAndCenterItemFromInfo","info","linkIdToDataMap","bounds","nodeIdToIndex","totalBounds","get","link","startNodeBounds","startNode","endNodeBounds","endNode","cX","cY","getPanZoomToCenterNode","DiagramNodeElement","state","previousState","activeId","nodeRenderer","onNodeSizeChanged","nodeIndex","data","isDimmed","nodeStyles","dimmedItemStyle","itemStyles","context","useTranslationBundle","ref","useRef","optionsRef","box","useResizeObserver","useCallback","entry","boxSize","borderBoxSize","inlineSize","blockSize","_jsx","class","classNames","role","selected","style","top","left","focused","hovered","children","DiagramNodeLayer","nodes","states","previousStates","nodeBounds","layerStyles","node","selectedNodeIds","includes","focusedId","hoveredId","jsx","highlightedIds","DiagramLinkElement","linkRenderer","layoutOutput","linkStyles","DiagramLinkLayer","links","selectedLinkIds","DiagramLabel","text","labelStyle","labelBorderStyle","labelStyles","labelPosition","labelRotation","rotation","getLabelRotation","borderColor","DiagramLabelLayer","itemProps","labelDimensions","direction","useUser","item","DiagramLayers","nodeLabelPositions","linkLabelPositions","_jsxs","jsxs","_Fragment","Fragment","Infinity","DiagramPanZoomContainer","panValues","panZoomStyles","translate","transform","getNodeDetailFromInfo","itemInfo","getNavigableLinksForNodeId","nodeId","listOfLinks","forEach","startId","endId","_getClockwiseAngle","currNode","oppositeNode","p1","_getNodeCenter","p2","atan2","PI","_getNodesDistance","sqrt","pow","_getLinkDirection","nodeBB","calcDistanceAngleWeighted","objectBB","currentBB","optimalAngle1","optimalAngle2","objCenterX","objCenterY","curCenterX","curCenterY","x_dist","abs","y_dist","distance","isValidDestination","objBB","curBB","compareCenters","_areEqualWithinTolerance","calcInContact","objRect","curRect","_isVerticallyAligned","_isHorizontallyAligned","rect1","rect2","a","b","_anglesAreEqualWithinTolerance","a1","a2","res","useDiagramNavigation","currentKeyboardFocusNode","nodeBoundsById","createNodeBoundsMap","getNextNavigableNode","listOfObjects","currBB","object","inContact","nextObject","nextDistance","Number","MAX_VALUE","nextInContact","hasFoundCurrent","objBounds","currBounds","getNextNavigableLink","listOfNodes","currentLink","keyboardFocusNode","linksWithSortingAttributes","linkDetail","addSortingAttributes","sort","link1","link2","linkAngle1","linkDistance1","linkDirection1","linkAngle2","linkDistance2","linkDirection2","bForward","index","navigateFromNodeToLink","event","adjLinks","currNodeBB","currNodeBBCenterX","nodeCenterX","altKey","code","navigateFromLinkToNode","linkId","key","linkData","startNodeBB","endNodeBB","startNodeCenterX","endNodeCenterX","DEFAULT_KB_PAN","DEFAULT_KB_ZOOM","useEvents","touchResponse","initNode","nodeIdToDataMap","nodeIdToIndexMap","onItemHover","onItemFocus","kbPanCallback","kbZoomCallback","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","sethoveredItemInfo","hoverHandlers","useVisHover","target","isCurrent","getRandomId","type","updatefocusedItemInfo","handleKeyboardInput","isFocusVisible","eventsProps","mergeProps","onKeyUp","onKeyDown","eventConsumed","isChangeItemType","isNavigationEvent","nextItemInfo","itemDetail","getLinkDetailFromInfo","handleKeyboardNavigationEvent","dPan","dx","shiftKey","dy","dZoom","ctrlKey","nZoom","nPan","cx","cy","center","preventDefault","stopPropagation","cancelEvent","onBlur","onPointerUp","useDiagramDatatip","datatip","focusedItemBoundsRef","panState","nodesMap","linksMap","hoveredItem","isRtl","datatipC","focusedItem","isPointerActive","content","getDatatipContent","elementBounds","datatipContent","datatipProps","useDatatip","placement","offset","calculateOffset","anchor","usePointerGesture","captureTargetRef","numPointers","onPointerGestureDown","onPointerGestureMove","onPointerGestureEnd","onExtraneousPointerDown","isDisabled","activePointers","e","findIndex","pointerEvent","pointerId","pointers","splice","onPointerDown","onPointerMove","setPointerCapture","onPointerCancel","onPointerLeave","pan","previousPan","nextPan","panDirection","panBounds","onPanChange","newPan","constrainPan","isPanChanged","panXYToCenterXY","useDragPan","panProps","onDragPanStart","onDragPanEnd","prevPanState","initialPanState","dragProps","draggableRegion","onDragStart","onDragMove","onDragEnd","inactiveState","isDragging","x0","y0","regionOffsetX","regionOffsetY","dragState","handlePointerEvent","cb","pageX","pageY","originalEvent","button","region","xMin","xMax","yMin","yMax","inDraggableRegion","getRegionOffset","useDrag","onPan","panning","nextZoom","onZoomChange","zoomValue","getDistance","usePinchZoom","zooming","onZoom","pinchProps","onPinchZoomStart","onPinchZoomChange","onPinchZoomEnd","origin","prevDistance","reset","pointer1","pointer2","offsetX","offsetY","getMidpoint","delta","usePinch","usePanZoom","props","cursor","setCursor","zoomProps","getZoomProps","getPanProps","prevZoom","initPanZoomState","elemBounds","panType","zoomRatio","minZoomX","minZoomY","initZoom","initCenterX","initCenterY","boundsX","boundsY","getPanBounds","dragPanProps","wheelZoomProps","onWheel","onWheelCallback","deltaX","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","getNormalizedDelta","metaKey","useWheel","useWheelZoom","pinchZoomProps","panZoomProps","DiagramWithDimensions","selectedIds","selectionMode","layout","onSelectionChange","otherProps","rootRef","setBounds","combinedLabelBounds","setCombinedLabelBounds","diagramNodes","nodeMap","diagramLinks","newLinks","filterLinksWithNoEndNodes","linkMap","resizeThrottling","newDimensions","getDimensionsFromBounds","textMeasureContent","getTextDimensions","useTextDimensions","nodeLabelPosRef","linkLabelPosRef","layoutOutputRef","labelBounds","getContentBounds","touchResponseStyle","useVisTouchResponse","supportsTouchDragGestures","selectionProps","selectionContent","nodeIndexToIdMap","linkIdToIndexMap","linkIndexToIdMap","encodeNodeId","decodeNodeId","slice","encodeLinkId","decodeLinkId","encodedSelection","useSelection","selection","idExtracter","getDataById","onChange","detail","newSelectedNodeIds","ids","filter","encId","newSelectedLinkIds","nodeData","selectedId","useDiagramSelection","startNB","endNB","startNCenter","endNCenter","getFocusedItemBounds","datatipAriaDescribedby","mergedEventProps","outerStyles","tabIndex","merge","nodeWidth","nodeHeight","idx","window","requestAnimationFrame","labelDims","layoutJSON","nodeItems","linkItems","nodeKeys","Array","from","keys","linkKeys","getNodeDimensions","getLabelDimensions","componentSize","constructLayoutJSON","nodePoints","nodeLabelPos","linkLabelPos","positions","hasNodeLabels","hasLinkLabels","deconstructLayoutJSON","newBounds","dim","mergeDimensions","getAllLabelBounds","TrackResizeContainer","dimensionStyle"],"mappings":"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"}