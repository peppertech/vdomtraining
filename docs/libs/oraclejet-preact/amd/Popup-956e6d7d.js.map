{"version":3,"file":"Popup-956e6d7d.js","sources":["../../src/UNSAFE_Popup/Popup.tsx"],"sourcesContent":["import { JSX, RefObject } from 'preact';\nimport { useState, useEffect, useLayoutEffect, useMemo, useRef, useCallback } from 'preact/hooks';\nimport { Floating, Offset, Placement, Coords, FlipOptions, ShiftOptions } from '../UNSAFE_Floating';\nimport {\n  FocusableElement,\n  focusOn,\n  focusWithin,\n  getActiveElement\n} from '../utils/PRIVATE_tabbableUtils';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { WindowOverlay, WindowOverlayPlacement } from '../UNSAFE_WindowOverlay';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { usePopupAnimation } from './usePopupAnimation';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { popupVars } from './themes/PopupContract.css';\nimport { getVarName } from '../utils/UNSAFE_stringUtils';\nimport { Property } from 'csstype';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { PopupRedwoodTheme } from './themes/redwood/PopupTheme';\nimport { dimensionInterpolations, DimensionProps } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\nexport type PopupPlacement = Placement | WindowOverlayPlacement;\nexport type OnCloseDetail = {\n  reason: 'escapeKey';\n};\nexport type InitialFocus = 'auto' | 'none' | 'popup' | 'firstFocusable';\nexport type Tail = 'none' | 'simple';\nexport type Modality = 'modal' | 'modeless';\n\ntype Props = IntrinsicProps &\n  DimensionProps &\n  TestIdProps & {\n    /**\n     * Specifies whether the Popup is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies Popup's anchor. Popup is placed relatively to its anchor.\n     */\n    anchorRef?: RefObject<Element | Coords>;\n    /**\n     * Specifies Popup's launcher. After Popup closes, it returns focus to the launcher.\n     */\n    launcherRef?: RefObject<HTMLElement>;\n    /**\n     * Specifies placement of the Popup relative to the anchor.\n     */\n    placement?: PopupPlacement;\n    /**\n     * Specifies displacement of the Popup from the anchor element placement along the specified axes.\n     * The offset object consists of mainAxis and crossAxis properties. The direction in which these properties\n     * are applied depends on the current value of the position property.\n     *\n     * The <code>mainAxis</code> property represents the distance between the Popup and the anchor.\n     * The <code>crossAxis</code> property represents the deviation in the opposite axis to the main axis - the skidding between the Popup and the anchor.\n     */\n    offset?: Offset;\n    /**\n     * Specifies modality of the Popup.\n     */\n    modality?: Modality;\n    /**\n     * Specifies whether a floating Popup changes placement to the opposite side to be kept in view when a collision is detected.\n     *\n     * The flipOptions object consists of mainAxis and crossAxis properties.\n     * The <code>mainAxis</code> runs along the side of the Popup element.\n     * The <code>crossAxis</code> runs along the alignment of the Popup element.\n     */\n    flipOptions?: FlipOptions;\n    /**\n     * Specifies whether a floating Popup shifts along axis to be kept in view when a collision is detected.\n     * Note that if both 'flip' and 'shift' are enabled on respective axis, the flip will take precedence.\n     *\n     * The shiftOptions object consists of mainAxis and crossAxis properties.\n     * The <code>mainAxis</code> runs along the side of the Popup element.\n     * The <code>crossAxis</code> runs along the alignment of the Popup element.\n     */\n    shiftOptions?: ShiftOptions;\n    /**\n     * Specifies if the Popup sets focus to its content when initially open.\n     * A value of none prevents the popup from setting focus when open.\n     *\n     * <code>auto</code> in modeless mode resolves to none.\n     * <code>none</code> prevents the popup from setting focus when open.\n     * <code>popup</code> sets focus to the root popup container (good choice for touch platforms).\n     * <code>firstFocusable</code> defines that a popup should set focus to the first focusable element within the popup's content.\n     */\n    initialFocus?: InitialFocus;\n    /**\n     * Specifies callback triggered when a user clicks outside Popup.\n     */\n    onClickOutside?: (event: MouseEvent) => void;\n    /**\n     * Specifies callback triggered when a user tries to close a Popup through UI interaction.\n     * The parent should listen to this event and close the Popup. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered when initial focus is set or when Popup receives it via F6 key.\n     */\n    onFocusSet?: () => void;\n    /**\n     * Specifies Popup's tail. Simple tail is an arrow pointing to Popup's anchor.\n     */\n    tail?: Tail;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Specifies the ARIA role type. Depending on how the popup is used in the page, the page developer should choose from the following:\n     * <code>tooltip</code> defines contextual popup that displays a description for an element. This is added automatically if not already specified.\n     * <code>dialog</code> defines an application window that is designed to interrupt the current processing of an application in order to prompt the user to enter information or require a response.\n     * <code>alertdialog</code> defines type of dialog that contains an alert message, where initial focus goes to an element within the dialog.\n     */\n    role?: HTMLAttributesSignalExcluded['role'];\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  };\n\n/**\n * A popup temporarily 'pops up' content in the foreground.\n */\nexport const Popup = forwardRef(\n  (\n    {\n      anchorRef,\n      launcherRef,\n      children,\n      isOpen = false,\n      modality = 'modeless',\n      offset = { mainAxis: 0, crossAxis: 0 },\n      flipOptions = { mainAxis: true, crossAxis: true },\n      shiftOptions = { mainAxis: false, crossAxis: false },\n      onClickOutside,\n      onClose,\n      initialFocus = 'auto',\n      placement = anchorRef ? 'top' : 'center',\n      tail = 'none',\n      onTransitionEnd,\n      onFocusSet,\n      role = modality === 'modeless' ? 'tooltip' : 'dialog',\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const localLauncherRef = useRef<HTMLElement | null>(null);\n    const [popupBgColor, setPopupBgColor] = useState<Property.BackgroundColor>();\n\n    const contentWrapperRef = useRef<HTMLDivElement | null>(null);\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    // We can not merge outsideClick to onClose event with {reason: 'outsideClick'} payload\n    // The reason is that we allow outsideClick/autodismiss in modeless mode and\n    // we need to detect outsideClick which is\n    useOutsideClick({\n      isDisabled: !(isOpen && contentWrapperRef.current),\n      ref: contentWrapperRef,\n      handler: (event) => {\n        onClickOutside?.(event);\n      }\n    });\n\n    function launcherKeyDownCallback(event: KeyboardEvent): void {\n      if (\n        localLauncherRef.current === getActiveElement() &&\n        event.code === 'F6' &&\n        modality === 'modeless'\n      ) {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        focusWithin(contentWrapperRef.current as HTMLElement);\n        onFocusSet?.();\n      }\n    }\n\n    const _onTransitionEnd = (isOpen: boolean) => {\n      if (isOpen) {\n        setInitialFocus();\n        onTransitionEnd?.(true);\n      } else {\n        onTransitionEnd?.(false);\n      }\n    };\n\n    // Animation\n    const { setAnimationElementRef, status, onPosition } = usePopupAnimation({\n      isOpen,\n      isAnimatedOnMount: true,\n      onTransitionEnd: _onTransitionEnd,\n      placement: placement\n    });\n    const stableRef = useMemo(\n      () => mergeRefs(setAnimationElementRef, ref),\n      [setAnimationElementRef, ref]\n    );\n\n    const returnFocus = useCallback((): void => {\n      // Try to return focus to 1.launcher or 2.anchor\n      const launcherEl = localLauncherRef.current;\n      const anchorEl = anchorRef?.current;\n\n      if (launcherEl) {\n        focusOn(launcherEl);\n        // Checking instanceof to avoid Coords type that can not be focused\n      } else if (anchorEl && anchorEl instanceof Element) {\n        focusOn(anchorEl as FocusableElement);\n      }\n    }, [localLauncherRef, anchorRef?.current]);\n\n    useEffect(() => {\n      // Init closing\n      if (!isOpen && status === 'opening') {\n        // Only actively return focus to the launcher or anchor if the popup contained focus.\n        // Otherwise, focus is already elsewhere on the page and should not be forced back\n        // because that could reopen the popup again, which essentially prevents the user from\n        // moving focus out of the launcher.\n        if (contentWrapperRef.current?.contains(getActiveElement())) {\n          returnFocus();\n        }\n      }\n    }, [isOpen, status, returnFocus]);\n\n    // Initialize launcher\n    useEffect(() => {\n      if (isOpen) {\n        if (!launcherRef?.current) {\n          // 1. If launcher is not defined, most frequent scenario is,\n          // that element, that has focus before opening a popup is considered launcher\n          localLauncherRef.current = getActiveElement() as HTMLElement;\n        } else if (launcherRef.current instanceof Element) {\n          // 2. launcherRef element was provided.\n          // Verify, if it exists in DOM, otherwise use the last active element\n          localLauncherRef.current = document.body.contains(launcherRef.current)\n            ? launcherRef.current\n            : (getActiveElement() as HTMLElement);\n        } else {\n          localLauncherRef.current = getActiveElement() as HTMLElement;\n        }\n        // Register F6 key handler to enter the Popup\n        localLauncherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n      }\n      return () => {\n        // Deregister F6 key handler\n        localLauncherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n      };\n    }, [isOpen, launcherRef]);\n    // Note: unlike oj-c-popup we do not default anchorRef to launcherRef in Preact Popup\n    // If anchorRef is undefined, we use WindowOverlay as anchor\n\n    const setInitialFocus = () => {\n      let derivedInitialFocus = initialFocus;\n      if (initialFocus === 'auto') {\n        if (modality === 'modal') {\n          // modal mode - set focus to first focusable\n          derivedInitialFocus = 'firstFocusable';\n        } else {\n          // modeless mode - do not steal focus by default\n          derivedInitialFocus = 'none';\n        }\n      }\n\n      // Case: 'popup'\n      // Focus on Popup container\n      if (derivedInitialFocus === 'popup') {\n        focusOn(contentWrapperRef.current as HTMLElement);\n        onFocusSet?.();\n        onTransitionEnd?.(false);\n      }\n\n      // Case: 'firstFocusable'\n      // Focus on first tabbable in the Popup container or container itself if there is none\n      if (derivedInitialFocus === 'firstFocusable') {\n        focusWithin(contentWrapperRef.current as HTMLElement);\n        onFocusSet?.();\n      }\n    };\n\n    const getMainAxisOffset = (offset?: Offset) => {\n      let calcOffset = 0;\n      if (offset) {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'mainAxis' does not exist on type 'OffsetFunction'.\n        calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;\n        if (tail === 'simple') {\n          calcOffset += 5;\n        }\n      }\n      return calcOffset;\n    };\n\n    const getCrossAxisOffset = (offset?: Offset) => {\n      if (!offset) {\n        return 0;\n      } else {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'crossAxis' does not exist on type 'OffsetFunction'.\n        return typeof offset === 'number' ? 0 : offset.crossAxis || 0;\n      }\n    };\n\n    const finalOffset = {\n      mainAxis: getMainAxisOffset(offset),\n      crossAxis: getCrossAxisOffset(offset)\n    };\n\n    const handlePopupKeyDown = (event: KeyboardEvent) => {\n      const currentlyFocusedEl = getActiveElement();\n      const wrapperEl = contentWrapperRef.current;\n      const launcherEl = localLauncherRef.current;\n      if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {\n        switch (event.code) {\n          case 'Escape': {\n            // Trigger onClose event with outside click detail\n            onClose?.({ reason: 'escapeKey' });\n            break;\n          }\n          case 'F6':\n            // Prevent default F6 handlers.\n            // F6 is a standard Chrome address bar shortcut on Windows.\n            event.preventDefault();\n            event.stopPropagation();\n\n            // Focus launcher\n            if (launcherEl && modality === 'modeless') {\n              focusOn(launcherEl);\n            }\n            break;\n        }\n      }\n    };\n\n    useLayoutEffect(() => {\n      if (\n        status === 'unmounted' ||\n        contentWrapperRef.current == null ||\n        popupBgColor != null ||\n        tail === 'none'\n      )\n        return;\n\n      const backgroundColorVar = getVarName(popupVars.backgroundColor);\n      const computedStyle = getComputedStyle(contentWrapperRef.current!);\n      setPopupBgColor(computedStyle.getPropertyValue(backgroundColorVar));\n    }, [status, contentWrapperRef, popupBgColor, tail]);\n\n    // Styles\n    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);\n    const isMounted = status !== 'unmounted';\n\n    const interpolations = [...Object.values(dimensionInterpolations)];\n    const styleInterpolations = mergeInterpolations<DimensionProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n\n    const renderPopup = () => {\n      return (\n        <div\n          ref={contentWrapperRef}\n          tabIndex={-1}\n          role={role}\n          className={classNames([baseTheme, classes])}\n          style={styles}\n          onKeyDown={handlePopupKeyDown}\n          aria-label={ariaLabel}\n          aria-labelledby={ariaLabelledBy}\n          aria-describedby={ariaDescribedBy}\n          {...testIdProps}>\n          {/*Setting restoreFocusRef to false because otherwise FocusTrap is stealing the focus back when :*/}\n          {/*we click outside of modeless Popup (that keeps being open).*/}\n          <FocusTrap restoreFocusRef={false}>{children}</FocusTrap>\n        </div>\n      );\n    };\n\n    const renderFloatingOrOverlayPopup = () => {\n      if (!anchorRef || !anchorRef.current) {\n        return (\n          <WindowOverlay placement={placement as WindowOverlayPlacement} offset={finalOffset}>\n            <div ref={stableRef}>{renderPopup()}</div>\n          </WindowOverlay>\n        );\n      } else {\n        return (\n          <Floating\n            ref={stableRef}\n            backgroundColor={popupBgColor}\n            anchorRef={anchorRef}\n            placement={placement as Placement}\n            offsetValue={finalOffset}\n            flipOptions={flipOptions}\n            shiftOptions={shiftOptions}\n            tail={tail}\n            onPosition={onPosition}>\n            {renderPopup()}\n          </Floating>\n        );\n      }\n    };\n\n    if (isMounted) {\n      if (modality === 'modal') {\n        return <Modal isOpen={isMounted}>{renderFloatingOrOverlayPopup()}</Modal>;\n      } else {\n        return <Layer>{renderFloatingOrOverlayPopup()}</Layer>;\n      }\n    } else return null;\n  }\n);\n"],"names":["Popup","forwardRef","anchorRef","launcherRef","children","isOpen","modality","offset","mainAxis","crossAxis","flipOptions","shiftOptions","onClickOutside","onClose","initialFocus","placement","tail","onTransitionEnd","onFocusSet","role","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","ref","localLauncherRef","useRef","popupBgColor","setPopupBgColor","useState","contentWrapperRef","testIdProps","useTestId","launcherKeyDownCallback","event","current","getActiveElement","code","preventDefault","stopPropagation","focusWithin","useOutsideClick","isDisabled","handler","setAnimationElementRef","status","onPosition","usePopupAnimation","isAnimatedOnMount","setInitialFocus","stableRef","useMemo","mergeRefs","returnFocus","useCallback","launcherEl","anchorEl","focusOn","Element","useEffect","contains","document","body","addEventListener","removeEventListener","derivedInitialFocus","finalOffset","calcOffset","getMainAxisOffset","getCrossAxisOffset","handlePopupKeyDown","currentlyFocusedEl","wrapperEl","reason","useLayoutEffect","backgroundColorVar","getVarName","popupVars","backgroundColor","computedStyle","getComputedStyle","getPropertyValue","baseTheme","classes","useComponentTheme","PopupRedwoodTheme","isMounted","interpolations","Object","values","dimensionInterpolations","styleInterpolations","mergeInterpolations","styles","renderPopup","_jsx","tabIndex","className","classNames","style","onKeyDown","FocusTrap","restoreFocusRef","renderFloatingOrOverlayPopup","Floating","offsetValue","WindowOverlay","jsx","Modal","Layer"],"mappings":"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"}