{"version":3,"file":"utils-2e2a48d1.js","sources":["../../src/PRIVATE_VisSVGText/utils/truncation.ts","../../src/PRIVATE_VisSVGText/utils/utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\n\nconst ELLIPSIS = '\\u2026';\n\nconst MAX_MULTILINE_THRESHOLD = 3;\n\n/**\n * Checks if the text lines ends with ellipses and\n * hence if they need tooltip.\n * @param lines\n * @returns\n */\nexport function endsWithEllipsis(lines: string[]) {\n  const lastLine = lines[lines.length - 1];\n  return lastLine?.endsWith(ELLIPSIS);\n}\n\n/**\n * Truncates the text in a single line.\n * @param text The untruncated text.\n * @param maxWidth The max available width.\n * @param maxHeight The max available height.\n * @param minChars The min chars before ellisis is introduced.\n * @param getTextDimensions\n * @returns\n */\nexport function truncateSingleLineText(\n  text: string,\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType\n) {\n  if (!getTextDimensions) {\n    return '';\n  }\n\n  if (maxWidth <= 0) {\n    return '';\n  }\n\n  let dims = getTextDimensions(text, textStyle);\n\n  if (dims.width <= maxWidth) return text;\n\n  if (dims.height > maxHeight) return '';\n\n  // Determine avg pixels per char and make an initial guess at the truncation\n  const textString = text;\n  const textLength = text.length;\n  const avgPixelsPerChar = dims.width / getTextLength(text);\n  let maxNumChars = Math.max(Math.floor(maxWidth / avgPixelsPerChar) - 2, minChars);\n\n  let truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n\n  // Add characters if initial guess is too short.\n  // Keep track of the previous string and dims in case we overshoot\n  let prevTextString = truncatedTextString;\n  dims = getTextDimensions(truncatedTextString, textStyle);\n  let prevDims = dims;\n  while (dims.width < maxWidth) {\n    if (maxNumChars >= textString.length) break;\n\n    // Calculate the availWidth and use that to estimate the number of characters to increment\n    const availWidth = maxWidth - dims.width;\n\n    // estimatedIncrement: The smaller of the chars remaining and the estimate of characters than can fit\n    const estimatedIncrement = Math.min(\n      textLength - maxNumChars,\n      Math.max(Math.floor(availWidth / avgPixelsPerChar), 1)\n    );\n\n    // Add chars and measure again\n    maxNumChars += estimatedIncrement;\n    truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n    dims = getTextDimensions(truncatedTextString, textStyle);\n\n    // If we overshot and the increment was only 1, then restore the old string\n    if (estimatedIncrement == 1 && dims.width > maxWidth) {\n      truncatedTextString = prevTextString;\n      dims = prevDims;\n      break;\n    }\n\n    // Otherwise update the previous string and dims\n    prevTextString = truncatedTextString;\n    prevDims = dims;\n  }\n\n  // Remove characters if initial guess is too long\n  while (dims.width > maxWidth) {\n    if (maxNumChars <= minChars) {\n      truncatedTextString = '';\n      break;\n    }\n\n    // Truncate 1 char at a time\n    maxNumChars -= 1;\n    truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n    dims = getTextDimensions(truncatedTextString, textStyle);\n  }\n\n  return truncatedTextString;\n}\n\n/**\n * Returns the length of the string after replacing zero length chars.\n * @param textString\n * @returns The length of the string.\n */\nfunction getTextLength(textString: string) {\n  textString = textString.replace(/[\\u200A\\u200B\\u200C\\u200D\\u200E\\u200F\\uFEFF]/g, '');\n  return textString.length;\n}\n\n/**\n * Truncates the string recursively.\n * @returns\n */\nfunction truncatedMultilineTextRecursive(\n  splits: string[],\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType,\n  layer = 1\n) {\n  const fullText = splits.join(' ');\n\n  const { width, height } = getTextDimensions(fullText, textStyle);\n\n  if (height > maxHeight) {\n    return [];\n  }\n\n  if (width <= maxWidth) {\n    return [splits.join(' ')];\n  }\n\n  let currentIndex = 0;\n  let lastUntrucatedLine = '';\n\n  while (currentIndex < splits.length) {\n    const currentLine = splits.slice(0, currentIndex + 1).join(' ');\n    const truncated = truncateSingleLineText(\n      currentLine,\n      textStyle,\n      maxWidth,\n      maxHeight,\n      minChars,\n      getTextDimensions\n    );\n\n    const isTruncated = truncated != currentLine;\n    const doesNotFit = truncated === '';\n\n    if (isTruncated) {\n      const newSplits = splits.slice(currentIndex);\n      const otherLines: string[] =\n        layer < MAX_MULTILINE_THRESHOLD\n          ? truncatedMultilineTextRecursive(\n              newSplits,\n              textStyle,\n              maxWidth,\n              maxHeight - 12,\n              minChars,\n              getTextDimensions,\n              layer + 1\n            )\n          : [];\n      if (otherLines.length === 0) {\n        return [truncated];\n      } else {\n        return [lastUntrucatedLine, ...otherLines];\n      }\n    } else if (doesNotFit) {\n      return [];\n    } else {\n      currentIndex += 1;\n      lastUntrucatedLine = currentLine;\n    }\n  }\n\n  // shouldn't actually reach here.\n  return [splits.join(' ')];\n}\n\n/**\n * Returns the array of lines of texts.\n * @param splits The words in the text.\n * @param maxWidth The max available width.\n * @param maxHeight The max available height.\n * @param minChars The min number of chars before ellipsis is shown.\n * @param getTextDimensions The function used to measure the dimension of a text.\n * @returns\n */\nexport function truncateMultilineText(\n  text: string,\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType\n) {\n  const splits = text.split(/\\s+/);\n  return truncatedMultilineTextRecursive(\n    splits,\n    textStyle,\n    maxWidth,\n    maxHeight,\n    minChars,\n    getTextDimensions,\n    1\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition } from '../../utils/UNSAFE_visTypes/chart';\nimport { cloneDimension } from '../../utils/PRIVATE_visLayoutUtils';\nimport { TextDimensions, GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\nimport { endsWithEllipsis, truncateMultilineText, truncateSingleLineText } from './truncation';\nimport { Dimension } from '../../utils/UNSAFE_visTypes/common';\n\nconst REPRESENTATIVE_TEXT = 'MV';\n\n/**\n * Returns the (x, y) coordinate of the text given the width and height of the chart.\n * @param position\n * @param availSpace\n * @param textDims\n * @returns\n */\nexport const positionMultilineText = (\n  lines: string[],\n  dims: Dimension[],\n  lineHeight: number,\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean\n) => {\n  const space = cloneDimension(availSpace);\n  return lines.map((_, i) => {\n    const textCoord = centerTextInAvailSpace(position, space, isRtl, dims[i]);\n\n    if (position === 'top') {\n      space.y += lineHeight;\n      space.height -= lineHeight;\n    } else if (position === 'left') {\n      space.x += lineHeight;\n      space.width -= lineHeight;\n    } else if (position === 'bottom') {\n      space.height -= lineHeight;\n    } else {\n      space.width -= lineHeight;\n    }\n\n    return textCoord;\n  });\n};\n\n/**\n * Returns the x and y positon for a centered text.\n * @param position\n * @param availSpace\n * @param isRtl\n * @param textDims\n * @returns\n */\nexport function centerTextInAvailSpace(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  textDims: { width: number; height: number }\n) {\n  let x: number;\n  let y: number;\n\n  if (position === 'left') {\n    x = availSpace.x + textDims.height / 2 - (isRtl ? textDims.height / 2 : 0);\n    y = availSpace.y + availSpace.height / 2;\n  } else if (position === 'right') {\n    x = availSpace.x + availSpace.width - (isRtl ? textDims.height / 2 : 0);\n    y = availSpace.y + availSpace.height / 2;\n  } else if (position === 'top') {\n    x = availSpace.x + availSpace.width / 2;\n    y = availSpace.y + textDims.height / 2;\n  } else {\n    x = availSpace.x + availSpace.width / 2;\n    y = availSpace.y + availSpace.height - textDims.height / 2;\n  }\n\n  return { x, y };\n}\n\n/**\n * Returns the props for the text component.\n */\nexport function getTextProps(\n  lines: string[],\n  textStyle: Record<string, any>,\n  bounds: TextDimensions,\n  isRotated: boolean,\n  isRtl: boolean,\n  getTextDimension: GetTextDimensionsType\n) {\n  let { x, y } = bounds;\n\n  const lineHeight = getTextDimension(REPRESENTATIVE_TEXT, textStyle).width;\n\n  const props: any = [];\n\n  lines.forEach((line, i) => {\n    const transform = isRotated\n      ? `matrix(0, ${isRtl ? 1 : -1}, ${isRtl ? -1 : 1}, 0, ${x}, ${y})`\n      : undefined;\n\n    props.push({\n      text: line,\n      x: isRotated ? undefined : x,\n      y: isRotated ? undefined : y + i * lineHeight,\n      transform: isRotated ? transform : undefined\n    });\n\n    x += isRotated ? lineHeight : 0;\n    y += isRotated ? 0 : lineHeight;\n  });\n  return props;\n}\n\n/**\n * Returns the text info for the given text.\n */\nexport function getTextInfo(\n  text: string,\n  textStyle: Record<string, any>,\n  width: number,\n  height: number,\n  isMultiline: boolean,\n  getTextDimension: GetTextDimensionsType\n) {\n  const lines = isMultiline\n    ? truncateMultilineText(text, textStyle, width, height, 1, getTextDimension)\n    : [truncateSingleLineText(text, textStyle, width, height, 1, getTextDimension)];\n\n  const lineHeight = getTextDimension(REPRESENTATIVE_TEXT, textStyle).width;\n  const dims = lines.map((line) => getTextDimension(line, textStyle));\n\n  const didNotFit = lines.every((line) => line === '');\n\n  const maxWidth = Math.max(\n    ...dims.map((dim) => {\n      return dim.width;\n    })\n  );\n\n  return {\n    lines,\n    dims,\n    didNotFit,\n    height: lines.length * lineHeight,\n    width: maxWidth,\n    isMultiline: lines.length > 1,\n    lineHeight,\n    isTruncated: endsWithEllipsis(lines)\n  };\n}\n"],"names":["ELLIPSIS","MAX_MULTILINE_THRESHOLD","endsWithEllipsis","lines","lastLine","length","endsWith","truncateSingleLineText","text","textStyle","maxWidth","maxHeight","minChars","getTextDimensions","dims","width","height","textString","textLength","avgPixelsPerChar","replace","getTextLength","maxNumChars","Math","max","floor","truncatedTextString","substring","prevTextString","prevDims","availWidth","estimatedIncrement","min","truncatedMultilineTextRecursive","splits","layer","fullText","join","currentIndex","lastUntrucatedLine","currentLine","slice","truncated","doesNotFit","newSplits","otherLines","truncateMultilineText","split","centerTextInAvailSpace","position","availSpace","isRtl","textDims","x","y","isMultiline","getTextDimension","lineHeight","map","line","didNotFit","every","dim","isTruncated","bounds","isRotated","props","forEach","i","transform","undefined","push","space","cloneDimension","_","textCoord"],"mappings":"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"}