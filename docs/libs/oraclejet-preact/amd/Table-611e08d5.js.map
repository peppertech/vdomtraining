{"version":3,"file":"Table-611e08d5.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeleton.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/utils/TableThemeUtils.ts","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableTooltipUtils.ts","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableFocusUtils.ts","../../src/PRIVATE_Table/hooks/useTruncationTooltip.tsx","../../src/PRIVATE_Table/hooks/useFocusHandling.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableNavigationUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/usePointerHandling.ts","../../src/PRIVATE_Table/hooks/useScrollHandling.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/hooks/useKeyboardHandling.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/Table.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  isRendered: boolean;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, isRendered, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width:${columnWidth}px;`;\n  };\n\n  return isRendered ? (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { dimensionInterpolations } from '../utils/UNSAFE_interpolations/dimensions';\nimport type { DimensionProps } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { WithRequired } from '../utils/UNSAFE_typeUtils';\nimport { tableSkeletonStyles } from './themes/Table.css';\n\nconst dimensions = ['height', 'width'] as const;\ntype Dimension = (typeof dimensions)[number];\n\n// This component has some StyleInterpolationProps.\n// Those are the height and width properties of the SkeletonProps.\ntype StyleInterpolationProps = Pick<DimensionProps, Dimension>;\n//This type has StyleInterpolationProps with the height prop made required.\ntype TableSkeletonProps = WithRequired<StyleInterpolationProps, 'height'>;\n\n// Create an array [dimensionInterpolations['height'], dimensionInterpolations['width']]\nconst skeletonDimensionInterpolation = Array.from(dimensions, (x) => dimensionInterpolations[x]);\nconst interpolations = [...Object.values(skeletonDimensionInterpolation)];\nconst SkeletonInterpolations = mergeInterpolations<TableSkeletonProps>(interpolations);\n\n/**\n * TableSkeleton component allows the appropriate skeleton to be rendered based on the\n * property values\n **/\nexport function TableSkeleton({ ...props }: TableSkeletonProps) {\n  const classes = classNames([tableSkeletonStyles.bar]);\n\n  const skeletonDimensions = SkeletonInterpolations({ width: '100%', ...props });\n  return <div style={skeletonDimensions} class={classes} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonStyles } from './themes/Table.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TableSkeleton } from './TableSkeleton';\n\ntype SkeletonRowProps = {\n  tableId: string;\n  colspan: number;\n  hasTabIndex: boolean;\n  isShowFocusRing: boolean;\n  isPendingLayout?: boolean;\n  isLoadMore?: boolean;\n};\n\n/**\n * TableSkeletonRow renders a set of 'loading' skeletons.\n **/\nexport function TableSkeletonRow({\n  tableId,\n  colspan,\n  hasTabIndex,\n  isShowFocusRing,\n  isPendingLayout = false,\n  isLoadMore = false\n}: SkeletonRowProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const cellClassArray = [tableSkeletonStyles.cell];\n  if (isShowFocusRing) {\n    cellClassArray.push(tableSkeletonStyles.focus);\n  }\n  const cellClasses = classNames(cellClassArray);\n  const innerCellClasses = classNames([tableSkeletonStyles.innerCell]);\n  const rowClasses = classNames([tableSkeletonStyles.row, tableSkeletonStyles.rowHeight]);\n\n  let firstRowClasses;\n  let secondRowClasses;\n  const accCellContent = (\n    <div style={'width:1px;height:0px;overflow:hidden;'}>{translations.collection_loading()}</div>\n  );\n  if (isPendingLayout) {\n    firstRowClasses = classNames([tableSkeletonStyles.row, tableSkeletonStyles.headerHeight]);\n    secondRowClasses = classNames([tableSkeletonStyles.row, tableSkeletonStyles.rowHeightFirst]);\n  } else {\n    secondRowClasses = rowClasses;\n    if (isLoadMore) {\n      firstRowClasses = rowClasses;\n    } else {\n      firstRowClasses = classNames([tableSkeletonStyles.row, tableSkeletonStyles.rowHeightFirst]);\n    }\n  }\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} role={'row'}>\n      <td\n        class={cellClasses}\n        colSpan={colspan}\n        role={'gridcell'}\n        tabIndex={hasTabIndex ? 0 : -1}\n        data-oj-cell-type={isPendingLayout ? 'pending' : isLoadMore ? 'loadMore' : 'loading'}\n        {...(isPendingLayout\n          ? { 'data-oj-table-pending-cell': tableId }\n          : isLoadMore\n          ? { 'data-oj-table-load-more-cell': tableId }\n          : { 'data-oj-table-loading-cell': tableId })}\n        data-oj-table-focusable={tableId}>\n        <div class={innerCellClasses}>\n          {accCellContent}\n          {[...Array(isLoadMore ? 3 : 25)].map((_element, index) => (\n            <div\n              class={index === 0 ? firstRowClasses : index === 1 ? secondRowClasses : rowClasses}>\n              <TableSkeleton height=\"4x\" />\n            </div>\n          ))}\n        </div>\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { tableCellStyles, tableHighContrastCellStyles } from '../themes/TableCellStyles.css';\nimport {\n  tableFooterCellStyles,\n  tableHighContrastFooterCellStyles,\n  footerPreviousBorderStart,\n  footerHighContrastPreviousBorderStart,\n  footerPreviousBorderStartNoPadding,\n  footerHighContrastPreviousBorderStartNoPadding,\n  footerPreviousPseudoHoverBorderStart,\n  footerHighContrastPreviousPseudoHoverBorderStart,\n  footerPreviousPseudoHoverBorderStartNoPadding,\n  footerHighContrastPreviousPseudoHoverBorderStartNoPadding\n} from '../themes/TableFooterCellStyles.css';\nimport {\n  tableHeaderCellStyles,\n  tableHighContrastHeaderCellStyles,\n  headerPreviousBorderStart,\n  headerHighContrastPreviousBorderStart,\n  headerPreviousBorderStartNoPadding,\n  headerHighContrastPreviousBorderStartNoPadding,\n  headerPreviousPseudoHoverBorderStart,\n  headerHighContrastPreviousPseudoHoverBorderStart,\n  headerPreviousPseudoHoverBorderStartNoPadding,\n  headerHighContrastPreviousPseudoHoverBorderStartNoPadding\n} from '../themes/TableHeaderCellStyles.css';\nimport { ColumnPadding, CurrentRowVariant } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to generate the class array for a data cell.\n */\nexport const getDataClassArray = (\n  isFirstColumnIndex: boolean,\n  isFinalColumnIndex: boolean,\n  isFirstRowIndex: boolean,\n  isFinalRowIndex: boolean,\n  hasVerticalGridlines: boolean,\n  hasHorizontalGridlines: boolean,\n  isRowSelected: boolean,\n  isPreviousRowSelected: boolean,\n  isColumnSelected: boolean,\n  isPreviousColumnSelected: boolean,\n  isShowFocusRing: boolean,\n  stickyColumn: 'none' | 'start' | 'end',\n  isRowSelectionEnabled: boolean,\n  isRowSingleSelection: boolean,\n  variant: CurrentRowVariant | undefined,\n  isActive: boolean,\n  isHover: boolean,\n  isPseudoHover: boolean,\n  isStickyStartEdge: boolean,\n  isStickyEndEdge: boolean,\n  isRtl: boolean,\n  isHighContrast: boolean,\n  padding?: ColumnPadding\n) => {\n  const cellStyles = isHighContrast ? tableHighContrastCellStyles : tableCellStyles;\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const isPaddingDisabled = padding === 'disabled';\n  const isComplexPadding = padding instanceof Object;\n  const isBottomPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.bottom === 'disabled')\n  );\n  const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));\n  const isStartPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.start === 'disabled')\n  );\n  const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));\n\n  // Sticky styling logic\n  if (stickyColumn === 'start') {\n    classArray.push(cellStyles.stickyStartColumn);\n  } else if (stickyColumn === 'end') {\n    classArray.push(cellStyles.stickyEndColumn);\n  }\n  if (isStickyStartEdge) {\n    classArray.push(cellStyles.stickyEdgeStart);\n    if (isRtl) {\n      classArray.push(cellStyles.stickyEdgeLeft);\n    } else {\n      classArray.push(cellStyles.stickyEdgeRight);\n    }\n  } else if (isStickyEndEdge) {\n    classArray.push(cellStyles.stickyEdgeEnd);\n    if (isRtl) {\n      classArray.push(cellStyles.stickyEdgeRight);\n    } else {\n      classArray.push(cellStyles.stickyEdgeLeft);\n    }\n  }\n\n  // Interaction styling logic\n  if (isRowSelectionEnabled) {\n    if (isActive) {\n      classArray.push(cellStyles.active);\n    } else if (isHover) {\n      classArray.push(cellStyles.hover);\n    } else if (isPseudoHover) {\n      classArray.push(cellStyles.pseudoHover);\n    }\n  }\n  if (variant === 'highlight') {\n    classArray.push(cellStyles.rowHighlight);\n  }\n  if (isShowFocusRing) {\n    classArray.push(cellStyles.focused);\n  }\n\n  // Selected Rows and Horizontal Gridline styling logic\n  if (isRowSelected) {\n    classArray.push(cellStyles.rowSelected);\n  }\n  if (isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) {\n    classArray.push(cellStyles.horizontalSelectedGridTop);\n    if (isTopPadding) {\n      classArray.push(cellStyles.selectedBorderTopPadding);\n    } else {\n      classArray.push(cellStyles.selectedBorderTopNoPadding);\n    }\n  } else if (!isFirstRowIndex && hasHorizontalGridlines) {\n    classArray.push(cellStyles.horizontalGridTop);\n    if (isTopPadding) {\n      classArray.push(cellStyles.borderTopPadding);\n    } else {\n      classArray.push(cellStyles.borderTopNoPadding);\n    }\n  } else if (isTopPadding) {\n    classArray.push(cellStyles.topSpacerPadding);\n  } else {\n    classArray.push(cellStyles.topSpacerNoPadding);\n  }\n  if (isFinalRowIndex) {\n    classArray.push(cellStyles.lastRow);\n    if (isRowSingleSelection && isRowSelected) {\n      classArray.push(cellStyles.horizontalSelectedGridBottom);\n      if (isBottomPadding) {\n        classArray.push(cellStyles.selectedBorderBottomPadding);\n      } else {\n        classArray.push(cellStyles.selectedBorderBottomNoPadding);\n      }\n    } else if (hasHorizontalGridlines) {\n      classArray.push(cellStyles.horizontalGridBottom);\n      if (isBottomPadding) {\n        classArray.push(cellStyles.borderBottomPadding);\n      } else {\n        classArray.push(cellStyles.borderBottomNoPadding);\n      }\n    } else if (isBottomPadding) {\n      classArray.push(cellStyles.bottomSpacerPadding);\n    } else {\n      classArray.push(cellStyles.bottomSpacerNoPadding);\n    }\n  } else {\n    classArray.push(cellStyles.notLastRow);\n    if (isBottomPadding) {\n      classArray.push(cellStyles.bottomPadding);\n    } else {\n      classArray.push(cellStyles.bottomNoPadding);\n    }\n  }\n\n  // Selected Columns and Vertical Gridline styling logic\n  if (isColumnSelected) {\n    classArray.push(cellStyles.columnSelected);\n    if (isStartPadding) {\n      classArray.push(cellStyles.selectedBorderStartPadding);\n    } else {\n      classArray.push(cellStyles.selectedBorderStartNoPadding);\n    }\n    if (isFinalColumnIndex) {\n      classArray.push(cellStyles.verticalSelectedGridEnd);\n      if (isEndPadding) {\n        classArray.push(cellStyles.selectedBorderEndPadding);\n      } else {\n        classArray.push(cellStyles.selectedBorderEndNoPadding);\n      }\n    } else if (isEndPadding) {\n      classArray.push(cellStyles.endPadding);\n    } else {\n      classArray.push(cellStyles.endNoPadding);\n    }\n  } else {\n    if (isPreviousColumnSelected) {\n      classArray.push(cellStyles.verticalSelectedGridStart);\n      if (isStartPadding) {\n        classArray.push(cellStyles.selectedBorderStartPadding);\n      } else {\n        classArray.push(cellStyles.selectedBorderStartNoPadding);\n      }\n    } else if (!isFirstColumnIndex && hasVerticalGridlines) {\n      classArray.push(cellStyles.verticalGridStart);\n      if (isStartPadding) {\n        classArray.push(cellStyles.borderStartPadding);\n      } else {\n        classArray.push(cellStyles.borderStartNoPadding);\n      }\n    } else if (isStartPadding) {\n      classArray.push(cellStyles.startSpacerPadding);\n    } else {\n      classArray.push(cellStyles.startSpacerNoPadding);\n    }\n    if (isFinalColumnIndex) {\n      if (isEndPadding) {\n        classArray.push(cellStyles.endSpacerPadding);\n      } else {\n        classArray.push(cellStyles.endSpacerNoPadding);\n      }\n    } else if (isEndPadding) {\n      classArray.push(cellStyles.endPadding);\n    } else {\n      classArray.push(cellStyles.endNoPadding);\n    }\n  }\n  return classArray;\n};\n\n/**\n * Helper function to generate the class array for a header or footer cell.\n */\nexport const getHeaderFooterClassArray = (\n  isHeader: boolean,\n  isActive: boolean,\n  isHover: boolean,\n  isPsuedoHover: boolean,\n  isFirstColumnIndex: boolean,\n  isFinalColumnIndex: boolean,\n  hasVerticalGridlines: boolean,\n  isSelected: boolean,\n  isPreviousSelected: boolean,\n  isColumnSelectable: boolean,\n  isShowFocusRing: boolean,\n  stickyColumn: 'none' | 'start' | 'end',\n  isStickyStartEdge: boolean,\n  isStickyEndEdge: boolean,\n  isRtl: boolean,\n  isHighContrast: boolean,\n  padding?: ColumnPadding\n) => {\n  let cellStyles;\n  let previousBorderStart;\n  let previousBorderStartNoPadding;\n  let previousPseudoHoverBorderStart;\n  let previousPseudoHoverBorderStartNoPadding;\n\n  if (isHeader) {\n    cellStyles = isHighContrast ? tableHighContrastHeaderCellStyles : tableHeaderCellStyles;\n    previousBorderStart = isHighContrast\n      ? headerHighContrastPreviousBorderStart\n      : headerPreviousBorderStart;\n    previousBorderStartNoPadding = isHighContrast\n      ? headerHighContrastPreviousBorderStartNoPadding\n      : headerPreviousBorderStartNoPadding;\n    previousPseudoHoverBorderStart = isHighContrast\n      ? headerHighContrastPreviousPseudoHoverBorderStart\n      : headerPreviousPseudoHoverBorderStart;\n    previousPseudoHoverBorderStartNoPadding = isHighContrast\n      ? headerHighContrastPreviousPseudoHoverBorderStartNoPadding\n      : headerPreviousPseudoHoverBorderStartNoPadding;\n  } else {\n    cellStyles = isHighContrast ? tableHighContrastFooterCellStyles : tableFooterCellStyles;\n    previousBorderStart = isHighContrast\n      ? footerHighContrastPreviousBorderStart\n      : footerPreviousBorderStart;\n    previousBorderStartNoPadding = isHighContrast\n      ? footerHighContrastPreviousBorderStartNoPadding\n      : footerPreviousBorderStartNoPadding;\n    previousPseudoHoverBorderStart = isHighContrast\n      ? footerHighContrastPreviousPseudoHoverBorderStart\n      : footerPreviousPseudoHoverBorderStart;\n    previousPseudoHoverBorderStartNoPadding = isHighContrast\n      ? footerHighContrastPreviousPseudoHoverBorderStartNoPadding\n      : footerPreviousPseudoHoverBorderStartNoPadding;\n  }\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const isPaddingDisabled = padding === 'disabled';\n  const isComplexPadding = padding instanceof Object;\n  const isBottomPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.bottom === 'disabled')\n  );\n  const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));\n  const isStartPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.start === 'disabled')\n  );\n  const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));\n  if (isBottomPadding) {\n    classArray.push(cellStyles.bottomPadding);\n  } else {\n    classArray.push(cellStyles.bottomNoPadding);\n  }\n  if (isTopPadding) {\n    classArray.push(cellStyles.topPadding);\n  } else {\n    classArray.push(cellStyles.topNoPadding);\n  }\n\n  // Sticky styling logic\n  if (stickyColumn === 'start') {\n    classArray.push(cellStyles.stickyStartColumn);\n  } else if (stickyColumn === 'end') {\n    classArray.push(cellStyles.stickyEndColumn);\n  }\n  if (isStickyStartEdge) {\n    classArray.push(cellStyles.stickyEdgeStart);\n    if (isRtl) {\n      classArray.push(cellStyles.stickyEdgeLeft);\n    } else {\n      classArray.push(cellStyles.stickyEdgeRight);\n    }\n  } else if (isStickyEndEdge) {\n    classArray.push(cellStyles.stickyEdgeEnd);\n    if (isRtl) {\n      classArray.push(cellStyles.stickyEdgeRight);\n    } else {\n      classArray.push(cellStyles.stickyEdgeLeft);\n    }\n  }\n\n  // Selected and Vertical Gridline styling logic\n  if (isSelected) {\n    classArray.push(cellStyles.selected);\n    if (isStartPadding) {\n      classArray.push(cellStyles.selectedBorderStartPadding);\n    } else {\n      classArray.push(cellStyles.selectedBorderStartNoPadding);\n    }\n    if (isFinalColumnIndex) {\n      classArray.push(cellStyles.verticalSelectedGridEnd);\n      if (isEndPadding) {\n        classArray.push(cellStyles.selectedBorderEndPadding);\n      } else {\n        classArray.push(cellStyles.selectedBorderEndNoPadding);\n      }\n    } else if (isEndPadding) {\n      classArray.push(cellStyles.endPadding);\n    } else {\n      classArray.push(cellStyles.endNoPadding);\n    }\n  } else {\n    if (isPreviousSelected) {\n      classArray.push(cellStyles.verticalSelectedGridStart);\n      if (isStartPadding) {\n        classArray.push(cellStyles.selectedBorderStartPadding);\n      } else {\n        classArray.push(cellStyles.selectedBorderStartNoPadding);\n      }\n    } else if (!isFirstColumnIndex && hasVerticalGridlines) {\n      classArray.push(cellStyles.verticalGridStart);\n      if (isStartPadding) {\n        classArray.push(cellStyles.borderStartPadding);\n      } else {\n        classArray.push(cellStyles.borderStartNoPadding);\n      }\n    } else if (isStartPadding) {\n      classArray.push(cellStyles.startSpacerPadding);\n      // dynamic start borders for when previous cell has hover / active states\n      classArray.push(previousBorderStart);\n      classArray.push(previousPseudoHoverBorderStart);\n    } else {\n      classArray.push(cellStyles.startSpacerNoPadding);\n      // dynamic start borders for when previous cell has hover / active states\n      classArray.push(previousBorderStartNoPadding);\n      classArray.push(previousPseudoHoverBorderStartNoPadding);\n    }\n    if (isFinalColumnIndex) {\n      if (isEndPadding) {\n        classArray.push(cellStyles.endSpacerPadding);\n      } else {\n        classArray.push(cellStyles.endSpacerNoPadding);\n      }\n    } else if (isEndPadding) {\n      classArray.push(cellStyles.endPadding);\n    } else {\n      classArray.push(cellStyles.endNoPadding);\n    }\n  }\n\n  // Interaction styling logic\n  if (isShowFocusRing) {\n    classArray.push(cellStyles.focused);\n  }\n  if (isColumnSelectable) {\n    if (isActive) {\n      if (isSelected) {\n        classArray.push(cellStyles.activeSelected);\n      } else {\n        classArray.push(cellStyles.active);\n        if (!isPreviousSelected && (!hasVerticalGridlines || isFirstColumnIndex)) {\n          if (isStartPadding) {\n            classArray.push(cellStyles.activeBorderStart);\n          } else {\n            classArray.push(cellStyles.activeBorderStartNoPadding);\n          }\n        }\n        if (isFinalColumnIndex) {\n          if (isEndPadding) {\n            classArray.push(cellStyles.activeBorderEnd);\n          } else {\n            classArray.push(cellStyles.activeBorderEndNoPadding);\n          }\n        }\n      }\n    } else if (isHover) {\n      if (isSelected) {\n        classArray.push(cellStyles.hoverSelected);\n      } else {\n        classArray.push(cellStyles.hover);\n        if (!isPreviousSelected && (!hasVerticalGridlines || isFirstColumnIndex)) {\n          if (isStartPadding) {\n            classArray.push(cellStyles.hoverBorderStart);\n          } else {\n            classArray.push(cellStyles.hoverBorderStartNoPadding);\n          }\n        }\n        if (isFinalColumnIndex) {\n          if (isEndPadding) {\n            classArray.push(cellStyles.hoverBorderEnd);\n          } else {\n            classArray.push(cellStyles.hoverBorderEndNoPadding);\n          }\n        }\n      }\n    } else if (isPsuedoHover) {\n      if (isSelected) {\n        classArray.push(cellStyles.pseudoHoverSelected);\n      } else {\n        classArray.push(cellStyles.pseudoHover);\n        if (!isPreviousSelected && (!hasVerticalGridlines || isFirstColumnIndex)) {\n          if (isStartPadding) {\n            classArray.push(cellStyles.pseudoHoverBorderStart);\n          } else {\n            classArray.push(cellStyles.pseudoHoverBorderStartNoPadding);\n          }\n        }\n        if (isFinalColumnIndex) {\n          if (isEndPadding) {\n            classArray.push(cellStyles.pseudoHoverBorderEnd);\n          } else {\n            classArray.push(cellStyles.pseudoHoverBorderEndNoPadding);\n          }\n        }\n      }\n    }\n  }\n  return classArray;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { FocusableElement } from '../../utils/PRIVATE_tabbableUtils';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: FocusableElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = <K>(element: HTMLElement) => {\n  return (\n    element.dataset['ojKeyType'] === 'number'\n      ? Number(element.dataset['ojKey'])\n      : element.dataset['ojKey']\n  ) as K;\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = <K>(\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > index) {\n    return getRowKey<K>(rowElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const index = Array.prototype.indexOf.call(rowElements, rowElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(rootElement: HTMLElement, tableId: string, rowKey: K) {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let i = 0; i < rowElements.length; i++) {\n    if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n      return i;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = <C>(element: HTMLElement) => {\n  return element.dataset['ojColumnKey'] as C;\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  if (headerElements.length > index) {\n    return getColumnKey(headerElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  const columnElements = rootElement.querySelectorAll(\n    isHeader\n      ? `[data-oj-table-header-cell='${tableId}']`\n      : `[data-oj-table-footer-cell='${tableId}']`\n  );\n  const index = Array.prototype.indexOf.call(columnElements, cellElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K extends string | number, D, C extends string>(\n  element: HTMLElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  cellSelector?: string,\n  onlyAncestors?: boolean\n): ActiveCell<K, C> | undefined {\n  const selectorString =\n    cellSelector != null ? cellSelector : `[data-oj-table-focusable='${tableId}']`;\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(selectorString) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor<K>(cellElement, `[data-oj-table-data-row='${tableId}']`)!,\n          columnKey: getColumnKey<C>(cellElement),\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return { columnKey: getColumnKey<C>(cellElement), type: cellType };\n      } else if (cellType === 'noData' || cellType === 'pending') {\n        return { type: cellType };\n      } else if (cellType === 'loading' || cellType === 'loadMore') {\n        const columnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n        if (columnKey != null) {\n          return { columnKey: columnKey, type: cellType };\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  rootElement: HTMLElement,\n  tableId: string,\n  cell: ActiveCell<K, C> | Cell<K, C>\n): HTMLElement | undefined {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'pending') {\n    // pending skeletons case\n    return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loading') {\n    // loading skeletons case\n    return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loadMore') {\n    // loadMore skeletons case\n    return rootElement.querySelector(`[data-oj-table-load-more-cell='${tableId}']`) as HTMLElement;\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (rootElement: HTMLElement, tableId: string) => {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (rootElement: HTMLElement, tableId: string) => {\n  const footerRowElement = rootElement.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const firstRowElement = rootElement.querySelector(`[data-oj-table-data-row='${tableId}']`);\n  if (firstRowElement != null) {\n    return getRowKey<K>(firstRowElement as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement) as K;\n  }\n  return undefined;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = <K extends string | number, C extends string>(\n  rootElement: HTMLElement,\n  tableId: string\n): ActiveCell<K, C> | undefined => {\n  const firstCellElement = rootElement.querySelector(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (firstCellElement != null) {\n    const firstCellType = getCellType(firstCellElement);\n    if (firstCellType === 'header' || firstCellType === 'footer') {\n      return { columnKey: getColumnKey<C>(firstCellElement), type: firstCellType };\n    } else if (firstCellType === 'noData') {\n      return { type: 'noData' };\n    }\n    return {\n      rowKey: keyExtractor<K>(firstCellElement, `[data-oj-table-data-row='${tableId}']`)!,\n      columnKey: getColumnKey<C>(firstCellElement),\n      type: 'data'\n    };\n  }\n  return undefined;\n};\n\n/**\n * Helper function to get the first or last column key.\n */\nexport const getBoundaryColumnKey = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isFirst: boolean\n) => {\n  if (columnsArray.length > 0) {\n    return isFirst ? columnsArray[0].key : columnsArray[columnsArray.length - 1].key;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the 'pending' layout cell\n */\nexport const getPendingLayoutCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to get the 'noData' cell\n */\nexport const getNoDataCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to determine if the 'loading' cell is present in the Table\n */\nexport const hasLoadingCell = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) != null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (rootElement: HTMLElement, tableId: string) => {\n  return getNoDataCellElement(rootElement, tableId) != null;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getCellType, getElementFromCell, logicalCellExtractor } from './TableDomUtils';\nimport { preventBrowserTooltipStyle } from '../themes/Table.css';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to determine if a given default-renderer cell contains truncated text.\n */\nconst _hasTruncatedText = (cellElement: HTMLElement) => {\n  if (cellElement.getAttribute('data-oj-renderer') !== 'default') {\n    return false;\n  }\n\n  const range = new Range();\n  range.selectNodeContents(cellElement);\n  const untruncatedTextLength = range.getBoundingClientRect().width;\n\n  const computedStyles = getComputedStyle(cellElement);\n  const padding = parseFloat(computedStyles.paddingLeft) + parseFloat(computedStyles.paddingRight);\n  const border = parseFloat(computedStyles.borderLeft) + parseFloat(computedStyles.borderRight);\n  const renderedTextLength = cellElement.getBoundingClientRect().width - padding - border;\n\n  // ensure at least 0.1px difference as browser zoom levels cause false positives due to rounding\n  return untruncatedTextLength - renderedTextLength > 0.1;\n};\n\n/**\n * Helper function to handle updating the Table's tooltip due to a focus navigation gesture.\n */\nexport function handleNavigationTooltipGesture<K, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  cell: ActiveCell<K, C>,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void\n) {\n  hideTooltip(true);\n  if (cell.type === 'data' || cell.type === 'header' || cell.type === 'footer') {\n    const cellElement = getElementFromCell(rootElement, tableId, cell);\n    if (cellElement != null && _hasTruncatedText(cellElement)) {\n      showTooltip(cell);\n    }\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer move gesture.\n */\nexport function handleMoveTooltipGesture<K extends string | number, D, C extends string>(\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  event: PointerEvent,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) {\n  let tooltipShown = false;\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    return;\n  }\n  const cellElement = (event.target as HTMLElement).closest(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (cellElement != null) {\n    const cellType = getCellType(cellElement);\n    if (\n      (cellType === 'data' || cellType === 'header' || cellType === 'footer') &&\n      _hasTruncatedText(cellElement)\n    ) {\n      showTooltip(logicalCellExtractor<K, D, C>(cellElement, tableId, columnsArray) as Cell<K, C>);\n      tooltipShown = true;\n    }\n  }\n  if (!tooltipShown) {\n    hideTooltip();\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer leave gesture.\n */\nexport const handleLeaveTableTooltipGesture = (\n  rootElement: HTMLDivElement,\n  event: PointerEvent,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) => {\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    // the pointer 'left' the table, but is only over a cell tooltip - in most cases, we want\n    // to just return here as the pointer is still 'over' the table. however, this can also\n    // occur when the pointer is technically outside of the table's bounds, and in that case\n    // we don't actually want to return as we should clear out our cell tooltip as expected\n    const boundingRect = rootElement.getBoundingClientRect();\n    const isOutOfBounds =\n      event.clientX < boundingRect.left ||\n      event.clientX > boundingRect.right ||\n      event.clientY < boundingRect.top ||\n      event.clientY > boundingRect.bottom;\n    if (!isOutOfBounds) {\n      return;\n    }\n  }\n  hideTooltip();\n};\n\n// Pointer Enter handler for elements that need to prevent default browser tooltips\nconst _pointerEnterHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.add(preventBrowserTooltipStyle);\n};\n\n// Pointer Leave handler for elements that need to prevent default browser tooltips\nconst _pointerLeaveHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.remove(preventBrowserTooltipStyle);\n};\n\n/*\n * Props that can be spread on elements that need to prevent default browser tooltips\n */\nexport const preventBrowserTooltipProps = {\n  onPointerEnter: _pointerEnterHandler,\n  onPointerLeave: _pointerLeaveHandler\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { DataColumnPadding, CurrentRowVariant, TableRendererContext } from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { getDataClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  isRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n  padding?: DataColumnPadding<K, D>;\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? String(rowData[field]) : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  isRowHeader,\n  stickyColumn = 'none',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding\n}: TableCellProps<K, D, C>) {\n  const browser = getClientHints().browser;\n  const hasRenderer = renderer !== _defaultCellRenderer;\n\n  const columnPadding =\n    typeof padding === 'function' ? padding({ key: rowKey, data: rowData }) : padding;\n  const cellClasses = classNames(\n    getDataClassArray(\n      columnIndex === 0,\n      isFinalColumnIndex,\n      rowIndex === 0,\n      isFinalRowIndex,\n      hasVerticalGridlines,\n      hasHorizontalGridlines,\n      isRowSelected,\n      isPreviousRowSelected,\n      isColumnSelected,\n      isPreviousColumnSelected,\n      isShowFocusRing,\n      stickyColumn,\n      isRowSelectionEnabled,\n      isRowSingleSelection,\n      variant,\n      applyActiveStyle,\n      applyHoverStyle,\n      applyPseudoHoverStyle,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      columnPadding\n    )\n  );\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={isRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-renderer={hasRenderer ? 'custom' : 'default'}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      {...(!hasRenderer && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelected ? { 'aria-selected': true } : {})}>\n      {renderer(cellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { tableRowStyles, tableHighContrastRowStyles } from './themes/TableRowStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey, isSameKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K, D, C> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedRowKeys?: Keys<K>;\n  isShowFocusRing: boolean;\n  activeColumnKey?: C;\n  isTabbableMode: boolean;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K, D, C>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  activeColumnKey,\n  isTabbableMode,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  disabledInteractionKeys,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const rowStyles = isHighContrast ? tableHighContrastRowStyles : tableRowStyles;\n  const classArray = [rowStyles.base, isFinalRow ? rowStyles.lastRowHeight : rowStyles.rowHeight];\n  const classes = classNames(classArray);\n\n  const accessibleRowName = (rowIndex + 2).toString();\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n  const selectorRenderer =\n    isRowSelectionEnabled && !isSingleRowSelectionEnabled\n      ? () => {\n          // conversion from 0-based index and adding the header row as it is always rendered\n          return (\n            <Selector\n              aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n              onChange={handleRowSelectorChange}\n              rowKey={rowKey}\n              selectedKeys={selectedRowKeys}\n            />\n          );\n        }\n      : undefined;\n\n  let isPreviousColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 2}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const isActive = columnKey === activeColumnKey;\n        const hasTabIndex = isActive && !isTabbableMode;\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.stickyEdge,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isColumnSelected: isColumnSelected,\n          isPreviousColumnSelected: isPreviousColumnSelected,\n          isShowFocusRing: isShowFocusRing && isActive,\n          hasTabIndex: hasTabIndex,\n          isTabbableMode: isTabbableMode,\n          isRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          variant: variant,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          isRtl: isRtl,\n          isHighContrast: isHighContrast,\n          padding: column.value.padding\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, any, string>[],\n  columnsArray2: TableColumn<string | number, any, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(TableRow, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.tableId === next.tableId &&\n      prev.rowKey === next.rowKey &&\n      prev.rowData === next.rowData &&\n      prev.rowIndex === next.rowIndex &&\n      prev.isFinalRow === next.isFinalRow &&\n      _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n      prev.hasHorizontalGridlines === next.hasHorizontalGridlines &&\n      prev.hasVerticalGridlines === next.hasVerticalGridlines &&\n      _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n      prev.isSelected === next.isSelected &&\n      prev.isPreviousSelected === next.isPreviousSelected &&\n      prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n      prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n      (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled\n        ? isSameKey(prev.selectedRowKeys, next.selectedRowKeys)\n        : true) &&\n      isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&\n      prev.isShowFocusRing === next.isShowFocusRing &&\n      prev.activeColumnKey === next.activeColumnKey &&\n      prev.isTabbableMode === next.isTabbableMode &&\n      prev.variant === next.variant &&\n      prev.onSelectionChange === next.onSelectionChange &&\n      prev.startStickyEdge === next.startStickyEdge &&\n      prev.endStickyEdge === next.endStickyEdge &&\n      prev.isRtl === next.isRtl &&\n      prev.isHighContrast === next.isHighContrast &&\n      prev.disabledInteractionKeys === next.disabledInteractionKeys\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { TableNoDataRendererContext } from '../UNSAFE_TableView';\nimport { useLayoutEffect, Ref } from 'preact/hooks';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  rootRef: Ref<HTMLDivElement>;\n  tableId: string;\n  columnsCount: number;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  ariaRowIndex: number;\n  renderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  rootRef,\n  tableId,\n  columnsCount,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  ariaRowIndex,\n  renderer\n}: TableNoDataProps) {\n  const browser = getClientHints().browser;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return translations.collection_noData();\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  // in firefox, table element heights are not stretched unless explicitly set in some cases\n  useLayoutEffect(() => {\n    if (browser === 'firefox') {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        const tableBodyElement = rootElement.querySelector(\n          `[data-oj-table-body='${tableId}']`\n        ) as HTMLElement;\n        const noDataElement = rootElement.querySelector(\n          `[data-oj-table-nodata-cell='${tableId}']`\n        ) as HTMLElement;\n        if (tableBodyElement != null && noDataElement != null) {\n          noDataElement.style.height = '';\n          noDataElement.style.height = `${tableBodyElement.getBoundingClientRect().height}px`;\n        }\n      }\n    }\n  });\n\n  return (\n    <tr aria-rowindex={ariaRowIndex} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n        id={useId()}\n        tabIndex={hasTabIndex ? 0 : -1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        {contentRenderer({ isTabbable: isTabbableMode })}\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment } from 'preact';\nimport { useCallback, Ref } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { ActiveCell, TableColumn, TableData } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  CurrentRowVariant,\n  TableNoDataRendererContext,\n  TableRowContext,\n  TableSelectionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { collectionStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K, D, C> = {\n  rootRef: Ref<HTMLDivElement>;\n  tableId: string;\n  isValidRender: boolean;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  tableData: TableData<K, D>[];\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isShowFocusRing: boolean;\n  isTabbableMode: boolean;\n  hasMore: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onLoadMore: () => void;\n  viewportConfig: ViewportConfig;\n  activeCell?: ActiveCell<K, C>;\n  currentRowKey?: K;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K, D, C>({\n  rootRef,\n  tableId,\n  isValidRender,\n  getAccessibleRowHeaders,\n  tableData,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isShowFocusRing,\n  isTabbableMode,\n  hasMore,\n  onLoadMore,\n  viewportConfig,\n  activeCell,\n  currentRowKey,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableBodyProps<K, D, C>) {\n  const browser = getClientHints().browser;\n  const collectionClasses = classNames([collectionStyles.base]);\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback((context: ItemContext<TableData<K, D>>) => {\n    return {\n      index: context.index,\n      data: context.data.data,\n      key: context.data.metadata\n    };\n  }, []);\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<TableData<K, D>>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsActiveCell = activeCell?.rowKey === rowKey;\n    const activeColumnKey = containsActiveCell ? activeCell.columnKey : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      disabledInteractionKeys: disabledInteractionKeys,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: currentRowKey === rowKey ? currentRowVariant : 'none',\n      isShowFocusRing: isShowFocusRing && containsActiveCell,\n      activeColumnKey: activeColumnKey,\n      isTabbableMode: isTabbableMode,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === tableData.length - 1,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    const isActive = activeCell?.type === 'noData';\n    const hasTabIndex = isActive && !isTabbableMode;\n    return {\n      rootRef: rootRef,\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isShowFocusRing: isShowFocusRing && isActive,\n      hasTabIndex: hasTabIndex,\n      isTabbableMode: isTabbableMode,\n      ariaRowIndex: isValidRender ? 2 : 1,\n      renderer: isValidRender ? noDataRenderer : undefined\n    };\n  };\n\n  const isShowEmptyLoading = tableData.length === 0 && hasMore;\n  const isShowNoData = tableData.length === 0 && !hasMore;\n\n  return (\n    <tbody class={collectionClasses} role={'presentation'} data-oj-table-body={tableId}>\n      {isShowNoData || !isValidRender ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <Fragment>\n          <LoadMoreCollection<TableData<K, D>>\n            data={tableData}\n            loadMoreIndicator={\n              <TableSkeletonRow\n                tableId={tableId}\n                hasTabIndex={\n                  isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore'\n                }\n                colspan={columnsArray.length}\n                isLoadMore={!isShowEmptyLoading}\n                isShowFocusRing={\n                  isShowFocusRing &&\n                  (isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore')\n                }\n              />\n            }\n            hasMore={hasMore}\n            onLoadMore={onLoadMore}\n            viewportConfig={viewportConfig}>\n            {collectionChildrenFunc}\n          </LoadMoreCollection>\n          <tr style={browser !== 'firefox' ? 'height: 100%;' : undefined} role={'presentation'} />\n        </Fragment>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport {\n  ColumnPadding,\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { tableHeaderCellTextStyles, tableHeaderSortContainerStyles } from './themes/Table.css';\nimport { tableHeaderCellStyles } from './themes/TableHeaderCellStyles.css';\nimport { getHeaderFooterClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { EmbeddedIconButton } from '../PRIVATE_EmbeddedIconButton';\nimport { SortAscendingIcon } from '../PRIVATE_ThemedIcons/SortAscendingIcon';\nimport { SortDefaultIcon } from '../PRIVATE_ThemedIcons/SortDefaultIcon';\nimport { SortDescendingIcon } from '../PRIVATE_ThemedIcons/SortDescendingIcon';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  headerText?: string;\n  selectedRowKeys?: Keys<K>;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  padding?: ColumnPadding;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  headerText,\n  stickyColumn = 'none',\n  renderer,\n  disabledInteractionKeys,\n  onSelectionChange,\n  sortable = 'disabled',\n  sortDirection,\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding\n}: TableHeaderCellProps<K, C>) {\n  const browser = getClientHints().browser;\n  const hasRenderer = renderer != null;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterClassArray(\n      true,\n      applyActiveStyle,\n      applyHoverStyle,\n      applyPseudoHoverStyle,\n      columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isSelected,\n      isPreviousSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      stickyColumn,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      padding\n    )\n  );\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const sortIconRenderer =\n    sortable === 'enabled' || sortDirection != null\n      ? () => (\n          <EmbeddedIconButton\n            aria-label={\n              sortable === 'enabled'\n                ? translations.collection_sortEnabled()\n                : translations.collection_sortDisabled()\n            }\n            isDisabled={sortable !== 'enabled'}\n            onAction={handleSortGesture}>\n            {sortDirection === 'ascending' ? (\n              <SortAscendingIcon />\n            ) : sortDirection === 'descending' ? (\n              <SortDescendingIcon />\n            ) : (\n              <SortDefaultIcon />\n            )}\n          </EmbeddedIconButton>\n        )\n      : undefined;\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    sortControl: sortIconRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortControl }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <div class={tableHeaderCellTextStyles.base}>\n            <span class={tableHeaderCellStyles.defaultRendererSpan}>{headerText}</span>\n          </div>\n        ) : undefined;\n      if (sortControl != null) {\n        return (\n          <div class={tableHeaderSortContainerStyles.base}>\n            {text}\n            {sortControl()}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <th\n      aria-colindex={columnIndex + 1}\n      {...getAriaSelected()}\n      {...getAriaSort()}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'columnheader'}\n      data-oj-cell-type={'header'}\n      data-oj-column-key={columnKey}\n      data-oj-renderer={hasRenderer ? 'custom' : 'default'}\n      data-oj-table-focusable={tableId}\n      data-oj-table-header-cell={tableId}\n      {...(!hasRenderer && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {getHeaderCellRenderer()(headerCellRendererProps)}\n    </th>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { tableHeaderRowStyles, tableHeaderRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  sortCriterion,\n  onSortCriterionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isResizeHover,\n  isRtl,\n  isHighContrast\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n  const containerClasses = classNames([tableHeaderRowContainerStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let isPreviousSelected = false;\n  return isRendered ? (\n    <thead class={containerClasses} role={'presentation'}>\n      <tr\n        aria-rowindex={1}\n        class={rowClasses}\n        role={'row'}\n        style={getStyle()}\n        data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            onSelectionChange: onSelectionChange,\n            sortable: column.value.sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.headerPadding\n          };\n          isPreviousSelected = isSelected;\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { ColumnPadding, TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { getHeaderFooterClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  footerText?: string;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n  padding?: ColumnPadding;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? footerText : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  stickyColumn = 'none',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  disabledInteractionKeys,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding\n}: TableFooterCellProps<C>) {\n  const browser = getClientHints().browser;\n  const hasRenderer = renderer !== _defaultFooterCellRenderer;\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterClassArray(\n      false,\n      applyActiveStyle,\n      applyHoverStyle,\n      applyPseudoHoverStyle,\n      columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isSelected,\n      isPreviousSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      stickyColumn,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      padding\n    )\n  );\n\n  const footerCellRendererProps = {\n    key: columnKey,\n    footerText: footerText,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-renderer={hasRenderer ? 'custom' : 'default'}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      {...(!hasRenderer && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {renderer(footerCellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { tableFooterRowStyles, tableFooterRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  dataRowCount: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedKeys,\n  isColumnSelectionEnabled,\n  disabledInteractionKeys,\n  startStickyEdge,\n  endStickyEdge,\n  dataRowCount,\n  isRtl,\n  isHighContrast\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n  const containerClasses = classNames([tableFooterRowContainerStyles.base]);\n\n  let isPreviousSelected = false;\n  return isRendered ? (\n    <tfoot class={containerClasses} role={'presentation'}>\n      <tr\n        aria-rowindex={Math.max(dataRowCount, 1) + 2}\n        class={rowClasses}\n        role={'row'}\n        data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSelected = containsKey(selectedKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.footerPadding\n          };\n          isPreviousSelected = isSelected;\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;`\n        : `left:${position}px;cursor:col-resize;`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { MutableRef } from 'preact/hooks';\nimport { ScrollDetail, SizingInfo, TableColumn } from '../Table';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { ViewportConfig } from '../../hooks/UNSAFE_useViewportIntersect';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  scrollbarWidth: number,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && fullColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyStartColumns = getStickyColumnIndicies(columnsArray, true);\n    for (let i = 0; i < stickyStartColumns.length; i++) {\n      const stickyIndex = stickyStartColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n    const stickyEndColumns = getStickyColumnIndicies(columnsArray, false);\n    for (let i = stickyEndColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyEndColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    getScrollerTopOffset(rootElement, tableId),\n    getScrollerBottomOffset(rootElement, tableId),\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    scrollerElement,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  scrollerElement.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(\n    rootElement,\n    scrollerElement,\n    tableId,\n    verticalScrollPosition\n  );\n  scrollerElement.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  scrollerElement: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.stickyEdge !== 'start') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(rootElement, scrollerElement, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? scrollerElement.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge !== 'start') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft < columnEnd) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? scrollerElement.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, 0)!;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, i)!;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      rootElement,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null && scrollDetail.locationY != null) {\n      _scrollRowIntoView(\n        rootElement,\n        tableId,\n        rowElement,\n        scrollerElement,\n        sizingInfo.boxHeight! - sizingInfo.contentHeight!,\n        scrollDetail.locationY\n      );\n    }\n  }\n  if (\n    scrollDetail.cell.type === 'data' ||\n    scrollDetail.cell.type === 'header' ||\n    scrollDetail.cell.type === 'footer'\n  ) {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationX != null) {\n      _scrollColumnIntoView(\n        cellElement,\n        scrollerElement,\n        columnsArray,\n        sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n        isRtl,\n        fullColumnWidths,\n        scrollDetail.locationX\n      );\n    }\n  }\n  if (scrollDetail.cell.type === 'loadMore') {\n    scrollerElement.scrollTop = scrollerElement.scrollHeight - scrollerElement.clientHeight + 1;\n  }\n  if (scrollDetail.cell.type === 'loading') {\n    resetVerticalScrollPosition(scrollerElement);\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n\n  const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n  for (let i = 0; i < stickyStartIndicies.length; i++) {\n    stickyIndex = stickyStartIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n  for (let i = stickyEndIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyEndIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n  updateStickyEdges(\n    scrollerElement,\n    columnsArray,\n    fullColumnWidths,\n    stickyEdgesState,\n    setStickyEdgesState\n  );\n}\n\n/**\n * Helper function to get the column indicies corresponding to the given edge.\n */\nexport const getStickyColumnIndicies = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isStart: boolean\n) => {\n  const stickyColumns = [];\n  const edge = isStart ? 'start' : 'end';\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge === edge) {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  scrollerElement: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  scrollLeft?: number\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n      for (i = 0; i < stickyStartIndicies.length; i++) {\n        const currentIndex = stickyStartIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = scrollerElement.scrollWidth - scrollerElement.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyEndIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {\n      setStickyEdgesState({ start: startIndex, end: endIndex });\n    }\n  }\n}\n\n/**\n * Helper function to hide a currently shown tooltip once the anchor cell scrolls out of view.\n */\nexport function hideOutOfViewTooltip<K, C, D>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  sizingInfo: SizingInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>,\n  hideTooltip: (isImmediate?: boolean) => void,\n  isRtl: boolean,\n  viewportConfig?: ViewportConfig\n) {\n  if (tooltipAnchorRef.current != null) {\n    const scroller = viewportConfig?.scroller() || scrollerElement;\n    const verticalOverflowDiff = _getVerticalOverflowDiff(\n      tooltipAnchorRef.current,\n      scroller,\n      getScrollerTopOffset(rootElement, tableId),\n      getScrollerBottomOffset(rootElement, tableId),\n      sizingInfo.boxHeight! - sizingInfo.contentHeight!\n    );\n    const topOverflowDiff = verticalOverflowDiff.top;\n    const hasTopOverflow = topOverflowDiff >= 0;\n    const bottomOverflowDiff = verticalOverflowDiff.bottom;\n    const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n    if (\n      (hasTopOverflow && Math.abs(topOverflowDiff) > tooltipAnchorRef.current.offsetHeight) ||\n      (hasBottomOverflow && Math.abs(bottomOverflowDiff) > tooltipAnchorRef.current.offsetHeight)\n    ) {\n      hideTooltip(true);\n      return;\n    }\n\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyStartColumns = getStickyColumnIndicies(columnsArray, true);\n    for (let i = 0; i < stickyStartColumns.length; i++) {\n      const stickyIndex = stickyStartColumns[i];\n      startOffset += fullColumnWidths[stickyIndex];\n    }\n    const stickyEndColumns = getStickyColumnIndicies(columnsArray, false);\n    for (let i = stickyEndColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyEndColumns[i];\n      endOffset += fullColumnWidths[stickyIndex];\n    }\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      tooltipAnchorRef.current,\n      scroller,\n      startOffset,\n      endOffset,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    if (\n      (hasLeftOverflow && Math.abs(leftOverflowDiff) > tooltipAnchorRef.current.offsetWidth) ||\n      (hasRightOverflow && Math.abs(rightOverflowDiff) > tooltipAnchorRef.current.offsetWidth)\n    ) {\n      hideTooltip(true);\n    }\n  }\n}\n\n/**\n * Helper function to reset the scroll position of the scroller element\n */\nexport const resetVerticalScrollPosition = (scrollerElement: HTMLDivElement) => {\n  scrollerElement.scrollTop = 0;\n};\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (scrollerRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return scrollerRef.current;\n      }\n    }\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData\n} from '../Table';\nimport { getBoundaryColumnKey, getElementFromCell } from './TableDomUtils';\nimport { applyScrollDetail, resetVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport { Cell, CellOverride } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to determine if a given active cell represents a 'transient' state.\n */\nexport function isTransientCell<K, C>(activeCell?: ActiveCell<K, C>) {\n  return (\n    activeCell != null &&\n    (activeCell.type === 'loadMore' ||\n      activeCell.type === 'loading' ||\n      activeCell.type === 'pending')\n  );\n}\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(\n  cell1?: ActiveCell<K, C> | Cell<K, C>,\n  cell2?: ActiveCell<K, C> | Cell<K, C>\n) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  if (cell1.type === cell2.type && cell1.rowKey === cell2.rowKey) {\n    // special case the transient 'loading' cell types as column keys are hints used for when a user\n    // navigates back to another region using the keyboard - otherwise we'd go to the first column\n    if (cell1.type === 'loading' || cell1.type === 'loadMore' || cell1.type === 'pending') {\n      return true;\n    }\n    return cell1.columnKey === cell2.columnKey;\n  }\n  return false;\n}\n\n/**\n * Helper function to determine the resulting cell from a cell override.\n */\nfunction _getCellFromCellOverride<K, D, C>(\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n): Cell<K, C> | undefined {\n  let cellType;\n  let cellRowKey;\n  let cellColumnKey;\n  if (cellOverride.rowKey != null) {\n    cellType = 'data';\n    cellRowKey = cellOverride.rowKey;\n    if (cellOverride.columnKey != null) {\n      cellColumnKey = cellOverride.columnKey;\n    } else if (currentCell?.columnKey != null) {\n      cellColumnKey = currentCell.columnKey;\n    } else {\n      cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n    }\n    if (cellColumnKey == null) {\n      return undefined;\n    }\n  } else if (cellOverride.columnKey != null) {\n    cellColumnKey = cellOverride.columnKey;\n    if (cellOverride.type != null) {\n      cellType = cellOverride.type;\n    } else if (currentCell?.type != null && currentCell.type !== 'noData') {\n      cellType = currentCell.type;\n    } else {\n      cellType = 'header';\n    }\n    if (cellType === 'data') {\n      if (currentCell?.rowKey != null) {\n        cellRowKey = currentCell.rowKey;\n      } else if (tableData.length > 0) {\n        cellRowKey = tableData[0].metadata;\n      }\n      if (cellRowKey == null) {\n        return undefined;\n      }\n    }\n  } else if (cellOverride.type != null) {\n    cellType = cellOverride.type;\n    if (cellType !== 'noData') {\n      if (currentCell?.columnKey != null) {\n        cellColumnKey = currentCell.columnKey;\n      } else {\n        cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n      }\n      if (cellColumnKey == null) {\n        return undefined;\n      }\n      if (cellType === 'data') {\n        if (currentCell?.rowKey != null) {\n          cellRowKey = currentCell.rowKey;\n        } else if (tableData.length > 0) {\n          cellRowKey = tableData[0].metadata;\n        }\n        if (cellRowKey == null) {\n          return undefined;\n        }\n      }\n    }\n  } else {\n    return undefined;\n  }\n  return { type: cellType, rowKey: cellRowKey, columnKey: cellColumnKey } as Cell<K, C>;\n}\n\n/**\n * Helper function to determine the resulting cell type from a cell override.\n */\nfunction _getCellTypeFromCellOverride<K, C>(\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n) {\n  if (cellOverride.type != null) {\n    return cellOverride.type;\n  }\n  if (cellOverride.rowKey != null) {\n    return 'data';\n  }\n  // if no type or rowKey was given, a columnKey must have been given\n  if (currentCell?.type != null && currentCell.type !== 'noData') {\n    return currentCell.type;\n  }\n  return 'header';\n}\n\n/**\n * Helper function to apply a current cell override if necessary.\n */\nexport function applyCurrentCellOverride<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void,\n  isEmbeddedSelect: boolean,\n  isPendingLayout: boolean,\n  isDataLoaded: boolean,\n  isRtl: boolean,\n  currentCellOverride?: CellOverride<K, C>,\n  fullColumnWidths?: number[]\n) {\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  // ensure any new currentCellOverride settings are applied if necessary\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (realizedCell != null) {\n        // override cell was determined - apply the override immediately\n        onActiveCellChanged({ value: realizedCell });\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        if (isEmbeddedSelect) {\n          // scroll 'current-cell-override' vertically into view immediately for embedded select\n          // otherwise, cell will be scrolled into view once the component or cell receives focus\n          if (!isPendingLayout && getElementFromCell(rootElement, tableId, realizedCell) != null) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: realizedCell, locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          } else if (isPendingLayout || !isDataLoaded) {\n            // corresponding element was not found - data is not ready for scrolling\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = true;\n          } else {\n            // corresponding element was not found - value was garbage\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          }\n        } else {\n          // not in an embedded select, so no scrolling should be performed\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        }\n      } else if (!isDataLoaded) {\n        // override cell could not be determined - data is still fetching\n        currencyStatusRef.current.hasPendingCurrentCellOverride = true;\n      } else {\n        // override cell could not be determined - value was garbage\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // override is set to clear the current cell\n      onActiveCellChanged({ value: currentCellOverride });\n      currencyStatusRef.current.currentCellOverride = currentCellOverride;\n      currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n      if (isEmbeddedSelect) {\n        // scroll back to the top for embedded select\n        resetVerticalScrollPosition(scrollerElement);\n      }\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  } else if (currencyStatusRef.current.hasPendingCurrentCellOverrideScroll) {\n    // try and apply any pending scroll from a previous cell override at this time\n    if (currencyStatusRef.current.currentCell != null) {\n      if (\n        !isPendingLayout &&\n        getElementFromCell(rootElement, tableId, currencyStatusRef.current.currentCell) != null\n      ) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: currencyStatusRef.current.currentCell, locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      } else if (!isPendingLayout && isDataLoaded) {\n        // corresponding element was not found - value was garbage\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // there is no longer a current cell to try and scroll to\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  }\n}\n\n/**\n * Helper to determine if the given render state includes the cell specified.\n */\nfunction _renderIncludesCell<K, D, C>(\n  cell: ActiveCell<K, C>,\n  columnsArray: TableColumn<K, D, C>[],\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  hasFooters: boolean\n) {\n  // pending layout is special as other regions exist, but are not yet navigable\n  if (isPendingLayout) {\n    return cell.type === 'pending';\n  }\n  if (cell.type === 'header' || (hasFooters && cell.type === 'footer')) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === cell.columnKey) {\n        return true;\n      }\n    }\n  } else if (tableData.length > 0) {\n    if (cell.type === 'loadMore') {\n      return hasMore;\n    }\n    if (cell.type === 'data') {\n      for (let i = 0; i < tableData.length; i++) {\n        if (tableData[i].metadata === cell.rowKey) {\n          return true;\n        }\n      }\n    }\n  } else {\n    return (cell.type === 'loading' && hasMore) || (cell.type === 'noData' && !hasMore);\n  }\n  return false;\n}\n\n/**\n * Helper to get the cell that should currently be a tab stop for the given render state.\n */\nexport function determineActiveCell<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  isEmbeddedSelect: boolean,\n  hasFooters: boolean,\n  currentCellOverride?: CellOverride<K, C>\n): ActiveCell<K, C> | undefined {\n  if (isPendingLayout) {\n    return { type: 'pending' };\n  }\n  // if no columns are specified, it is a special case 'noData' display\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return { type: 'noData' };\n  }\n  // if nothing specifies where focus should go, use the first header cell\n  const defaultFirstCell: ActiveCell<K, C> = {\n    type: 'header',\n    columnKey: firstColumnKey\n  };\n\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (\n        realizedCell != null &&\n        _renderIncludesCell(\n          realizedCell,\n          columnsArray,\n          tableData,\n          hasMore,\n          isPendingLayout,\n          hasFooters\n        )\n      ) {\n        return realizedCell;\n      }\n      // if here, the resulting cell from the override could not be determined or was not valid\n      const overrideCellType = _getCellTypeFromCellOverride(currentCellOverride, currentCell);\n      if (overrideCellType === 'data') {\n        if (tableData.length === 0 && hasMore) {\n          // pending 'data' override when 'loading' skeletons are shown\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        }\n      } else if (overrideCellType === 'noData' && tableData.length === 0 && hasMore) {\n        // pending 'noData' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell?.columnKey as C };\n      }\n    } else if (\n      _renderIncludesCell(\n        defaultFirstCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return defaultFirstCell;\n    } else {\n      return undefined;\n    }\n  }\n\n  // if here, there is no current cell override that can be applied during this render\n  const activeCell = currencyStatusRef.current.activeCell;\n  if (activeCell != null) {\n    if (activeCell.type === 'loadMore') {\n      const initialData = currencyStatusRef.current.loadMoreInitialData;\n      // if loadMore skeletons are no longer shown, or the data has changed, shift to\n      // the next row in the data set if possible - otherwise just the closest row\n      if (tableData.length > 0 && tableData !== initialData) {\n        const rowKey =\n          initialData != null && tableData.length > initialData.length\n            ? tableData[initialData.length].metadata\n            : tableData[tableData.length - 1].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else if (tableData.length === 0) {\n        if (hasMore) {\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        } else {\n          return { type: 'noData' };\n        }\n      }\n    }\n    if (\n      _renderIncludesCell(activeCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n    ) {\n      return activeCell;\n    } else if (activeCell.type === 'loading') {\n      if (currentCell != null && (currentCell.type === 'data' || currentCell.type === 'noData')) {\n        // if the current cell is already set to 'data' or 'noData', and is now available, return it\n        if (\n          _renderIncludesCell(\n            currentCell,\n            columnsArray,\n            tableData,\n            hasMore,\n            isPendingLayout,\n            hasFooters\n          )\n        ) {\n          return currentCell;\n        }\n      }\n      // otherwise, find the first row if available, and try and maintain the columnKey\n      if (tableData.length > 0) {\n        const rowKey = tableData[0].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else {\n        return { type: 'noData' };\n      }\n    }\n  }\n\n  // if here, there is no active cell, or the active cell is no longer valid\n  if (currentCell != null) {\n    if (\n      _renderIncludesCell(\n        currentCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return currentCell;\n    }\n    if (currentCell.type === 'data') {\n      if (tableData.length === 0 && hasMore) {\n        // pending 'data' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell.columnKey };\n      }\n    } else if (currentCell.type === 'noData' && tableData.length === 0 && hasMore) {\n      // pending 'noData' override when 'loading' skeletons are shown\n      return { type: 'loading', columnKey: firstColumnKey };\n    }\n  }\n  if (\n    _renderIncludesCell(\n      defaultFirstCell,\n      columnsArray,\n      tableData,\n      hasMore,\n      isPendingLayout,\n      hasFooters\n    )\n  ) {\n    return defaultFirstCell;\n  }\n  return undefined;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useEffect, useRef, useState, Ref } from 'preact/hooks';\nimport { useId } from '../../hooks/UNSAFE_useId';\nimport { useColorScheme } from '../../hooks/UNSAFE_useColorScheme';\nimport { useScale } from '../../hooks/UNSAFE_useScale';\nimport { TooltipContent } from '../../hooks/UNSAFE_useTooltip/TooltipContent';\nimport {\n  getGlobalTooltipManager,\n  getWrappedTooltipContent,\n  SHOW_TOOLTIP_DELAY\n} from '../../utils/PRIVATE_tooltipUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { cellComparator } from '../utils/TableFocusUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\ntype UseTruncationTooltipOptions = {\n  rootRef: Ref<HTMLDivElement>;\n  tableId: string;\n};\n\n// delay small interaction times concerning a tooltip\nconst SMALL_INTERACTION_DELAY = 50;\n\n/**\n * Hook that manages cell template tooltip interactions on the Table when truncation is present.\n */\nexport function useTruncationTooltip<K, C>({ rootRef, tableId }: UseTruncationTooltipOptions) {\n  const globalTooltipManager = getGlobalTooltipManager();\n\n  const tooltipId = useId();\n\n  const tooltipCellRef = useRef<Cell<K, C>>();\n  const pendingShowTooltipCellRef = useRef<Cell<K, C>>();\n  const tooltipAnchorRef = useRef<HTMLElement>();\n  const tooltipTextRef = useRef<string>();\n  const [tooltipText, setTooltipText] = useState<string>();\n\n  const pointerDownRef = useRef<boolean>(false);\n  const pointerDownTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const showTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  // helper method for clearing the hide tooltip timeout\n  const _clearHideTooltipTimeout = useCallback(() => {\n    clearTimeout(hideTooltipTimeoutRef.current);\n    hideTooltipTimeoutRef.current = undefined;\n  }, []);\n\n  // helper method for clearing the show tooltip timeout\n  const _clearShowTooltipTimeout = useCallback(() => {\n    clearTimeout(showTooltipTimeoutRef.current);\n    showTooltipTimeoutRef.current = undefined;\n    pendingShowTooltipCellRef.current = undefined;\n  }, []);\n\n  // helper method for setting up the show tooltip timeout\n  const _setupShowTooltipTimeout = useCallback(() => {\n    showTooltipTimeoutRef.current = setTimeout(function () {\n      // when showing a tooltip, clear any pending 'clear tooltip timeouts'\n      if (hideTooltipTimeoutRef.current != null) {\n        _clearHideTooltipTimeout();\n      }\n      showTooltipTimeoutRef.current = undefined;\n      const cell = pendingShowTooltipCellRef.current;\n      const rootElement = rootRef.current;\n      if (rootElement != null && cell != null) {\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null) {\n          setTooltipText(String(cellElement.textContent));\n          tooltipAnchorRef.current = cellElement;\n          tooltipCellRef.current = cell;\n        }\n      }\n      pendingShowTooltipCellRef.current = undefined;\n    }, SHOW_TOOLTIP_DELAY);\n  }, [rootRef, tableId, _clearHideTooltipTimeout]);\n\n  // helper method for setting up the hide tooltip timeout\n  const _setupHideTooltipTimeout = useCallback(() => {\n    hideTooltipTimeoutRef.current = setTimeout(\n      function () {\n        // unlike in the showtooltip timeout logic, we do not want to clear\n        // pending show tooltip timeouts when clearing a tooltip as it could\n        // still be waiting to be shown in another location at this time\n        hideTooltipTimeoutRef.current = undefined;\n        setTooltipText(undefined);\n        tooltipAnchorRef.current = undefined;\n        tooltipCellRef.current = undefined;\n      },\n      Math.max(SHOW_TOOLTIP_DELAY - SMALL_INTERACTION_DELAY, 0)\n    );\n  }, []);\n\n  // callback method to signal a tooltip is desired on the given cell\n  const showTooltip = useCallback(\n    (anchorCell: Cell<K, C>) => {\n      if (cellComparator(tooltipCellRef.current, anchorCell)) {\n        // if the tooltip is already showing in the right cell, clear all timeouts\n        if (showTooltipTimeoutRef.current != null) {\n          _clearShowTooltipTimeout();\n        }\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        return;\n      }\n      if (showTooltipTimeoutRef.current == null) {\n        // if no tooltip is already pending, start a new tooltip timeout\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      } else if (!cellComparator(pendingShowTooltipCellRef.current, anchorCell)) {\n        // if a different tooltip is already pending, start a new tooltip timeout\n        _clearShowTooltipTimeout();\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      }\n      if (tooltipCellRef.current != null && hideTooltipTimeoutRef.current == null) {\n        // if the tooltip is showing on a different cell, ensure a hide timeout is setup\n        _setupHideTooltipTimeout();\n      }\n    },\n    [\n      _setupShowTooltipTimeout,\n      _setupHideTooltipTimeout,\n      _clearShowTooltipTimeout,\n      _clearHideTooltipTimeout\n    ]\n  );\n\n  // callback method to signal the current tooltip is no longer desired\n  const hideTooltip = useCallback(\n    (isImmediate?: boolean) => {\n      // ignore hide tooltip calls if due to focus loss from a pointer down on the tooltip itself\n      if (pointerDownRef.current) {\n        return;\n      }\n      if (showTooltipTimeoutRef.current != null) {\n        _clearShowTooltipTimeout();\n      }\n      if (isImmediate) {\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        setTooltipText(undefined);\n        tooltipAnchorRef.current = undefined;\n        tooltipCellRef.current = undefined;\n      } else if (hideTooltipTimeoutRef.current == null) {\n        _setupHideTooltipTimeout();\n      }\n    },\n    [_setupHideTooltipTimeout, _clearShowTooltipTimeout, _clearHideTooltipTimeout]\n  );\n\n  // Pointer move handler for the tooltip.\n  const _pointerMoveHandler = useCallback((_event: PointerEvent) => {\n    if (showTooltipTimeoutRef.current != null) {\n      clearTimeout(showTooltipTimeoutRef.current);\n      showTooltipTimeoutRef.current = undefined;\n      pendingShowTooltipCellRef.current = undefined;\n    }\n    if (hideTooltipTimeoutRef.current != null) {\n      clearTimeout(hideTooltipTimeoutRef.current);\n      hideTooltipTimeoutRef.current = undefined;\n    }\n  }, []);\n\n  // Pointer leave handler for the tooltip.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const targetElement = event.relatedTarget as HTMLElement;\n      if (targetElement != null && targetElement.closest(`#${tableId}`) != null) {\n        return;\n      }\n      hideTooltip();\n    },\n    [tableId, hideTooltip]\n  );\n\n  // Pointer down handler for the tooltip.\n  const _pointerDownHandler = useCallback((_event: PointerEvent) => {\n    pointerDownRef.current = true;\n    if (pointerDownTimeoutRef.current != null) {\n      clearTimeout(pointerDownTimeoutRef.current);\n    }\n    pointerDownTimeoutRef.current = setTimeout(function () {\n      pointerDownRef.current = false;\n      pointerDownTimeoutRef.current = undefined;\n    }, SMALL_INTERACTION_DELAY);\n  }, []);\n\n  // handles logic involving competing tooltips managed outside of the TableView.\n  // make sure this check runs BEFORE the rendered content is created below\n  const isOpenOverrideRef = useRef<boolean>(true);\n  if (tooltipText != null && tooltipText !== tooltipTextRef.current) {\n    isOpenOverrideRef.current = true;\n  }\n\n  const tooltipPointerProps = {\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler\n  };\n\n  // avoid applying undefined text after initial render completes as it can appear\n  // while the tooltip is going through its closing animation and looks broken\n  const renderRawContent = (\n    <TooltipContent\n      {...tooltipPointerProps}\n      id={tooltipId}\n      isOpen={isOpenOverrideRef.current}\n      isDatatip={false}>\n      {tooltipText != null ? tooltipText : tooltipTextRef.current}\n    </TooltipContent>\n  );\n\n  // make sure these are in sync AFTER the rendered content is created above - this helps ensure\n  // that empty text does not show up while the tooltip is going through a closing animation.\n  tooltipTextRef.current = tooltipText;\n\n  // offsets attempt to show the tooltip without overlapping content of nearby cells\n  const scale = useScale();\n  let mainAxisOffset = -8;\n  let crossAxisOffset = -14;\n  if (scale === 'md') {\n    mainAxisOffset = -7;\n    crossAxisOffset = -12;\n  } else if (scale === 'sm') {\n    mainAxisOffset = -6;\n    crossAxisOffset = -11;\n  }\n  const currentColorScheme = useColorScheme();\n  const tooltipContent =\n    tooltipAnchorRef.current != null\n      ? getWrappedTooltipContent(\n          renderRawContent,\n          'tooltip',\n          currentColorScheme,\n          tooltipAnchorRef as Ref<HTMLElement>,\n          'end-top',\n          { mainAxis: mainAxisOffset, crossAxis: crossAxisOffset }\n        )\n      : undefined;\n\n  const destroyCallback = useCallback(() => {\n    hideTooltip(true);\n  }, [hideTooltip]);\n\n  useEffect(() => {\n    if (isOpenOverrideRef.current && tooltipAnchorRef.current != null) {\n      globalTooltipManager.register(destroyCallback);\n    } else {\n      globalTooltipManager.unregister(destroyCallback);\n    }\n  }, [tooltipAnchorRef, destroyCallback, tooltipText, globalTooltipManager]);\n\n  return { tooltipContent, tooltipId, showTooltip, hideTooltip, tooltipAnchorRef };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useEffect, useMemo, useRef, useState, MutableRef, Ref } from 'preact/hooks';\nimport {\n  getElementContainsFunc,\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../../utils/PRIVATE_collectionUtils';\nimport {\n  FocusableElement,\n  allTabbableElements,\n  getActiveElement,\n  getBodyElement,\n  isTabbableElement\n} from '../../utils/PRIVATE_tabbableUtils';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData\n} from '../Table';\nimport { getCellType, getElementFromCell, logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  applyCurrentCellOverride,\n  cellComparator,\n  determineActiveCell,\n  isTransientCell\n} from '../utils/TableFocusUtils';\nimport { applyScrollDetail } from '../utils/TableScrollUtils';\nimport { handleNavigationTooltipGesture } from '../utils/TableTooltipUtils';\nimport { Cell, CellOverride, CurrentCellDetail } from '../../UNSAFE_TableView';\n\ntype UseFocusHandlingProps<K, D, C extends string> = {\n  rootRef: Ref<HTMLDivElement>;\n  scrollerRef: Ref<HTMLDivElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  cellSupportsTabbable: (cell: ActiveCell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isEmbeddedSelect: boolean;\n  isDataLoaded: boolean;\n};\n\n// constant timeout values for delays following a input gesture until enabling focus rings\nconst MOUSE_FOCUS_SHIFT_TIMEOUT = 0;\nconst TOUCH_FOCUS_SHIFT_TIMEOUT = 200;\n\n// constant event.key values that trigger focus ring logic\nconst NAVIGATION_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape',\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End',\n  'PageUp',\n  'PageDown'\n];\n\n// constant event.key values that trigger 'scroll to current' logic\nconst SCROLL_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape'\n];\n\n/**\n * Hook that manages focus interactions on the Preact Table\n */\nexport function useFocusHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  tableId,\n  isRtl,\n  tableData,\n  hasMore,\n  hasFooters,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  cellSupportsTabbable,\n  fullColumnWidths,\n  currentCellOverride,\n  onPersistCurrentCell,\n  showTooltip,\n  hideTooltip,\n  isPendingLayout,\n  isEmbeddedSelect,\n  isDataLoaded\n}: UseFocusHandlingProps<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // tracks focus loss during render cycle for potential focus recapture cases\n  const isRenderCycle = useRef<boolean>(true);\n  isRenderCycle.current = true;\n  const blurredRenderCycleElementRef = useRef<FocusableElement | null>(null);\n  const isPendingLayoutFocusRef = useRef<boolean>(false);\n\n  // track current 'focus info' state\n  const hasFocusRef = useRef<boolean>(false);\n  const [isTabbableMode, setIsTabbableMode] = useState<boolean>(false);\n  const [isShowFocusRing, setIsShowFocusRing] = useState<boolean>(false);\n\n  // track pointer down information\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isShowFocusRingOverrideRef = useRef<boolean | null>(null);\n\n  // track the active and current cell information\n  const [activeCell, setActiveCell] = useState<ActiveCell<K, C> | undefined>(undefined);\n  const currencyStatusRef = useRef<CurrencyStatus<K, D, C>>({\n    hasPendingCurrentCellOverride: false,\n    hasPendingCurrentCellOverrideScroll: false\n  });\n\n  const currentActiveCell = determineActiveCell<K, D, C>(\n    columnsArray,\n    currencyStatusRef,\n    tableData,\n    hasMore,\n    isPendingLayout,\n    isEmbeddedSelect,\n    hasFooters,\n    currentCellOverride\n  );\n\n  // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately\n  const onActiveCellChanged = useMemo(() => {\n    return (detail: ActiveCellDetail<K, C>) => {\n      const newActiveCell = detail.value;\n      if (!cellComparator(currencyStatusRef.current.activeCell, newActiveCell)) {\n        setActiveCell(newActiveCell);\n        currencyStatusRef.current.activeCell = newActiveCell;\n        if (!isTransientCell(newActiveCell)) {\n          const newCurrentCell = newActiveCell as Cell<K, C>;\n          // only update current cell when 'active' is not one of the transient 'skeleton' regions\n          if (onPersistCurrentCell != null) {\n            onPersistCurrentCell({ value: newCurrentCell });\n          }\n          currencyStatusRef.current.currentCell = newCurrentCell;\n\n          // make sure pending current cell override states are updated on current changed\n          if (newCurrentCell != null) {\n            currencyStatusRef.current.previousEmbeddedSelectCurrentCell = newCurrentCell;\n          }\n          currencyStatusRef.current.currentCellOverride = currentCellOverride;\n          currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        } else if (newActiveCell?.type === 'loadMore') {\n          currencyStatusRef.current.loadMoreInitialData = tableData;\n        }\n        selectionExtensionElementRef.current = undefined;\n      }\n    };\n  }, [currentCellOverride, tableData, onPersistCurrentCell, selectionExtensionElementRef]);\n\n  // Helper function to set the Table's focus tracking state to reflect that it is inactive.\n  const _setAsInactive = useCallback(() => {\n    hasFocusRef.current = false;\n    isPendingLayoutFocusRef.current = false;\n\n    setIsTabbableMode(false);\n    setIsShowFocusRing(false);\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Helper function to set the Table's focus tracking state to reflect that one of its cells has focus.\n  const _enableNavigationMode = useCallback(\n    (cell: ActiveCell<K, C>, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = scrollerRef.current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(false);\n        const focusRingState =\n          isShowFocusRingOverrideRef.current !== null\n            ? isShowFocusRingOverrideRef.current\n            : !recentPointerRef.current;\n        setIsShowFocusRing(focusRingState);\n        if (focusRingState) {\n          handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip);\n        }\n        if (!recentPointerRef.current && !skipScrollCellIntoView) {\n          applyScrollDetail(\n            rootElement,\n            scrollerElement,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: cell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n        onActiveCellChanged({ value: cell });\n      }\n    },\n    [\n      rootRef,\n      scrollerRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths,\n      showTooltip,\n      hideTooltip\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that it is tabbable.\n  const _enableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>, isKeyboard?: boolean, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = scrollerRef.current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(true);\n        if (!isKeyboard) {\n          setIsShowFocusRing(false);\n          onActiveCellChanged({ value: cell });\n          if (!recentPointerRef.current && !skipScrollCellIntoView) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: cell, locationX: 'inView', locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      scrollerRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that a user has\n  // exited tabbable mode via the keyboard (esc or 'F2')\n  const _disableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null) {\n          cellElement.focus({ preventScroll: true });\n        } else {\n          rootElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    [rootRef, tableId]\n  );\n\n  // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown\n  // on desktop devices should not result in a focus ring being shown on the focused element\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType !== 'touch') {\n        if (pointerTimerRef.current != null) {\n          clearTimeout(pointerTimerRef.current);\n        }\n        recentPointerRef.current = true;\n        pointerTimerRef.current = setTimeout(() => {\n          recentPointerRef.current = false;\n          if (isShowFocusRing) {\n            setIsShowFocusRing(false);\n          }\n        }, MOUSE_FOCUS_SHIFT_TIMEOUT);\n      }\n    },\n    [isShowFocusRing]\n  );\n\n  // TouchEnd handler for the outer Table. Focus transfers that occur following a touchend\n  // on touch devices should not result in a focus ring being shown on the focused element\n  const _touchEndHandler = useCallback(() => {\n    if (pointerTimerRef.current != null) {\n      clearTimeout(pointerTimerRef.current);\n    }\n    recentPointerRef.current = true;\n    pointerTimerRef.current = setTimeout(() => {\n      recentPointerRef.current = false;\n      if (isShowFocusRing) {\n        setIsShowFocusRing(false);\n      }\n    }, TOUCH_FOCUS_SHIFT_TIMEOUT);\n  }, [isShowFocusRing]);\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'active'.\n  // If an 'active' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'active'.\n  const _onFocusHandler = (event: FocusEvent) => {\n    hasFocusRef.current = true;\n    const rootElement = rootRef.current;\n    const scrollerElement = scrollerRef.current;\n    if (rootElement != null) {\n      // don't scroll active into view if previous blur was due to window focus loss\n      const skipScrollCellIntoView = blurFromWindowRef.current || isPendingLayout;\n      blurFromWindowRef.current = false;\n\n      const targetElement = event.target as HTMLElement;\n      if (targetElement === rootElement || targetElement === scrollerElement) {\n        if (currentActiveCell != null) {\n          _enableNavigationMode(currentActiveCell, skipScrollCellIntoView);\n        }\n      } else {\n        const cell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n        if (cell != null) {\n          if (getCellType(targetElement) != null) {\n            // handle individual focusable regions receiving focus\n            _enableNavigationMode(cell, skipScrollCellIntoView);\n          } else {\n            _enableTabbableMode(cell, false, skipScrollCellIntoView);\n          }\n        }\n      }\n    }\n    if (pointerTimerRef.current != null) {\n      clearTimeout(pointerTimerRef.current);\n      pointerTimerRef.current = null;\n    }\n    recentPointerRef.current = false;\n    isShowFocusRingOverrideRef.current = null;\n  };\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _onBlurHandler = useCallback(\n    (event: FocusEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        if (event.target === document.activeElement) {\n          // save focus ring state so it's set once focus comes back\n          isShowFocusRingOverrideRef.current = isShowFocusRing;\n        }\n        const relatedTarget = event.relatedTarget as Element;\n        const isUnknownRelatedTarget = relatedTarget == null;\n        blurFromWindowRef.current = isUnknownRelatedTarget;\n        if (isUnknownRelatedTarget || !getElementContainsFunc(rootElement, true)(relatedTarget)) {\n          _setAsInactive();\n          if (isRenderCycle.current) {\n            // store element that loses focus during a render cycle for recapturing focus logic\n            blurredRenderCycleElementRef.current = event.target as FocusableElement;\n          }\n        }\n      }\n    },\n    [rootRef, isShowFocusRing, _setAsInactive]\n  );\n\n  // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys\n  // Esc, F2, Enter, and Tab. It also ensures the active cell is scrolled into view on any key\n  const _onKeyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = scrollerRef.current;\n      if (rootElement != null && scrollerElement != null) {\n        if (isPendingLayout) {\n          if (NAVIGATION_KEYS.indexOf(event.key) > -1) {\n            setIsShowFocusRing(true);\n          }\n        } else if (activeCell != null) {\n          if (cellSupportsTabbable(activeCell)) {\n            if (event.key === 'F2') {\n              if (isTabbableMode) {\n                _disableTabbableMode(activeCell);\n              } else {\n                _enableTabbableMode(activeCell, true);\n              }\n            } else if (event.key === 'Esc' || event.key === 'Escape') {\n              // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n              _disableTabbableMode(activeCell);\n            } else if (event.key === 'Enter' && !isTabbableMode) {\n              _enableTabbableMode(activeCell, true);\n            }\n          }\n          if (!isTabbableMode) {\n            if (NAVIGATION_KEYS.indexOf(event.key) > -1) {\n              setIsShowFocusRing(true);\n            }\n            if (SCROLL_KEYS.indexOf(event.key) > -1) {\n              applyScrollDetail(\n                rootElement,\n                scrollerElement,\n                tableId,\n                columnsArray,\n                sizingInfoRef.current,\n                { cell: activeCell, locationX: 'inView', locationY: 'inView' },\n                isRtl,\n                fullColumnWidths\n              );\n            }\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      scrollerRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      isTabbableMode,\n      activeCell,\n      cellSupportsTabbable,\n      fullColumnWidths,\n      isPendingLayout,\n      _enableTabbableMode,\n      _disableTabbableMode\n    ]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onStartFocusTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null && activeCell != null) {\n        handleEnterActionableMode(\n          detail.hasFocusWithin && getCellType(detail.activeElement) == null,\n          allTabbableElements(\n            getElementFromCell(rootElement, tableId, activeCell) as FocusableElement\n          ),\n          (value?: ActiveCell<K, D>) => {\n            setIsTabbableMode(value != undefined);\n          }\n        );\n      }\n    },\n    [rootRef, activeCell, tableId]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusStartEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(true, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusEndEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(false, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Ensure focus is properly set at the completion of every render cycle\n  // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE\n  useEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = scrollerRef.current;\n    if (rootElement != null && scrollerElement != null) {\n      // ensure current-cell-override is up to date on each render\n      applyCurrentCellOverride(\n        rootElement,\n        scrollerElement,\n        tableId,\n        tableData,\n        columnsArray,\n        sizingInfoRef,\n        currencyStatusRef,\n        onActiveCellChanged,\n        isEmbeddedSelect,\n        isPendingLayout,\n        isDataLoaded,\n        isRtl,\n        currentCellOverride,\n        fullColumnWidths\n      );\n\n      const blurredRenderCycleElement = blurredRenderCycleElementRef.current;\n      blurredRenderCycleElementRef.current = null;\n      isRenderCycle.current = false;\n\n      const activeElement = getActiveElement(rootElement);\n      // if we were tracking focus during the render cycle, ensure we recapture focus if needed\n      if (\n        blurredRenderCycleElement != null &&\n        activeElement === getBodyElement(rootElement) &&\n        (!getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||\n          !isTabbableElement(blurredRenderCycleElement, true))\n      ) {\n        rootElement.focus({ preventScroll: true });\n        return;\n      }\n      if (hasFocusRef.current) {\n        if (\n          currentActiveCell != null &&\n          cellComparator(activeCell, currencyStatusRef.current.activeCell)\n        ) {\n          // ensure real browser focus is on the correct cell element\n          const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n          if (cellElement != null) {\n            // cell is valid, so set focus on it if needed\n            if (\n              (!isTabbableMode && activeElement !== cellElement) ||\n              (isTabbableMode && !getElementContainsFunc(cellElement, true)(activeElement))\n            ) {\n              cellElement.focus({ preventScroll: true });\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return {\n    focusHandlingProps: {\n      onPointerDown: _pointerDownHandler,\n      onTouchEnd: _touchEndHandler,\n      onFocus: _onFocusHandler,\n      onBlur: _onBlurHandler,\n      onKeyDown: _onKeyDownHandler\n    },\n    activeCell,\n    onActiveCellChanged,\n    currentCell: currencyStatusRef.current.currentCell,\n    currentActiveCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { ActiveCell, TableColumn, TableData } from '../Table';\nimport { RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  let rowKey: K | null;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(rootElement, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      const rowContext = {\n        key: rowKey,\n        data: tableData[rowIndex].data\n      };\n      onRowAction({ context: rowContext, target: targetElement });\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a row action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      if (column.value.sortable === 'enabled') {\n        let sortDirection;\n        if (sortCriterion != null) {\n          for (const criterion of sortCriterion) {\n            if (criterion.key === column.key) {\n              sortDirection = criterion.sortDirection;\n              break;\n            }\n          }\n        }\n        const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n        onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n        return true;\n      }\n      break;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn } from '../Table';\nimport {\n  getBoundaryColumnKey,\n  getElementFromCell,\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport { cellComparator } from './TableFocusUtils';\nimport { applyScrollDetail, getVerticalScrollPosition } from './TableScrollUtils';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scroller: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'noData') {\n    const newColumnKey = firstColumnKey;\n    if (isPrevious) {\n      newCell = { columnKey: newColumnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: newColumnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loading') {\n    if (isPrevious) {\n      newCell = { columnKey: initialCell.columnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loadMore') {\n    if (isPrevious) {\n      const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      }\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType !== 'pending') {\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        rootElement,\n        currentRowKey,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        // if adjacent row has no children, it is the 'buffer' row used for height sizing\n        if (adjacentRowElement != null && adjacentRowElement.children.length > 0) {\n          const rowKey = getRowKey<K>(adjacentRowElement);\n          if (rowKey != null) {\n            newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n            onActiveCellChanged({ value: newCell });\n          } else {\n            newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n            if (getElementFromCell(rootElement, tableId, newCell) != null) {\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        } else if (isPrevious) {\n          newCell = { columnKey: initialCell.columnKey, type: 'header' };\n          onActiveCellChanged({ value: newCell });\n        } else if (hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      } else if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else if (hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else {\n          newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n          if (getElementFromCell(rootElement, tableId, newCell) != null) {\n            onActiveCellChanged({ value: newCell });\n          } else {\n            const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n            if (rowKey != null) {\n              newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n              onActiveCellChanged({ value: newCell });\n            } else {\n              newCell = { columnKey: initialCell.columnKey, type: 'header' };\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scroller,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scroller: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  if (initialCell.type !== 'noData' && initialCell.type !== 'pending') {\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > 0) {\n      const verticalScrollPosition = getVerticalScrollPosition(rootElement, scroller, tableId);\n      const verticalRowIndex = getRowIndexForRowKey(\n        rootElement,\n        tableId,\n        verticalScrollPosition.rowKey!\n      );\n      let targetRowIndex;\n      if (isPrevious) {\n        if (verticalScrollPosition.offsetY === 0) {\n          targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n        } else {\n          targetRowIndex = verticalRowIndex!;\n        }\n      } else {\n        const scrollerRect = rootElement.getBoundingClientRect();\n        const scrollbarHeight =\n          sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n        const scrollerBottom =\n          scrollerRect.bottom + getScrollerBottomOffset(rootElement, tableId) + scrollbarHeight;\n        targetRowIndex = verticalRowIndex!;\n        while (rowElements.length > targetRowIndex + 1) {\n          targetRowIndex += 1;\n          const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n          if (elementBottom > scrollerBottom) {\n            break;\n          }\n        }\n      }\n      const newRowKey = getRowKeyForRowIndex<K>(rootElement, tableId, targetRowIndex);\n      if (newRowKey != null) {\n        const newCell: ActiveCell<K, C> = {\n          rowKey: newRowKey,\n          columnKey: initialCell.columnKey,\n          type: 'data'\n        };\n        if (newRowKey !== initialCell.rowKey) {\n          onActiveCellChanged({ value: newCell });\n        }\n        if (!cellComparator(initialCell, newCell)) {\n          hideTooltip(true);\n        }\n        applyScrollDetail(\n          rootElement,\n          scroller,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: newCell, locationX: 'inView', locationY: isPrevious ? 'bottom' : 'top' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scroller: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scroller,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scroller: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  includeRows: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const newKey = getBoundaryColumnKey<K, D, C>(columnsArray, isPrevious);\n  if (newKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    if (includeRows) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        const newRowKey = isPrevious\n          ? getFirstFocusableRowKey<K>(rootElement, tableId)\n          : getLastFocusableRowKey<K>(rootElement, tableId);\n        if (newRowKey != null) {\n          newCell = { rowKey: newRowKey, columnKey: newKey, type: 'data' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scroller,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, SizingInfo, TableColumn } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { applyScrollDetail } from './TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { TableSelectionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isMultiSelectGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n  if (newRowKey != null) {\n    if (selectionMode?.row === 'single' || selectionMode?.row === 'multiple') {\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectGesture && selectionMode.row === 'multiple') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = targetElement.closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          rootElement,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isMultiSelectGesture && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isMultiSelectGesture) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple') {\n      selectedRows = emptyKeys as Keys<K>;\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (\n    ((selectionMode?.row === 'multiple' && activeCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (activeCell.type === 'header' || activeCell.type === 'footer'))) &&\n    targetCell?.type === activeCell.type\n  ) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      const isRow = targetCell.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            activeCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            targetCellElement.parentElement as HTMLElement\n          ) != null\n        );\n      } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n        const isHeader = targetCell.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader) !=\n            null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (targetCell != null) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      if (\n        ((selectionMode?.row === 'multiple' && targetCell.type === 'data') ||\n          (selectionMode?.column === 'multiple' &&\n            (targetCell.type === 'header' || targetCell.type === 'footer'))) &&\n        targetCell.type === activeCell.type\n      ) {\n        let startIndex;\n        let endIndex;\n        let endElement;\n        const isRow = targetCell.type === 'data';\n        if (isRow) {\n          endElement = targetCellElement.parentElement as HTMLElement;\n          startIndex = getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            activeCellElement.parentElement as HTMLElement\n          );\n          endIndex = getRowIndexForRowElement(rootElement, tableId, endElement);\n        } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n          const isHeader = targetCell.type === 'header';\n          endElement = targetCellElement;\n          startIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            activeCellElement,\n            isHeader\n          );\n          endIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            targetCellElement,\n            isHeader\n          );\n        }\n        if (startIndex != null && endIndex != null) {\n          selectionExtensionElementRef.current = endElement;\n          _applyRangeSelection(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            startIndex,\n            endIndex,\n            isRow,\n            onSelectionChange,\n            selectionMode,\n            selected\n          );\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  targetElement: HTMLElement,\n  isPrevious: boolean,\n  activeCell: ActiveCell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n  if (activeCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isRow = activeCell.type === 'data';\n    const isHeader = activeCell.type === 'header';\n    if (isRow) {\n      startElement = activeCellElement.parentElement as HTMLElement;\n      startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n    } else {\n      startElement = activeCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(\n        rootElement,\n        tableId,\n        startElement,\n        isHeader\n      );\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let extendedElement;\n      const cursorElement = selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          rootElement,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          selectionMode,\n          selected\n        );\n      }\n\n      // scroll 'extensionElement' into view\n      const extensionElement =\n        selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : activeCellElement;\n      let extensionCell;\n      if (isRow) {\n        const rowKey = keyExtractor<K>(extensionElement, `[data-oj-table-data-row='${tableId}']`);\n        if (rowKey != null) {\n          extensionCell = {\n            type: activeCell.type,\n            rowKey: rowKey,\n            columnKey: activeCell.columnKey\n          };\n        }\n      } else {\n        extensionCell = logicalCellExtractor<K, D, C>(extensionElement, tableId, columnsArray);\n      }\n      if (extensionCell != null) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: extensionCell, locationX: 'inView', locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizeDetail, ColumnWidths } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (fullColumnWidths != null) {\n    if (resizeInfoRef.current.key == null) {\n      _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n    }\n    if (resizeInfoRef.current.key != null) {\n      const innerTable = rootElement.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        const resizeColumnWidths = [];\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          const columnWidth = fullColumnWidths[i];\n          resizeColumnWidths.push(columnWidth as number);\n        }\n        resizeInfoRef.current = {\n          isResizing: true,\n          isResizeHover: true,\n          key: resizeInfoRef.current.key,\n          startX: pointerX,\n          delta: 0,\n          fullColumnWidths: resizeColumnWidths,\n          ignoreClick: resizeInfoRef.current.ignoreClick\n        };\n        if (onColumnResizing != null) {\n          onColumnResizing({\n            key: resizeInfoRef.current.key,\n            delta: 0,\n            allColumnWidths: appliedColumnWidths\n          });\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing && fullColumnWidths != null) {\n    const innerTable = rootElement.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n    if (innerTable != null) {\n      const rect = innerTable.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      // handle resize move operation\n      if (onColumnResizing != null) {\n        onColumnResizing({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const resizeColumnWidths = [];\n      for (const columnWidth of resizeInfoRef.current.fullColumnWidths) {\n        resizeColumnWidths.push(columnWidth);\n      }\n      const innerTable = rootElement.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n        onColumnResize({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = rootElement.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      rootElement,\n      tableId,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef, MutableRef, Ref } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending } from '../../utils/PRIVATE_textSelectionUtils';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, ColumnResizeInfo, TableColumn, TableData } from '../Table';\nimport { handleRowActionGesture } from '../utils/TableActionUtils';\nimport { logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport {\n  handleLeaveTableTooltipGesture,\n  handleMoveTooltipGesture\n} from '../utils/TableTooltipUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  RowActionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UsePointerHandlingOptions<K, D, C extends string> = {\n  rootRef: Ref<HTMLDivElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths: ColumnWidths<C>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  activeCell?: ActiveCell<K, C>;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isSelectionExtension: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  tooltipId: string;\n};\n\n/**\n * Hook that manages pointer interactions on the Preact Table\n */\nexport function usePointerHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  tableId,\n  tableData,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  resizeInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  activeCell,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  showTooltip,\n  hideTooltip,\n  tooltipId\n}: UsePointerHandlingOptions<K, D, C>) {\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId);\n        if (onColumnResizing != null) {\n          if (!resizeInfoRef.current.isResizing) {\n            handleOverResizeRegionGesture(\n              rootElement,\n              tableId,\n              event,\n              columnsArray,\n              resizeInfoRef,\n              isRtl\n            );\n          } else {\n            handleColumnResizingGesture(\n              rootElement,\n              tableId,\n              event,\n              appliedColumnWidths,\n              resizeInfoRef,\n              isRtl,\n              fullColumnWidths,\n              onColumnResizing\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      fullColumnWidths,\n      onColumnResizing,\n      showTooltip,\n      hideTooltip,\n      tooltipId\n    ]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        const targetElement = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          activeCell != null &&\n          event.shiftKey &&\n          isRangeSelectionGesture(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            activeCell,\n            selectionMode\n          )\n        ) {\n          // prevent focus change on selection extension gesture\n          if (!getIsSelectionPending()) {\n            event.preventDefault();\n          }\n        } else if (\n          handleColumnResizeStartGesture(\n            rootElement,\n            tableId,\n            event,\n            columnsArray,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          )\n        ) {\n          // prevent focus change on column resize gesture\n          event.preventDefault();\n          resizeInfoRef.current.ignoreClick = true;\n        } else if (logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray) == null) {\n          // prevent focus shift when interacting with 'non-focusable' regions (ie - scrollbar)\n          event.preventDefault();\n        }\n      }\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      activeCell,\n      selectionMode,\n      onTableSelectionChange,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleColumnResizeEndGesture(\n          rootElement,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [rootRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef);\n        handleLeaveTableTooltipGesture(rootElement, event, hideTooltip, tooltipId);\n      }\n    },\n    [rootRef, tableId, resizeInfoRef, hideTooltip, tooltipId]\n  );\n\n  // Pointer enter handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleEnterResizingGesture(\n          rootElement,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [rootRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted.\n  const _clickHandler = useCallback(\n    (event: MouseEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        let isSelectionExtension = false;\n        const platform = getClientHints().platform;\n        const target = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          !resizeInfoRef.current.ignoreClick &&\n          !getIsSelectionPending()\n        ) {\n          if (activeCell != null && event.shiftKey) {\n            isSelectionExtension = handleRangeSelectionGesture(\n              rootElement,\n              tableId,\n              columnsArray,\n              target,\n              activeCell,\n              selectionExtensionElementRef,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n          if (!isSelectionExtension) {\n            handleSelectionGesture(\n              rootElement,\n              tableId,\n              columnsArray,\n              target,\n              (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n        }\n        if (\n          onRowAction != null &&\n          !getIsSelectionPending() &&\n          handleRowActionGesture(rootElement, tableId, tableData, onRowAction, target)\n        ) {\n          event.stopPropagation();\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      tableData,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      activeCell,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  return {\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler,\n    onPointerUp: _pointerUpHandler,\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerEnter: _pointerEnterHandler,\n    onClick: _clickHandler\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, MutableRef, Ref } from 'preact/hooks';\nimport { SizingInfo, TableColumn } from '../Table';\nimport { hideOutOfViewTooltip, updateStickyEdges } from '../utils/TableScrollUtils';\n\ntype UseScrollHandlingProps<K, D, C extends string> = {\n  rootRef: Ref<HTMLDivElement>;\n  scrollerRef: Ref<HTMLDivElement>;\n  tableId: string;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  fullColumnWidths?: number[];\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages handling scroll events on the Preact Table\n */\nexport function useScrollHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  tableId,\n  sizingInfoRef,\n  columnsArray,\n  stickyEdgesState,\n  setStickyEdgesState,\n  fullColumnWidths,\n  tooltipAnchorRef,\n  hideTooltip,\n  isRtl\n}: UseScrollHandlingProps<K, D, C>) {\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated\n  // and any out of view tooltips are hidden.\n  const _scrollHandler = useCallback(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = scrollerRef.current;\n    if (rootElement != null && scrollerElement != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        scrollerElement.scrollLeft\n      );\n      hideOutOfViewTooltip(\n        rootElement,\n        scrollerElement,\n        tableId,\n        sizingInfoRef.current,\n        columnsArray,\n        fullColumnWidths,\n        tooltipAnchorRef,\n        hideTooltip,\n        isRtl\n      );\n    }\n  }, [\n    rootRef,\n    scrollerRef,\n    tableId,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths,\n    tooltipAnchorRef,\n    hideTooltip,\n    isRtl\n  ]);\n\n  return { onScroll: _scrollHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useMemo, useRef, MutableRef, Ref } from 'preact/hooks';\nimport { useCollectionInteractionContext } from '../../hooks/UNSAFE_useCollectionInteractionContext';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { ActiveCell, ColumnResizeInfo, SizingInfo, TableColumn, TableData } from '../Table';\nimport { useTruncationTooltip } from './useTruncationTooltip';\nimport { useFocusHandling } from './useFocusHandling';\nimport { useKeyboardHandling } from './useKeyboardHandling';\nimport { usePointerHandling } from './usePointerHandling';\nimport { useScrollHandling } from './useScrollHandling';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  CellOverride,\n  ColumnWidths,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  rootRef: Ref<HTMLDivElement>;\n  scrollerRef: Ref<HTMLDivElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths: ColumnWidths<C>;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  cellHasRenderer: (cell: ActiveCell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  isPendingLayout: boolean;\n};\n\nconst _defaultDisabledRowInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  tableId,\n  tableData,\n  hasMore,\n  hasFooters,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  sizingInfoRef,\n  resizeInfoRef,\n  stickyEdgesState,\n  setStickyEdgesState,\n  cellHasRenderer,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  currentCellOverride,\n  onPersistCurrentCell,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  isPendingLayout\n}: UseInteractionManagerOptions<K, D, C>) {\n  const { tooltipContent, tooltipId, tooltipAnchorRef, showTooltip, hideTooltip } =\n    useTruncationTooltip<K, C>({ rootRef, tableId });\n\n  // whether row selection is triggered on 'enter' keypresses in addition to 'spacebar'\n  const isEmbeddedSelect = useCollectionInteractionContext() === 'embedded';\n  const disabledRowInteractionKeys = isEmbeddedSelect\n    ? undefined\n    : _defaultDisabledRowInteractionKeys;\n\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup focus tracking using the useFocusHandling hook\n  const {\n    focusHandlingProps,\n    activeCell,\n    onActiveCellChanged,\n    currentActiveCell,\n    currentCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  } = useFocusHandling({\n    rootRef,\n    scrollerRef,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    isRtl,\n    cellSupportsTabbable: cellHasRenderer,\n    fullColumnWidths,\n    currentCellOverride,\n    onPersistCurrentCell,\n    showTooltip,\n    hideTooltip,\n    isPendingLayout,\n    isEmbeddedSelect,\n    isDataLoaded: !hasMore || tableData.length > 0\n  });\n\n  const keyboardHandlingProps = useKeyboardHandling({\n    rootRef,\n    scrollerRef,\n    tableId,\n    tableData,\n    isRtl,\n    isTabbableMode,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths,\n    activeCell,\n    onActiveCellChanged,\n    isSelectRowsOnEnter: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    hideTooltip\n  });\n\n  const pointerHandlingProps = usePointerHandling({\n    rootRef,\n    tableId,\n    tableData,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    resizeInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths,\n    onColumnResizing,\n    onColumnResize,\n    activeCell,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    showTooltip,\n    hideTooltip,\n    tooltipId\n  });\n\n  const scrollHandlingProps = useScrollHandling({\n    rootRef,\n    scrollerRef,\n    tableId,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths,\n    tooltipAnchorRef,\n    hideTooltip,\n    isRtl\n  });\n\n  const interactionManagerProps = !isPendingLayout\n    ? mergeProps(focusHandlingProps, keyboardHandlingProps, pointerHandlingProps)\n    : focusHandlingProps;\n\n  return {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    tooltipContent,\n    disabledRowInteractionKeys\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, MutableRef, Ref } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn, TableData } from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport {\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableNavigationUtils';\nimport { handleSelectionGesture, handleExtendSelectionGesture } from '../utils/TableSelectionUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { RowActionDetail, SortCriterionDetail, TableSelectionDetail } from '../../UNSAFE_TableView';\n\ntype UseKeyboardHandlingProps<K, D, C extends string> = {\n  rootRef: Ref<HTMLDivElement>;\n  scrollerRef: Ref<HTMLDivElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  isTabbableMode: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>) => void;\n  fullColumnWidths?: number[];\n  activeCell?: ActiveCell<K, C>;\n  isSelectRowsOnEnter: boolean;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isExtendableSelection: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n};\n\n/**\n * Hook that manages keyboard interactions on the Preact Table\n */\nexport function useKeyboardHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  tableId,\n  tableData,\n  isRtl,\n  isTabbableMode,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  activeCell,\n  onActiveCellChanged,\n  isSelectRowsOnEnter,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  hideTooltip\n}: UseKeyboardHandlingProps<K, D, C>) {\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = scrollerRef.current;\n      if (rootElement != null && scrollerElement != null) {\n        const platform = getClientHints().platform;\n        const keyHandlers: Record<string, () => void> = {\n          ' ': function () {\n            if (activeCell != null) {\n              if (!isTabbableMode) {\n                if (onTableSelectionChange != null) {\n                  handleSelectionGesture(\n                    rootElement,\n                    tableId,\n                    columnsArray,\n                    getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                    true,\n                    onTableSelectionChange,\n                    selectionMode,\n                    selected\n                  );\n                }\n                event.preventDefault();\n              }\n              if (\n                onRowAction != null &&\n                handleRowActionGesture(\n                  rootElement,\n                  tableId,\n                  tableData,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  activeCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          Enter: function () {\n            if (activeCell != null) {\n              if (activeCell.type === 'data') {\n                if (isSelectRowsOnEnter && !isTabbableMode) {\n                  if (onTableSelectionChange != null) {\n                    handleSelectionGesture(\n                      rootElement,\n                      tableId,\n                      columnsArray,\n                      getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                      true,\n                      onTableSelectionChange,\n                      selectionMode,\n                      selected\n                    );\n                  }\n                  event.preventDefault();\n                }\n                if (\n                  onRowAction != null &&\n                  handleRowActionGesture(\n                    rootElement,\n                    tableId,\n                    tableData,\n                    onRowAction,\n                    event.target as HTMLElement,\n                    activeCell\n                  )\n                ) {\n                  event.stopPropagation();\n                }\n              } else if (\n                activeCell.type === 'header' &&\n                !isTabbableMode &&\n                onSortCriterionChange != null &&\n                handleSortActionGesture(\n                  columnsArray,\n                  activeCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          ArrowUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  true,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  false,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowLeft: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  !isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowRight: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          PageUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          PageDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          Home: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          End: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          }\n        };\n        if (Object.keys(keyHandlers).includes(event.key)) {\n          keyHandlers[event.key]();\n        }\n      }\n    },\n    [\n      rootRef,\n      scrollerRef,\n      tableId,\n      tableData,\n      isRtl,\n      isTabbableMode,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      fullColumnWidths,\n      activeCell,\n      onActiveCellChanged,\n      isSelectRowsOnEnter,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange,\n      hideTooltip\n    ]\n  );\n\n  return { onKeyDown: _keyDownHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SampledWidths, TableColumn } from '../Table';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function getLayoutColumnWidths<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollbarWidth: number,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  if (isFixed) {\n    return _getFixedLayoutColumnWidths(availableWidth, columnsArray, staticColumnWidths);\n  }\n\n  const innerTableElement = rootElement.querySelectorAll(\n    `[data-oj-table-inner-table='${tableId}']`\n  )[0] as HTMLTableElement;\n  const tableCols = rootElement.querySelectorAll(\n    `[data-oj-table-col='${tableId}']`\n  ) as NodeListOf<HTMLTableColElement>;\n  const headerElements = rootElement.querySelectorAll(\n    `[data-oj-table-header-cell='${tableId}']`\n  ) as NodeListOf<HTMLElement>;\n\n  let newColumnWidths = _getContentsLayoutColumnWidths(\n    innerTableElement,\n    headerElements,\n    sampledColumnWidthsRef,\n    availableWidth,\n    columnsArray,\n    staticColumnWidths\n  );\n  if (availableWidth === -1) {\n    let totalWidth = 0;\n    const widthsArray = [];\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newColumnWidths[columnsArray[i].key];\n      widthsArray.push(width);\n      totalWidth += width;\n    }\n    // for content sizing, apply the new column widths immediately, and check to see\n    // if all space is actually utilized - this supports no width constraint scenarios\n    _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n    availableWidth = rootElement.getBoundingClientRect().width - scrollbarWidth;\n    if (Math.abs(totalWidth - availableWidth) > 0.005) {\n      newColumnWidths = _getContentsLayoutColumnWidths(\n        innerTableElement,\n        headerElements,\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        staticColumnWidths\n      );\n    }\n  }\n  return newColumnWidths;\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnWidths<K, D, C extends string>(\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalWidth = 0;\n  let pendingTotalWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  const appliedColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalWidth += columnWidth;\n      pendingTotalWidth += columnWidth;\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray.push(columnWidth);\n      appliedColumnWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnWidthsArray.push(undefined);\n      newColumnWidthsArray.push(columnMinWidth);\n      appliedColumnWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalWidth < availableWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnWidths<K, D, C extends string>(\n  innerTableElement: HTMLTableElement,\n  headerElements: NodeListOf<HTMLElement>,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalWidth = 0;\n    let pendingTotalWidth = 0;\n    let totalPreferredWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledWidths = sampledColumnWidthsRef.current;\n    const sampledMinWidthsArray = [];\n    const sampledWeightWidthsArray = [] as number[];\n    const appliedColumnWidthsArray = [];\n    if (sampledWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinWidthsArray.push(sampledWidths.minWidths[columnsArray[i].key]);\n        sampledWeightWidthsArray.push(sampledWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      // when sampledColumnWidths are not populated, table has 'max-content' width applied,\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledWeightWidthsArray.push(sampledWeightWidth);\n        sampledColumnWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightWidth;\n      }\n      // specify 'min-content' width, allowing measurements to represent minimum auto-resizable column widths\n      innerTableElement.style.width = 'min-content';\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledMinWidthsArray.push(sampledMinWidth);\n        sampledColumnWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnWidth;\n        const sampledMinWidth = sampledMinWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinWidth) {\n          columnWidth = minWidth;\n        } else if (maxWidth != null && sampledMinWidth >= maxWidth) {\n          columnWidth = maxWidth;\n        } else {\n          columnWidth = sampledMinWidth;\n        }\n        pendingTotalWidth += columnWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightWidthsArray[i]\n            ? minWidth\n            : sampledWeightWidthsArray[i];\n        sampledWeightWidthsArray[i] = columnWeight;\n        totalPreferredWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnWidthsArray[i] = columnWidth;\n        appliedColumnWidthsArray.push(columnWidth);\n      } else {\n        forcedTotalWidth += forcedWidth;\n        pendingTotalWidth += forcedWidth;\n        totalPreferredWidth += forcedWidth;\n        appliedColumnWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableWidth === -1) {\n      availableWidth = totalPreferredWidth;\n    }\n    if (pendingTotalWidth < availableWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableWidth,\n        totalPreferredWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalWidth,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        sampledWeightWidthsArray,\n        columnMaxWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnWidthsArray: number[]\n) {\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = columnWidthsArray[i];\n  }\n  return columnWidths;\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _updateTableSizing(\n  innerTableElement: HTMLTableElement,\n  tableCols: NodeListOf<HTMLTableColElement>,\n  widthsArray: number[],\n  totalWidth: number\n) {\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i];\n    tableCol.style.width = `${widthsArray[i]}px`;\n  }\n  innerTableElement.style.width = `${totalWidth}px`;\n  innerTableElement.style.tableLayout = 'fixed';\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport {\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useRef,\n  useLayoutEffect,\n  useState\n} from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { JSXInternal } from 'preact/src/jsx';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport {\n  Cell,\n  CellOverride,\n  Column,\n  ColumnWidths,\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition\n} from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { getLayoutColumnWidths } from './utils/TableLayoutUtils';\nimport {\n  getViewportConfig,\n  getHorizontalScrollPosition,\n  setHorizontalScrollPosition,\n  getVerticalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyColumns\n} from './utils/TableScrollUtils';\nimport {\n  focusTrackerStyles,\n  innerTableStyles,\n  scrollerStyles,\n  tableSkeletonStyles\n} from './themes/Table.css';\nimport { TableVariantOptions } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type ActiveCell<K, C> =\n  | Cell<K, C>\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loading';\n    }\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loadMore';\n    }\n  | {\n      rowKey?: never;\n      columnKey?: never;\n      type: 'pending';\n    };\n\nexport type ActiveCellDetail<K, C> = {\n  value?: ActiveCell<K, C>;\n};\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type TableData<K, D> = {\n  data: D;\n  metadata: K;\n};\n\nexport type CurrencyStatus<K, D, C> = {\n  activeCell?: ActiveCell<K, C>;\n  currentCell?: Cell<K, C>;\n  currentCellOverride?: CellOverride<K, C>;\n  hasPendingCurrentCellOverride: boolean;\n  hasPendingCurrentCellOverrideScroll: boolean;\n  previousEmbeddedSelectCurrentCell?: Cell<K, C>;\n  loadMoreInitialData?: TableData<K, D>[];\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    };\n\ntype LayoutInfo =\n  | {\n      isLayoutRequired: true;\n      columnWidthsArray?: number[];\n    }\n  | {\n      isLayoutRequired: false;\n      columnWidthsArray: number[];\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      fullColumnWidths?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      fullColumnWidths: number[];\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: ActiveCell<K, C> | Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\nconst _disabledHeaderFooterInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Component that renders data in a flat table.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCellOverride,\n    onPersistCurrentCell,\n    currentRowVariant = 'none',\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const rootRef = useRef<HTMLDivElement>(null);\n  const scrollerRef = useRef<HTMLDivElement>(null);\n  const [_isInitialRender, setIsInitialRender] = useState<boolean>(true);\n  const sizingInfoRef = useRef<SizingInfo>({ isInitialRender: true });\n  const pendingResizeEntryRef = useRef<ResizeObserverEntry | undefined>();\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<ColumnWidths<C>>();\n  const [contentSize, setContentSize] = useState<{ width: number; height: number } | undefined>();\n  const overflowRef = useRef<{ isHorizontal: boolean; isVertical: boolean }>({\n    isHorizontal: false,\n    isVertical: false\n  });\n  const sampledColumnWidthsRef = useRef<SampledWidths<C>>();\n  const horizontalScrollPositionOverrideRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionOverrideRef = useRef<TableVerticalScrollPosition<K>>();\n\n  const tableData = useMemo(() => {\n    const newDataArray =\n      data != null\n        ? data.map((d: D) => {\n            const key = getRowKey(d);\n            return { data: d, metadata: key };\n          })\n        : [];\n    return newDataArray as Array<TableData<K, D>>;\n  }, [data, getRowKey]);\n\n  // debounce loadMore calls to prevent state changes from triggering multiple calls\n  const loadMoreDataRef = useRef<TableData<K, D>[]>();\n  if (!hasMore) {\n    // clear loadMoreData cache once more data is not available\n    loadMoreDataRef.current = undefined;\n  }\n  const onTableLoadMore = useCallback(() => {\n    if (tableData === loadMoreDataRef.current) {\n      return;\n    }\n    loadMoreDataRef.current = tableData;\n    return onLoadMore();\n  }, [tableData, onLoadMore]);\n\n  const [stickyEdgesState, setStickyEdgesState] = useState<{ start?: number; end?: number }>({\n    start: undefined,\n    end: undefined\n  });\n\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  const { direction, forcedColors } = useUser();\n  const isRtl = direction === 'rtl';\n  const testIdProps = useTestId(testId);\n\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [] as Array<TableColumn<K, D, C>>;\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  let isLayoutRequired = false;\n  const columnWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const appliedWidth = appliedColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (appliedWidth == null || (staticWidth != null && staticWidth !== appliedWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      columnWidthsArray.push(appliedWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n  const layoutInfo = {\n    isLayoutRequired: isLayoutRequired,\n    columnWidthsArray: isLayoutRequired ? undefined : columnWidthsArray\n  } as LayoutInfo;\n\n  useImperativeHandle(\n    ref!,\n    () => {\n      return {\n        getHorizontalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getHorizontalScrollPosition(\n            scrollerRef.current!,\n            columnsArray,\n            layoutInfo.columnWidthsArray\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition(rootRef.current!, scrollerRef.current!, tableId);\n        }\n      };\n    },\n    [tableId, columnsArray, layoutInfo.isLayoutRequired, layoutInfo.columnWidthsArray]\n  );\n\n  const cellHasRenderer = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      let hasRenderer = false;\n      if (cell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else if (cell.type !== 'loadMore' && cell.type !== 'loading' && cell.type !== 'pending') {\n        for (const column of columnsArray) {\n          if (column.key === cell.columnKey) {\n            if (cell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (cell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (cell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const isPendingLayout = layout === 'pending';\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = hasMore || isPendingLayout ? -1 : tableData.length + (hasFooters ? 2 : 1);\n  const ariaColumnCount = Math.max(columnsArray.length, 1);\n\n  const {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    tooltipContent,\n    disabledRowInteractionKeys\n  } = useInteractionManager({\n    rootRef,\n    scrollerRef,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths: appliedColumnWidths!,\n    sizingInfoRef,\n    resizeInfoRef,\n    stickyEdgesState,\n    setStickyEdgesState,\n    cellHasRenderer,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    onColumnResizing,\n    onColumnResize,\n    currentCellOverride,\n    onPersistCurrentCell,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    isPendingLayout\n  });\n\n  // ensure sampled column sizes are cleared if 'columns' or 'layout' is updated\n  useLayoutEffect(() => {\n    sampledColumnWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns, layout]);\n\n  // ensure applied column widths are cleared if 'columnWidths' is updated\n  useLayoutEffect(() => {\n    setAppliedColumnWidths(undefined);\n  }, [columnWidths]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    if (isPendingLayout) {\n      return;\n    }\n    const rootElement = rootRef.current;\n    if (\n      rootElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      layoutInfo.isLayoutRequired &&\n      sizingInfoRef.current.defaultScrollbarWidth != null &&\n      columnsArray.length > 0\n    ) {\n      const totalWidth =\n        layout === 'fixed'\n          ? sizingInfoRef.current.boxWidth - sizingInfoRef.current.defaultScrollbarWidth\n          : -1;\n      const newColumnWidths = getLayoutColumnWidths(\n        rootElement,\n        sizingInfoRef.current.defaultScrollbarWidth,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [tableId, columnsArray, columnWidths, layout, layoutInfo.isLayoutRequired, isPendingLayout]);\n\n  // setup component resize-based sizing calculation updates\n  const resizeObserverCallbackRef = useRef<(entry: ResizeObserverEntry) => void>();\n  resizeObserverCallbackRef.current = (entry: ResizeObserverEntry) => {\n    pendingResizeEntryRef.current = entry;\n    window.requestAnimationFrame((): void => {\n      const currentEntry = pendingResizeEntryRef.current;\n      if (currentEntry != null && rootRef.current != null) {\n        let availableWidth;\n        let scrollbarWidth;\n        const newContentWidth = currentEntry.contentBoxSize[0].inlineSize;\n        const newContentHeight = currentEntry.contentBoxSize[0].blockSize;\n        const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n        const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n\n        if (newContentWidth !== 0 || newBoxWidth !== 0) {\n          if (sizingInfoRef.current.isInitialRender) {\n            scrollbarWidth = newBoxWidth - newContentWidth;\n            availableWidth = layout === 'fixed' ? newContentWidth : -1;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              defaultScrollbarWidth: scrollbarWidth,\n              defaultScrollbarHeight: newBoxHeight - newContentHeight\n            };\n            setIsInitialRender(false);\n          } else {\n            scrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n            availableWidth = overflowRef.current.isVertical\n              ? newContentWidth\n              : newBoxWidth - scrollbarWidth;\n            sizingInfoRef.current.contentWidth = newContentWidth;\n            sizingInfoRef.current.boxWidth = newBoxWidth;\n            sizingInfoRef.current.contentHeight = newContentHeight;\n            sizingInfoRef.current.boxHeight = newBoxHeight;\n          }\n          if (!isPendingLayout && columnsArray.length > 0) {\n            const newColumnWidths = getLayoutColumnWidths(\n              rootRef.current,\n              scrollbarWidth,\n              tableId,\n              layout === 'fixed',\n              sampledColumnWidthsRef,\n              availableWidth,\n              columnsArray,\n              columnWidths\n            );\n            setAppliedColumnWidths(newColumnWidths);\n          }\n          if (\n            contentSize == null ||\n            contentSize.width !== newContentWidth ||\n            contentSize.height !== newContentHeight\n          ) {\n            setContentSize({ width: newContentWidth, height: newContentHeight });\n          }\n        }\n      }\n      pendingResizeEntryRef.current = undefined;\n    });\n  };\n  // ensure resize observer callback function is static to avoid hook re-subscribing each render\n  const staticResizeObserverCallback = useCallback((entry: ResizeObserverEntry) => {\n    resizeObserverCallbackRef.current!(entry);\n  }, []);\n  useResizeObserver(scrollerRef, staticResizeObserverCallback);\n\n  // after each additional render, update scrollbar states if necessary\n  useLayoutEffect(() => {\n    const scrollerElement = scrollerRef.current;\n    if (\n      rootRef.current != null &&\n      scrollerElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      contentSize != null &&\n      contentSize.width === sizingInfoRef.current.contentWidth &&\n      contentSize.height === sizingInfoRef.current.contentHeight\n    ) {\n      const scrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n      const innerTable = rootRef.current.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const innerTableWidth = innerTable.getBoundingClientRect().width;\n        const innerTableHeight = innerTable.getBoundingClientRect().height;\n        // check for at least 0.5px difference to account for browser rounding issues\n        const hasHorizontalOverflow = innerTableWidth - contentSize.width > 0.5;\n        overflowRef.current.isHorizontal = hasHorizontalOverflow;\n        if (hasHorizontalOverflow) {\n          scrollerElement.classList.remove(scrollerStyles.noHorizontalScroll);\n          scrollerElement.classList.add(scrollerStyles.horizontalScroll);\n        } else {\n          scrollerElement.classList.remove(scrollerStyles.horizontalScroll);\n          scrollerElement.classList.add(scrollerStyles.noHorizontalScroll);\n        }\n        // check for at least 0.5px difference to account for browser rounding issues\n        const hasVerticalOverflow = innerTableHeight - contentSize.height > 0.5;\n        overflowRef.current.isVertical = hasVerticalOverflow;\n        if (hasVerticalOverflow) {\n          scrollerElement.classList.remove(scrollerStyles.noVerticalScroll);\n          scrollerElement.classList.add(scrollerStyles.verticalScroll);\n          scrollerElement.style.paddingInlineEnd = '';\n        } else {\n          scrollerElement.classList.remove(scrollerStyles.verticalScroll);\n          scrollerElement.classList.add(scrollerStyles.noVerticalScroll);\n          scrollerElement.style.paddingInlineEnd = `${scrollbarWidth}px`;\n        }\n      }\n    }\n  }, [tableId, contentSize, data, noDataRenderer, appliedColumnWidths]);\n\n  // update horizontal scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setHorizontalScrollPosition(\n        scrollerRef.current!,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        isRtl,\n        horizontalScrollPositionOverride\n      );\n      horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;\n    }\n  }, [\n    tableId,\n    columnsArray,\n    layoutInfo.isLayoutRequired,\n    layoutInfo.columnWidthsArray,\n    horizontalScrollPositionOverride,\n    isRtl\n  ]);\n\n  // update vertical scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setVerticalScrollPosition(\n        rootRef.current!,\n        scrollerRef.current!,\n        tableId,\n        verticalScrollPositionOverride\n      );\n      verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;\n    }\n  }, [tableId, layoutInfo.isLayoutRequired, verticalScrollPositionOverride]);\n\n  // ensure sticky columns are updated appropriately\n  useLayoutEffect(() => {\n    if (rootRef.current != null && scrollerRef.current != null && !layoutInfo.isLayoutRequired) {\n      updateStickyColumns(\n        rootRef.current,\n        scrollerRef.current,\n        tableId,\n        isRtl,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        stickyEdgesState,\n        setStickyEdgesState\n      );\n    }\n  }, [\n    tableId,\n    columnsArray,\n    layoutInfo.isLayoutRequired,\n    layoutInfo.columnWidthsArray,\n    isRtl,\n    stickyEdgesState\n  ]);\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    pendingLayout: isPendingLayout ? 'isPendingLayout' : 'notPendingLayout',\n    showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n  });\n\n  let scrollerStyle;\n  const scrollerClassArray = [scrollerStyles.base];\n  if (sizingInfoRef.current.isInitialRender) {\n    scrollerClassArray.push(scrollerStyles.forceScroll);\n  } else {\n    if (overflowRef.current.isHorizontal) {\n      scrollerClassArray.push(scrollerStyles.horizontalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noHorizontalScroll);\n    }\n    if (overflowRef.current.isVertical) {\n      scrollerClassArray.push(scrollerStyles.verticalScroll);\n      scrollerStyle = '';\n    } else {\n      scrollerClassArray.push(scrollerStyles.noVerticalScroll);\n      scrollerStyle = `padding-inline-end: ${sizingInfoRef.current.defaultScrollbarWidth}px;`;\n    }\n  }\n\n  const scrollerClasses = classNames(scrollerClassArray);\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n  const focusTrackerClasses = classNames([focusTrackerStyles.base]);\n\n  const startStickyEdge = stickyEdgesState.start;\n  const endStickyEdge = stickyEdgesState.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' || selectionMode?.row === 'multiple';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n\n  const getTableBodyProps = () => {\n    return {\n      rootRef: rootRef,\n      tableId: tableId,\n      isValidRender: columnsArray.length > 0,\n      tableData: tableData,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      activeCell: currentActiveCell,\n      currentRowKey: currentCell?.type === 'data' ? currentCell.rowKey : undefined,\n      currentRowVariant: currentRowVariant,\n      isShowFocusRing: isShowFocusRing,\n      isTabbableMode: isTabbableMode,\n      hasMore: hasMore,\n      onLoadMore: onTableLoadMore,\n      noDataRenderer: noDataRenderer,\n      viewportConfig: getViewportConfig(scrollerRef),\n      disabledInteractionKeys: disabledRowInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: forcedColors === 'active'\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!layoutInfo.isLayoutRequired) {\n      columnWidthsArray = layoutInfo.columnWidthsArray;\n    } else if (layout === 'fixed') {\n      // default to 100px for each column when layout is not yet available\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = 100;\n      }\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'header' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      isShowFocusRing: isShowFocusRing,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl,\n      isHighContrast: forcedColors === 'active'\n    };\n  };\n\n  const getTableFooterProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'footer' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isShowFocusRing: isShowFocusRing,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      dataRowCount: tableData.length,\n      isRtl: isRtl,\n      isHighContrast: forcedColors === 'active'\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (columnResizingIndicator != null && !layoutInfo.isLayoutRequired) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += layoutInfo.columnWidthsArray[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    if (!layoutInfo.isLayoutRequired) {\n      let totalWidth = 0;\n      for (let i = 0; i < layoutInfo.columnWidthsArray.length; i++) {\n        totalWidth += layoutInfo.columnWidthsArray[i];\n      }\n      return `width:${totalWidth}px;table-layout:fixed;`;\n    } else if (columnsArray.length > 0) {\n      if (layout === 'fixed') {\n        // default to 100px for each column when layout is not yet available\n        return `width:${columnsArray.length * 100}px;table-layout:fixed;`;\n      } else {\n        // shrink table down as much as possible when a 'contents' layout is required, otherwise\n        // the sampled column widths will not reflect the true weight sizes with line-clamping\n        return 'width:max-content;will-change:width;';\n      }\n    }\n    // no columns are present\n    return 'width:100%;';\n  };\n\n  const getPendingLayoutSkeletons = () => {\n    return isPendingLayout ? (\n      <div class={tableSkeletonStyles.pendingLayout}>\n        <table role={'presentation'} style={'width:100%;table-layout:fixed;'}>\n          <tbody role={'presentation'}>\n            <TableSkeletonRow\n              tableId={tableId}\n              hasTabIndex={currentActiveCell?.type === 'pending'}\n              colspan={ariaColumnCount}\n              isPendingLayout={true}\n              isShowFocusRing={false}\n            />\n          </tbody>\n        </table>\n      </div>\n    ) : undefined;\n  };\n\n  return (\n    <div\n      {...testIdProps}\n      ref={rootRef}\n      aria-colcount={ariaColumnCount}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-rowcount={ariaRowCount}\n      {...(selectionMode?.column === 'multiple' || selectionMode?.row === 'multiple'\n        ? { 'aria-multiselectable': true }\n        : {})}\n      class={classes}\n      id={tableId}\n      role={'grid'}\n      tabIndex={currentActiveCell != null ? -1 : 0}\n      {...interactionManagerProps}>\n      <div\n        ref={scrollerRef}\n        class={scrollerClasses}\n        role={'rowgroup'}\n        style={scrollerStyle}\n        tabIndex={-1}\n        {...scrollHandlingProps}>\n        <FocusTracker\n          styleClass={focusTrackerClasses}\n          isDisabled={!isTabbableMode}\n          onFocusStartEdge={onFocusStartEdge}\n          onFocusEndEdge={onFocusEndEdge}\n          onStartTracking={onStartFocusTracking}>\n          <TabbableModeContext.Provider value={{ isTabbable: isTabbableMode }}>\n            <table\n              aria-hidden={isPendingLayout ? true : undefined}\n              class={tableClasses}\n              role={'presentation'}\n              style={getTableStyle()}\n              data-oj-table-inner-table={tableId}>\n              <TableColGroup {...getTableColGroupProps()} />\n              <TableHeader {...getTableHeaderProps()} />\n              <TableBody {...getTableBodyProps()} />\n              <TableFooter {...getTableFooterProps()} />\n            </table>\n          </TabbableModeContext.Provider>\n          {getTableDragIndicator()}\n        </FocusTracker>\n        {tooltipContent}\n      </div>\n      {getPendingLayoutSkeletons()}\n    </div>\n  );\n}) as <K extends string | number, D, C extends string>(\n  p: Props<K, D, C> & { ref?: ForwardedRef<TableViewHandle<K, C>> }\n) => JSXInternal.Element;\n"],"names":["TableColGroup","tableId","isRendered","columnWidthsArray","getColStyle","columnWidth","_jsx","jsx","children","map","style","skeletonDimensionInterpolation","Array","from","x","dimensionInterpolations","interpolations","Object","values","SkeletonInterpolations","mergeInterpolations","TableSkeleton","props","classes","classNames","tableSkeletonStyles","bar","skeletonDimensions","width","class","TableSkeletonRow","colspan","hasTabIndex","isShowFocusRing","isPendingLayout","isLoadMore","translations","useTranslationBundle","cellClassArray","cell","push","focus","cellClasses","innerCellClasses","innerCell","rowClasses","row","rowHeight","firstRowClasses","secondRowClasses","accCellContent","collection_loading","headerHeight","rowHeightFirst","LOADMORE_STYLE_CLASS","role","colSpan","tabIndex","_jsxs","_element","index","height","getDataClassArray","isFirstColumnIndex","isFinalColumnIndex","isFirstRowIndex","isFinalRowIndex","hasVerticalGridlines","hasHorizontalGridlines","isRowSelected","isPreviousRowSelected","isColumnSelected","isPreviousColumnSelected","stickyColumn","isRowSelectionEnabled","isRowSingleSelection","variant","isActive","isHover","isPseudoHover","isStickyStartEdge","isStickyEndEdge","isRtl","isHighContrast","padding","cellStyles","tableHighContrastCellStyles","tableCellStyles","classArray","base","isPaddingDisabled","isComplexPadding","isBottomPadding","bottom","isEndPadding","end","isStartPadding","start","isTopPadding","top","stickyStartColumn","stickyEndColumn","stickyEdgeStart","stickyEdgeLeft","stickyEdgeRight","stickyEdgeEnd","active","hover","pseudoHover","rowHighlight","focused","rowSelected","horizontalSelectedGridTop","selectedBorderTopPadding","selectedBorderTopNoPadding","horizontalGridTop","borderTopPadding","borderTopNoPadding","topSpacerPadding","topSpacerNoPadding","lastRow","horizontalSelectedGridBottom","selectedBorderBottomPadding","selectedBorderBottomNoPadding","horizontalGridBottom","borderBottomPadding","borderBottomNoPadding","bottomSpacerPadding","bottomSpacerNoPadding","notLastRow","bottomPadding","bottomNoPadding","columnSelected","selectedBorderStartPadding","selectedBorderStartNoPadding","verticalSelectedGridEnd","selectedBorderEndPadding","selectedBorderEndNoPadding","endPadding","endNoPadding","verticalSelectedGridStart","verticalGridStart","borderStartPadding","borderStartNoPadding","startSpacerPadding","startSpacerNoPadding","endSpacerPadding","endSpacerNoPadding","getHeaderFooterClassArray","isHeader","isPsuedoHover","isSelected","isPreviousSelected","isColumnSelectable","previousBorderStart","previousBorderStartNoPadding","previousPseudoHoverBorderStart","previousPseudoHoverBorderStartNoPadding","tableHighContrastHeaderCellStyles","tableHeaderCellStyles","headerHighContrastPreviousBorderStart","headerPreviousBorderStart","headerHighContrastPreviousBorderStartNoPadding","headerPreviousBorderStartNoPadding","headerHighContrastPreviousPseudoHoverBorderStart","headerPreviousPseudoHoverBorderStart","headerHighContrastPreviousPseudoHoverBorderStartNoPadding","headerPreviousPseudoHoverBorderStartNoPadding","tableHighContrastFooterCellStyles","tableFooterCellStyles","footerHighContrastPreviousBorderStart","footerPreviousBorderStart","footerHighContrastPreviousBorderStartNoPadding","footerPreviousBorderStartNoPadding","footerHighContrastPreviousPseudoHoverBorderStart","footerPreviousPseudoHoverBorderStart","footerHighContrastPreviousPseudoHoverBorderStartNoPadding","footerPreviousPseudoHoverBorderStartNoPadding","topPadding","topNoPadding","selected","activeSelected","activeBorderStart","activeBorderStartNoPadding","activeBorderEnd","activeBorderEndNoPadding","hoverSelected","hoverBorderStart","hoverBorderStartNoPadding","hoverBorderEnd","hoverBorderEndNoPadding","pseudoHoverSelected","pseudoHoverBorderStart","pseudoHoverBorderStartNoPadding","pseudoHoverBorderEnd","pseudoHoverBorderEndNoPadding","getCellType","element","dataset","getRowKey","Number","getRowKeyForRowIndex","rootElement","rowElements","querySelectorAll","length","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","cellElement","columnElements","logicalCellExtractor","columnsArray","cellSelector","onlyAncestors","selectorString","startingElement","parentElement","closest","cellType","rowKey","keyExtractor","columnKey","type","getBoundaryColumnKey","getElementFromCell","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerTopOffset","headerRowElement","getBoundingClientRect","getScrollerBottomOffset","footerRowElement","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","isFirst","key","hasNoDataCell","getNoDataCellElement","hasFooterCells","_hasTruncatedText","getAttribute","range","Range","selectNodeContents","untruncatedTextLength","computedStyles","getComputedStyle","parseFloat","paddingLeft","paddingRight","border","borderLeft","borderRight","handleLeaveTableTooltipGesture","event","hideTooltip","tooltipId","targetElement","relatedTarget","boundingRect","clientX","left","right","clientY","preventBrowserTooltipProps","onPointerEnter","target","classList","add","preventBrowserTooltipStyle","onPointerLeave","remove","_defaultCellRenderer","rowData","field","String","undefined","TableCell","columnIndex","rowIndex","isTabbableMode","isRowHeader","renderer","selectorRenderer","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","browser","getClientHints","hasRenderer","columnPadding","data","cellRendererProps","selector","isTabbable","id","useId","MemoizeTableRow","memo","isFinalRow","rowHeaderColumnKeys","isSingleRowSelectionEnabled","selectedRowKeys","all","keys","Set","activeColumnKey","selectedColumnKeys","disabledInteractionKeys","onSelectionChange","startStickyEdge","endStickyEdge","interactionProps","useInteractionStyle","disabledKeys","rowStyles","tableHighContrastRowStyles","tableRowStyles","lastRowHeight","accessibleRowName","toString","handleRowSelectorChange","detail","value","column","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","containsKey","cellProps","stickyEdge","has","prev","next","columnsArray1","columnsArray2","i","_areColumnsArraysEquivalent","set1","set2","size","every","isSameKey","TableNoData","rootRef","columnsCount","ariaRowIndex","themeClasses","useComponentTheme","TableNoDataRedwoodTheme","defaultRenderer","showFocusRing","contentRenderer","collection_noData","useLayoutEffect","current","tableBodyElement","noDataElement","TableBody","isValidRender","getAccessibleRowHeaders","tableData","hasMore","onLoadMore","viewportConfig","activeCell","currentRowKey","currentRowVariant","noDataRenderer","collectionClasses","collectionStyles","getRowContext","useCallback","context","metadata","isShowEmptyLoading","isShowNoData","getNoDataProps","Fragment","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsActiveCell","rowProps","TableHeaderCell","headerText","sortable","sortDirection","onSortCriterionChange","selectorAllState","deletedKeys","handleSelectorChange","headerCellRendererProps","SelectorAll","collection_selectAllRows","sortControl","EmbeddedIconButton","collection_sortEnabled","collection_sortDisabled","isDisabled","onAction","handleSortGesture","SortAscendingIcon","SortDescendingIcon","SortDefaultIcon","SvgChevronUpDown","getHeaderCellRenderer","text","tableHeaderCellTextStyles","defaultRendererSpan","tableHeaderSortContainerStyles","getAriaSort","TableHeader","activeKey","isColumnSelectionEnabled","sortCriterion","isResizeHover","tableHeaderRowStyles","containerClasses","tableHeaderRowContainerStyles","criterion","headerCellProps","selectable","headerRenderer","headerPadding","_defaultFooterCellRenderer","footerText","TableFooterCell","footerCellRendererProps","TableFooter","dataRowCount","tableFooterRowStyles","tableFooterRowContainerStyles","Math","max","footerCellProps","footerRenderer","footerPadding","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","hasTopOverflow","bottomOverflowDiff","hasBottomOverflow","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","topOffset","bottomOffset","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","applyScrollDetail","sizingInfo","scrollDetail","findElementByKey","locationY","boxHeight","contentHeight","locationX","columnElement","stickyStartColumns","getStickyColumnIndicies","stickyIndex","stickyEndColumns","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","scrollHeight","clientHeight","resetVerticalScrollPosition","isStart","stickyColumns","edge","_applyStickyColumnOffset","stickyOffset","styleProperty","styleValue","j","updateStickyEdges","stickyEdgesState","setStickyEdgesState","currentScrollIndex","newScrollPosition","startIndex","endIndex","stickyStartIndicies","currentIndex","currentWidth","endOverflow","scrollWidth","clientWidth","stickyEndIndicies","getViewportConfig","scrollerRef","config","scroller","cellComparator","cell1","cell2","_getCellFromCellOverride","cellOverride","currentCell","cellRowKey","cellColumnKey","_renderIncludesCell","hasFooters","SMALL_INTERACTION_DELAY","MOUSE_FOCUS_SHIFT_TIMEOUT","TOUCH_FOCUS_SHIFT_TIMEOUT","NAVIGATION_KEYS","SCROLL_KEYS","useFocusHandling","sizingInfoRef","selectionExtensionElementRef","cellSupportsTabbable","currentCellOverride","onPersistCurrentCell","showTooltip","isEmbeddedSelect","isDataLoaded","blurFromWindowRef","useRef","isRenderCycle","blurredRenderCycleElementRef","isPendingLayoutFocusRef","hasFocusRef","setIsTabbableMode","useState","setIsShowFocusRing","recentPointerRef","pointerTimerRef","isShowFocusRingOverrideRef","setActiveCell","currencyStatusRef","hasPendingCurrentCellOverride","hasPendingCurrentCellOverrideScroll","currentActiveCell","firstColumnKey","defaultFirstCell","previousEmbeddedSelectCurrentCell","realizedCell","overrideCellType","_getCellTypeFromCellOverride","initialData","loadMoreInitialData","determineActiveCell","onActiveCellChanged","useMemo","newActiveCell","isTransientCell","newCurrentCell","_setAsInactive","_enableNavigationMode","skipScrollCellIntoView","focusRingState","handleNavigationTooltipGesture","_enableTabbableMode","isKeyboard","_disableTabbableMode","preventScroll","_pointerDownHandler","pointerType","clearTimeout","setTimeout","_touchEndHandler","_onBlurHandler","document","activeElement","isUnknownRelatedTarget","getElementContainsFunc","_onKeyDownHandler","onStartFocusTracking","handleEnterActionableMode","hasFocusWithin","allTabbableElements","onFocusStartEdge","handleWrapActionableFocus","tabbableElements","onFocusEndEdge","useEffect","applyCurrentCellOverride","blurredRenderCycleElement","getActiveElement","getBodyElement","isTabbableElement","focusHandlingProps","onPointerDown","onTouchEnd","onFocus","onBlur","onKeyDown","handleRowActionGesture","onRowAction","targetCell","targetCellElement","handleAdjacentRowGesture","initialCell","isPrevious","newCell","newColumnKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","handlePageRowGesture","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","handleJumpColumnGesture","includeRows","handleSelectionGesture","isMultiSelectGesture","selectionMode","emptyKeys","selectedRows","selectedColumns","removeKey","addKey","_applyRangeSelection","isRowGesture","handleExtendSelectionGesture","activeCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","resizeInfoRef","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","appliedColumnWidths","onColumnResize","isResizing","innerTable","rect","currentX","delta","startX","allColumnWidths","ignoreClick","usePointerHandling","onColumnResizing","onTableSelectionChange","selectionTouchRef","_pointerMoveHandler","tooltipShown","handleMoveTooltipGesture","handleColumnResizingGesture","handleOverResizeRegionGesture","shiftKey","isRangeSelectionGesture","getIsSelectionPending","preventDefault","pointerX","resizeColumnWidths","handleColumnResizeStartGesture","_pointerUpHandler","_pointerLeaveHandler","handleLeaveResizingGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","isSelectionExtension","platform","endElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","onPointerMove","onPointerUp","onClick","useScrollHandling","tooltipAnchorRef","_scrollHandler","offsetHeight","offsetWidth","hideOutOfViewTooltip","onScroll","_defaultDisabledRowInteractionKeys","useInteractionManager","cellHasRenderer","tooltipContent","globalTooltipManager","getGlobalTooltipManager","tooltipCellRef","pendingShowTooltipCellRef","tooltipTextRef","tooltipText","setTooltipText","pointerDownRef","pointerDownTimeoutRef","showTooltipTimeoutRef","hideTooltipTimeoutRef","_clearHideTooltipTimeout","_clearShowTooltipTimeout","_setupShowTooltipTimeout","textContent","SHOW_TOOLTIP_DELAY","_setupHideTooltipTimeout","anchorCell","isImmediate","_event","isOpenOverrideRef","tooltipPointerProps","renderRawContent","TooltipContent","isOpen","isDatatip","scale","useScale","mainAxisOffset","crossAxisOffset","currentColorScheme","useColorScheme","getWrappedTooltipContent","mainAxis","crossAxis","destroyCallback","register","unregister","useTruncationTooltip","useCollectionInteractionContext","disabledRowInteractionKeys","isExtendableSelection","keyboardHandlingProps","isSelectRowsOnEnter","_keyDownHandler","keyHandlers","Enter","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","includes","useKeyboardHandling","pointerHandlingProps","scrollHandlingProps","interactionManagerProps","mergeProps","getLayoutColumnWidths","isFixed","sampledColumnWidthsRef","availableWidth","staticColumnWidths","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalWidth","pendingTotalWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","isMaxRuleApplied","_enforceWeightedMinRules","_enforceFixedMinMaxRules","_createColumnWidths","_getFixedLayoutColumnWidths","innerTableElement","tableCols","newColumnWidths","_getContentsLayoutColumnWidths","totalWidth","widthsArray","tableLayout","_updateTableSizing","columnMinWidthsArray","totalPreferredWidth","totalRemainingWeight","sampledWidths","sampledMinWidthsArray","sampledWeightWidthsArray","minWidths","weightWidths","sampledWeightWidth","sampledMinWidth","forcedWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","newWidth","columnWidths","_defaultSelected","_disabledHeaderFooterInteractionKeys","Table","forwardRef","ariaLabel","ariaLabelledBy","columns","columnOrder","layout","gridlines","horizontalScrollPositionOverride","verticalScrollPositionOverride","columnResizingIndicator","testId","ref","_isInitialRender","setIsInitialRender","isInitialRender","pendingResizeEntryRef","setAppliedColumnWidths","contentSize","setContentSize","overflowRef","isHorizontal","isVertical","horizontalScrollPositionOverrideRef","verticalScrollPositionOverrideRef","d","loadMoreDataRef","onTableLoadMore","direction","forcedColors","useUser","testIdProps","useTestId","newColumnsArray","entries","isLayoutRequired","appliedWidth","staticWidth","layoutInfo","useImperativeHandle","some","ariaRowCount","ariaColumnCount","defaultScrollbarWidth","resizeObserverCallbackRef","entry","window","requestAnimationFrame","currentEntry","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","defaultScrollbarHeight","staticResizeObserverCallback","useResizeObserver","innerTableWidth","innerTableHeight","hasHorizontalOverflow","scrollerStyles","noHorizontalScroll","horizontalScroll","hasVerticalOverflow","noVerticalScroll","verticalScroll","paddingInlineEnd","stickyStartOffset","stickyEndOffset","updateStickyColumns","TableRedwoodTheme","pendingLayout","scrollerStyle","scrollerClassArray","forceScroll","scrollerClasses","tableClasses","innerTableStyles","focusTrackerClasses","focusTrackerStyles","vertical","horizontal","jsxs","FocusTracker","styleClass","onStartTracking","TabbableModeContext","Provider","getTableStyle","getTableColGroupProps","getTableDragIndicator"],"mappings":"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AvBpC,GAAejnB,IAEfynB,GACE7d,EACA8P,EACAvc,EACAuN,EACA6V,EACA3W,GACA,EACAgL,EACA4L,EACA6I,EACAjnB,EACA8Y,EACA+L,EACA3e,GAGFod,GACE9b,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACA,EACArgB,EACAwL,EACAsN,GAGJvN,EAAMoc,iBAET,EACDkF,UAAW,WACJ5f,GAAgC,MAAduF,IAEE,WAApBA,EAAWvJ,MAAyC,WAApBuJ,EAAWvJ,OAC5CsC,EAAMic,UACoB,MAA1BP,GAC0B,aAA1BpC,GAAehV,OAmBfwU,GACE7c,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACCrgB,EACDA,EACAwL,EACAsN,GA5BFuM,GACE7d,EACA8P,EACAvc,EACAuN,EACA6V,EACA3W,GACA,EACAgL,EACA4L,EACA6I,EACAjnB,EACA8Y,EACA+L,EACA3e,GAiBJqF,EAAMoc,iBAET,EACDmF,WAAY,WACL7f,GAAgC,MAAduF,IAEE,WAApBA,EAAWvJ,MAAyC,WAApBuJ,EAAWvJ,OAC5CsC,EAAMic,UACoB,MAA1BP,GAC0B,aAA1BpC,GAAehV,OAmBfwU,GACE7c,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,EACArgB,EACAA,EACAwL,EACAsN,GA5BFuM,GACE7d,EACA8P,EACAvc,EACAuN,EACA6V,EACA3W,GACA,EACAgL,EACA4L,EACA6I,EACAjnB,EACA8Y,EACA+L,EACA3e,GAiBJqF,EAAMoc,iBAET,EACDoF,OAAQ,WACD9f,GAAgC,MAAduF,IACrBuR,GACEvc,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACA,EACArgB,EACAwL,EACAsN,GAEFvN,EAAMoc,iBAET,EACDqF,SAAU,WACH/f,GAAgC,MAAduF,IACrBuR,GACEvc,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACA,EACArgB,EACAwL,EACAsN,GAEFvN,EAAMoc,iBAET,EACDsF,KAAM,WACChgB,GAAgC,MAAduF,IACrBiS,GACEjd,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACA,EACa,QAAbkI,EAAqBhd,EAAMmd,QAAUnd,EAAMod,QAC3C3oB,EACAwL,EACAsN,GAEFvN,EAAMoc,iBAET,EACDuF,IAAK,WACEjgB,GAAgC,MAAduF,IACrBiS,GACEjd,EACA8P,EACAvc,EACAuN,EACA6V,EACA3L,EACA6N,GACA,EACa,QAAbkI,EAAqBhd,EAAMmd,QAAUnd,EAAMod,QAC3C3oB,EACAwL,EACAsN,GAEFvN,EAAMoc,iBAET,GAEC5rB,OAAO0S,KAAK+d,GAAaW,SAAS5hB,EAAMnB,MAC1CoiB,EAAYjhB,EAAMnB,MAErB,IAEH,CACE+G,EACA6L,EACAjiB,EACAqX,EACApS,EACAiN,EACA3E,EACA6V,EACAC,EACAtF,EACAtG,EACA6N,EACAiM,EACAzH,EACA3e,EACA+gB,EACA9D,EACAzN,EACA3B,EACAvI,IAIJ,MAAO,CAAEyX,UAAWsJ,EACtB,CD9RgCa,CAAoB,CAChDjc,UACA6L,cACAjiB,UACAqX,YACApS,QACAiN,iBACA3E,eACA6V,gBACAC,+BACAtF,mBACAtG,aACA6N,sBACAiM,oBAAqB7N,EACrBoG,gBACA3e,WACA+gB,yBACA9D,cACAzN,gBACA3B,wBACAvI,gBAGI6hB,GAAuBtG,GAAmB,CAC9C5V,UACApW,UACAqX,YACApS,QACAsI,eACA+d,sBACAP,gBACA1H,+BACAtF,mBACAkO,mBACAV,iBACA9T,aACAqS,gBACA3e,WACA+gB,yBACA9D,cACA3E,cACAhT,cACAC,cAGI6hB,GAAsBtE,GAAkB,CAC5C7X,UACA6L,cACAjiB,UACAojB,gBACA7V,eACA4T,mBACAC,sBACArD,mBACAmQ,mBACAzd,cACAxL,UAOF,MAAO,CACLutB,wBAL+BvwB,EAE7B4lB,EADA4K,aAAW5K,EAAoByJ,GAAuBgB,IAKxDC,uBACArG,yBACAlqB,kBACAkQ,iBACAuQ,cACAmC,oBACAmC,uBACAI,mBACAG,kBACAqH,iBACAyC,6BAEJ,UE9MgBsB,GACdjmB,EACAgR,EACAzd,EA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"}