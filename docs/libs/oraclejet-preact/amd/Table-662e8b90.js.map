{"version":3,"file":"Table-662e8b90.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableFocusUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/Table.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width: ${columnWidth}px;`;\n  };\n\n  return (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useState, useEffect } from 'preact/hooks';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonBarContainerStyles, tableSkeletonCellStyles } from './themes/Table.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Skeleton } from '../UNSAFE_Skeleton';\n\ntype SkeletonRowProps = {\n  /**\n   * Total number of columns to span\n   */\n  colspan: number;\n  /**\n   * The preact key value\n   */\n  preactKey: any;\n  /**\n   * Allows to specify number of skeletons to be rendered on initial load\n   **/\n  minimumCount?: number;\n};\n\n/**\n * Allows to specify the time delay for rendering the component\n **/\nconst _timerValue = 50;\n\n/**\n * TableSkeletonRow renders 'minimumCount' number of skeletons\n * of the variant specified from its child element - Skeleton's prop after\n * 'timerValue' ms delay\n **/\nexport function TableSkeletonRow({ colspan, preactKey, minimumCount = 1 }: SkeletonRowProps) {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsVisible(true);\n    }, _timerValue);\n  }, []);\n\n  const cellClasses = classNames([tableSkeletonCellStyles.base]);\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} key={preactKey}>\n      {isVisible ? (\n        <td class={cellClasses} colSpan={colspan} role=\"presentation\">\n          {[...Array(minimumCount)].map((_element) => (\n            <div class={tableSkeletonBarContainerStyles.base}>\n              <Skeleton height=\"4x\" />\n            </div>\n          ))}\n        </td>\n      ) : null}\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { CurrentRowVariant, TableRendererContext } from '../UNSAFE_TableView';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TableCellVariantOptions } from './themes/TableCellStyles.css';\nimport { TableCellRedwoodTheme } from './themes/redwood/TableCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isFocusRingVisible: boolean;\n  isTabbable: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? (\n    <Text overflowWrap=\"breakWord\" lineClamp={1} variant=\"primary\" size=\"md\">\n      {String(rowData[field])}\n    </Text>\n  ) : null;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isFocusRingVisible,\n  isTabbable,\n  isRowHeader,\n  stickyColumn = 'none',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableCellProps<K, D, C>) {\n  const hasRenderer = renderer !== _defaultCellRenderer;\n  const { classes: themeClasses } = useComponentTheme<TableCellVariantOptions>(\n    TableCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstRow: rowIndex === 0 ? 'isFirstRow' : 'notFirstRow',\n      lastRow: isFinalRowIndex ? 'isLastRow' : 'notLastRow',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderTopSpacer:\n        !(isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) &&\n        (!hasHorizontalGridlines || rowIndex === 0)\n          ? 'isBorderTopSpacer'\n          : 'notBorderTopSpacer',\n      borderBottomSpacer:\n        isFinalRowIndex && !((isRowSingleSelection && isRowSelected) || hasHorizontalGridlines)\n          ? 'isBorderBottomSpacer'\n          : 'notBorderBottomSpacer',\n      borderStartSpacer:\n        !(isPreviousColumnSelected || isColumnSelected) &&\n        (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isColumnSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      horizontalGrid: hasHorizontalGridlines ? 'isHorizontalGrid' : 'notHorizontalGrid',\n      rowSingleSelection: isRowSingleSelection ? 'isRowSingleSelection' : 'notRowSingleSelection',\n      rowSelectable: isRowSelectionEnabled ? 'isRowSelectable' : 'notRowSelectable',\n      rowSelected: isRowSelected ? 'isRowSelected' : 'notRowSelected',\n      previousRowSelected: isPreviousRowSelected\n        ? 'isPreviousRowSelected'\n        : 'notPreviousRowSelected',\n      columnSelected: isColumnSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousColumnSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      rowHighlight: variant === 'highlight' ? 'isRowHighlight' : 'notRowHighlight',\n      focusRingVisible: isFocusRingVisible ? 'isFocusRingVisible' : 'notFocusRingVisible',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={isRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        {renderer(cellRendererProps)}\n      </TabbableModeContext.Provider>\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { TableRowVariantOptions } from './themes/TableRowStyles.css';\nimport { TableRowRedwoodTheme } from './themes/redwood/TableRowTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K, D, C> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  showFocusRing: boolean;\n  containsTabbableCell: boolean;\n  isRtl: boolean;\n  selectedRowKeys?: Keys<K>;\n  focusedColumnKey?: C;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K, D, C>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  showFocusRing,\n  containsTabbableCell,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  focusedColumnKey,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const { classes: themeClasses } = useComponentTheme<TableRowVariantOptions>(\n    TableRowRedwoodTheme,\n    { lastRow: isFinalRow ? 'isLastRow' : 'notLastRow' }\n  );\n\n  const classes = classNames([themeClasses]);\n\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        { value: { row: detail.value, column: selectedColumnKeys }, target: detail.target },\n        false\n      );\n    }\n  };\n\n  let isPreviousColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 1}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const selectorRenderer = isRowSelectionEnabled\n          ? () => {\n              // conversion from 0-based index and adding the header row as it is always rendered\n              const accessibleRowName = (rowIndex + 2).toString();\n              return (\n                <Selector\n                  aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n                  onChange={handleRowSelectorChange}\n                  rowKey={rowKey}\n                  selectedKeys={selectedRowKeys}\n                />\n              );\n            }\n          : undefined;\n\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.stickyEdge,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isColumnSelected: isColumnSelected,\n          isPreviousColumnSelected: isPreviousColumnSelected,\n          isFocusRingVisible:\n            showFocusRing && !containsTabbableCell && column.key === focusedColumnKey,\n          isTabbable: column.key === focusedColumnKey && containsTabbableCell,\n          isRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          variant: variant,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          isRtl: isRtl\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, any, string>[],\n  columnsArray2: TableColumn<string | number, any, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(TableRow, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.tableId === next.tableId &&\n      prev.rowKey === next.rowKey &&\n      prev.rowData === next.rowData &&\n      prev.rowIndex === next.rowIndex &&\n      prev.isFinalRow === next.isFinalRow &&\n      _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n      prev.horizontalGridlines === next.horizontalGridlines &&\n      prev.verticalGridlines === next.verticalGridlines &&\n      _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n      prev.isSelected === next.isSelected &&\n      prev.isPreviousSelected === next.isPreviousSelected &&\n      prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n      prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n      prev.showFocusRing === next.showFocusRing &&\n      prev.containsTabbableCell === next.containsTabbableCell &&\n      prev.selectedRowKeys === next.selectedRowKeys &&\n      prev.focusedColumnKey === next.focusedColumnKey &&\n      prev.selectedColumnKeys === next.selectedColumnKeys &&\n      prev.variant === next.variant &&\n      prev.onSelectionChange === next.onSelectionChange &&\n      prev.startStickyEdge === next.startStickyEdge &&\n      prev.endStickyEdge === next.endStickyEdge &&\n      prev.isRtl === next.isRtl\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  tableId: string;\n  columnsCount: number;\n  isFocusRingVisible: boolean;\n  isTabbable: boolean;\n  renderer?: () => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  tableId,\n  columnsCount,\n  isFocusRingVisible,\n  isTabbable,\n  renderer\n}: TableNoDataProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      focusRingVisible: isFocusRingVisible ? 'isFocusRingVisible' : 'notFocusRingVisible'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return (\n      <Text lineClamp={1} variant=\"primary\" size=\"md\">\n        {translations.collection_noData()}\n      </Text>\n    );\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  return (\n    <tr aria-rowindex={2} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        id={useId()}\n        tabIndex={-1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        <TabbableModeContext.Provider value={{ isTabbable }}>\n          {contentRenderer()}\n        </TabbableModeContext.Provider>\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { TableColumn } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  Cell,\n  CurrentRowVariant,\n  TableSelectionDetail,\n  TableRowContext\n} from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { collectionStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K, D, C> = {\n  tableId: string;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  data: D[] | null;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  getCurrentTabbableCell: () => Cell<K, C> | undefined;\n  showFocusRing: boolean;\n  getRowKey: (data: D) => K;\n  hasMore: boolean;\n  isRtl: boolean;\n  onLoadMore: () => void;\n  viewportConfig: ViewportConfig;\n  currentCell?: Cell<K, C>;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: () => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K, D, C>({\n  tableId,\n  getAccessibleRowHeaders,\n  data,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  getCurrentTabbableCell,\n  showFocusRing,\n  getRowKey,\n  hasMore,\n  onLoadMore,\n  viewportConfig,\n  currentCell,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableBodyProps<K, D, C>) {\n  // track the empty loading state and generate a new key when it changes to avoid\n  // issues with skeleton animations becoming out of sync when more are added\n  const loadIndicatorKeyRef = useRef<number>(new Date().getTime());\n  const isShowEmptyLoadingRef = useRef<boolean>();\n\n  const collectionClasses = classNames([collectionStyles.base]);\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback(\n    (context: ItemContext<{ data: D }>) => {\n      return {\n        index: context.index,\n        data: context.data.data,\n        key: getRowKey(context.data.data)\n      };\n    },\n    [getRowKey]\n  );\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<{ data: D }>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsCurrentCell = currentCell?.rowKey === rowKey;\n    const containsTabbableCell = getCurrentTabbableCell()?.rowKey === rowKey;\n    const rowShowsFocusRing = showFocusRing && containsCurrentCell;\n    const focusedColumnKey =\n      containsCurrentCell && (containsTabbableCell || rowShowsFocusRing)\n        ? currentCell.columnKey\n        : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: containsCurrentCell ? currentRowVariant : undefined,\n      focusedColumnKey: focusedColumnKey,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      showFocusRing: rowShowsFocusRing,\n      containsTabbableCell: containsTabbableCell,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === (data != null ? data.length - 1 : -1),\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    const tabbableCell = getCurrentTabbableCell();\n    const isTabbable = tabbableCell?.type === 'noData';\n    return {\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isTabbable: isTabbable,\n      isFocusRingVisible: showFocusRing && !isTabbable && currentCell?.type === 'noData',\n      renderer: noDataRenderer\n    };\n  };\n\n  const collectionData =\n    data != null\n      ? data.map((d: D) => {\n          const key = getRowKey(d);\n          return { data: d, metadata: key };\n        })\n      : [];\n\n  const isShowEmptyLoading = data != null && data.length === 0 && hasMore;\n  const isShowNoData = data == null || (data.length === 0 && !hasMore);\n  const prevIsEmpty = isShowEmptyLoadingRef.current;\n  if (prevIsEmpty !== isShowEmptyLoading) {\n    loadIndicatorKeyRef.current = new Date().getTime();\n  }\n  isShowEmptyLoadingRef.current = isShowEmptyLoading;\n\n  return (\n    <tbody class={collectionClasses}>\n      {isShowNoData ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <LoadMoreCollection\n          data={collectionData}\n          loadMoreIndicator={\n            <TableSkeletonRow\n              colspan={columnsArray.length}\n              preactKey={loadIndicatorKeyRef.current}\n              minimumCount={isShowEmptyLoading ? 25 : 3}\n            />\n          }\n          hasMore={hasMore}\n          onLoadMore={onLoadMore}\n          viewportConfig={viewportConfig}>\n          {collectionChildrenFunc}\n        </LoadMoreCollection>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport { Text } from '../UNSAFE_Text';\nimport {\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { tableHeaderSortContainerStyles } from './themes/Table.css';\nimport { TableHeaderCellVariantOptions } from './themes/TableHeaderCellStyles.css';\nimport { TableHeaderCellRedwoodTheme } from './themes/redwood/TableHeaderCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { EmbeddedIconButton } from '../PRIVATE_EmbeddedIconButton';\nimport { SortAscendingIcon } from '../PRIVATE_ThemedIcons/SortAscendingIcon';\nimport { SortDefaultIcon } from '../PRIVATE_ThemedIcons/SortDefaultIcon';\nimport { SortDescendingIcon } from '../PRIVATE_ThemedIcons/SortDescendingIcon';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isFocusRingVisible: boolean;\n  isTabbable: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  headerText?: string;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isFocusRingVisible,\n  isTabbable,\n  headerText,\n  stickyColumn = 'none',\n  renderer,\n  onSelectionChange,\n  sortable = 'disabled',\n  sortDirection,\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableHeaderCellProps<K, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const hasRenderer = renderer != null;\n  const { classes: themeClasses } = useComponentTheme<TableHeaderCellVariantOptions>(\n    TableHeaderCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderStartSpacer:\n        !(isPreviousSelected || isSelected) && (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      columnSelectable: isColumnSelectable ? 'isColumnSelectable' : 'notColumnSelectable',\n      columnSelected: isSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      focusRingVisible: isFocusRingVisible ? 'isFocusRingVisible' : 'notFocusRingVisible',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else if (selectedRowKeys.all) {\n    selectorAllState = 'partial-all';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        { value: { row: detail.value, column: selectedColumnKeys }, target: detail.target },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const sortIconRenderer =\n    sortable === 'enabled' || sortDirection != null\n      ? () => (\n          <EmbeddedIconButton\n            aria-label={\n              sortable === 'enabled'\n                ? translations.collection_sortEnabled()\n                : translations.collection_sortDisabled()\n            }\n            isDisabled={sortable !== 'enabled'}\n            onAction={handleSortGesture}>\n            {sortDirection === 'ascending' ? (\n              <SortAscendingIcon />\n            ) : sortDirection === 'descending' ? (\n              <SortDescendingIcon />\n            ) : (\n              <SortDefaultIcon />\n            )}\n          </EmbeddedIconButton>\n        )\n      : undefined;\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    sortControl: sortIconRenderer\n  };\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortControl }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <Text overflowWrap=\"breakWord\" lineClamp={3} variant=\"primary\" size=\"md\">\n            {headerText}\n          </Text>\n        ) : null;\n      if (sortControl != null) {\n        return (\n          <div class={tableHeaderSortContainerStyles.base}>\n            {text}\n            {sortControl()}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <th\n      aria-colindex={columnIndex + 1}\n      {...getAriaSelected()}\n      {...getAriaSort()}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={'columnheader'}\n      data-oj-cell-type={'header'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-header-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}\n      {...(isColumnSelectable && interactionProps)}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        {getHeaderCellRenderer()(headerCellRendererProps)}\n      </TabbableModeContext.Provider>\n    </th>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { tableHeaderRowStyles, tableHeaderRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  containsTabbableCell: boolean;\n  focusedKey?: C;\n  showFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  columnsArray,\n  hasVerticalGridlines,\n  focusedKey,\n  showFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  containsTabbableCell,\n  onSelectionChange,\n  sortCriterion,\n  onSortCriterionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isResizeHover,\n  isRtl\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n  const containerClasses = classNames([tableHeaderRowContainerStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let isPreviousSelected = false;\n  return (\n    <thead class={containerClasses}>\n      <tr class={rowClasses} role={'row'} style={getStyle()} data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            selectedColumnKeys: selectedColumnKeys,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isFocusRingVisible: showFocusRing && columnKey === focusedKey && !containsTabbableCell,\n            isTabbable: columnKey === focusedKey && containsTabbableCell,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            onSelectionChange: onSelectionChange,\n            sortable: column.value.sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl\n          };\n          isPreviousSelected = isSelected;\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TableFooterCellVariantOptions } from './themes/TableFooterCellStyles.css';\nimport { TableFooterCellRedwoodTheme } from './themes/redwood/TableFooterCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isFocusRingVisible: boolean;\n  isTabbable: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  footerText?: string;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? (\n    <Text lineClamp={1} variant=\"primary\" size=\"md\">\n      {footerText}\n    </Text>\n  ) : null;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isFocusRingVisible,\n  isTabbable,\n  stickyColumn = 'none',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableFooterCellProps<C>) {\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const hasRenderer = renderer !== _defaultFooterCellRenderer;\n  const { classes: themeClasses } = useComponentTheme<TableFooterCellVariantOptions>(\n    TableFooterCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderStartSpacer:\n        !(isPreviousSelected || isSelected) && (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      columnSelectable: isColumnSelectable ? 'isColumnSelectable' : 'notColumnSelectable',\n      columnSelected: isSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      focusRingVisible: isFocusRingVisible ? 'isFocusRingVisible' : 'notFocusRingVisible',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  const footerCellRendererProps = { key: columnKey, footerText: footerText };\n\n  // TODO - make sure JAWS reads the aria-rowindex\n  // correctly - may need another div if not\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}\n      {...(isColumnSelectable && interactionProps)}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        {renderer(footerCellRendererProps)}\n      </TabbableModeContext.Provider>\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { tableFooterRowStyles, tableFooterRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  containsTabbableCell: boolean;\n  focusedKey?: C;\n  showFocusRing: boolean;\n  isRtl: boolean;\n  selectedKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  focusedKey,\n  showFocusRing,\n  selectedKeys,\n  isColumnSelectionEnabled,\n  containsTabbableCell,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n  const containerClasses = classNames([tableFooterRowContainerStyles.base]);\n\n  let isPreviousSelected = false;\n  return isRendered ? (\n    <tfoot class={containerClasses}>\n      <tr class={rowClasses} role={'row'} data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSelected = containsKey(selectedKeys, columnKey);\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isFocusRingVisible: showFocusRing && columnKey === focusedKey && !containsTabbableCell,\n            isTabbable: columnKey === focusedKey && containsTabbableCell,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl\n          };\n          isPreviousSelected = isSelected;\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;`\n        : `left:${position}px;cursor:col-resize;`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: HTMLElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = (element: HTMLElement) => {\n  return element.dataset['ojKeyType'] === 'number'\n    ? Number(element.dataset['ojKey'])\n    : element.dataset['ojKey'];\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = (root: HTMLElement, tableId: string, index: number) => {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > index) {\n      return getRowKey(rowElements[index] as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  root: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    const index = Array.prototype.indexOf.call(rowElements, rowElement);\n    if (index > -1) {\n      return index;\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(root: HTMLElement, tableId: string, rowKey: K) {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (let i = 0; i < rowElements.length; i++) {\n      if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = (element: HTMLElement) => {\n  return element.dataset['ojColumnKeyType'] === 'number'\n    ? Number(element.dataset['ojColumnKey'])\n    : element.dataset['ojColumnKey'];\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (root: HTMLElement, tableId: string, index: number) => {\n  if (root != null) {\n    const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    if (headerElements.length > index) {\n      return getColumnKey(headerElements[index] as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  root: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  if (root != null) {\n    const columnElements = root.querySelectorAll(\n      isHeader\n        ? `[data-oj-table-header-cell='${tableId}']`\n        : `[data-oj-table-footer-cell='${tableId}']`\n    );\n    const index = Array.prototype.indexOf.call(columnElements, cellElement);\n    if (index > -1) {\n      return index;\n    }\n  }\n  return null;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K, C>(\n  element: HTMLElement,\n  tableId: string,\n  cellSelector: string,\n  onlyAncestors?: boolean\n): Cell<K, C> | null {\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(cellSelector) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor(cellElement, `[data-oj-table-data-row='${tableId}']`) as K,\n          columnKey: getColumnKey(cellElement) as C,\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return {\n          columnKey: getColumnKey(cellElement) as C,\n          type: cellType\n        };\n      } else if (cellType === 'noData') {\n        return {\n          type: cellType\n        };\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  root: HTMLElement,\n  tableId: string,\n  cell: Cell<K, C>\n): HTMLElement | null {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = root.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return root.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  }\n  return null;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (root: HTMLElement, tableId: string) => {\n  const headerRowElement = root.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (root: HTMLElement, tableId: string) => {\n  const footerRowElement = root.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    const firstRowElement = root.querySelector(`[data-oj-table-data-row='${tableId}']`);\n    if (firstRowElement != null) {\n      return getRowKey(firstRowElement as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = (root: HTMLElement, tableId: string) => {\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement);\n  }\n  return null;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    const firstCellElement = root.querySelector(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (firstCellElement != null) {\n      const firstCellType = getCellType(firstCellElement);\n      if (firstCellType === 'header' || firstCellType === 'footer') {\n        return { columnKey: getColumnKey(firstCellElement), type: firstCellType };\n      } else if (firstCellType === 'noData') {\n        return { type: 'noData' };\n      }\n      return {\n        rowKey: getRowKey(firstCellElement),\n        columnKey: getColumnKey(firstCellElement),\n        type: 'data'\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    return root.querySelectorAll(`[data-oj-table-nodata-cell='${tableId}']`).length > 0;\n  }\n  return false;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    return root.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { TableColumn } from '../Table';\nimport { Cell, RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  data: D[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: Cell<K, C>\n) {\n  let rowKey;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(root, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor(targetElement, `[data-oj-table-data-row='${tableId}']`) as K;\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(root, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      const rowContext = {\n        key: rowKey,\n        data: data[rowIndex]\n      };\n      onRowAction({ context: rowContext, target: targetElement });\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a row action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      if (column.value.sortable === 'enabled') {\n        let sortDirection;\n        if (sortCriterion != null) {\n          for (const criterion of sortCriterion) {\n            if (criterion.key === column.key) {\n              sortDirection = criterion.sortDirection;\n              break;\n            }\n          }\n        }\n        const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n        onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n        return true;\n      }\n      break;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { Ref } from 'preact/hooks';\nimport { ScrollDetail, SizingInfo, TableColumn } from '../Table';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { ViewportConfig } from '../../hooks/UNSAFE_useViewportIntersect';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\nimport { tableCellStyles } from '../themes/TableCellStyles.css';\nimport { tableHeaderCellStyles } from '../themes/TableHeaderCellStyles.css';\nimport { tableFooterCellStyles } from '../themes/TableFooterCellStyles.css';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  scrollbarWidth: number,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && fullColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyStartColumns = getStickyColumnIndicies(columnsArray, true);\n    for (let i = 0; i < stickyStartColumns.length; i++) {\n      const stickyIndex = stickyStartColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n    const stickyEndColumns = getStickyColumnIndicies(columnsArray, false);\n    for (let i = stickyEndColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyEndColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  root: HTMLDivElement,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  const topOffset = getScrollerTopOffset(root, tableId);\n  const bottomOffset = getScrollerBottomOffset(root, tableId);\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    topOffset,\n    bottomOffset,\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    root,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  root.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(root, tableId, verticalScrollPosition);\n  root.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        root,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.stickyEdge !== 'start') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(root, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? root.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge !== 'start') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft < columnEnd) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? root.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex(root, tableId, 0) as K;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.rowKey = getRowKeyForRowIndex(root, tableId, i) as K;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  viewportConfig?: ViewportConfig\n) {\n  const scroller = viewportConfig?.scroller() || root;\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      root,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null) {\n      _scrollRowIntoView(\n        root,\n        tableId,\n        rowElement,\n        scroller,\n        sizingInfo.boxHeight! - sizingInfo.contentHeight!,\n        scrollDetail.locationY\n      );\n    }\n  }\n  const cellElement = getElementFromCell(root, tableId, scrollDetail.cell);\n  if (cellElement != null) {\n    _scrollColumnIntoView(\n      cellElement,\n      scroller,\n      columnsArray,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl,\n      fullColumnWidths,\n      scrollDetail.locationX\n    );\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  currentStickyEdgesRef: Ref<{ start?: number; end?: number }>,\n  isForce?: boolean\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n\n  const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n  for (let i = 0; i < stickyStartIndicies.length; i++) {\n    stickyIndex = stickyStartIndicies[i];\n    _applyStickyColumnOffset(root, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n  for (let i = stickyEndIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyEndIndicies[i];\n    _applyStickyColumnOffset(root, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n\n  updateStickyEdges(\n    root,\n    tableId,\n    isRtl,\n    columnsArray,\n    fullColumnWidths,\n    currentStickyEdgesRef,\n    undefined,\n    isForce\n  );\n}\n\n/**\n * Helper function to get the column indicies corresponding to the given edge.\n */\nexport const getStickyColumnIndicies = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isStart: boolean\n) => {\n  const stickyColumns = [];\n  const edge = isStart ? 'start' : 'end';\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge === edge) {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = root.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  currentStickyEdgesRef: Ref<{ start?: number; end?: number }>,\n  scrollLeft?: number,\n  isForce?: boolean\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      root,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n      for (i = 0; i < stickyStartIndicies.length; i++) {\n        const currentIndex = stickyStartIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n    _updateStickyEdge(root, tableId, isRtl, currentStickyEdgesRef, true, startIndex, isForce);\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = root.scrollWidth - root.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyEndIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    _updateStickyEdge(root, tableId, isRtl, currentStickyEdgesRef, false, endIndex, isForce);\n  }\n}\n\n/**\n * Helper function to update a specific sticky edge of the Table.\n */\nconst _updateStickyEdge = (\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  currentStickyEdgesRef: Ref<{ start?: number; end?: number }>,\n  isStart: boolean,\n  edgeIndex?: number,\n  isForce?: boolean\n) => {\n  if (currentStickyEdgesRef.current != null) {\n    const currentEdgeIndex = isStart\n      ? currentStickyEdgesRef.current.start\n      : currentStickyEdgesRef.current.end;\n    if (currentEdgeIndex !== edgeIndex || isForce) {\n      if (currentEdgeIndex != null) {\n        _addRemoveStickyEdgeStyle(root, tableId, isRtl, isStart, false, currentEdgeIndex);\n      }\n      if (edgeIndex != null) {\n        _addRemoveStickyEdgeStyle(root, tableId, isRtl, isStart, true, edgeIndex);\n      }\n      if (isStart) {\n        currentStickyEdgesRef.current.start = edgeIndex;\n      } else {\n        currentStickyEdgesRef.current.end = edgeIndex;\n      }\n    }\n  }\n};\n\n/**\n * Helper function to apply or remove edge styling from a specific column.\n */\nconst _addRemoveStickyEdgeStyle = (\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  isStart: boolean,\n  isAdd: boolean,\n  edgeIndex: number\n) => {\n  const isLeft = (isRtl && isStart) || (!isRtl && !isStart);\n  const modifierFunc = isAdd ? 'add' : 'remove';\n\n  const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[edgeIndex] as HTMLElement;\n  headerElement.classList[modifierFunc](\n    isLeft ? tableHeaderCellStyles.stickyEdgeLeft : tableHeaderCellStyles.stickyEdgeRight,\n    isStart ? tableHeaderCellStyles.stickyEdgeStart : tableHeaderCellStyles.stickyEdgeEnd\n  );\n\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[edgeIndex] as HTMLElement;\n    cellElement.classList[modifierFunc](\n      isLeft ? tableCellStyles.stickyEdgeLeft : tableCellStyles.stickyEdgeRight,\n      isStart ? tableCellStyles.stickyEdgeStart : tableCellStyles.stickyEdgeEnd\n    );\n  }\n\n  const footerElements = root.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[edgeIndex] as HTMLElement;\n    footerElement.classList[modifierFunc](\n      isLeft ? tableFooterCellStyles.stickyEdgeLeft : tableFooterCellStyles.stickyEdgeRight,\n      isStart ? tableFooterCellStyles.stickyEdgeStart : tableFooterCellStyles.stickyEdgeEnd\n    );\n  }\n};\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (\n  outerTableRef: RefObject<HTMLElement>,\n  config?: ViewportConfig\n) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return outerTableRef.current;\n      }\n    }\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SizingInfo, TableColumn } from '../Table';\nimport {\n  getCellType,\n  getFirstFocusableCell,\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  logicalCellExtractor,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport {\n  _getVerticalOverflowDiff,\n  applyScrollDetail,\n  getVerticalScrollPosition\n} from './TableScrollUtils';\nimport { Cell, CurrentCellDetail } from '../../UNSAFE_TableView';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(cell1?: Cell<K, C> | null, cell2?: Cell<K, C> | null) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  return (\n    cell1?.rowKey === cell2?.rowKey &&\n    cell1?.columnKey === cell2?.columnKey &&\n    cell1?.type === cell2?.type\n  );\n}\n\n/**\n * Helper function to handle focus somewhere in the Table.\n */\nexport function handleElementFocus<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  targetElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  pendingCurrentCellRef: MutableRef<Cell<K, C> | undefined>,\n  blurFromWindowRef: MutableRef<boolean>,\n  pendingSelectionExtensionRef: MutableRef<boolean>,\n  isRtl: boolean,\n  currentCell?: Cell<K, C>,\n  onCurrentCellChange?: (detail: CurrentCellDetail<K, C>) => void,\n  fullColumnWidths?: number[]\n) {\n  // don't scroll current into view if previous blur was due to window focus loss\n  const scrollCurrentIntoView = !blurFromWindowRef.current;\n  blurFromWindowRef.current = false;\n\n  if (root === targetElement) {\n    // handle overall root element receiving focus\n    if (pendingCurrentCellRef.current == null && !pendingSelectionExtensionRef.current) {\n      if (currentCell == null) {\n        if (onCurrentCellChange != null) {\n          const firstCell = getFirstFocusableCell(root, tableId) as Cell<K, C>;\n          if (firstCell != null) {\n            onCurrentCellChange({ value: firstCell as Cell<K, C> });\n            if (scrollCurrentIntoView) {\n              // scroll currentCell into view if focus is not due to pointer down\n              applyScrollDetail(\n                root,\n                tableId,\n                columnsArray,\n                sizingInfoRef.current,\n                { cell: firstCell, locationX: 'inView', locationY: 'inView' },\n                isRtl,\n                fullColumnWidths\n              );\n            }\n          }\n        }\n      } else if (scrollCurrentIntoView) {\n        // scroll currentCell into view if focus is not due to pointer down\n        applyScrollDetail(\n          root,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: currentCell, locationX: 'inView', locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n    pendingCurrentCellRef.current = undefined;\n  } else if (getCellType(targetElement) != null) {\n    // handle individual focusable regions receiving focus\n    if (!pendingSelectionExtensionRef.current && onCurrentCellChange != null) {\n      const cell = logicalCellExtractor(\n        targetElement,\n        tableId,\n        `[data-oj-table-focusable='${tableId}']`\n      ) as Cell<K, C>;\n      if (!cellComparator(currentCell, cell)) {\n        pendingCurrentCellRef.current = cell;\n        onCurrentCellChange({ value: cell });\n      }\n      // scroll currentCell into view if focus is not due to pointer down\n      if (currentCell != null && pendingCurrentCellRef.current == null && scrollCurrentIntoView) {\n        applyScrollDetail(\n          root,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: currentCell, locationX: 'inView', locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n    // move focus to the overall root element\n    root.focus({ preventScroll: true });\n  }\n}\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: Cell<K, C>,\n  onCurrentCellChange: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const columnKey = initialCell.columnKey;\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        root,\n        currentRowKey as string | number,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        if (adjacentRowElement != null) {\n          const rowKey = getRowKey(adjacentRowElement) as K;\n          if (rowKey != null) {\n            newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n            onCurrentCellChange({ value: newCurrentCell });\n          }\n        } else if (isPrevious) {\n          newCurrentCell = { columnKey: initialCell.columnKey, type: 'header' } as Cell<K, C>;\n          onCurrentCellChange({ value: newCurrentCell });\n        } else if (hasFooterCells(root, tableId)) {\n          newCurrentCell = { columnKey: initialCell.columnKey, type: 'footer' } as Cell<K, C>;\n          onCurrentCellChange({ value: newCurrentCell });\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey(root, tableId) as K;\n      if (rowKey != null) {\n        newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      } else if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = { type: 'noData' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      } else if (hasFooterCells(root, tableId)) {\n        newCurrentCell = { columnKey: initialCell.columnKey, type: 'footer' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      const rowKey = getLastFocusableRowKey(root, tableId) as K;\n      if (rowKey != null) {\n        newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      } else if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = { type: 'noData' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: initialCell.columnKey, type: 'header' } as Cell<K, C>;\n        onCurrentCellChange({ value: newCurrentCell });\n      }\n    }\n  } else {\n    const newColumnKey = _getBoundaryColumnKey(columnsArray, true);\n    if (isPrevious) {\n      newCurrentCell = { columnKey: newColumnKey, type: 'header' } as Cell<K, C>;\n      onCurrentCellChange({ value: newCurrentCell });\n    } else if (hasFooterCells(root, tableId)) {\n      newCurrentCell = { columnKey: newColumnKey, type: 'footer' } as Cell<K, C>;\n      onCurrentCellChange({ value: newCurrentCell });\n    }\n  }\n  // scroll 'current' element into view\n  if (newCurrentCell != null) {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: newCurrentCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  } else {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: initialCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  }\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: Cell<K, C>,\n  onCurrentCellChange: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    const verticalScrollPosition = getVerticalScrollPosition(root, tableId);\n    const verticalRowIndex = getRowIndexForRowKey(root, tableId, verticalScrollPosition.rowKey!);\n    let targetRowIndex;\n    if (isPrevious) {\n      if (verticalScrollPosition.offsetY === 0) {\n        targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n      } else {\n        targetRowIndex = verticalRowIndex!;\n      }\n    } else {\n      const scrollerRect = root.getBoundingClientRect();\n      const scrollbarHeight =\n        sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n      const scrollerBottom =\n        scrollerRect.bottom + getScrollerBottomOffset(root, tableId) + scrollbarHeight;\n      targetRowIndex = verticalRowIndex!;\n      while (rowElements.length > targetRowIndex + 1) {\n        targetRowIndex += 1;\n        const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n        if (elementBottom > scrollerBottom) {\n          break;\n        }\n      }\n    }\n    const newRowKey = getRowKeyForRowIndex(root, tableId, targetRowIndex) as K;\n    if (newRowKey != null) {\n      const newCurrentCell = {\n        rowKey: newRowKey,\n        columnKey: initialCell.columnKey,\n        type: 'data'\n      } as Cell<K, C>;\n      if (newRowKey !== initialCell.rowKey) {\n        onCurrentCellChange({ value: newCurrentCell });\n      }\n      applyScrollDetail(\n        root,\n        tableId,\n        columnsArray,\n        sizingInfoRef.current,\n        { cell: newCurrentCell, locationX: 'inView', locationY: isPrevious ? 'bottom' : 'top' },\n        isRtl,\n        fullColumnWidths\n      );\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return null;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: Cell<K, C>,\n  onCurrentCellChange: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCurrentCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onCurrentCellChange({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: newKey, type: cellType };\n        onCurrentCellChange({ value: newCurrentCell });\n      }\n    }\n  }\n  // scroll 'current' element into view\n  if (newCurrentCell != null) {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: newCurrentCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  } else {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: initialCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  }\n}\n\n/**\n * Helper function to get the first or last column key.\n */\nfunction _getBoundaryColumnKey<K, D, C>(columnsArray: TableColumn<K, D, C>[], isFirst: boolean) {\n  if (isFirst) {\n    return columnsArray[0].key;\n  }\n  return columnsArray[columnsArray.length - 1].key;\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: Cell<K, C>,\n  onCurrentCellChange: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  includeRows: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getBoundaryColumnKey(columnsArray, isPrevious);\n    if (includeRows) {\n      if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = {\n          type: 'noData'\n        } as Cell<K, C>;\n        if (!cellComparator(newCurrentCell, initialCell)) {\n          onCurrentCellChange({ value: newCurrentCell });\n        }\n      } else {\n        const newRowKey = isPrevious\n          ? (getFirstFocusableRowKey(root, tableId) as K)\n          : (getLastFocusableRowKey(root, tableId) as K);\n        if (newRowKey != null) {\n          newCurrentCell = {\n            rowKey: newRowKey,\n            columnKey: newKey,\n            type: 'data'\n          } as Cell<K, C>;\n          if (!cellComparator(newCurrentCell, initialCell)) {\n            onCurrentCellChange({ value: newCurrentCell });\n          }\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCurrentCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onCurrentCellChange({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: newKey, type: cellType };\n        onCurrentCellChange({ value: newCurrentCell });\n      }\n    }\n  }\n  // scroll 'current' element into view\n  if (newCurrentCell != null) {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: newCurrentCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  } else {\n    applyScrollDetail(\n      root,\n      tableId,\n      columnsArray,\n      sizingInfoRef.current,\n      { cell: initialCell, locationX: 'inView', locationY: 'inView' },\n      isRtl,\n      fullColumnWidths\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { SizingInfo, TableColumn } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { applyScrollDetail } from './TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { Cell, TableSelectionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  target: HTMLElement,\n  isMultiSelectGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor(target, `[data-oj-table-data-row='${tableId}']`) as K;\n  if (newRowKey != null) {\n    if (selectionMode?.row === 'single' || selectionMode?.row === 'multiple') {\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectGesture && selectionMode.row === 'multiple') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = target.closest(`[data-oj-table-focusable='${tableId}']`) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          root,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isMultiSelectGesture && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isMultiSelectGesture) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: target },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  target: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple') {\n      selectedRows = emptyKeys as Keys<K>;\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex(root, tableId, i) as K;\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex(root, tableId, i) as K;\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: target },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  target: HTMLElement,\n  currentCell: Cell<K, C>,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode }\n) {\n  const targetCell = logicalCellExtractor(\n    target,\n    tableId,\n    `[data-oj-table-focusable='${tableId}']`\n  ) as Cell<K, C>;\n  if (\n    ((selectionMode?.row === 'multiple' && currentCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (currentCell.type === 'header' || currentCell.type === 'footer'))) &&\n    targetCell?.type === currentCell.type\n  ) {\n    const currentCellElement = getElementFromCell(root, tableId, currentCell);\n    const targetCellElement = getElementFromCell(root, tableId, targetCell);\n    if (currentCellElement != null && targetCellElement != null) {\n      const isRow = targetCell?.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            root,\n            tableId,\n            currentCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(root, tableId, targetCellElement.parentElement as HTMLElement) !=\n            null\n        );\n      } else if (targetCell?.type === 'header' || targetCell?.type === 'footer') {\n        const isHeader = targetCell?.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(root, tableId, currentCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(root, tableId, targetCellElement, isHeader) != null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  target: HTMLElement,\n  currentCell: Cell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor(\n    target,\n    tableId,\n    `[data-oj-table-focusable='${tableId}']`\n  ) as Cell<K, C>;\n  const currentCellElement = getElementFromCell(root, tableId, currentCell);\n  const targetCellElement = getElementFromCell(root, tableId, targetCell);\n  if (currentCellElement != null && targetCellElement != null) {\n    if (\n      ((selectionMode?.row === 'multiple' && targetCell?.type === 'data') ||\n        (selectionMode?.column === 'multiple' &&\n          (targetCell?.type === 'header' || targetCell?.type === 'footer'))) &&\n      targetCell?.type === currentCell.type\n    ) {\n      let startIndex;\n      let endIndex;\n      let endElement;\n      const isRow = targetCell?.type === 'data';\n      if (isRow) {\n        endElement = targetCellElement.parentElement as HTMLElement;\n        startIndex = getRowIndexForRowElement(\n          root,\n          tableId,\n          currentCellElement.parentElement as HTMLElement\n        );\n        endIndex = getRowIndexForRowElement(root, tableId, endElement);\n      } else if (targetCell?.type === 'header' || targetCell?.type === 'footer') {\n        const isHeader = targetCell?.type === 'header';\n        endElement = targetCellElement;\n        startIndex = getColumnIndexForHeaderFooterElement(\n          root,\n          tableId,\n          currentCellElement,\n          isHeader\n        );\n        endIndex = getColumnIndexForHeaderFooterElement(root, tableId, targetCellElement, isHeader);\n      }\n      if (startIndex != null && endIndex != null) {\n        selectionExtensionElementRef.current = endElement;\n        _applyRangeSelection(\n          root,\n          tableId,\n          columnsArray,\n          target,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          selectionMode,\n          selected\n        );\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  target: HTMLElement,\n  isPrevious: boolean,\n  currentCell: Cell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const currentCellElement = getElementFromCell(root, tableId, currentCell);\n  if (currentCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isRow = currentCell.type === 'data';\n    const isHeader = currentCell.type === 'header';\n    if (isRow) {\n      startElement = currentCellElement.parentElement as HTMLElement;\n      startIndex = getRowIndexForRowElement(root, tableId, startElement);\n    } else {\n      startElement = currentCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(root, tableId, startElement, isHeader);\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let extendedElement;\n      const cursorElement = selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          root,\n          tableId,\n          columnsArray,\n          target,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          selectionMode,\n          selected\n        );\n      }\n\n      // scroll 'extensionElement' into view\n      const extensionElement =\n        selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : currentCellElement;\n      let extensionCell;\n      if (isRow) {\n        const rowKey = keyExtractor(extensionElement, `[data-oj-table-data-row='${tableId}']`) as K;\n        extensionCell = {\n          type: currentCell.type,\n          rowKey: rowKey,\n          columnKey: currentCell.columnKey\n        };\n      } else {\n        extensionCell = logicalCellExtractor(\n          extensionElement,\n          tableId,\n          `[data-oj-table-focusable='${tableId}']`\n        ) as Cell<K, C>;\n      }\n      applyScrollDetail(\n        root,\n        tableId,\n        columnsArray,\n        sizingInfoRef.current,\n        { cell: extensionCell, locationX: 'inView', locationY: 'inView' },\n        isRtl,\n        fullColumnWidths\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizeDetail, ColumnWidths } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(root, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (fullColumnWidths != null) {\n    if (resizeInfoRef.current.key == null) {\n      _updateResizingState(root, tableId, event, columnsArray, resizeInfoRef, isRtl);\n    }\n    if (resizeInfoRef.current.key != null) {\n      const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        const resizeColumnWidths = [];\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          const columnWidth = fullColumnWidths[i];\n          resizeColumnWidths.push(columnWidth as number);\n        }\n        resizeInfoRef.current = {\n          isResizing: true,\n          isResizeHover: true,\n          key: resizeInfoRef.current.key,\n          startX: pointerX,\n          delta: 0,\n          fullColumnWidths: resizeColumnWidths,\n          ignoreClick: resizeInfoRef.current.ignoreClick\n        };\n        if (onColumnResizing != null) {\n          onColumnResizing({\n            key: resizeInfoRef.current.key,\n            delta: 0,\n            allColumnWidths: appliedColumnWidths\n          });\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = root.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing && fullColumnWidths != null) {\n    const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n    if (innerTable != null) {\n      const rect = innerTable.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      // handle resize move operation\n      if (onColumnResizing != null) {\n        onColumnResizing({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const resizeColumnWidths = [];\n      for (const columnWidth of resizeInfoRef.current.fullColumnWidths) {\n        resizeColumnWidths.push(columnWidth);\n      }\n      const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n        onColumnResize({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  root: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = root.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      root,\n      tableId,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useMemo, useRef, MutableRef, Ref } from 'preact/hooks';\nimport { useCollectionFocusRing } from '../../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../../hooks/PRIVATE_useTabbableModeSet';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { ColumnResizeInfo, SizingInfo, TableColumn } from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell, logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  cellComparator,\n  handleElementFocus,\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableFocusUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  handleExtendSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport { updateStickyEdges } from '../utils/TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  tableId: string;\n  data: D[] | null;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths: ColumnWidths<C>;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  currentStickyEdgesRef: Ref<{ start?: number; end?: number }>;\n  cellHasRenderer: (currentCell: Cell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCell?: Cell<K, C>;\n  onCurrentCellChange?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  outerTableRef,\n  tableId,\n  data,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  sizingInfoRef,\n  resizeInfoRef,\n  currentStickyEdgesRef,\n  cellHasRenderer,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  currentCell,\n  onCurrentCellChange,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange\n}: UseInteractionManagerOptions<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // the logical cell targeted via focus that should become 'current'\n  const pendingCurrentCellRef = useRef<Cell<K, C>>();\n\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // tracks whether the most recent 'click' gesture is part of a selection extension gesture\n  const pendingSelectionExtensionRef = useRef<boolean>(false);\n\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onCurrentCellChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableCurrentCellChange = useMemo(() => {\n    return onCurrentCellChange != null\n      ? (detail: CurrentCellDetail<K, C>) => {\n          pendingSelectionExtensionRef.current = false;\n          selectionExtensionElementRef.current = undefined;\n          onCurrentCellChange(detail);\n        }\n      : undefined;\n  }, [onCurrentCellChange]);\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            pendingSelectionExtensionRef.current = false;\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup tabbable mode tracking using the shared useTabbableModeSet hook\n  const [isCurrentTabbableCell, tabbableModeProps, getCurrentTabbableCell, setCurrentTabbableCell] =\n    useTabbableModeSet(\n      outerTableRef,\n      (element: HTMLElement) => {\n        return logicalCellExtractor(\n          element,\n          tableId,\n          `[data-oj-table-focusable='${tableId}']`,\n          true\n        ) as Cell<K, C>;\n      },\n      currentCell,\n      onTableCurrentCellChange,\n      cellHasRenderer,\n      cellComparator\n    );\n  const isTabbable = !isCurrentTabbableCell(undefined);\n\n  // setup focus ring management using the shared useCollectionFocusRing hook\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(outerTableRef, [\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'PageUp',\n    'PageDown',\n    'Home',\n    'End'\n  ]);\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _blurHandler = useCallback((event: FocusEvent) => {\n    blurFromWindowRef.current = event.relatedTarget == null;\n  }, []);\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'current'.\n  // If a 'current' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'current'.\n  const _focusHandler = useCallback(\n    (event: FocusEvent) => {\n      const targetElement = event.target as HTMLElement;\n      if (outerTableRef.current != null && targetElement != null) {\n        handleElementFocus(\n          outerTableRef.current,\n          tableId,\n          targetElement,\n          columnsArray,\n          sizingInfoRef,\n          pendingCurrentCellRef,\n          blurFromWindowRef,\n          pendingSelectionExtensionRef,\n          isRtl,\n          currentCell,\n          onTableCurrentCellChange,\n          fullColumnWidths\n        );\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      currentCell,\n      onTableCurrentCellChange,\n      fullColumnWidths\n    ]\n  );\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null && onColumnResizing != null) {\n        if (!resizeInfoRef.current.isResizing) {\n          handleOverResizeRegionGesture(\n            outerTableRef.current,\n            tableId,\n            event,\n            columnsArray,\n            resizeInfoRef,\n            isRtl\n          );\n        } else {\n          handleColumnResizingGesture(\n            outerTableRef.current,\n            tableId,\n            event,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          );\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        let isSelectionExtension = false;\n        const target = event.target as HTMLElement;\n        if (onTableSelectionChange != null) {\n          if (currentCell != null && event.shiftKey) {\n            isSelectionExtension = isRangeSelectionGesture(\n              outerTableRef.current,\n              tableId,\n              target,\n              currentCell,\n              selectionMode\n            );\n            pendingSelectionExtensionRef.current = isSelectionExtension;\n          }\n        }\n        if (!isSelectionExtension) {\n          if (\n            handleColumnResizeStartGesture(\n              outerTableRef.current,\n              tableId,\n              event,\n              columnsArray,\n              appliedColumnWidths,\n              resizeInfoRef,\n              isRtl,\n              fullColumnWidths,\n              onColumnResizing\n            )\n          ) {\n            resizeInfoRef.current.ignoreClick = true;\n          }\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      currentCell,\n      selectionMode,\n      onTableSelectionChange,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleColumnResizeEndGesture(\n          outerTableRef.current,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [outerTableRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (_event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleLeaveResizingGesture(outerTableRef.current, tableId, resizeInfoRef);\n      }\n    },\n    [outerTableRef, tableId, resizeInfoRef]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleEnterResizingGesture(\n          outerTableRef.current,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [outerTableRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted.\n  const _clickHandler = useCallback(\n    (event: MouseEvent) => {\n      let isSelectionExtension = false;\n      const platform = getClientHints().platform;\n      const target = event.target as HTMLElement;\n      if (outerTableRef.current != null) {\n        if (onTableSelectionChange != null && !resizeInfoRef.current.ignoreClick) {\n          if (currentCell != null && event.shiftKey) {\n            isSelectionExtension = handleRangeSelectionGesture(\n              outerTableRef.current,\n              tableId,\n              columnsArray,\n              target,\n              currentCell,\n              selectionExtensionElementRef,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n          if (!isSelectionExtension) {\n            handleSelectionGesture(\n              outerTableRef.current,\n              tableId,\n              columnsArray,\n              target,\n              (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n        }\n        if (\n          onRowAction != null &&\n          data != null &&\n          handleRowActionGesture(outerTableRef.current, tableId, data, onRowAction, target)\n        ) {\n          event.stopPropagation();\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      data,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      currentCell,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const platform = getClientHints().platform;\n      const keyHandlers: Record<string, (root: HTMLDivElement) => void> = {\n        ' ': function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (currentCell != null) {\n              if (!isTabbable && onTableSelectionChange != null) {\n                handleSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  getElementFromCell(root, tableId, currentCell) as HTMLElement,\n                  true,\n                  onTableSelectionChange,\n                  selectionMode,\n                  selected\n                );\n              }\n              if (\n                onRowAction != null &&\n                data != null &&\n                handleRowActionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  data,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  currentCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        Enter: function () {\n          if (outerTableRef.current != null) {\n            if (currentCell != null) {\n              if (\n                onRowAction != null &&\n                data != null &&\n                currentCell.type === 'data' &&\n                handleRowActionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  data,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  currentCell\n                )\n              ) {\n                event.stopPropagation();\n              } else if (\n                !isTabbable &&\n                onSortCriterionChange != null &&\n                currentCell.type === 'header' &&\n                handleSortActionGesture(\n                  columnsArray,\n                  currentCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        ArrowUp: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n              if (\n                currentCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  true,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  currentCell,\n                  onTableCurrentCellChange,\n                  true,\n                  isRtl,\n                  fullColumnWidths\n                );\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        ArrowDown: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n              if (\n                currentCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  false,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  currentCell,\n                  onTableCurrentCellChange,\n                  false,\n                  isRtl,\n                  fullColumnWidths\n                );\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        ArrowLeft: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n              if (\n                (currentCell.type === 'header' || currentCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  true,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  currentCell,\n                  onTableCurrentCellChange,\n                  !isRtl,\n                  isRtl,\n                  fullColumnWidths\n                );\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        ArrowRight: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n              if (\n                (currentCell.type === 'header' || currentCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  false,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  currentCell,\n                  onTableCurrentCellChange,\n                  isRtl,\n                  isRtl,\n                  fullColumnWidths\n                );\n              }\n            }\n            event.preventDefault();\n          }\n        },\n        PageUp: function (root: HTMLDivElement) {\n          if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n            handlePageRowGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onTableCurrentCellChange,\n              true,\n              isRtl,\n              fullColumnWidths\n            );\n          }\n          event.preventDefault();\n        },\n        PageDown: function (root: HTMLDivElement) {\n          if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n            handlePageRowGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onTableCurrentCellChange,\n              false,\n              isRtl,\n              fullColumnWidths\n            );\n          }\n          event.preventDefault();\n        },\n        Home: function (root: HTMLDivElement) {\n          if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n            handleJumpColumnGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onTableCurrentCellChange,\n              true,\n              platform === 'mac' ? event.metaKey : event.ctrlKey,\n              isRtl,\n              fullColumnWidths\n            );\n          }\n          event.preventDefault();\n        },\n        End: function (root: HTMLDivElement) {\n          if (!isTabbable && currentCell != null && onTableCurrentCellChange != null) {\n            handleJumpColumnGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onTableCurrentCellChange,\n              false,\n              platform === 'mac' ? event.metaKey : event.ctrlKey,\n              isRtl,\n              fullColumnWidths\n            );\n          }\n          event.preventDefault();\n        }\n      };\n      if (Object.keys(keyHandlers).includes(event.key) && outerTableRef.current != null) {\n        keyHandlers[event.key](outerTableRef.current);\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      data,\n      isRtl,\n      isTabbable,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      fullColumnWidths,\n      currentCell,\n      onTableCurrentCellChange,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange\n    ]\n  );\n\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated.\n  const _scrollHandler = useCallback(() => {\n    if (outerTableRef.current != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        outerTableRef.current,\n        tableId,\n        isRtl,\n        columnsArray,\n        fullColumnWidths,\n        currentStickyEdgesRef,\n        outerTableRef.current.scrollLeft\n      );\n    }\n  }, [outerTableRef, tableId, isRtl, columnsArray, currentStickyEdgesRef, fullColumnWidths]);\n\n  const interactionManagerProps = mergeProps(tabbableModeProps, focusRingProps, {\n    onBlur: _blurHandler,\n    onFocus: _focusHandler,\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler,\n    onPointerUp: _pointerUpHandler,\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerEnter: _pointerEnterHandler,\n    onClick: _clickHandler,\n    onKeyDown: _keyDownHandler,\n    onScroll: _scrollHandler\n  });\n\n  return {\n    interactionManagerProps,\n    onTableSelectionChange,\n    showFocusRing,\n    isCurrentTabbableCell,\n    getCurrentTabbableCell,\n    setCurrentTabbableCell\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SampledWidths, TableColumn } from '../Table';\nimport { tableStyles } from '../themes/TableStyles.css';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function getLayoutColumnWidths<K, D, C extends string>(\n  outerTableElement: HTMLDivElement,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  if (isFixed) {\n    return _getFixedLayoutColumnWidths(availableWidth, columnsArray, staticColumnWidths);\n  }\n  let newColumnWidths = _getContentsLayoutColumnWidths(\n    outerTableElement,\n    tableId,\n    sampledColumnWidthsRef,\n    availableWidth,\n    columnsArray,\n    staticColumnWidths\n  );\n  if (availableWidth === -1) {\n    let totalWidth = 0;\n    const widthsArray = [];\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newColumnWidths[columnsArray[i].key];\n      widthsArray.push(width);\n      totalWidth += width;\n    }\n    // for content sizing, apply the new column widths immediately, and check to see\n    // if all space is actually utilized - this supports no width constraint scenarios\n    _udpateTableSizing(outerTableElement, tableId, widthsArray, totalWidth);\n    availableWidth = outerTableElement.scrollWidth;\n    if (Math.abs(totalWidth - availableWidth) > 1) {\n      newColumnWidths = _getContentsLayoutColumnWidths(\n        outerTableElement,\n        tableId,\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        staticColumnWidths\n      );\n    }\n  }\n  return newColumnWidths;\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnWidths<K, D, C extends string>(\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalWidth = 0;\n  let pendingTotalWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  const appliedColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalWidth += columnWidth;\n      pendingTotalWidth += columnWidth;\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray.push(columnWidth);\n      appliedColumnWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnWidthsArray.push(undefined);\n      newColumnWidthsArray.push(columnMinWidth);\n      appliedColumnWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalWidth < availableWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnWidths<K, D, C extends string>(\n  outerTableElement: HTMLDivElement,\n  tableId: string,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalWidth = 0;\n    let pendingTotalWidth = 0;\n    let totalPreferredWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledWidths = sampledColumnWidthsRef.current;\n    const sampledMinWidthsArray = [];\n    const sampledWeightWidthsArray = [] as number[];\n    const appliedColumnWidthsArray = [];\n    if (sampledWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinWidthsArray.push(sampledWidths.minWidths[columnsArray[i].key]);\n        sampledWeightWidthsArray.push(sampledWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      const headerElements = outerTableElement.querySelectorAll(\n        `[data-oj-table-header-cell='${tableId}']`\n      );\n      // when sampledColumnWidths are not populated, content wrapping is disabled in the table\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledWeightWidthsArray.push(sampledWeightWidth);\n        sampledColumnWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightWidth;\n      }\n      // re-enable wrapping, allowing measurements to represent minimum auto-resizable column widths\n      outerTableElement.classList.remove(tableStyles.disableWrapping);\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledMinWidthsArray.push(sampledMinWidth);\n        sampledColumnWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnWidth;\n        const sampledMinWidth = sampledMinWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinWidth) {\n          columnWidth = minWidth;\n        } else if (maxWidth != null && sampledMinWidth >= maxWidth) {\n          columnWidth = maxWidth;\n        } else {\n          columnWidth = sampledMinWidth;\n        }\n        pendingTotalWidth += columnWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightWidthsArray[i]\n            ? minWidth\n            : sampledWeightWidthsArray[i];\n        sampledWeightWidthsArray[i] = columnWeight;\n        totalPreferredWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnWidthsArray[i] = columnWidth;\n        appliedColumnWidthsArray.push(columnWidth);\n      } else {\n        forcedTotalWidth += forcedWidth;\n        pendingTotalWidth += forcedWidth;\n        totalPreferredWidth += forcedWidth;\n        appliedColumnWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableWidth === -1) {\n      availableWidth = totalPreferredWidth;\n    }\n    if (pendingTotalWidth < availableWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableWidth,\n        totalPreferredWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalWidth,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        sampledWeightWidthsArray,\n        columnMaxWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnWidthsArray: number[]\n) {\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = columnWidthsArray[i];\n  }\n  return columnWidths;\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _udpateTableSizing(\n  root: HTMLDivElement,\n  tableId: string,\n  widthsArray: number[],\n  totalWidth: number\n) {\n  const tableCols = root.querySelectorAll(`[data-oj-table-col='${tableId}']`);\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i] as HTMLTableColElement;\n    tableCol.style.width = `${widthsArray[i]}px`;\n  }\n  const innerTableElem = root.querySelectorAll(\n    `[data-oj-table-inner-table='${tableId}']`\n  )[0] as HTMLElement;\n  innerTableElem.style.width = `${totalWidth}px`;\n  innerTableElem.style.tableLayout = 'fixed';\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport {\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useRef,\n  useLayoutEffect,\n  useEffect,\n  useState\n} from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport {\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../utils/PRIVATE_collectionUtils';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport {\n  Cell,\n  Column,\n  ColumnWidths,\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition\n} from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { getElementFromCell } from './utils/TableDomUtils';\nimport { getLayoutColumnWidths } from './utils/TableLayoutUtils';\nimport {\n  getViewportConfig,\n  getHorizontalScrollPosition,\n  setHorizontalScrollPosition,\n  getVerticalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyColumns\n} from './utils/TableScrollUtils';\nimport { innerTableStyles, focusTrackerStyles } from './themes/Table.css';\nimport { TableVariantOptions, tableStyles } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { FocusableElement, getActiveElement, getBodyElement } from '../utils/PRIVATE_tabbableUtils';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    };\n\ntype LayoutInfo =\n  | {\n      isLayoutRequired: true;\n      columnWidthsArray?: number[];\n    }\n  | {\n      isLayoutRequired: false;\n      columnWidthsArray: number[];\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      fullColumnWidths?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      fullColumnWidths: number[];\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\n/**\n * Component that renders items as a flat table.\n * In order to maximize performance, only items that are visible in the viewport are rendered.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCell,\n    onCurrentCellChange,\n    currentRowVariant,\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const outerTableRef = useRef<HTMLDivElement>(null);\n  const sizingInfoRef = useRef<SizingInfo>({ isInitialRender: true });\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<ColumnWidths<C>>();\n  const [contentHeight, setContentHeight] = useState<number>();\n  const isVerticalScrollRef = useRef<boolean>(false);\n  const sampledColumnWidthsRef = useRef<SampledWidths<C>>();\n  const horizontalScrollPositionRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionRef = useRef<TableVerticalScrollPosition<K>>();\n\n  const currentStickyEdgesRef = useRef<{ start?: number; end?: number }>({\n    start: undefined,\n    end: undefined\n  });\n\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const testIdProps = useTestId(testId);\n\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [] as Array<TableColumn<K, D, C>>;\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  let isLayoutRequired = false;\n  const columnWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const appliedWidth = appliedColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (appliedWidth == null || (staticWidth != null && staticWidth !== appliedWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      columnWidthsArray.push(appliedWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n  const layoutInfo = {\n    isLayoutRequired: isLayoutRequired,\n    columnWidthsArray: isLayoutRequired ? undefined : columnWidthsArray\n  } as LayoutInfo;\n\n  useImperativeHandle(\n    ref!,\n    () => {\n      return {\n        getHorizontalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getHorizontalScrollPosition(\n            outerTableRef.current!,\n            columnsArray,\n            layoutInfo.columnWidthsArray\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition(outerTableRef.current!, tableId);\n        }\n      };\n    },\n    [tableId, columnsArray, layoutInfo.isLayoutRequired, layoutInfo.columnWidthsArray]\n  );\n\n  const cellHasRenderer = useCallback(\n    (currentCell: Cell<K, C>) => {\n      let hasRenderer = false;\n      if (currentCell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else {\n        for (const column of columnsArray) {\n          if (column.key === currentCell.columnKey) {\n            if (currentCell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (currentCell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (currentCell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const {\n    interactionManagerProps,\n    onTableSelectionChange,\n    showFocusRing,\n    isCurrentTabbableCell,\n    getCurrentTabbableCell,\n    setCurrentTabbableCell\n  } = useInteractionManager({\n    outerTableRef,\n    tableId,\n    data,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths: appliedColumnWidths!,\n    sizingInfoRef,\n    resizeInfoRef,\n    currentStickyEdgesRef,\n    cellHasRenderer,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    onColumnResizing,\n    onColumnResize,\n    currentCell,\n    onCurrentCellChange,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange\n  });\n\n  useEffect(() => {\n    // if focus was somehow dropped to the body during the render cycle - recapture focus here\n    if (\n      outerTableRef.current != null &&\n      getCurrentTabbableCell() != null &&\n      getActiveElement(outerTableRef.current) === getBodyElement(outerTableRef.current)\n    ) {\n      outerTableRef.current.focus({ preventScroll: true });\n    }\n  });\n\n  // ensure sampled column sizes are cleared if 'columns' is updated\n  useLayoutEffect(() => {\n    sampledColumnWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    const rootElement = outerTableRef.current;\n    if (\n      rootElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      layoutInfo.isLayoutRequired\n    ) {\n      const totalWidth =\n        layout === 'fixed'\n          ? sizingInfoRef.current.boxWidth - sizingInfoRef.current.defaultScrollbarWidth\n          : -1;\n      const newColumnWidths = getLayoutColumnWidths(\n        rootElement,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [tableId, columnsArray, columnWidths, layout, layoutInfo.isLayoutRequired]);\n\n  // setup component resize-based sizing calculation updates\n  const resizeObserverCallbackRef = useRef<(entry: ResizeObserverEntry) => void>();\n  resizeObserverCallbackRef.current = (entry: ResizeObserverEntry) => {\n    if (outerTableRef.current != null) {\n      let availableWidth;\n      const newContentWidth = entry.contentBoxSize[0].inlineSize;\n      const newContentHeight = entry.contentBoxSize[0].blockSize;\n      const newBoxWidth = entry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = entry.borderBoxSize[0].blockSize;\n\n      if (sizingInfoRef.current.isInitialRender) {\n        availableWidth = layout === 'fixed' ? newContentWidth : -1;\n        sizingInfoRef.current = {\n          isInitialRender: false,\n          contentWidth: newContentWidth,\n          boxWidth: newBoxWidth,\n          contentHeight: newContentHeight,\n          boxHeight: newBoxHeight,\n          defaultScrollbarWidth: newBoxWidth - newContentWidth,\n          defaultScrollbarHeight: newBoxHeight - newContentHeight\n        };\n      } else {\n        availableWidth = isVerticalScrollRef.current\n          ? newContentWidth\n          : newBoxWidth - sizingInfoRef.current.defaultScrollbarWidth;\n        sizingInfoRef.current.contentWidth = newContentWidth;\n        sizingInfoRef.current.boxWidth = newBoxWidth;\n        sizingInfoRef.current.contentHeight = newContentHeight;\n        sizingInfoRef.current.boxHeight = newBoxHeight;\n      }\n      const newColumnWidths = getLayoutColumnWidths(\n        outerTableRef.current,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n      if (contentHeight !== newContentHeight) {\n        setContentHeight(newContentHeight);\n      }\n    }\n  };\n  // ensure resize observer callback function is static to avoid hook re-subscribing each render\n  const staticResizeObserverCallback = useCallback((entry: ResizeObserverEntry) => {\n    resizeObserverCallbackRef.current!(entry);\n  }, []);\n  useResizeObserver({ ref: outerTableRef, callback: staticResizeObserverCallback });\n\n  // after each additional render, update vertical scrollbar state if necessary\n  useLayoutEffect(() => {\n    if (\n      outerTableRef.current != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      contentHeight != null\n    ) {\n      const innerTable = outerTableRef.current.querySelector(\n        `[data-oj-table-inner-table='${tableId}']`\n      );\n      if (innerTable != null) {\n        const hasVerticalOverflow = contentHeight < innerTable.getBoundingClientRect().height;\n        if (isVerticalScrollRef.current !== hasVerticalOverflow) {\n          isVerticalScrollRef.current = hasVerticalOverflow;\n          if (hasVerticalOverflow) {\n            outerTableRef.current.classList.remove(tableStyles.noVerticalScroll);\n            outerTableRef.current.classList.add(tableStyles.verticalScroll);\n          } else {\n            outerTableRef.current.classList.remove(tableStyles.verticalScroll);\n            outerTableRef.current.classList.add(tableStyles.noVerticalScroll);\n          }\n        }\n      }\n    }\n  }, [tableId, contentHeight, data, noDataRenderer, appliedColumnWidths]);\n\n  // update horizontal scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      horizontalScrollPositionRef.current !== horizontalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setHorizontalScrollPosition(\n        outerTableRef.current!,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        isRtl,\n        horizontalScrollPositionOverride\n      );\n      horizontalScrollPositionRef.current = horizontalScrollPositionOverride;\n    }\n  }, [\n    tableId,\n    columnsArray,\n    layoutInfo.isLayoutRequired,\n    layoutInfo.columnWidthsArray,\n    horizontalScrollPositionOverride,\n    isRtl\n  ]);\n\n  // update vertical scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      verticalScrollPositionRef.current !== verticalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setVerticalScrollPosition(outerTableRef.current!, tableId, verticalScrollPositionOverride);\n      verticalScrollPositionRef.current = verticalScrollPositionOverride;\n    }\n  }, [tableId, layoutInfo.isLayoutRequired, verticalScrollPositionOverride]);\n\n  // ensure sticky columns are updated appropriately\n  useLayoutEffect(() => {\n    if (outerTableRef.current != null && !layoutInfo.isLayoutRequired) {\n      updateStickyColumns(\n        outerTableRef.current,\n        tableId,\n        isRtl,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        currentStickyEdgesRef,\n        true\n      );\n    }\n  }, [tableId, columnsArray, layoutInfo.isLayoutRequired, layoutInfo.columnWidthsArray, isRtl]);\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    forceScroll: sizingInfoRef.current.isInitialRender ? 'isForceScroll' : 'notForceScroll',\n    verticalScroll: isVerticalScrollRef.current ? 'isVerticalScroll' : 'notVerticalScroll',\n    disableWrapping:\n      layout === 'contents' && sampledColumnWidthsRef.current === undefined\n        ? 'isDisableWrapping'\n        : 'notDisableWrapping'\n  });\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n  const focusTrackerClasses = classNames([focusTrackerStyles.base]);\n\n  // ensure aria-activedescendant is applied to the 'currentCell' at all times\n  useEffect(() => {\n    if (outerTableRef.current != null && currentCell != null) {\n      const cellElement = getElementFromCell(outerTableRef.current, tableId, currentCell);\n      if (cellElement != null) {\n        outerTableRef.current.setAttribute('aria-activedescendant', cellElement.id);\n      }\n    }\n  }, [tableId, currentCell]);\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = data == null ? undefined : hasMore ? -1 : data.length + (hasFooters ? 2 : 1);\n\n  const startStickyEdge = currentStickyEdgesRef.current?.start;\n  const endStickyEdge = currentStickyEdgesRef.current?.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' || selectionMode?.row === 'multiple';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n\n  const getTableBodyProps = () => {\n    return {\n      tableId: tableId,\n      data: data,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      currentCell: currentCell,\n      currentRowVariant: currentRowVariant,\n      getCurrentTabbableCell: getCurrentTabbableCell,\n      showFocusRing: showFocusRing,\n      getRowKey: getRowKey,\n      hasMore: hasMore,\n      onLoadMore: onLoadMore,\n      noDataRenderer: noDataRenderer,\n      viewportConfig: getViewportConfig(outerTableRef),\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!layoutInfo.isLayoutRequired) {\n      columnWidthsArray = layoutInfo.columnWidthsArray;\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    const tabbableCell = getCurrentTabbableCell();\n    const containsTabbableCell = tabbableCell?.type === 'header';\n    return {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      focusedKey: currentCell?.type === 'header' ? currentCell.columnKey : undefined,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      containsTabbableCell: containsTabbableCell,\n      onSelectionChange: onTableSelectionChange,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      showFocusRing: showFocusRing,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableFooterProps = () => {\n    const tabbableCell = getCurrentTabbableCell();\n    const containsTabbableCell = tabbableCell?.type === 'footer';\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      focusedKey: currentCell?.type === 'footer' ? currentCell.columnKey : undefined,\n      selectedKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      containsTabbableCell: containsTabbableCell,\n      showFocusRing: showFocusRing,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (columnResizingIndicator != null && !layoutInfo.isLayoutRequired) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += layoutInfo.columnWidthsArray[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    let widthString = '';\n    let heightString = '';\n    if (!layoutInfo.isLayoutRequired) {\n      let totalWidth = 0;\n      for (let i = 0; i < layoutInfo.columnWidthsArray.length; i++) {\n        totalWidth += layoutInfo.columnWidthsArray[i];\n      }\n      widthString = `width: ${totalWidth}px; table-layout: fixed;`;\n    } else {\n      // shrink table down as much as possible when a 'contents' layout is required, otherwise\n      // the sampled column widths will not reflect the true minimum sizes with line-clamping\n      widthString = layout !== 'contents' ? 'width: 100%;' : 'width: 1px';\n    }\n    if (contentHeight != null) {\n      heightString = data == null || data.length === 0 ? `min-height: ${contentHeight}px;` : '';\n    }\n    return `${widthString}${heightString}`;\n  };\n\n  const onStartTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      handleEnterActionableMode(\n        detail.hasFocusWithin,\n        detail.tabbableElements,\n        setCurrentTabbableCell\n      );\n    },\n    [setCurrentTabbableCell]\n  );\n\n  const onFocusStartEdge = useCallback(\n    (detail: { tabbableElements: FocusableElement[] }) => {\n      handleWrapActionableFocus(true, detail.tabbableElements, setCurrentTabbableCell);\n    },\n    [setCurrentTabbableCell]\n  );\n\n  const onFocusEndEdge = useCallback(\n    (detail: { tabbableElements: FocusableElement[] }) => {\n      handleWrapActionableFocus(false, detail.tabbableElements, setCurrentTabbableCell);\n    },\n    [setCurrentTabbableCell]\n  );\n\n  return (\n    <div\n      {...testIdProps}\n      ref={outerTableRef}\n      aria-colcount={columnsArray.length}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-rowcount={ariaRowCount}\n      {...(selectionMode?.column === 'multiple' || selectionMode?.row === 'multiple'\n        ? { 'aria-multiselectable': true }\n        : {})}\n      class={classes}\n      role={'grid'}\n      tabIndex={0}\n      {...interactionManagerProps}>\n      <FocusTracker\n        styleClass={focusTrackerClasses}\n        isDisabled={isCurrentTabbableCell(undefined)}\n        onFocusStartEdge={onFocusStartEdge}\n        onFocusEndEdge={onFocusEndEdge}\n        onStartTracking={onStartTracking}>\n        <table\n          class={tableClasses}\n          role={'presentation'}\n          style={getTableStyle()}\n          data-oj-table-inner-table={tableId}>\n          <TableColGroup {...getTableColGroupProps()} />\n          <TableHeader {...getTableHeaderProps()} />\n          <TableBody {...getTableBodyProps()} />\n          <TableFooter {...getTableFooterProps()} />\n        </table>\n        {getTableDragIndicator()}\n      </FocusTracker>\n    </div>\n  );\n});\n"],"names":["TableColGroup","tableId","columnWidthsArray","getColStyle","columnWidth","_jsx","map","jsx","style","_timerValue","TableSkeletonRow","colspan","preactKey","minimumCount","isVisible","setIsVisible","useState","useEffect","setTimeout","cellClasses","classNames","tableSkeletonCellStyles","base","class","LOADMORE_STYLE_CLASS","children","colSpan","role","Array","_element","tableSkeletonBarContainerStyles","Skeleton","height","_defaultCellRenderer","rowData","field","Text","overflowWrap","lineClamp","variant","size","String","TableCell","columnKey","columnIndex","rowKey","rowIndex","isFinalRowIndex","isFinalColumnIndex","hasVerticalGridlines","hasHorizontalGridlines","isRowSelected","isPreviousRowSelected","isColumnSelected","isPreviousColumnSelected","isFocusRingVisible","isTabbable","isRowHeader","stickyColumn","renderer","selectorRenderer","isRowSelectionEnabled","isRowSingleSelection","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","isStickyStartEdge","isStickyEndEdge","isRtl","hasRenderer","classes","themeClasses","useComponentTheme","TableCellRedwoodTheme","defaultRenderer","firstRow","lastRow","firstColumn","lastColumn","borderTopSpacer","borderBottomSpacer","borderStartSpacer","borderEndSpacer","verticalGrid","horizontalGrid","rowSingleSelection","rowSelectable","rowSelected","previousRowSelected","columnSelected","previousColumnSelected","stickyStartColumn","stickyEndColumn","stickyStartEdge","stickyEndEdge","rowHighlight","focusRingVisible","active","hover","pseudoHover","rtl","cellRendererProps","selector","id","useId","tabIndex","TabbableModeContext","Provider","value","MemoizeTableRow","memo","isFinalRow","columnsArray","rowHeaderColumnKeys","isSelected","isPreviousSelected","isSingleRowSelectionEnabled","showFocusRing","containsTabbableCell","selectedRowKeys","all","keys","Set","focusedColumnKey","selectedColumnKeys","onSelectionChange","startStickyEdge","endStickyEdge","translations","useTranslationBundle","interactionProps","useInteractionStyle","TableRowRedwoodTheme","handleRowSelectorChange","detail","row","column","target","accessibleRowName","toString","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","undefined","key","containsKey","cellProps","stickyEdge","length","has","prev","next","columnsArray1","columnsArray2","i","_areColumnsArraysEquivalent","horizontalGridlines","verticalGridlines","set1","set2","every","x","TableNoData","columnsCount","rowClasses","tableRowStyles","TableNoDataRedwoodTheme","contentRenderer","collection_noData","TableBody","getAccessibleRowHeaders","data","getCurrentTabbableCell","getRowKey","hasMore","onLoadMore","viewportConfig","currentCell","currentRowVariant","selected","noDataRenderer","loadIndicatorKeyRef","useRef","Date","getTime","isShowEmptyLoadingRef","collectionClasses","collectionStyles","getRowContext","useCallback","context","index","collectionData","d","metadata","isShowEmptyLoading","isShowNoData","current","tabbableCell","type","getNoDataProps","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsCurrentCell","rowShowsFocusRing","rowProps","TableHeaderCell","isColumnSelectable","headerText","sortable","sortDirection","onSortCriterionChange","TableHeaderCellRedwoodTheme","columnSelectable","selectorAllState","isSameKey","deletedKeys","handleSelectorChange","headerCellRendererProps","SelectorAll","collection_selectAllRows","sortControl","EmbeddedIconButton","collection_sortEnabled","collection_sortDisabled","isDisabled","onAction","handleSortGesture","SortAscendingIcon","SortDescendingIcon","SortDefaultIcon","SvgChevronUpDown","getHeaderCellRenderer","text","_jsxs","tableHeaderSortContainerStyles","getAriaSort","TableHeader","focusedKey","isColumnSelectionEnabled","sortCriterion","isResizeHover","tableHeaderRowStyles","containerClasses","tableHeaderRowContainerStyles","criterion","headerCellProps","selectable","headerRenderer","_defaultFooterCellRenderer","footerText","TableFooterCell","TableFooterCellRedwoodTheme","footerCellRendererProps","TableFooter","isRendered","tableFooterRowStyles","tableFooterRowContainerStyles","footerCellProps","footerRenderer","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","getCellType","element","dataset","Number","getRowKeyForRowIndex","root","rowElements","querySelectorAll","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","cellElement","isHeader","columnElements","logicalCellExtractor","cellSelector","onlyAncestors","startingElement","parentElement","closest","cellType","keyExtractor","getElementFromCell","cell","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerBottomOffset","footerRowElement","getBoundingClientRect","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","getFirstFocusableCell","firstCellElement","firstCellType","hasNoDataCell","hasFooterCells","handleRowActionGesture","onRowAction","targetElement","targetCell","targetCellElement","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","topOffset","headerRowElement","getScrollerTopOffset","bottomOffset","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","top","hasTopOverflow","bottomOverflowDiff","bottom","hasBottomOverflow","Math","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","left","right","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","rowHeight","applyScrollDetail","sizingInfo","scrollDetail","scroller","findElementByKey","boxHeight","contentHeight","locationY","columnElement","stickyStartColumns","getStickyColumnIndicies","stickyIndex","stickyEndColumns","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","locationX","isStart","stickyColumns","edge","push","_applyStickyColumnOffset","stickyOffset","styleProperty","styleValue","j","updateStickyEdges","currentStickyEdgesRef","isForce","currentScrollIndex","newScrollPosition","startIndex","endIndex","stickyStartIndicies","currentIndex","_updateStickyEdge","currentWidth","endOverflow","scrollWidth","clientWidth","stickyEndIndicies","edgeIndex","currentEdgeIndex","start","end","_addRemoveStickyEdgeStyle","isAdd","isLeft","modifierFunc","classList","tableHeaderCellStyles","stickyEdgeLeft","stickyEdgeRight","stickyEdgeStart","stickyEdgeEnd","tableCellStyles","tableFooterCellStyles","getViewportConfig","outerTableRef","config","cellComparator","cell1","cell2","handleAdjacentRowGesture","sizingInfoRef","initialCell","onCurrentCellChange","isPrevious","newCurrentCell","currentRowKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","newColumnKey","_getBoundaryColumnKey","handlePageRowGesture","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","max","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","isFirst","handleJumpColumnGesture","includeRows","handleSelectionGesture","isMultiSelectGesture","selectionMode","emptyKeys","selectedRows","selectedColumns","removeKey","addKey","_applyRangeSelection","isRowGesture","handleExtendSelectionGesture","selectionExtensionElementRef","currentCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","event","resizeInfoRef","getElementContainsFunc","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","appliedColumnWidths","onColumnResize","isResizing","innerTable","rect","currentX","clientX","delta","startX","allColumnWidths","ignoreClick","useInteractionManager","cellHasRenderer","onColumnResizing","blurFromWindowRef","pendingCurrentCellRef","selectionTouchRef","pendingSelectionExtensionRef","onTableCurrentCellChange","useMemo","onTableSelectionChange","isExtendableSelection","isCurrentTabbableCell","tabbableModeProps","setCurrentTabbableCell","useTabbableModeSet","focusRingProps","useCollectionFocusRing","_blurHandler","relatedTarget","_focusHandler","scrollCurrentIntoView","firstCell","focus","preventScroll","handleElementFocus","_pointerMoveHandler","handleColumnResizingGesture","handleOverResizeRegionGesture","_pointerDownHandler","pointerType","isSelectionExtension","shiftKey","isRangeSelectionGesture","pointerX","resizeColumnWidths","handleColumnResizeStartGesture","_pointerUpHandler","_pointerLeaveHandler","_event","handleLeaveResizingGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","platform","getClientHints","endElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","_keyDownHandler","keyHandlers","preventDefault","Enter","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","Object","includes","_scrollHandler","interactionManagerProps","mergeProps","onBlur","onFocus","onPointerMove","onPointerDown","onPointerUp","onPointerLeave","onPointerEnter","onClick","onKeyDown","onScroll","getLayoutColumnWidths","outerTableElement","isFixed","sampledColumnWidthsRef","availableWidth","staticColumnWidths","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalWidth","pendingTotalWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","isMaxRuleApplied","_enforceWeightedMinRules","_enforceFixedMinMaxRules","_createColumnWidths","_getFixedLayoutColumnWidths","newColumnWidths","_getContentsLayoutColumnWidths","totalWidth","widthsArray","width","tableCols","innerTableElem","tableLayout","_udpateTableSizing","columnMinWidthsArray","totalPreferredWidth","totalRemainingWeight","sampledWidths","sampledMinWidthsArray","sampledWeightWidthsArray","minWidths","weightWidths","sampledWeightWidth","remove","tableStyles","disableWrapping","sampledMinWidth","forcedWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","newWidth","columnWidths","_defaultSelected","Table","forwardRef","ariaLabel","ariaLabelledBy","columns","columnOrder","layout","gridlines","horizontalScrollPositionOverride","verticalScrollPositionOverride","columnResizingIndicator","testId","ref","isInitialRender","setAppliedColumnWidths","setContentHeight","isVerticalScrollRef","horizontalScrollPositionRef","verticalScrollPositionRef","direction","useUser","testIdProps","useTestId","newColumnsArray","entries","isLayoutRequired","appliedWidth","staticWidth","layoutInfo","useImperativeHandle","getActiveElement","getBodyElement","useLayoutEffect","rootElement","defaultScrollbarWidth","resizeObserverCallbackRef","entry","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","defaultScrollbarHeight","staticResizeObserverCallback","useResizeObserver","callback","hasVerticalOverflow","noVerticalScroll","add","verticalScroll","stickyStartOffset","stickyEndOffset","updateStickyColumns","TableRedwoodTheme","forceScroll","tableClasses","innerTableStyles","focusTrackerClasses","focusTrackerStyles","setAttribute","hasFooters","some","ariaRowCount","vertical","horizontal","onStartTracking","handleEnterActionableMode","hasFocusWithin","tabbableElements","onFocusStartEdge","handleWrapActionableFocus","onFocusEndEdge","jsxs","FocusTracker","styleClass","widthString","heightString","getTableStyle","getTableColGroupProps","getTableHeaderProps","getTableFooterProps","getTableDragIndicator"],"mappings":"o6CAmBgBA,GAAcC,QAAEA,EAAOC,kBAAEA,IACvC,MAAMC,EAAeC,GACG,MAAfA,EAAsB,GAAK,UAAUA,OAG9C,OACEC,EAAAA,yBACGH,EAAkBI,KAAKF,GACfC,EAAAE,IAAA,MAAA,CAAKC,MAAOL,EAAYC,GAAY,oBAAqBH,OAIxE,CCAA,MAAMQ,EAAc,GAOd,SAAUC,GAAiBC,QAAEA,EAAOC,UAAEA,EAASC,aAAEA,EAAe,IACpE,MAAOC,EAAWC,GAAgBC,EAAQA,UAAC,GAE3CC,EAAAA,WAAU,KACRC,YAAW,KACTH,GAAa,EAAK,GACjBN,EAAY,GACd,IAEH,MAAMU,EAAcC,EAAUA,WAAC,CAACC,EAAAA,wBAAwBC,OAExD,OACEjB,EAAAE,IAAA,KAAA,CAAIgB,MAAOC,EAAoBA,qBAAAC,SAC5BX,EACCT,EAAAE,IAAA,KAAA,CAAIgB,MAAOJ,EAAaO,QAASf,EAASgB,KAAK,eAAcF,SAC1D,IAAIG,MAAMf,IAAeP,KAAKuB,GAC7BxB,EAAAA,IAAK,MAAA,CAAAkB,MAAOO,EAA+BA,gCAACR,KAC1CG,SAAApB,EAAAE,IAACwB,EAAQA,SAAC,CAAAC,OAAO,aAIrB,MATgCpB,EAY1C,CCTA,SAASqB,GAA8BC,QAAEA,EAAOC,MAAEA,IAChD,OAAgB,MAATA,EACL9B,MAAC+B,EAAAA,KAAI,CAACC,aAAa,YAAYC,UAAW,EAAGC,QAAQ,UAAUC,KAAK,KACjEf,SAAAgB,OAAOP,EAAQC,MAEhB,IACN,CAKgB,SAAAO,GAAmBzC,QACjCA,EAAOiC,QACPA,EAAOC,MACPA,EAAKQ,UACLA,EAASC,YACTA,EAAWC,OACXA,EAAMC,SACNA,EAAQC,gBACRA,EAAeC,mBACfA,EAAkBC,qBAClBA,EAAoBC,uBACpBA,EAAsBC,cACtBA,EAAaC,sBACbA,EAAqBC,iBACrBA,EAAgBC,yBAChBA,EAAwBC,mBACxBA,EAAkBC,WAClBA,EAAUC,YACVA,EAAWC,aACXA,EAAe,OAAMC,SACrBA,EAAW1B,EAAoB2B,iBAC/BA,EAAgBC,sBAChBA,EAAqBC,qBACrBA,EAAoBvB,QACpBA,EAAOwB,iBACPA,EAAgBC,gBAChBA,EAAeC,sBACfA,EAAqBC,kBACrBA,EAAiBC,gBACjBA,EAAeC,MACfA,IAEA,MAAMC,EAAcV,IAAa1B,GACzBqC,QAASC,GAAiBC,EAAAA,kBAChCC,EAAAA,sBACA,CACEC,gBAAkBL,EAAoC,qBAAtB,oBAChCM,SAAuB,IAAb7B,EAAiB,aAAe,cAC1C8B,QAAS7B,EAAkB,YAAc,aACzC8B,YAA6B,IAAhBjC,EAAoB,gBAAkB,iBACnDkC,WAAY9B,EAAqB,eAAiB,gBAClD+B,gBACIjB,IAAyBX,GAAiBC,IAC1CF,GAAuC,IAAbJ,EAExB,qBADA,oBAENkC,mBACEjC,KAAsBe,GAAwBX,GAAkBD,GAC5D,uBACA,wBACN+B,kBACI3B,GAA4BD,GAC5BJ,GAAwC,IAAhBL,EAEtB,uBADA,sBAENsC,gBACElC,IAAuBK,EAAmB,oBAAsB,qBAClE8B,aAAclC,EAAuB,iBAAmB,kBACxDmC,eAAgBlC,EAAyB,mBAAqB,oBAC9DmC,mBAAoBvB,EAAuB,uBAAyB,wBACpEwB,cAAezB,EAAwB,kBAAoB,mBAC3D0B,YAAapC,EAAgB,gBAAkB,iBAC/CqC,oBAAqBpC,EACjB,wBACA,yBACJqC,eAAgBpC,EAAmB,mBAAqB,oBACxDqC,uBAAwBpC,EACpB,2BACA,4BACJqC,kBAAoC,UAAjBjC,EAA2B,sBAAwB,uBACtEkC,gBAAkC,QAAjBlC,EAAyB,oBAAsB,qBAChEmC,gBAAiB3B,EAAoB,oBAAsB,qBAC3D4B,cAAe3B,EAAkB,kBAAoB,mBACrD4B,aAA0B,cAAZxD,EAA0B,iBAAmB,kBAC3DyD,iBAAkBzC,EAAqB,qBAAuB,sBAC9D0C,OAAQlC,EAAmB,WAAa,YACxCmC,MAAOlC,EAAkB,UAAY,WACrCmC,YAAalC,EAAwB,gBAAkB,iBACvDmC,IAAKhC,EAAQ,QAAU,WAIrBjD,EAAcC,EAAAA,WAAW,CAACmD,IAE1B8B,EAAoB,CACxBnE,QAASA,EACTW,OAAQA,EACRV,MAAOA,EACPQ,UAAWA,EACX2D,SAAU1C,GAGZ,OACEvD,EAAAE,IAAA,KAAA,CAAA,gBACiBqC,EAAc,EAC7BrB,MAAOJ,EACPoF,GAAIC,UACJC,UAAW,EACX9E,KAAM8B,EAAc,YAAc,WAAU,oBACzB,OACC,qBAAAd,EACK,0BAAA1C,EACA,0BAAAA,KACC,iBAAd0C,GAA0B,CAAE,0BAA2B,UACnElB,SAAApB,EAAAE,IAACmG,EAAmBA,oBAACC,SAAQ,CAACC,MAAO,CAAEpD,cACpC/B,SAAAkC,EAAS0C,MAIlB,CCDA,MA4BaQ,EAAkBC,EAAAA,MAlJ/B,UAA2B7G,QACzBA,EAAO4C,OACPA,EAAMX,QACNA,EAAOY,SACPA,EAAQiE,WACRA,EAAUC,aACVA,EAAYC,oBACZA,EAAmBhE,qBACnBA,EAAoBC,uBACpBA,EAAsBgE,WACtBA,EAAUC,mBACVA,EAAkBtD,sBAClBA,EAAqBuD,4BACrBA,EAA2BC,cAC3BA,EAAaC,qBACbA,EAAoBC,gBACpBA,EAAkB,CAAEC,KAAK,EAAOC,KAAM,IAAIC,KAAUC,iBACpDA,EAAgBC,mBAChBA,EAAqB,CAAEJ,KAAK,EAAOC,KAAM,IAAIC,KAAUnF,QACvDA,EAAOsF,kBACPA,EAAiBC,gBACjBA,EAAeC,cACfA,EAAa3D,MACbA,IAEA,MAAM4D,EAAeC,uBAAiC,6BAChDC,iBAAEA,EAAgBnE,iBAAEA,EAAgBC,gBAAEA,EAAeC,sBAAEA,GAC3DkE,EAAAA,uBAEM7D,QAASC,GAAiBC,oBAChC4D,EAAAA,qBACA,CAAExD,QAASmC,EAAa,YAAc,eAGlCzC,EAAUlD,EAAAA,WAAW,CAACmD,IAEtB8D,EAA2BC,IACN,MAArBT,GACFA,EACE,CAAEjB,MAAO,CAAE2B,IAAKD,EAAO1B,MAAO4B,OAAQZ,GAAsBa,OAAQH,EAAOG,SAC3E,EAEH,EAGH,IAAInF,GAA2B,EAC/B,OACEjD,EAAAA,IACiB,KAAA,CAAA,gBAAAyC,EAAW,EAC1BvB,MAAO+C,EACP3C,KAAM,MACO,cAAAkB,2BACW5C,KACnB4D,EACDqD,EACE,CAAE,iBAAiB,GACnB,CAAE,iBAAiB,GACrB,CAAE,KACiB,iBAAXrE,GAAuB,CAAE,mBAAoB,aACpDgB,GAAyBqE,WAC7BlB,EAAa1G,KAAI,CAACkI,EAA8B5F,KAC/C,MAAMgB,EAAmBC,EACrB,KAEE,MAAM6E,GAAqB5F,EAAW,GAAG6F,WACzC,OACEtI,EAAAA,IAACuI,EAAAA,SAAQ,CAAA,aACKZ,EAAaa,qBAAqB,CAAEC,SAAUJ,IAC1DK,SAAUV,EACVxF,OAAQA,EACRmG,aAAczB,GAEhB,OAEJ0B,EAEEtG,EAAY6F,EAAOU,IACnB7F,EAAmB8F,EAAAA,YAAYvB,EAAoBjF,GACnDyG,EAAY,CAChBnJ,QAASA,EACTiC,QAASA,EACTC,MAAOqG,EAAO5B,MAAMzE,MACpBuB,aAAc8E,EAAO5B,MAAMyC,WAC3B1G,UAAWA,EACXC,YAAaA,EACbC,OAAQA,EACRC,SAAUA,EACVC,gBAAiBgE,EACjB/D,mBAAoBJ,IAAgBoE,EAAasC,OAAS,EAC1DrG,qBAAsBA,EACtBC,uBAAwBA,EACxBC,cAAe+D,EACf9D,sBAAuB+D,EACvB9D,iBAAkBA,EAClBC,yBAA0BA,EAC1BC,mBACE8D,IAAkBC,GAAwBkB,EAAOU,MAAQvB,EAC3DnE,WAAYgF,EAAOU,MAAQvB,GAAoBL,EAC/C7D,YAAawD,EAAoBsC,IAAIf,EAAOU,KAC5CvF,SAAU6E,EAAO5B,MAAMjD,SACvBC,iBAAkBA,EAClBrB,QAASA,EACTsB,sBAAuBA,EACvBC,qBAAsBsD,EACtBrD,iBAAkBA,EAClBC,gBAAiBA,EACjBC,sBAAuBA,EACvBC,kBAAmBtB,IAAgBkF,EACnC3D,gBAAiBvB,IAAgBmF,EACjC3D,MAAOA,GAGT,OADAd,EAA2BD,EACpBhD,EAACE,IAAAmC,EAAc,IAAA0G,GAAa,KAI3C,IA8B8C,CAACI,EAAWC,KACxD,SAAID,IAAQC,KAERD,EAAKvJ,UAAYwJ,EAAKxJ,SACtBuJ,EAAK3G,SAAW4G,EAAK5G,QACrB2G,EAAKtH,UAAYuH,EAAKvH,SACtBsH,EAAK1G,WAAa2G,EAAK3G,UACvB0G,EAAKzC,aAAe0C,EAAK1C,YAzBK,EAClC2C,EACAC,KAEA,GAAID,EAAcJ,SAAWK,EAAcL,OAAQ,CACjD,IAAK,IAAIM,EAAI,EAAGA,EAAIF,EAAcJ,OAAQM,IACxC,GACEF,EAAcE,GAAGV,MAAQS,EAAcC,GAAGV,KAC1CQ,EAAcE,GAAGhD,QAAU+C,EAAcC,GAAGhD,MAE5C,OAAO,EAGX,OAAO,CACR,CACD,OAAO,CAAK,EAWRiD,CAA4BL,EAAKxC,aAAcyC,EAAKzC,eACpDwC,EAAKM,sBAAwBL,EAAKK,qBAClCN,EAAKO,oBAAsBN,EAAKM,oBAtCJC,EAuCHR,EAAKvC,oBAvCkBgD,EAuCGR,EAAKxC,oBAtChD,MAAR+C,EACa,MAARC,EAEG,MAARA,GAGGD,EAAKxH,OAASyH,EAAKzH,MAAQ,IAAIwH,GAAME,OAAOC,GAAMF,EAAKV,IAAIY,OAiC9DX,EAAKtC,aAAeuC,EAAKvC,YACzBsC,EAAKrC,qBAAuBsC,EAAKtC,oBACjCqC,EAAK3F,wBAA0B4F,EAAK5F,uBACpC2F,EAAKpC,8BAAgCqC,EAAKrC,6BAC1CoC,EAAKnC,gBAAkBoC,EAAKpC,eAC5BmC,EAAKlC,uBAAyBmC,EAAKnC,sBACnCkC,EAAKjC,kBAAoBkC,EAAKlC,iBAC9BiC,EAAK7B,mBAAqB8B,EAAK9B,kBAC/B6B,EAAK5B,qBAAuB6B,EAAK7B,oBACjC4B,EAAKjH,UAAYkH,EAAKlH,SACtBiH,EAAK3B,oBAAsB4B,EAAK5B,mBAChC2B,EAAK1B,kBAAoB2B,EAAK3B,iBAC9B0B,EAAKzB,gBAAkB0B,EAAK1B,eAC5ByB,EAAKpF,QAAUqF,EAAKrF,OArDO,IAAC4F,EAAoBC,CAwDxC,ICnME,SAAAG,GAAYnK,QAC1BA,EAAOoK,aACPA,EAAY9G,mBACZA,EAAkBC,WAClBA,EAAUG,SACVA,IAEA,MAAMqE,EAAeC,uBAAiC,4BAEhDqC,EAAalJ,EAAUA,WAAC,CAACmJ,EAAAA,eAAejJ,QAEtCgD,QAASC,GAAiBC,EAAAA,kBAChCgG,EAAAA,wBACA,CACE9F,gBAA6B,MAAZf,EAAmB,oBAAsB,qBAC1DqC,iBAAkBzC,EAAqB,qBAAuB,wBAI5DpC,EAAcC,EAAAA,WAAW,CAACmD,IAUhC,MAAMkG,EAA8B,MAAZ9G,EAAmBA,EAR3C,WACE,OACEtD,MAAC+B,EAAIA,KAAA,CAACE,UAAW,EAAGC,QAAQ,UAAUC,KAAK,KACxCf,SAAAuG,EAAa0C,qBAGnB,EAID,OACErK,EAAAE,IAAA,KAAA,CAAA,gBAAmB,EAAGgB,MAAO+I,EAAY3I,KAAM,MAAKF,SAClDpB,EAAAA,IACiB,KAAA,CAAA,gBAAA,EACfkB,MAAOJ,EACPoF,GAAIC,UACJC,UAAW,EACX9E,KAAM,WACND,QAAS2I,EACU,oBAAA,SACM,0BAAApK,EACE,4BAAAA,EAC3BwB,SAAApB,EAAAE,IAACmG,EAAmBA,oBAACC,SAAQ,CAACC,MAAO,CAAEpD,cAAY/B,SAChDgJ,SAKX,CCzBM,SAAUE,GAAmB1K,QACjCA,EAAO2K,wBACPA,EAAuBC,KACvBA,EAAI7D,aACJA,EAAY/D,qBACZA,EAAoBC,uBACpBA,EAAsB4H,uBACtBA,EAAsBzD,cACtBA,EAAa0D,UACbA,EAASC,QACTA,EAAOC,WACPA,EAAUC,eACVA,EAAcC,YACdA,EAAWC,kBACXA,EAAiBC,SACjBA,EAAQxH,sBACRA,EAAqBuD,4BACrBA,EAA2BS,kBAC3BA,EAAiByD,eACjBA,EAAcxD,gBACdA,EAAeC,cACfA,EAAa3D,MACbA,IAIA,MAAMmH,EAAsBC,EAAAA,QAAe,IAAIC,MAAOC,WAChDC,EAAwBH,EAAAA,SAExBI,EAAoBxK,EAAUA,WAAC,CAACyK,EAAAA,iBAAiBvK,OAGjDwK,EAAgBC,eACnBC,IACQ,CACLC,MAAOD,EAAQC,MACfpB,KAAMmB,EAAQnB,KAAKA,KACnB3B,IAAK6B,EAAUiB,EAAQnB,KAAKA,SAGhC,CAACE,IAGH,IAAI5D,GAAqB,EACzB,MAoDM+E,EACI,MAARrB,EACIA,EAAKvK,KAAK6L,IAED,CAAEtB,KAAMsB,EAAGC,SADNrB,EAAUoB,OAGxB,GAEAE,EAA6B,MAARxB,GAAgC,IAAhBA,EAAKvB,QAAgB0B,EAC1DsB,EAAuB,MAARzB,GAAiC,IAAhBA,EAAKvB,SAAiB0B,EAO5D,OANoBW,EAAsBY,UACtBF,IAClBd,EAAoBgB,SAAU,IAAId,MAAOC,WAE3CC,EAAsBY,QAAUF,EAG9BhM,EAAOE,IAAA,QAAA,CAAAgB,MAAOqK,WACXU,EACCjM,EAACE,IAAA6J,EAAgB,IA/BA,MACrB,MAAMoC,EAAe1B,IACftH,EAAoC,WAAvBgJ,GAAcC,KACjC,MAAO,CACLxM,QAASA,EACToK,aAAcrD,EAAasC,OAC3B9F,WAAYA,EACZD,mBAAoB8D,IAAkB7D,GAAoC,WAAtB2H,GAAasB,KACjE9I,SAAU2H,EACX,EAsBoBoB,KAEjBrM,EAAAE,IAACoM,qBAAkB,CACjB9B,KAAMqB,EACNU,kBACEvM,EAACE,IAAAG,EACC,CAAAC,QAASqG,EAAasC,OACtB1I,UAAW2K,EAAoBgB,QAC/B1L,aAAcwL,EAAqB,GAAK,IAG5CrB,QAASA,EACTC,WAAYA,EACZC,eAAgBA,WApFQc,IAC9B,MAAMa,EAAkBf,EAAcE,GAChCnJ,EAASgK,EAAgB3D,IACzB4D,EAAsB3B,GAAatI,SAAWA,EAC9CyE,EAAuBwD,KAA0BjI,SAAWA,EAC5DkK,EAAoB1F,GAAiByF,EACrCnF,EACJmF,IAAwBxF,GAAwByF,GAC5C5B,EAAYxI,eACZsG,EACA/B,EAAaiC,EAAWA,YAACkC,EAAS9C,IAAK1F,GACvCmK,EAAW,CACf/M,QAASA,EACT+G,aAAcA,EACdC,oBAAqB2D,EAAwBiC,GAC7C5J,qBAAsBA,EACtBC,uBAAwBA,EACxBgE,WAAYA,EACZC,mBAAoBA,EACpBU,kBAAmBA,EACnBhE,sBAAuBA,EACvBuD,4BAA6BA,EAC7B7E,QAASuK,EAAsB1B,OAAoBnC,EACnDtB,iBAAkBA,EAClBJ,gBAAiB8D,EAAS9C,IAC1BX,mBAAoByD,EAAS7C,OAC7BnB,cAAe0F,EACfzF,qBAAsBA,EACtBxE,SAAU+J,EAAgBZ,MAC1BpJ,OAAQA,EACRX,QAAS2K,EAAgBhC,KACzB9D,WAAY8F,EAAgBZ,SAAmB,MAARpB,EAAeA,EAAKvB,OAAS,GAAK,GACzExB,gBAAiBA,EACjBC,cAAeA,EACf3D,MAAOA,GAGT,OADA+C,EAAqBD,EACd7G,EAACE,IAAAsG,EAAoB,IAAAmG,GAAY,KAqD5C,UC9HgBC,GAAsBhN,QACpCA,EAAO0C,UACPA,EAASC,YACTA,EAAWI,mBACXA,EAAkBC,qBAClBA,EAAoBiE,WACpBA,EAAUC,mBACVA,EAAkB+F,mBAClBA,EAAkBrJ,sBAClBA,EAAqB+D,mBACrBA,EAAqB,CAAEJ,KAAK,EAAOC,KAAM,IAAIC,KAAUH,gBACvDA,EAAkB,CAAEC,KAAK,EAAOC,KAAM,IAAIC,KAAUnE,mBACpDA,EAAkBC,WAClBA,EAAU2J,WACVA,EAAUzJ,aACVA,EAAe,OAAMC,SACrBA,EAAQkE,kBACRA,EAAiBuF,SACjBA,EAAW,WAAUC,cACrBA,EAAaC,sBACbA,EAAqBpJ,kBACrBA,EAAiBC,gBACjBA,EAAeC,MACfA,IAEA,MAAM4D,EAAeC,uBAAiC,6BAEhDC,iBAAEA,EAAgBnE,iBAAEA,EAAgBC,gBAAEA,EAAeC,sBAAEA,GAC3DkE,EAAAA,sBAEI9D,EAA0B,MAAZV,GACZW,QAASC,GAAiBC,EAAAA,kBAChC+I,EAAAA,4BACA,CACE7I,gBAAkBL,EAAoC,qBAAtB,oBAChCQ,YAA6B,IAAhBjC,EAAoB,gBAAkB,iBACnDkC,WAAY9B,EAAqB,eAAiB,gBAClDiC,kBACIkC,GAAsBD,GAAiBjE,GAAwC,IAAhBL,EAE7D,uBADA,sBAENsC,gBACElC,IAAuBkE,EAAa,oBAAsB,qBAC5D/B,aAAclC,EAAuB,iBAAmB,kBACxDuK,iBAAkBN,EAAqB,qBAAuB,sBAC9DzH,eAAgByB,EAAa,mBAAqB,oBAClDxB,uBAAwByB,EACpB,2BACA,4BACJxB,kBAAoC,UAAjBjC,EAA2B,sBAAwB,uBACtEkC,gBAAkC,QAAjBlC,EAAyB,oBAAsB,qBAChEmC,gBAAiB3B,EAAoB,oBAAsB,qBAC3D4B,cAAe3B,EAAkB,kBAAoB,mBACrD6B,iBAAkBzC,EAAqB,qBAAuB,sBAC9D0C,OAAQlC,EAAmB,WAAa,YACxCmC,MAAOlC,EAAkB,UAAY,WACrCmC,YAAalC,EAAwB,gBAAkB,iBACvDmC,IAAKhC,EAAQ,QAAU,WAIrBjD,EAAcC,EAAAA,WAAW,CAACmD,IAEhC,IAAIkJ,EAEFA,EADEC,EAASA,UAACnG,EAAiB,CAAEC,KAAK,EAAMmG,YAAa,IAAIjG,MACxC,MACVgG,EAASA,UAACnG,EAAiB,CAAEC,KAAK,EAAOC,KAAM,IAAIC,MACzC,OACVH,EAAgBC,IACN,cAEA,UAGrB,MAAMoG,EAAwBtF,IACH,MAArBT,GACFA,EACE,CAAEjB,MAAO,CAAE2B,IAAKD,EAAO1B,MAAO4B,OAAQZ,GAAsBa,OAAQH,EAAOG,SAC3E,EAEH,EAmCGoF,EAA0B,CAC9B3E,IAAKvG,EACLwK,WAAYA,EACZC,SAAUA,EACVC,cAAeA,EACf/G,SArCuBzC,EACrB,IACExD,MAACyN,EAAAA,0BACa9F,EAAa+F,2BACzBhF,SAAU6E,EACVvC,SAAUoC,SAGdxE,EA8BF+E,YA3Ba,YAAbZ,GAA2C,MAAjBC,EACtB,IACEhN,MAAC4N,EAAkBA,mBAAA,CAAA,aAEF,YAAbb,EACIpF,EAAakG,yBACblG,EAAamG,0BAEnBC,WAAyB,YAAbhB,EACZiB,SAAUC,EAAiB7M,SACR,cAAlB4L,EACChN,EAAAA,IAACkO,EAAAA,iBACmB,eAAlBlB,EACFhN,EAAAA,IAACmO,EAAAA,eAAqB,CAAA,GAEtBnO,EAAAA,IAACoO,EAAeC,iBAAA,WAItBzF,GAWAqF,EAAoBvC,EAAAA,aAAY,KACpC,GAA6B,MAAzBuB,EAA+B,CAEjCA,EAAsB,CAAC,CAAEpE,IAAKvG,EAAW0K,cADF,cAAlBA,EAAgC,aAAe,cAErE,IACA,CAAC1K,EAAW0K,EAAeC,IAExBqB,EAAwB5C,EAAAA,aAAY,IACxB,MAAZpI,EACKA,EAEF,EAAGwJ,aAAYa,kBACpB,MAAMY,EACU,MAAdzB,EACE9M,MAAC+B,OAAI,CAACC,aAAa,YAAYC,UAAW,EAAGC,QAAQ,UAAUC,KAAK,KACjEf,SAAA0L,IAED,KACN,OAAmB,MAAfa,EAEAa,OAAA,MAAA,CAAKtN,MAAOuN,EAAAA,+BAA+BxN,KACxCG,SAAA,CAAAmN,EACAZ,OAIAY,CAAI,GAEZ,CAACjL,IAgBJ,OACEtD,MACiB,KAAA,CAAA,gBAAAuC,EAAc,KAf3BsE,EACK,CAAE,iBAAiB,GAErBgG,EAAqB,CAAE,iBAAiB,QAAUjE,KAGvC,MAClB,GAAsB,cAAlBoE,GAAmD,eAAlBA,EACnC,MAAO,CAAE,YAAaA,EAER,EAOV0B,GACJxN,MAAOJ,EACPoF,GAAIC,UACJC,UAAW,EACX9E,KAAM,eAAc,oBACD,SACC,qBAAAgB,EACK,0BAAA1C,8BACEA,KACD,iBAAd0C,GAA0B,CAAE,0BAA2B,aAC9DuK,GAAsBhF,EAC3BzG,SAAApB,MAACqG,EAAAA,oBAAoBC,SAAS,CAAAC,MAAO,CAAEpD,cAAY/B,SAChDkN,IAAwBd,MAIjC,UCrNgBmB,GAAqB/O,QACnCA,EAAO+G,aACPA,EAAY/D,qBACZA,EAAoBgM,WACpBA,EAAU5H,cACVA,EAAaO,mBACbA,EAAkBL,gBAClBA,EAAe2H,yBACfA,EAAwBrL,sBACxBA,EAAqByD,qBACrBA,EAAoBO,kBACpBA,EAAiBsH,cACjBA,EAAa7B,sBACbA,EAAqBxF,gBACrBA,EAAeC,cACfA,EAAaqH,cACbA,EAAahL,MACbA,IAEA,MAAMkG,EAAalJ,EAAUA,WAAC,CAACiO,EAAAA,qBAAqB/N,OAC9CgO,EAAmBlO,EAAUA,WAAC,CAACmO,EAAAA,8BAA8BjO,OAMnE,IAAI6F,GAAqB,EACzB,OACE9G,MAAA,QAAA,CAAOkB,MAAO+N,EAAgB7N,SAC5BpB,EAAAA,IAAI,KAAA,CAAAkB,MAAO+I,EAAY3I,KAAM,MAAOnB,MAN/B4O,EAAgB,sBAAwB,GAMoC,2BAAAnP,WAC9E+G,EAAa1G,KAAI,CAACkI,EAA8B5F,KAC/C,MAAMD,EAAY6F,EAAOU,IACzB,IAAImE,EACJ,GAAqB,MAAjB8B,EACF,IAAK,MAAMK,KAAaL,EACtB,GAAIK,EAAUtG,MAAQvG,EAAW,CAC/B0K,EAAgBmC,EAAUnC,cAC1B,KACD,CAGL,MAAMnG,EAAaiC,EAAAA,YAAYvB,EAAoBjF,GAC7C8M,EAAkB,CACtBxP,QAASA,EACTgD,qBAAsBA,EACtBN,UAAWA,EACXC,YAAaA,EACbI,mBAAoBJ,IAAgBoE,EAAasC,OAAS,EAC1D5F,aAAc8E,EAAO5B,MAAMyC,WAC3BnC,WAAYA,EACZC,mBAAoBA,EACpBS,mBAAoBA,EACpBL,gBAAiBA,EACjB2F,mBAAoBgC,GAAwD,aAA5B1G,EAAO5B,MAAM8I,WAC7D7L,sBAAuBA,EACvBN,mBAAoB8D,GAAiB1E,IAAcsM,IAAe3H,EAClE9D,WAAYb,IAAcsM,GAAc3H,EACxC6F,WAAY3E,EAAO5B,MAAMuG,WACzBxJ,SAAU6E,EAAO5B,MAAM+I,eACvB9H,kBAAmBA,EACnBuF,SAAU5E,EAAO5B,MAAMwG,SACvBC,cAAeA,EACfC,sBAAuBA,EACvBpJ,kBAAmBtB,IAAgBkF,EACnC3D,gBAAiBvB,IAAgBmF,EACjC3D,MAAOA,GAGT,OADA+C,EAAqBD,EACd7G,EAACE,IAAA0M,EAAoB,IAAAwC,GAAmB,OAKzD,CCzEA,SAASG,GAA8BC,WAAEA,IACvC,OAAqB,MAAdA,EACLxP,EAAAA,IAAC+B,EAAAA,KAAI,CAACE,UAAW,EAAGC,QAAQ,UAAUC,KAAK,KAAIf,SAC5CoO,IAED,IACN,UAKgBC,GAAmB7P,QACjCA,EAAO0C,UACPA,EAASC,YACTA,EAAWI,mBACXA,EAAkBC,qBAClBA,EAAoBiE,WACpBA,EAAUC,mBACVA,EAAkB+F,mBAClBA,EAAkB3J,mBAClBA,EAAkBC,WAClBA,EAAUE,aACVA,EAAe,OAAMmM,WACrBA,EAAUlM,SACVA,EAAWiM,EAA0B1L,kBACrCA,EAAiBC,gBACjBA,EAAeC,MACfA,IAEA,MAAM8D,iBAAEA,EAAgBnE,iBAAEA,EAAgBC,gBAAEA,EAAeC,sBAAEA,GAC3DkE,EAAAA,sBAEI9D,EAAcV,IAAaiM,GACzBtL,QAASC,GAAiBC,EAAAA,kBAChCuL,EAAAA,4BACA,CACErL,gBAAkBL,EAAoC,qBAAtB,oBAChCQ,YAA6B,IAAhBjC,EAAoB,gBAAkB,iBACnDkC,WAAY9B,EAAqB,eAAiB,gBAClDiC,kBACIkC,GAAsBD,GAAiBjE,GAAwC,IAAhBL,EAE7D,uBADA,sBAENsC,gBACElC,IAAuBkE,EAAa,oBAAsB,qBAC5D/B,aAAclC,EAAuB,iBAAmB,kBACxDuK,iBAAkBN,EAAqB,qBAAuB,sBAC9DzH,eAAgByB,EAAa,mBAAqB,oBAClDxB,uBAAwByB,EACpB,2BACA,4BACJxB,kBAAoC,UAAjBjC,EAA2B,sBAAwB,uBACtEkC,gBAAkC,QAAjBlC,EAAyB,oBAAsB,qBAChEmC,gBAAiB3B,EAAoB,oBAAsB,qBAC3D4B,cAAe3B,EAAkB,kBAAoB,mBACrD6B,iBAAkBzC,EAAqB,qBAAuB,sBAC9D0C,OAAQlC,EAAmB,WAAa,YACxCmC,MAAOlC,EAAkB,UAAY,WACrCmC,YAAalC,EAAwB,gBAAkB,iBACvDmC,IAAKhC,EAAQ,QAAU,WAIrBjD,EAAcC,EAAAA,WAAW,CAACmD,IAE1ByL,EAA0B,CAAE9G,IAAKvG,EAAWkN,WAAYA,GAI9D,OACExP,EAAAA,IACiB,KAAA,CAAA,gBAAAuC,EAAc,KACxBsE,EACD,CAAE,iBAAiB,GACnBgG,EACA,CAAE,iBAAiB,GACnB,GACJ3L,MAAOJ,EACPoF,GAAIC,EAAAA,QACJC,UAAW,EACX9E,KAAM,+BACa,SAAQ,qBACPgB,EAAS,0BACJ1C,EAAO,4BACLA,KACD,iBAAd0C,GAA0B,CAAE,0BAA2B,aAC9DuK,GAAsBhF,WAC3B7H,MAACqG,EAAAA,oBAAoBC,SAAS,CAAAC,MAAO,CAAEpD,cAAY/B,SAChDkC,EAASqM,MAIlB,CClGM,SAAUC,IAAqBhQ,QACnCA,EAAOiQ,WACPA,EAAUlJ,aACVA,EAAY/D,qBACZA,EAAoBgM,WACpBA,EAAU5H,cACVA,EAAa2B,aACbA,EAAYkG,yBACZA,EAAwB5H,qBACxBA,EAAoBQ,gBACpBA,EAAeC,cACfA,EAAa3D,MACbA,IAEA,MAAMkG,EAAalJ,EAAUA,WAAC,CAAC+O,EAAAA,qBAAqB7O,OAC9CgO,EAAmBlO,EAAUA,WAAC,CAACgP,EAAAA,8BAA8B9O,OAEnE,IAAI6F,GAAqB,EACzB,OAAO+I,EACL7P,MAAA,QAAA,CAAOkB,MAAO+N,EAAgB7N,SAC5BpB,MAAI,KAAA,CAAAkB,MAAO+I,EAAY3I,KAAM,MAAK,2BAA4B1B,EAAOwB,SAClEuF,EAAa1G,KAAI,CAACkI,EAA8B5F,KAC/C,MAAMD,EAAY6F,EAAOU,IACnBhC,EAAaiC,EAAAA,YAAYH,EAAcrG,GACvC0N,EAAkB,CACtBpQ,QAASA,EACT0C,UAAWA,EACXC,YAAaA,EACbI,mBAAoBJ,IAAgBoE,EAAasC,OAAS,EAC1DrG,qBAAsBA,EACtBS,aAAc8E,EAAO5B,MAAMyC,WAC3BnC,WAAYA,EACZC,mBAAoBA,EACpB+F,mBAAoBgC,GAAwD,aAA5B1G,EAAO5B,MAAM8I,WAC7DnM,mBAAoB8D,GAAiB1E,IAAcsM,IAAe3H,EAClE9D,WAAYb,IAAcsM,GAAc3H,EACxCuI,WAAYrH,EAAO5B,MAAMiJ,WACzBlM,SAAU6E,EAAO5B,MAAM0J,eACvBpM,kBAAmBtB,IAAgBkF,EACnC3D,gBAAiBvB,IAAgBmF,EACjC3D,MAAOA,GAGT,OADA+C,EAAqBD,EACd7G,EAACE,IAAAuP,EAAoB,IAAAO,GAAmB,QAInD,IACN,UC7DgBE,IAAmBC,SAAEA,EAAQpM,MAAEA,IAC7C,MAAMqM,EAA4BrP,EAAUA,WAAC,CAACsP,EAAAA,yBAAyBpP,OAWvE,OAAOjB,EAAAE,IAAA,MAAA,CAAKgB,MAAOkP,EAA2BjQ,MAR5B,MAAZgQ,EACKpM,EACH,SAASoM,yBACT,QAAQA,yBAEP,iBAIX,CCrBO,MAAMG,GAAeC,GACnBA,EAAQC,QAAoB,WAMxB9F,GAAa6F,GACgB,WAAjCA,EAAQC,QAAmB,UAC9BC,OAAOF,EAAQC,QAAe,OAC9BD,EAAQC,QAAe,MAMhBE,GAAuB,CAACC,EAAmB/Q,EAAiBgM,KACvE,GAAY,MAAR+E,EAAc,CAChB,MAAMC,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,GAAIgR,EAAY3H,OAAS2C,EACvB,OAAOlB,GAAUkG,EAAYhF,GAEhC,CACD,OAAO,IAAI,EAMAkF,GAA2B,CACtCH,EACA/Q,EACAmR,KAEA,GAAY,MAARJ,EAAc,CAChB,MAAMC,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OAChEgM,EAAQrK,MAAMyP,UAAUC,QAAQC,KAAKN,EAAaG,GACxD,GAAInF,GAAS,EACX,OAAOA,CAEV,CACD,OAAO,IAAI,EAqBN,MAAMuF,GAAgBZ,GACmB,WAAvCA,EAAQC,QAAyB,gBACpCC,OAAOF,EAAQC,QAAqB,aACpCD,EAAQC,QAAqB,YAmBtBY,GAAuC,CAClDT,EACA/Q,EACAyR,EACAC,KAEA,GAAY,MAARX,EAAc,CAChB,MAAMY,EAAiBZ,EAAKE,iBAC1BS,EACI,+BAA+B1R,MAC/B,+BAA+BA,OAE/BgM,EAAQrK,MAAMyP,UAAUC,QAAQC,KAAKK,EAAgBF,GAC3D,GAAIzF,GAAS,EACX,OAAOA,CAEV,CACD,OAAO,IAAI,EAMP,SAAU4F,GACdjB,EACA3Q,EACA6R,EACAC,GAEA,MAAMC,EAAkBD,EAAgBnB,EAAQqB,cAAgBrB,EAChE,GAAuB,MAAnBoB,EAAyB,CAC3B,MAAMN,EAAcM,EAAgBE,QAAQJ,GAC5C,GAAmB,MAAfJ,EAAqB,CACvB,MAAMS,EAAWxB,GAAYe,GAC7B,GAAiB,SAAbS,EACF,MAAO,CACLtP,OAAQuP,EAAYA,aAACV,EAAa,4BAA4BzR,OAC9D0C,UAAW6O,GAAaE,GACxBjF,KAAM0F,GAEH,GAAiB,WAAbA,GAAsC,WAAbA,EAClC,MAAO,CACLxP,UAAW6O,GAAaE,GACxBjF,KAAM0F,GAEH,GAAiB,WAAbA,EACT,MAAO,CACL1F,KAAM0F,EAGX,CACF,CACD,OAAO,IACT,UAKgBE,GACdrB,EACA/Q,EACAqS,GAEA,GAAkB,WAAdA,EAAK7F,KAAmB,CAE1B,MAAM8F,EAAiBvB,EAAKE,iBAAiB,+BAA+BjR,OAC5E,IAAK,MAAMuS,KAAiBD,EAC1B,GAAID,EAAK3P,YAAc6O,GAAagB,GAClC,OAAOA,CAGZ,MAAM,GAAkB,WAAdF,EAAK7F,KAAmB,CAEjC,MAAMgG,EAAiBzB,EAAKE,iBAAiB,+BAA+BjR,OAC5E,IAAK,MAAMyS,KAAiBD,EAC1B,GAAIH,EAAK3P,YAAc6O,GAAakB,GAClC,OAAOA,CAGZ,MAAM,GAAkB,SAAdJ,EAAK7F,KAAiB,CAE/B,MAAMwE,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,IAAK,MAAMmR,KAAcH,EACvB,GAAIqB,EAAKzP,SAAWkI,GAAUqG,GAA4B,CACxD,MAAMuB,EAAevB,EAAWF,iBAAiB,6BAA6BjR,OAC9E,IAAK,MAAMyR,KAAeiB,EACxB,GAAIL,EAAK3P,YAAc6O,GAAaE,GAClC,OAAOA,CAGZ,CAEJ,MAAM,GAAkB,WAAdY,EAAK7F,KAEd,OAAOuE,EAAK4B,cAAc,+BAA+B3S,OAE3D,OAAO,IACT,CAKO,MAUM4S,GAA0B,CAAC7B,EAAmB/Q,KACzD,MAAM6S,EAAmB9B,EAAK4B,cAC5B,8BAA8B3S,OAEhC,OAA2B,MAApB6S,EAA2BA,EAAiBC,wBAAwB/Q,OAAS,CAAC,EAM1EgR,GAA0B,CAAChC,EAAmB/Q,KACzD,GAAY,MAAR+Q,EAAc,CAChB,MAAMiC,EAAkBjC,EAAK4B,cAAc,4BAA4B3S,OACvE,GAAuB,MAAnBgT,EACF,OAAOlI,GAAUkI,EAEpB,CACD,OAAO,IAAI,EAMAC,GAAyB,CAAClC,EAAmB/Q,KACxD,MAAMgR,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OAChEkT,EAAWlC,EAAY3H,OAC7B,OAAI6J,EAAW,EACNpI,GAAUkG,EAAYkC,EAAW,IAEnC,IAAI,EAMAC,GAAwB,CAACpC,EAAmB/Q,KACvD,GAAY,MAAR+Q,EAAc,CAChB,MAAMqC,EAAmBrC,EAAK4B,cAC5B,6BAA6B3S,OAE/B,GAAwB,MAApBoT,EAA0B,CAC5B,MAAMC,EAAgB3C,GAAY0C,GAClC,MAAsB,WAAlBC,GAAgD,WAAlBA,EACzB,CAAE3Q,UAAW6O,GAAa6B,GAAmB5G,KAAM6G,GAC/B,WAAlBA,EACF,CAAE7G,KAAM,UAEV,CACL5J,OAAQkI,GAAUsI,GAClB1Q,UAAW6O,GAAa6B,GACxB5G,KAAM,OAET,CACF,CACD,OAAO,IAAI,EAMA8G,GAAgB,CAACvC,EAAmB/Q,IACnC,MAAR+Q,GACKA,EAAKE,iBAAiB,+BAA+BjR,OAAaqJ,OAAS,EAQzEkK,GAAiB,CAACxC,EAAmB/Q,IACpC,MAAR+Q,GACKA,EAAKE,iBAAiB,8BAA8BjR,OAAaqJ,OAAS,EC1QrE,SAAAmK,GACdzC,EACA/Q,EACA4K,EACA6I,EACAC,EACAC,GAEA,IAAI/Q,EACAuO,EACJ,GAAyB,SAArBwC,GAAYnH,KAAiB,CAC/B5J,EAAS+Q,EAAW/Q,OACpB,MAAMgR,EAAoBxB,GAAmBrB,EAAM/Q,EAAS2T,GACnC,MAArBC,IACFzC,EAAayC,EAAkB5B,cAElC,MACCpP,EAASuP,EAAYA,aAACuB,EAAe,4BAA4B1T,OACnD,MAAV4C,IACFuO,EAAauC,EAAczB,QAAQ,4BAA4BjS,QAGnE,GAAc,MAAV4C,GAAgC,MAAduO,EAAoB,CACxC,MAAMtO,EAAWqO,GAAyBH,EAAM/Q,EAASmR,GACzD,GAAgB,MAAZtO,EAAkB,CAMpB,OADA4Q,EAAY,CAAE1H,QAJK,CACjB9C,IAAKrG,EACLgI,KAAMA,EAAK/H,IAEsB2F,OAAQkL,KACpC,CACR,CACF,CACD,OAAO,CACT,CCmFA,MAAMG,GAAqB,CACzB9C,EACA/Q,EACAmR,EACA2C,EACAC,EACAC,KAEA,MAAMC,EF2D4B,EAAClD,EAAmB/Q,KACtD,MAAMkU,EAAmBnD,EAAK4B,cAC5B,8BAA8B3S,OAEhC,OAA2B,MAApBkU,EAA2BA,EAAiBpB,wBAAwB/Q,OAAS,CAAC,EE/DnEoS,CAAqBpD,EAAM/Q,GACvCoU,EAAexB,GAAwB7B,EAAM/Q,GAC7CqU,EAAuBC,GAC3BnD,EACA2C,EACAG,EACAG,EACAL,GAEIQ,EAAkBF,EAAqBG,IACvCC,EAAiBF,GAAmB,EACpCG,EAAqBL,EAAqBM,OAC1CC,EAAoBF,GAAsB,EAG5CD,GAAkBG,IAGN,MAAZZ,GAAiC,WAAbA,EAGlBY,EACEC,KAAKC,IAAIP,GAAmBM,KAAKC,IAAIJ,GACvCZ,EAAgBiB,UAAYC,GAC1BlB,EAAgBiB,UAAYL,GAC5B,GAGFZ,EAAgBiB,UAAYC,GAC1BlB,EAAgBiB,UAAYR,GAC5B,GAGKE,IACLI,KAAKC,IAAIJ,GAAsBG,KAAKC,IAAIP,GAC1CT,EAAgBiB,UAAYC,GAC1BlB,EAAgBiB,UAAYR,GAC5B,GAGFT,EAAgBiB,UAAYC,GAC1BlB,EAAgBiB,UAAYL,GAC5B,IAKNZ,EAAgBiB,UADM,QAAbf,EACmBgB,GAC1BlB,EAAgBiB,UAAYR,GAC5B,GAG0BS,GAC1BlB,EAAgBiB,UAAYL,GAC5B,GAEH,EAOGM,GAAoB,CAACrO,EAAesO,IAGjCA,EAASJ,KAAKK,KAAKvO,GAASkO,KAAKM,MAAMxO,GAM1CyO,GAA6B,CACjCzE,EACAmD,EACAuB,EACAC,EACAC,EACApR,KAEA,MAAMqR,EAAc7E,EAAQmC,wBACtB2C,EAAe3B,EAAgBhB,wBAErC,OAAI3O,EACK,CACLuR,KAAMD,EAAaC,KAAOF,EAAYE,KAAOJ,EAAYC,EACzDI,MAAOH,EAAYG,MAAQF,EAAaE,MAAQN,GAG3C,CACLK,KAAMD,EAAaC,KAAOF,EAAYE,KAAOL,EAC7CM,MAAOH,EAAYG,MAAQF,EAAaE,MAAQL,EAAYC,EAE/D,EAMUjB,GAA2B,CACtC3D,EACAmD,EACAG,EACAG,EACAL,KAEA,MAAMyB,EAAc7E,EAAQmC,wBACtB2C,EAAe3B,EAAgBhB,wBAErC,MAAO,CACL0B,IAAKiB,EAAajB,IAAMgB,EAAYhB,IAAMP,EAC1CU,OAAQa,EAAYb,OAASc,EAAad,OAASP,EAAeL,EACnE,EAMG,SAAU6B,GACd7E,EACAhK,EACA8O,EACA1R,EACA2R,GAEA,MAAM5L,EAwBR,SACE6G,EACAhK,EACA8O,EACAE,GAEA,GAAsB,MAAlBA,EAAwB,CAC1B,IAAIrT,EACAsT,GAAY,EAChB,GAAgC,MAA5BD,EAAerT,UAEjBsT,GAAY,EACZtT,EAAYqT,EAAerT,eACtB,GAA8B,MAA1BqT,EAAeE,SAAuC,MAApBF,EAAe7L,EAAW,CAErE8L,GAAY,EAMZtT,EALwCwT,GACtCnF,EACAhK,EACA8O,GAE0CnT,SAC7C,CACD,GAAIsT,GACF,GAAiB,MAAbtT,EAAmB,CACrB,IAAIwH,EAAI,EACR,IAAK,IAAIP,EAAI,EAAGA,EAAIkM,EAAiBxM,OAAQM,IAAK,CAChD,GAAI5C,EAAa4C,GAAGV,MAAQvG,EAC1B,OAAOwH,GAA+B,MAA1B6L,EAAeE,QAAkBF,EAAeE,QAAU,GAE/B,UAArClP,EAAa4C,GAAGhD,MAAMyC,aACxBc,GAAK2L,EAAiBlM,GAEzB,CACF,OACI,GAAwB,MAApBoM,EAAe7L,EACxB,OAAO6L,EAAe7L,CAEzB,CAED,MACF,CAjEYiM,CACRpF,EACAhK,EACA8O,EACAC,GAEF/E,EAAKqF,WAAkB,MAALlM,EAAa/F,GAAS+F,EAAIA,EAAK,CACnD,UAKgBmM,GACdtF,EACA/Q,EACAsW,GAEA,MAAMC,EAqDR,SACExF,EACA/Q,EACA+V,GAEA,GAAsB,MAAlBA,EAAwB,CAC1B,IAAInT,EACA4T,GAAS,EAUb,GAT6B,MAAzBT,EAAenT,QAEjB4T,GAAS,EACT5T,EAASmT,EAAenT,QACW,MAA1BmT,EAAeU,SAAuC,MAApBV,EAAeQ,IAE1DC,GAAS,EACT5T,EAAS8T,GAA0B3F,EAAM/Q,GAAS4C,QAEhD4T,GACF,GAAc,MAAV5T,EAAgB,CAClB,IAAI2T,EAAI,EACR,MAAMvF,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,IAAK,IAAI2J,EAAI,EAAGA,EAAIqH,EAAY3H,OAAQM,IAAK,CAC3C,GAAI/G,IAAWkI,GAAUkG,EAAYrH,IACnC,OAAO4M,GAA+B,MAA1BR,EAAeU,QAAkBV,EAAeU,QAAU,GAExEF,GAAKvF,EAAYrH,GAAGmJ,wBAAwB/Q,MAC7C,CACF,OACI,GAAwB,MAApBgU,EAAeQ,EACxB,OAAOR,EAAeQ,CAEzB,CAED,MACF,CAvFYI,CAAgC5F,EAAM/Q,EAASsW,GACzDvF,EAAKgE,UAAiB,MAALwB,EAAYA,EAAI,CACnC,CA2FM,SAAUL,GACdnF,EACAhK,EACA8O,EACAe,GAGA,MAAMR,EAAavB,KAAKC,IAAqB,MAAjB8B,EAAwB7F,EAAKqF,WAAaQ,GAEhEb,EAAmD,CACvD7L,EAAGkM,EACH1T,eAAWsG,EACXiN,aAASjN,GAGX,IAAI6N,EAAY,EAChB,GAAI9P,EAAasC,OAAS,GACL,IAAf+M,EAGF,OAFAL,EAAerT,UAAYqE,EAAa,GAAGkC,IAC3C8M,EAAeE,QAAU,EAClBF,EAGX,IAAK,IAAIpM,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAIvC,GAHyC,UAArC5C,EAAa4C,GAAGhD,MAAMyC,aACxByN,GAAahB,EAAiBlM,IAE5ByM,EAAaS,EAAW,CAC1Bd,EAAerT,UAAYqE,EAAa4C,GAAGV,IAC3C8M,EAAeE,QAAUJ,EAAiBlM,GAAKyM,EAAaS,EAC5D,KACD,CAEH,OAAOd,CACT,UAMgBW,GACd3F,EACA/Q,EACA8W,GAGA,MAAM/B,EAAYF,KAAKC,IAAoB,MAAhBgC,EAAuB/F,EAAKgE,UAAY+B,GAE7Df,EAAiD,CACrDQ,EAAGxB,EACHnS,YAAQoG,EACRyN,aAASzN,GAGX,IAAI+N,EAAY,EAChB,MAAM/F,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,GAAIgR,EAAY3H,OAAS,GACL,IAAd0L,EAGF,OAFAgB,EAAenT,OAASkO,GAAqBC,EAAM/Q,EAAS,GAC5D+V,EAAeU,QAAU,EAClBV,EAGX,IAAK,IAAIpM,EAAI,EAAGA,EAAIqH,EAAY3H,OAAQM,IAAK,CAC3C,MAAMqN,EAAYhG,EAAYrH,GAAGmJ,wBAAwB/Q,OAEzD,GADAgV,GAAaC,EACTjC,EAAYgC,EAAW,CACzBhB,EAAenT,OAASkO,GAAqBC,EAAM/Q,EAAS2J,GAC5DoM,EAAeU,QAAUO,EAAYjC,EAAYgC,EACjD,KACD,CACF,CACD,OAAOhB,CACT,UAEgBkB,GACdlG,EACA/Q,EACA+G,EACAmQ,EACAC,EACAhT,EACA0R,EACA5K,GAEA,MAAMmM,EAAWnM,GAAgBmM,YAAcrG,EAC/C,GAA+B,SAA3BoG,EAAa9E,KAAK7F,KAAiB,CACrC,MAAM2E,EAAakG,EAAAA,iBACjBtG,EACAoG,EAAa9E,KAAKzP,OAClB,4BAA4B5C,OAEZ,MAAdmR,GACF0C,GACE9C,EACA/Q,EACAmR,EACAiG,EACAF,EAAWI,UAAaJ,EAAWK,cACnCJ,EAAaK,UAGlB,CACD,MAAM/F,EAAcW,GAAmBrB,EAAM/Q,EAASmX,EAAa9E,MAChD,MAAfZ,GAncN,SACEgG,EACA3D,EACA/M,EACAwO,EACApR,EACA0R,EACA7B,GAEA,MAAMtR,EAAY6O,GAAakG,GAE/B,IAAI9U,EACJ,IAAK,IAAIgH,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACvC,GAAI5C,EAAa4C,GAAGV,MAAQvG,EAAW,CACrCC,EAAcgH,EACd,KACD,CAEH,GAAmB,MAAfhH,GAA2C,MAApBkT,EAA0B,CACnD,IAAIR,EAAc,EACdC,EAAY,EAEhB,MAAMoC,EAAqBC,GAAwB5Q,GAAc,GACjE,IAAK,IAAI4C,EAAI,EAAGA,EAAI+N,EAAmBrO,OAAQM,IAAK,CAClD,MAAMiO,EAAcF,EAAmB/N,GACvC,KAAIiO,EAAcjV,GAGhB,MAFA0S,GAAeQ,EAAiB+B,EAInC,CACD,MAAMC,EAAmBF,GAAwB5Q,GAAc,GAC/D,IAAK,IAAI4C,EAAIkO,EAAiBxO,OAAS,EAAGM,GAAK,EAAGA,IAAK,CACrD,MAAMiO,EAAcC,EAAiBlO,GACrC,KAAIiO,EAAcjV,GAGhB,MAFA2S,GAAaO,EAAiB+B,EAIjC,CAED,MAAME,EAAyB1C,GAC7BqC,EACA3D,EACAuB,EACAC,EACAC,EACApR,GAEI4T,EAAmBD,EAAuBpC,KAC1CsC,EAAkBD,GAAoB,EACtCE,EAAoBH,EAAuBnC,MAC3CuC,EAAmBD,GAAqB,EAG9C,GAAID,GAAmBE,EACrB,OAGc,MAAZlE,GAAiC,WAAbA,EAGlBgE,EACEnD,KAAKC,IAAImD,GAAqBpD,KAAKC,IAAIiD,GACzCjE,EAAgBsC,WAAapB,GAC3BlB,EAAgBsC,WAAa2B,GAC7B,GAGFjE,EAAgBsC,WAAapB,GAC3BlB,EAAgBsC,WAAa6B,GAC7B,GAGKC,IACLrD,KAAKC,IAAIiD,GAAoBlD,KAAKC,IAAImD,GACxCnE,EAAgBsC,WAAapB,GAC3BlB,EAAgBsC,WAAa6B,GAC7B,GAGFnE,EAAgBsC,WAAapB,GAC3BlB,EAAgBsC,WAAa2B,GAC7B,IAKNjE,EAAgBsC,WADM,UAAbpC,EACoBgB,GAC3BlB,EAAgBsC,WAAa2B,GAC7B,GAG2B/C,GAC3BlB,EAAgBsC,WAAa6B,GAC7B,EAGL,CACH,CAiWIE,CACE1G,EACA2F,EACArQ,EACAmQ,EAAWkB,SAAYlB,EAAWmB,aAClClU,EACA0R,EACAsB,EAAamB,UAGnB,CA+CO,MAAMX,GAA0B,CACrC5Q,EACAwR,KAEA,MAAMC,EAAgB,GAChBC,EAAOF,EAAU,QAAU,MACjC,IAAK,IAAI5O,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACnC5C,EAAa4C,GAAGhD,MAAMyC,aAAeqP,GACvCD,EAAcE,KAAK/O,GAGvB,OAAO6O,CAAa,EAMhBG,GAA2B,CAC/B5H,EACA/Q,EACAmE,EACAxB,EACAiW,EACAL,KAEA,MAAMM,EAAiBN,IAAYpU,IAAYoU,GAAWpU,EAAS,OAAS,QACtE2U,EAAa,GAAGF,MAEC7H,EAAKE,iBAAiB,+BAA+BjR,OACvC2C,GACvBpC,MAAMsY,GAAiBC,EAErC,MAAM9H,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,IAAK,IAAI+Y,EAAI,EAAGA,EAAI/H,EAAY3H,OAAQ0P,IAAK,CACxB/H,EAAY+H,GACC9H,iBAAiB,6BAA6BjR,OAC7C2C,GACrBpC,MAAMsY,GAAiBC,CACpC,CAED,MAAMtG,EAAiBzB,EAAKE,iBAAiB,+BAA+BjR,OAC5E,GAAIwS,EAAenJ,OAAS,EAAG,CACPmJ,EAAe7P,GACvBpC,MAAMsY,GAAiBC,CACtC,YAMaE,GACdjI,EACA/Q,EACAmE,EACA4C,EACA8O,EACAoD,EACA7C,EACA8C,GAEA,GAAInS,EAAasC,OAAS,EAAG,CAC3B,IAAIM,EACAwP,EACJ,MAAMC,EAAoBlD,GACxBnF,EACAhK,EACA8O,EACAO,GAEF,IAAKzM,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACnC,GAAI5C,EAAa4C,GAAGV,MAAQmQ,EAAkB1W,UAAW,CACvDyW,EAAqBxP,EACrB,KACD,CAGH,IAAI0P,EAgBAC,EAbJ,GAAIF,EAAkBlP,GAAM,EAAG,CAC7B,MAAMqP,EAAsB5B,GAAwB5Q,GAAc,GAClE,IAAK4C,EAAI,EAAGA,EAAI4P,EAAoBlQ,OAAQM,IAAK,CAC/C,MAAM6P,EAAeD,EAAoB5P,GACzC,KAAI6P,EAAeL,GAGjB,MAFAE,EAAaG,CAIhB,CACF,CACDC,GAAkB1I,EAAM/Q,EAASmE,EAAO8U,GAAuB,EAAMI,EAAYH,GAGjF,IAAIQ,EAAe,EACnB,MACMC,EADe5I,EAAK6I,YAAc7I,EAAK8I,YACVT,EAAkBlP,EAGrD,GAAIyP,GAAe,EAAG,CACpB,MAAMG,EAAoBnC,GAAwB5Q,GAAc,GAChE,IAAK,IAAI4C,EAAI5C,EAAasC,OAAS,EAAGM,GAAK,EAAGA,IAC5C,IAAsC,IAAlCmQ,EAAkBzI,QAAQ1H,GAC5B2P,EAAW3P,OAGX,GADA+P,GAAgB7D,EAAiBlM,GAC7B+P,EAAeC,EACjB,KAIP,CACDF,GAAkB1I,EAAM/Q,EAASmE,EAAO8U,GAAuB,EAAOK,EAAUJ,EACjF,CACH,CAKA,MAAMO,GAAoB,CACxB1I,EACA/Q,EACAmE,EACA8U,EACAV,EACAwB,EACAb,KAEA,GAAqC,MAAjCD,EAAsB3M,QAAiB,CACzC,MAAM0N,EAAmBzB,EACrBU,EAAsB3M,QAAQ2N,MAC9BhB,EAAsB3M,QAAQ4N,KAC9BF,IAAqBD,GAAab,KACZ,MAApBc,GACFG,GAA0BpJ,EAAM/Q,EAASmE,EAAOoU,GAAS,EAAOyB,GAEjD,MAAbD,GACFI,GAA0BpJ,EAAM/Q,EAASmE,EAAOoU,GAAS,EAAMwB,GAE7DxB,EACFU,EAAsB3M,QAAQ2N,MAAQF,EAEtCd,EAAsB3M,QAAQ4N,IAAMH,EAGzC,GAMGI,GAA4B,CAChCpJ,EACA/Q,EACAmE,EACAoU,EACA6B,EACAL,KAEA,MAAMM,EAAUlW,GAASoU,IAAcpU,IAAUoU,EAC3C+B,EAAeF,EAAQ,MAAQ,SAEdrJ,EAAKE,iBAAiB,+BAA+BjR,OACvC+Z,GACvBQ,UAAUD,GACtBD,EAASG,EAAqBA,sBAACC,eAAiBD,EAAqBA,sBAACE,gBACtEnC,EAAUiC,EAAqBA,sBAACG,gBAAkBH,EAAqBA,sBAACI,eAG1E,MAAM5J,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,IAAK,IAAI+Y,EAAI,EAAGA,EAAI/H,EAAY3H,OAAQ0P,IAAK,CACxB/H,EAAY+H,GACC9H,iBAAiB,6BAA6BjR,OAC7C+Z,GACrBQ,UAAUD,GACpBD,EAASQ,EAAeA,gBAACJ,eAAiBI,EAAeA,gBAACH,gBAC1DnC,EAAUsC,EAAeA,gBAACF,gBAAkBE,EAAeA,gBAACD,cAE/D,CAED,MAAMpI,EAAiBzB,EAAKE,iBAAiB,+BAA+BjR,OAC5E,GAAIwS,EAAenJ,OAAS,EAAG,CACPmJ,EAAeuH,GACvBQ,UAAUD,GACtBD,EAASS,EAAqBA,sBAACL,eAAiBK,EAAqBA,sBAACJ,gBACtEnC,EAAUuC,EAAqBA,sBAACH,gBAAkBG,EAAqBA,sBAACF,cAE3E,GAMUG,GAAoB,CAC/BC,EACAC,IAGEA,GAAU,CACR7D,SAAU,IACD4D,EAAc1O,SC/rBb,SAAA4O,GAAqBC,EAA2BC,GAC9D,OAAa,MAATD,EACc,MAATC,EAEI,MAATA,IAIFD,GAAOvY,SAAWwY,GAAOxY,QACzBuY,GAAOzY,YAAc0Y,GAAO1Y,WAC5ByY,GAAO3O,OAAS4O,GAAO5O,KAE3B,UA8FgB6O,GACdtK,EACA/Q,EACA+G,EACAuU,EACAC,EACAC,EACAC,EACAtX,EACA0R,GAEA,IAAI6F,EACJ,MAAMxJ,EAAWqJ,EAAY/O,KAC7B,GAAiB,WAAb0F,EAAuB,CACzB,MAAMxP,EAAY6Y,EAAY7Y,UAC9B,GAAiB,SAAbwP,EAAqB,CACvB,MAAMyJ,EAAgBJ,EAAY3Y,OAC5BgZ,EAAoBvE,EAAgBA,iBACxCtG,EACA4K,EACA,4BAA4B3b,OAE9B,GAAyB,MAArB4b,EAA2B,CAC7B,MAAMC,EAAqBJ,EACtBG,EAAkBE,uBAClBF,EAAkBG,mBACvB,GAA0B,MAAtBF,EAA4B,CAC9B,MAAMjZ,EAASkI,GAAU+Q,GACX,MAAVjZ,IACF8Y,EAAiB,CAAE9Y,OAAQA,EAAQF,UAAWA,EAAW8J,KAAM,QAC/DgP,EAAoB,CAAE7U,MAAO+U,IAEhC,MAAUD,GACTC,EAAiB,CAAEhZ,UAAW6Y,EAAY7Y,UAAW8J,KAAM,UAC3DgP,EAAoB,CAAE7U,MAAO+U,KACpBnI,GAAexC,EAAM/Q,KAC9B0b,EAAiB,CAAEhZ,UAAW6Y,EAAY7Y,UAAW8J,KAAM,UAC3DgP,EAAoB,CAAE7U,MAAO+U,IAEhC,CACF,MAAM,GAAiB,WAAbxJ,GAA0BuJ,GAY9B,GAAiB,WAAbvJ,GAAyBuJ,EAAY,CAC9C,MAAM7Y,EAASqQ,GAAuBlC,EAAM/Q,GAC9B,MAAV4C,GACF8Y,EAAiB,CAAE9Y,OAAQA,EAAQF,UAAWA,EAAW8J,KAAM,QAC/DgP,EAAoB,CAAE7U,MAAO+U,KACpBpI,GAAcvC,EAAM/Q,IAC7B0b,EAAiB,CAAElP,KAAM,UACzBgP,EAAoB,CAAE7U,MAAO+U,MAE7BA,EAAiB,CAAEhZ,UAAW6Y,EAAY7Y,UAAW8J,KAAM,UAC3DgP,EAAoB,CAAE7U,MAAO+U,IAEhC,MAxBgD,CAC/C,MAAM9Y,EAASmQ,GAAwBhC,EAAM/Q,GAC/B,MAAV4C,GACF8Y,EAAiB,CAAE9Y,OAAQA,EAAQF,UAAWA,EAAW8J,KAAM,QAC/DgP,EAAoB,CAAE7U,MAAO+U,KACpBpI,GAAcvC,EAAM/Q,IAC7B0b,EAAiB,CAAElP,KAAM,UACzBgP,EAAoB,CAAE7U,MAAO+U,KACpBnI,GAAexC,EAAM/Q,KAC9B0b,EAAiB,CAAEhZ,UAAW6Y,EAAY7Y,UAAW8J,KAAM,UAC3DgP,EAAoB,CAAE7U,MAAO+U,IAEhC,CAaF,KAAM,CACL,MAAMM,EAAeC,GAAsBlV,GAAc,GACrD0U,GACFC,EAAiB,CAAEhZ,UAAWsZ,EAAcxP,KAAM,UAClDgP,EAAoB,CAAE7U,MAAO+U,KACpBnI,GAAexC,EAAM/Q,KAC9B0b,EAAiB,CAAEhZ,UAAWsZ,EAAcxP,KAAM,UAClDgP,EAAoB,CAAE7U,MAAO+U,IAEhC,CAGCzE,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QALI,MAAlBoP,EAMA,CAAErJ,KAAMqJ,EAAgBpD,UAAW,SAAUd,UAAW,UAUxD,CAAEnF,KAAMkJ,EAAajD,UAAW,SAAUd,UAAW,UATrDrT,EACA0R,EAaN,UASgBqG,GACdnL,EACA/Q,EACA+G,EACAuU,EACAC,EACAC,EACAC,EACAtX,EACA0R,GAEA,MAAM7E,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,GAAIgR,EAAY3H,OAAS,EAAG,CAC1B,MAAMiN,EAAyBI,GAA0B3F,EAAM/Q,GACzDmc,WHvM8BpL,EAAmB/Q,EAAiB4C,GAC1E,GAAY,MAARmO,EAAc,CAChB,MAAMC,EAAcD,EAAKE,iBAAiB,4BAA4BjR,OACtE,IAAK,IAAI2J,EAAI,EAAGA,EAAIqH,EAAY3H,OAAQM,IACtC,GAAI/G,IAAWkI,GAAUkG,EAAYrH,IACnC,OAAOA,CAGZ,CACD,OAAO,IACT,CG6L6ByS,CAAqBrL,EAAM/Q,EAASsW,EAAuB1T,QACpF,IAAIyZ,EACJ,GAAIZ,EAEAY,EADqC,IAAnC/F,EAAuBG,QACR5B,KAAKyH,IAAIH,EAAoB,EAAG,GAEhCA,MAEd,CACL,MAAM1G,EAAe1E,EAAK+B,wBACpBiB,EACJuH,EAAchP,QAAQgL,UAAagE,EAAchP,QAAQiL,cACrDgF,EACJ9G,EAAad,OAAS/B,GAAwB7B,EAAM/Q,GAAW+T,EAEjE,IADAsI,EAAiBF,EACVnL,EAAY3H,OAASgT,EAAiB,GAAG,CAC9CA,GAAkB,EAElB,GADsBrL,EAAYqL,GAAgBvJ,wBAAwB6B,OACtD4H,EAClB,KAEH,CACF,CACD,MAAMC,EAAY1L,GAAqBC,EAAM/Q,EAASqc,GACtD,GAAiB,MAAbG,EAAmB,CACrB,MAAMd,EAAiB,CACrB9Y,OAAQ4Z,EACR9Z,UAAW6Y,EAAY7Y,UACvB8J,KAAM,QAEJgQ,IAAcjB,EAAY3Y,QAC5B4Y,EAAoB,CAAE7U,MAAO+U,IAE/BzE,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QACd,CAAE+F,KAAMqJ,EAAgBpD,UAAW,SAAUd,UAAWiE,EAAa,SAAW,OAChFtX,EACA0R,EAEH,CACF,CACH,UAgCgB4G,GACd1L,EACA/Q,EACA+G,EACAuU,EACAC,EACAC,EACAC,EACAtX,EACA0R,GAEA,IAAI6F,EACJ,MAAMxJ,EAAWqJ,EAAY/O,KAC7B,GAAiB,WAAb0F,EAAuB,CACzB,MACMwK,EAzCV,SACEC,EACA5V,EACA0U,GAEA,IAAIjC,GAAgB,EACpB,MAAMpP,EAAerD,EAAasC,OAClC,IAAK,IAAIM,EAAI,EAAGA,EAAIS,EAAcT,IAChC,GAAI5C,EAAa4C,GAAGV,MAAQ0T,EAAY,CACtCnD,EAAe7P,EACf,KACD,CAEH,OAAI8R,GAA+B,IAAjBjC,EACTzS,EAAayS,EAAe,GAAGvQ,IAC5BwS,GAAcjC,IAAiBpP,EAAe,EAGnD,KAFErD,EAAayS,EAAe,GAAGvQ,GAG1C,CAsBmB2T,CADIrB,EAAY7Y,UACkBqE,EAAc0U,GACjD,MAAViB,IACe,SAAbxK,GACFwJ,EAAiB,CAAE9Y,OAAQ2Y,EAAY3Y,OAAQF,UAAWga,EAAQlQ,KAAM0F,GACxEsJ,EAAoB,CAAE7U,MAAO+U,MAE7BA,EAAiB,CAAEhZ,UAAWga,EAAQlQ,KAAM0F,GAC5CsJ,EAAoB,CAAE7U,MAAO+U,KAGlC,CAGCzE,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QALI,MAAlBoP,EAMA,CAAErJ,KAAMqJ,EAAgBpD,UAAW,SAAUd,UAAW,UAUxD,CAAEnF,KAAMkJ,EAAajD,UAAW,SAAUd,UAAW,UATrDrT,EACA0R,EAaN,CAKA,SAASoG,GAA+BlV,EAAsC8V,GAC5E,OAAIA,EACK9V,EAAa,GAAGkC,IAElBlC,EAAaA,EAAasC,OAAS,GAAGJ,GAC/C,CAWM,SAAU6T,GACd/L,EACA/Q,EACA+G,EACAuU,EACAC,EACAC,EACAC,EACAsB,EACA5Y,EACA0R,GAEA,IAAI6F,EACJ,MAAMxJ,EAAWqJ,EAAY/O,KAC7B,GAAiB,WAAb0F,EAAuB,CACzB,MAAMyK,EAAapB,EAAY7Y,UACzBga,EAAST,GAAsBlV,EAAc0U,GACnD,GAAIsB,EACF,GAAIzJ,GAAcvC,EAAM/Q,GACtB0b,EAAiB,CACflP,KAAM,UAEH0O,GAAeQ,EAAgBH,IAClCC,EAAoB,CAAE7U,MAAO+U,QAE1B,CACL,MAAMc,EAAYf,EACb1I,GAAwBhC,EAAM/Q,GAC9BiT,GAAuBlC,EAAM/Q,GACjB,MAAbwc,IACFd,EAAiB,CACf9Y,OAAQ4Z,EACR9Z,UAAWga,EACXlQ,KAAM,QAEH0O,GAAeQ,EAAgBH,IAClCC,EAAoB,CAAE7U,MAAO+U,IAGlC,MACQgB,IAAWC,IACH,SAAbzK,GACFwJ,EAAiB,CAAE9Y,OAAQ2Y,EAAY3Y,OAAQF,UAAWga,EAAQlQ,KAAM0F,GACxEsJ,EAAoB,CAAE7U,MAAO+U,MAE7BA,EAAiB,CAAEhZ,UAAWga,EAAQlQ,KAAM0F,GAC5CsJ,EAAoB,CAAE7U,MAAO+U,KAGlC,CAGCzE,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QALI,MAAlBoP,EAMA,CAAErJ,KAAMqJ,EAAgBpD,UAAW,SAAUd,UAAW,UAUxD,CAAEnF,KAAMkJ,EAAajD,UAAW,SAAUd,UAAW,UATrDrT,EACA0R,EAaN,UClcgBmH,GACdjM,EACA/Q,EACA+G,EACAyB,EACAyU,EACArV,EACAsV,EACA9R,GAEA,MAAM+R,EAAY,CAAE5V,KAAK,EAAOC,KAAM,IAAIC,KAC1C,IAAI2V,EAAgC,MAAjBhS,GAAU9C,IAAc8C,EAAS9C,IAAO6U,EACvDE,EAAsC,MAApBjS,GAAU7C,OAAiB6C,EAAS7C,OAAU4U,EAEpE,MAAMX,EAAYrK,EAAAA,aAAa3J,EAAQ,4BAA4BxI,OACnE,GAAiB,MAAbwc,EACyB,WAAvBU,GAAe5U,KAA2C,aAAvB4U,GAAe5U,MAElD8U,EADkB,MAAhBA,EACa,CAAE7V,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAAC+U,KAClCtT,EAAWA,YAACkU,EAAcZ,GAM3BS,EACMK,EAAAA,UAAUF,EAAcZ,GAAW,GAEnC,CAAEjV,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAAC+U,KARxCS,GAA8C,aAAtBC,EAAc5U,IACzBiV,EAAMA,OAACH,EAAcZ,GAErB,CAAEjV,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAAC+U,KAOhDa,EAAkBF,QAEf,GAA8B,WAA1BD,GAAe3U,QAAiD,aAA1B2U,GAAe3U,OAAuB,CACrF,MAAMkJ,EAAcjJ,EAAOyJ,QAAQ,6BAA6BjS,OAChE,GAAmB,MAAfyR,EAAqB,CACvB,MAAMS,EAAWxB,GAAYe,GAC7B,GAAiB,WAAbS,GAAsC,WAAbA,EAAuB,CAClD,MAAMlG,EAAQwF,GACZT,EACA/Q,EACAyR,EACa,WAAbS,GAEF,GAAa,MAATlG,EAAe,CACjB,MAAMzD,EAASxB,EAAaiF,GACI,aAA5BzD,EAAO5B,MAAM8I,aAEb4N,EADqB,MAAnBA,EACgB,CAAE9V,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAACc,EAAOU,OAC5CC,EAAAA,YAAYmU,EAAiB9U,EAAOU,KAMrCgU,EACSK,EAASA,UAACD,EAAiB9U,EAAOU,KAAK,GAEvC,CAAE1B,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAACc,EAAOU,OARlDgU,GAAiD,aAAzBC,EAAc3U,OACtBgV,EAAAA,OAAOF,EAAiB9U,EAAOU,KAE/B,CAAE1B,KAAK,EAAOC,KAAM,IAAIC,IAAI,CAACc,EAAOU,OAO1DmU,EAAeD,EAElB,CACF,CACF,CACF,CAEI1P,EAASA,UAAC2P,EAAchS,GAAU9C,MAASmF,EAAAA,UAAU4P,EAAiBjS,GAAU7C,SACnFX,EACE,CAAEjB,MAAO,CAAE2B,IAAK8U,EAAc7U,OAAQ8U,GAAmB7U,OAAQA,IACjE,EAGN,CAKA,SAASgV,GACPzM,EACA/Q,EACA+G,EACAyB,EACA6Q,EACAC,EACAmE,EACA7V,EACAsV,EACA9R,GAEA,MAAM+R,EAAY,CAAE5V,KAAK,EAAOC,KAAM,IAAIC,KAC1C,IAAI2V,EAAgC,MAAjBhS,GAAU9C,IAAc8C,EAAS9C,IAAO6U,EACvDE,EAAsC,MAApBjS,GAAU7C,OAAiB6C,EAAS7C,OAAU4U,EAEpE,GAAIM,GAEF,GADAJ,EAAkBF,EACS,aAAvBD,GAAe5U,IAGjB,GAFA8U,EAAeD,EAEX9D,GAAcC,EAChB,IAAK,IAAI3P,EAAI0P,EAAY1P,GAAK2P,EAAU3P,IAAK,CAC3C,MAAMV,EAAM6H,GAAqBC,EAAM/Q,EAAS2J,GAChDyT,EAAeG,EAAMA,OAACH,EAAcnU,EACrC,MAED,IAAK,IAAIU,EAAI0P,EAAY1P,GAAK2P,EAAU3P,IAAK,CAC3C,MAAMV,EAAM6H,GAAqBC,EAAM/Q,EAAS2J,GAChDyT,EAAeG,EAAMA,OAACH,EAAcnU,EACrC,OAKL,GADAmU,EAAeD,EACe,aAA1BD,GAAe3U,OAGjB,GAFA8U,EAAkBF,EAEd9D,GAAcC,EAChB,IAAK,IAAI3P,EAAI0P,EAAY1P,GAAK2P,EAAU3P,IAAK,CAC3C,MAAMpB,EAASxB,EAAa4C,GACI,aAA5BpB,EAAO5B,MAAM8I,aACf4N,EAAkBE,EAAAA,OAAOF,EAAiB9U,EAAOU,KAEpD,MAED,IAAK,IAAIU,EAAI0P,EAAY1P,GAAK2P,EAAU3P,IAAK,CAC3C,MAAMpB,EAASxB,EAAa4C,GACI,aAA5BpB,EAAO5B,MAAM8I,aACf4N,EAAkBE,EAAAA,OAAOF,EAAiB9U,EAAOU,KAEpD,CAKFwE,EAASA,UAAC2P,EAAchS,GAAU9C,MAASmF,EAAAA,UAAU4P,EAAiBjS,GAAU7C,SACnFX,EACE,CAAEjB,MAAO,CAAE2B,IAAK8U,EAAc7U,OAAQ8U,GAAmB7U,OAAQA,IACjE,EAGN,CA6HM,SAAUkV,GACd3M,EACA/Q,EACA+G,EACAuU,EACA9S,EACAiT,EACAvQ,EACAyS,EACA/V,EACAzD,EACA0R,EACAqH,EACA9R,GAEA,MAAMwS,EAAqBxL,GAAmBrB,EAAM/Q,EAASkL,GAC7D,GAA0B,MAAtB0S,EAA4B,CAC9B,IAAIvE,EACAwE,EACJ,MAAMC,EAA6B,SAArB5S,EAAYsB,KACpBkF,EAAgC,WAArBxG,EAAYsB,KAQ7B,GAPIsR,GACFD,EAAeD,EAAmB5L,cAClCqH,EAAanI,GAAyBH,EAAM/Q,EAAS6d,KAErDA,EAAeD,EACfvE,EAAa7H,GAAqCT,EAAM/Q,EAAS6d,EAAcnM,IAE/D,MAAd2H,EAAoB,CACtB,IAAIC,EACAyE,EACJ,MAAMC,EAAgBL,EAA6BrR,QAC9B,MAAjB0R,GACFD,EAAkBtC,EACbuC,EAAclC,uBACdkC,EAAcjC,mBACI,MAAnBgC,GACFJ,EAA6BrR,QAAUyR,EACvCzE,EAAWwE,EACP5M,GAAyBH,EAAM/Q,EAAS+d,GACxCvM,GAAqCT,EAAM/Q,EAAS+d,EAAiBrM,IAEzE4H,EAAWwE,EACP5M,GAAyBH,EAAM/Q,EAASge,GACxCxM,GAAqCT,EAAM/Q,EAASge,EAAetM,KAGzEqM,EAAkBtC,EACboC,EAAa/B,uBACb+B,EAAa9B,mBACK,MAAnBgC,GACFJ,EAA6BrR,QAAUyR,EACvCzE,EAAWwE,EACP5M,GAAyBH,EAAM/Q,EAAS+d,GACxCvM,GAAqCT,EAAM/Q,EAAS+d,EAAiBrM,IAEzE4H,EAAWD,GAGC,MAAZC,GACFkE,GACEzM,EACA/Q,EACA+G,EACAyB,EACA6Q,EACAC,EACAwE,EACAlW,EACAsV,EACA9R,GAKJ,MAAM6S,EACoC,MAAxCN,EAA6BrR,QACzBqR,EAA6BrR,QAC7BsR,EACN,IAAIM,EACJ,GAAIJ,EAAO,CACT,MAAMlb,EAASuP,EAAAA,aAAa8L,EAAkB,4BAA4Bje,OAC1Eke,EAAgB,CACd1R,KAAMtB,EAAYsB,KAClB5J,OAAQA,EACRF,UAAWwI,EAAYxI,UAE1B,MACCwb,EAAgBtM,GACdqM,EACAje,EACA,6BAA6BA,OAGjCiX,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QACd,CAAE+F,KAAM6L,EAAe5F,UAAW,SAAUd,UAAW,UACvDrT,EACA0R,EAEH,CACF,CACH,CCzTA,SAASsI,GACPpN,EACA/Q,EACAoe,EACArX,EACAsX,EACAla,GAEA,MAAM+P,EAAmBnD,EAAK4B,cAC5B,8BAA8B3S,OAEhC,GAAwB,MAApBkU,EAA0B,CAC5B,MAAM5B,EAAiB4B,EAAiBjD,iBACtC,+BAA+BjR,OAEjC,GAAIse,EAAsBA,uBAACpK,EAAvBoK,CAAyCF,EAAM5V,QAAwB,CACzE,IAAI2G,GAAgB,EACpB,IAAK,IAAIxF,EAAI,EAAGA,EAAI2I,EAAejJ,OAAQM,IAAK,CAC9C,MACM4U,EADgBjM,EAAe3I,GACNmJ,wBACzB0L,EAAUra,EAAQoa,EAAS7I,KAAO6I,EAAS5I,MACjD,GAAId,KAAKC,IAAI0J,EAAUJ,EAAMK,QAAU,EAAG,CACxC,GAA4C,YAAxC1X,EAAa4C,GAAGhD,MAAM+X,cACxB,MAGFL,EAAc/R,QAAQrD,IAAMlC,EAAa4C,GAAGV,IAC5CiL,EAAiB3T,MAAMoe,OAAS,aAChCxP,GAAgB,EAChBkP,EAAc/R,QAAQ6C,eAAgB,CACvC,CACF,CACIA,IACH+E,EAAiB3T,MAAMoe,OAAS,GAChCN,EAAc/R,QAAQrD,SAAMD,EAC5BqV,EAAc/R,QAAQ6C,eAAgB,EAEzC,MACyB,MAApB+E,IACFA,EAAiB3T,MAAMoe,OAAS,IAElCN,EAAc/R,QAAQrD,SAAMD,EAC5BqV,EAAc/R,QAAQ6C,eAAgB,CAEzC,CACH,CAqCgB,SAAAyP,GACd7N,EACA/Q,EACAoe,EACAS,EACAR,EACAla,EACA2a,GAEA,GAAIT,EAAc/R,QAAQyS,YACF,MAAlBD,EAAwB,CAE1B,IAAK,MAAM3e,KAAeke,EAAc/R,QAAQuJ,kBAGhD,MAAMmJ,EAAajO,EAAK4B,cAAc,+BAA+B3S,OACrE,GAAkB,MAAdgf,EAAoB,CACtB,MAAMC,EAAOD,EAAWlM,wBAClBoM,EAAW/a,EAAQ8a,EAAKtJ,MAAQyI,EAAMe,QAAUf,EAAMe,QAAUF,EAAKvJ,KAE3E2I,EAAc/R,QAAQ8S,MAAQF,EAAWb,EAAc/R,QAAQ+S,OAC/DP,EAAe,CACb7V,IAAKoV,EAAc/R,QAAQrD,IAC3BmW,MAAOf,EAAc/R,QAAQ8S,MAC7BE,gBAAiBT,GAEpB,CACF,CAEHR,EAAc/R,QAAU,CACtByS,YAAY,EACZ5P,cAAekP,EAAc/R,QAAQ6C,cACrCoQ,YAAalB,EAAc/R,QAAQiT,YAEvC,CCzHM,SAAUC,IAAsExE,cACpFA,EAAahb,QACbA,EAAO4K,KACPA,EAAIzG,MACJA,EAAK4C,aACLA,EAAY8X,oBACZA,EAAmBvD,cACnBA,EAAa+C,cACbA,EAAapF,sBACbA,EAAqBwG,gBACrBA,EAAe5J,iBACfA,EAAgB6J,iBAChBA,EAAgBZ,eAChBA,EAAc5T,YACdA,EAAWsQ,oBACXA,EAAmB0B,cACnBA,EAAa9R,SACbA,EAAQxD,kBACRA,EAAiB6L,YACjBA,EAAWvE,cACXA,EAAa7B,sBACbA,IAGA,MAAMsS,EAAoBpU,UAAgB,GAGpCqU,EAAwBrU,EAAAA,SAGxBsU,EAAoBtU,UAAgB,GAGpCuU,EAA+BvU,UAAgB,GAG/CoS,EAA+BpS,EAAAA,SAG/BwU,EAA2BC,EAAAA,SAAQ,IACT,MAAvBxE,EACFnT,IACCyX,EAA6BxT,SAAU,EACvCqR,EAA6BrR,aAAUtD,EACvCwS,EAAoBnT,EAAO,OAE7BW,GACH,CAACwS,IAGEyE,EAAyBD,EAAAA,SAAQ,IACT,MAArBpY,EACH,CAACS,EAAoC6X,KAC9BA,IACHJ,EAA6BxT,SAAU,EACvCqR,EAA6BrR,aAAUtD,GAEzCpB,EAAkBS,EAAO,OAE3BW,GACH,CAACpB,KAGGuY,EAAuBC,EAAmBvV,EAAwBwV,GACvEC,EAAkBA,mBAChBtF,GACCrK,GACQiB,GACLjB,EACA3Q,EACA,6BAA6BA,OAC7B,IAGJkL,EACA6U,EACAN,EACAvE,IAEE3X,GAAc4c,OAAsBnX,IAGnC5B,EAAemZ,GAAkBC,EAAAA,uBAAuBxF,EAAe,CAC5E,UACA,YACA,YACA,aACA,SACA,WACA,OACA,QAMIyF,EAAe3U,eAAasS,IAChCuB,EAAkBrT,QAAiC,MAAvB8R,EAAMsC,aAAqB,GACtD,IAKGC,EAAgB7U,eACnBsS,IACC,MAAM1K,EAAgB0K,EAAM5V,OACC,MAAzBwS,EAAc1O,SAAoC,MAAjBoH,GHrIrC,SACJ3C,EACA/Q,EACA0T,EACA3M,EACAuU,EACAsE,EACAD,EACAG,EACA3b,EACA+G,EACAsQ,EACA3F,GAGA,MAAM+K,GAAyBjB,EAAkBrT,QAGjD,GAFAqT,EAAkBrT,SAAU,EAExByE,IAAS2C,EAAe,CAE1B,GAAqC,MAAjCkM,EAAsBtT,UAAoBwT,EAA6BxT,QACzE,GAAmB,MAAfpB,GACF,GAA2B,MAAvBsQ,EAA6B,CAC/B,MAAMqF,EAAY1N,GAAsBpC,EAAM/Q,GAC7B,MAAb6gB,IACFrF,EAAoB,CAAE7U,MAAOka,IACzBD,GAEF3J,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QACd,CAAE+F,KAAMwO,EAAWvI,UAAW,SAAUd,UAAW,UACnDrT,EACA0R,GAIP,OACQ+K,GAET3J,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QACd,CAAE+F,KAAMnH,EAAaoN,UAAW,SAAUd,UAAW,UACrDrT,EACA0R,GAIN+J,EAAsBtT,aAAUtD,CACjC,MAAM,GAAkC,MAA9B0H,GAAYgD,GAAwB,CAE7C,IAAKoM,EAA6BxT,SAAkC,MAAvBkP,EAA6B,CACxE,MAAMnJ,EAAOT,GACX8B,EACA1T,EACA,6BAA6BA,OAE1Bkb,GAAehQ,EAAamH,KAC/BuN,EAAsBtT,QAAU+F,EAChCmJ,EAAoB,CAAE7U,MAAO0L,KAGZ,MAAfnH,GAAwD,MAAjC0U,EAAsBtT,SAAmBsU,GAClE3J,GACElG,EACA/Q,EACA+G,EACAuU,EAAchP,QACd,CAAE+F,KAAMnH,EAAaoN,UAAW,SAAUd,UAAW,UACrDrT,EACA0R,EAGL,CAED9E,EAAK+P,MAAM,CAAEC,eAAe,GAC7B,CACH,CGoDQC,CACEhG,EAAc1O,QACdtM,EACA0T,EACA3M,EACAuU,EACAsE,EACAD,EACAG,EACA3b,EACA+G,EACA6U,EACAlK,EAEH,GAEH,CACEmF,EACAhb,EACA+G,EACAuU,EACAnX,EACA+G,EACA6U,EACAlK,IAKEoL,EAAsBnV,eACzBsS,IAC8B,MAAzBpD,EAAc1O,SAAuC,MAApBoT,IAC9BrB,EAAc/R,QAAQyS,oBDnFjChO,EACA/Q,EACAoe,EACAS,EACAR,EACAla,EACA0R,EACA6J,GAEA,GAAIrB,EAAc/R,QAAQyS,YAAkC,MAApBlJ,EAA0B,CAChE,MAAMmJ,EAAajO,EAAK4B,cAAc,+BAA+B3S,OACrE,GAAkB,MAAdgf,EAAoB,CACtB,MAAMC,EAAOD,EAAWlM,wBAClBoM,EAAW/a,EAAQ8a,EAAKtJ,MAAQyI,EAAMe,QAAUf,EAAMe,QAAUF,EAAKvJ,KAE3E2I,EAAc/R,QAAQ8S,MAAQF,EAAWb,EAAc/R,QAAQ+S,OAEvC,MAApBK,GACFA,EAAiB,CACfzW,IAAKoV,EAAc/R,QAAQrD,IAC3BmW,MAAOf,EAAc/R,QAAQ8S,MAC7BE,gBAAiBT,GAGtB,CACF,CACH,CCmEUqC,CACElG,EAAc1O,QACdtM,EACAoe,EACAS,EACAR,EACAla,EACA0R,EACA6J,GD3NI,SACd3O,EACA/Q,EACAoe,EACArX,EACAsX,EACAla,GAGAga,GAAqBpN,EAAM/Q,EAASoe,EAAOrX,EAAcsX,EAAela,EAC1E,CCgMUgd,CACEnG,EAAc1O,QACdtM,EACAoe,EACArX,EACAsX,EACAla,GAcL,GAEH,CACE6W,EACAhb,EACA+G,EACA8X,EACAR,EACAla,EACA0R,EACA6J,IAOE0B,EAAsBtV,eACzBsS,IACC,GAA6B,MAAzBpD,EAAc1O,QAAiB,CACjCuT,EAAkBvT,QAAgC,UAAtB8R,EAAMiD,YAClC,IAAIC,GAAuB,EAC3B,MAAM9Y,EAAS4V,EAAM5V,OACS,MAA1ByX,GACiB,MAAf/U,GAAuBkT,EAAMmD,WAC/BD,EF5FN,SACJvQ,EACA/Q,EACAwI,EACA0C,EACAgS,GAEA,MAAMvJ,EAAa/B,GACjBpJ,EACAxI,EACA,6BAA6BA,OAE/B,IAC2B,aAAvBkd,GAAe5U,KAA2C,SAArB4C,EAAYsB,MACtB,aAA1B0Q,GAAe3U,SACQ,WAArB2C,EAAYsB,MAA0C,WAArBtB,EAAYsB,QAClDmH,GAAYnH,OAAStB,EAAYsB,KACjC,CACA,MAAMoR,EAAqBxL,GAAmBrB,EAAM/Q,EAASkL,GACvD0I,EAAoBxB,GAAmBrB,EAAM/Q,EAAS2T,GAC5D,GAA0B,MAAtBiK,GAAmD,MAArBhK,EAA2B,CAE3D,GADmC,SAArBD,GAAYnH,KAExB,OAKO,MAJL0E,GACEH,EACA/Q,EACA4d,EAAmB5L,gBAGnB,MADFd,GAAyBH,EAAM/Q,EAAS4T,EAAkB5B,eAGvD,GAAyB,WAArB2B,GAAYnH,MAA0C,WAArBmH,GAAYnH,KAAmB,CACzE,MAAMkF,EAAgC,WAArBiC,GAAYnH,KAC7B,OAEI,MADFgF,GAAqCT,EAAM/Q,EAAS4d,EAAoBlM,IAEY,MAApFF,GAAqCT,EAAM/Q,EAAS4T,EAAmBlC,EAE1E,CACF,CACF,CACD,OAAO,CACT,CEiDmC8P,CACrBxG,EAAc1O,QACdtM,EACAwI,EACA0C,EACAgS,GAEF4C,EAA6BxT,QAAUgV,GAGtCA,YDjPXvQ,EACA/Q,EACAoe,EACArX,EACA8X,EACAR,EACAla,EACA0R,EACA6J,GAEA,GAAwB,MAApB7J,IAC+B,MAA7BwI,EAAc/R,QAAQrD,KACxBkV,GAAqBpN,EAAM/Q,EAASoe,EAAOrX,EAAcsX,EAAela,GAEzC,MAA7Bka,EAAc/R,QAAQrD,KAAa,CACrC,MAAM+V,EAAajO,EAAK4B,cAAc,+BAA+B3S,OACrE,GAAkB,MAAdgf,EAAoB,CACtB,MAAMC,EAAOD,EAAWlM,wBAClB2O,EAAWtd,EAAQ8a,EAAKtJ,MAAQyI,EAAMe,QAAUf,EAAMe,QAAUF,EAAKvJ,KAErEgM,EAAqB,GAC3B,IAAK,IAAI/X,EAAI,EAAGA,EAAIkM,EAAiBxM,OAAQM,IAAK,CAChD,MAAMxJ,EAAc0V,EAAiBlM,GACrC+X,EAAmBhJ,KAAKvY,EACzB,CAiBD,OAhBAke,EAAc/R,QAAU,CACtByS,YAAY,EACZ5P,eAAe,EACflG,IAAKoV,EAAc/R,QAAQrD,IAC3BoW,OAAQoC,EACRrC,MAAO,EACPvJ,iBAAkB6L,EAClBnC,YAAalB,EAAc/R,QAAQiT,aAEb,MAApBG,GACFA,EAAiB,CACfzW,IAAKoV,EAAc/R,QAAQrD,IAC3BmW,MAAO,EACPE,gBAAiBT,KAGd,CACR,CACF,CAEH,OAAO,CACT,CCqMY8C,CACE3G,EAAc1O,QACdtM,EACAoe,EACArX,EACA8X,EACAR,EACAla,EACA0R,EACA6J,KAGFrB,EAAc/R,QAAQiT,aAAc,EAGzC,IAEH,CACEvE,EACAhb,EACA+G,EACA8X,EACAR,EACAla,EACA+G,EACAgS,EACA+C,EACApK,EACA6J,IAKEkC,EAAoB9V,eACvBsS,IAC8B,MAAzBpD,EAAc1O,SAChBsS,GACE5D,EAAc1O,QACdtM,EACAoe,EACAS,EACAR,EACAla,EACA2a,EAEH,GAEH,CAAC9D,EAAehb,EAAS6e,EAAqBR,EAAela,EAAO2a,IAIhE+C,EAAuB/V,eAC1BgW,IAC8B,MAAzB9G,EAAc1O,kBD1HtByE,EACA/Q,EACAqe,GAEA,IAAKA,EAAc/R,QAAQyS,WAAY,CACrC,MAAM7K,EAAmBnD,EAAK4B,cAC5B,8BAA8B3S,OAER,MAApBkU,IACFA,EAAiB3T,MAAMoe,OAAS,IAElCN,EAAc/R,QAAQ6C,eAAgB,CACvC,CACH,CC8GQ4S,CAA2B/G,EAAc1O,QAAStM,EAASqe,EAC5D,GAEH,CAACrD,EAAehb,EAASqe,IAIrB2D,EAAuBlW,eAC1BsS,IAC8B,MAAzBpD,EAAc1O,SDjHR,SACdyE,EACA/Q,EACAoe,EACAS,EACAR,EACAla,EACA2a,GAIIT,EAAc/R,QAAQyS,YAAgC,IAAlBX,EAAM6D,SAC5CrD,GACE7N,EACA/Q,EACAoe,EACAS,EACAR,EACAla,EACA2a,EAGN,CC4FQoD,CACElH,EAAc1O,QACdtM,EACAoe,EACAS,EACAR,EACAla,EACA2a,EAEH,GAEH,CAAC9D,EAAehb,EAAS6e,EAAqBR,EAAela,EAAO2a,IAKhEqD,EAAgBrW,eACnBsS,IACC,IAAIkD,GAAuB,EAC3B,MAAMc,EAAWC,mBAAiBD,SAC5B5Z,EAAS4V,EAAM5V,OACQ,MAAzBwS,EAAc1O,UACc,MAA1B2T,GAAmC5B,EAAc/R,QAAQiT,cACxC,MAAfrU,GAAuBkT,EAAMmD,WAC/BD,WF/IVvQ,EACA/Q,EACA+G,EACAyB,EACA0C,EACAyS,EACA/V,EACAsV,EACA9R,GAEA,MAAMuI,EAAa/B,GACjBpJ,EACAxI,EACA,6BAA6BA,OAEzB4d,EAAqBxL,GAAmBrB,EAAM/Q,EAASkL,GACvD0I,EAAoBxB,GAAmBrB,EAAM/Q,EAAS2T,GAC5D,GAA0B,MAAtBiK,GAAmD,MAArBhK,IAEL,aAAvBsJ,GAAe5U,KAA2C,SAArBqL,GAAYnH,MACtB,aAA1B0Q,GAAe3U,SACQ,WAArBoL,GAAYnH,MAA0C,WAArBmH,GAAYnH,QAClDmH,GAAYnH,OAAStB,EAAYsB,KACjC,CACA,IAAI6M,EACAC,EACAgJ,EACJ,MAAMxE,EAA6B,SAArBnK,GAAYnH,KAC1B,GAAIsR,EACFwE,EAAa1O,EAAkB5B,cAC/BqH,EAAanI,GACXH,EACA/Q,EACA4d,EAAmB5L,eAErBsH,EAAWpI,GAAyBH,EAAM/Q,EAASsiB,QAC9C,GAAyB,WAArB3O,GAAYnH,MAA0C,WAArBmH,GAAYnH,KAAmB,CACzE,MAAMkF,EAAgC,WAArBiC,GAAYnH,KAC7B8V,EAAa1O,EACbyF,EAAa7H,GACXT,EACA/Q,EACA4d,EACAlM,GAEF4H,EAAW9H,GAAqCT,EAAM/Q,EAAS4T,EAAmBlC,EACnF,CACD,GAAkB,MAAd2H,GAAkC,MAAZC,EAcxB,OAbAqE,EAA6BrR,QAAUgW,EACvC9E,GACEzM,EACA/Q,EACA+G,EACAyB,EACA6Q,EACAC,EACAwE,EACAlW,EACAsV,EACA9R,IAEK,CAEV,CAEH,OAAO,CACT,CE6EmCmX,CACrBvH,EAAc1O,QACdtM,EACA+G,EACAyB,EACA0C,EACAyS,EACAsC,EACA/C,EACA9R,IAGCkW,GACHtE,GACEhC,EAAc1O,QACdtM,EACA+G,EACAyB,GACc,QAAb4Z,EAAqBhE,EAAMoE,QAAUpE,EAAMqE,UAAY5C,EAAkBvT,QAC1E2T,EACA/C,EACA9R,IAKW,MAAfqI,GACQ,MAAR7I,GACA4I,GAAuBwH,EAAc1O,QAAStM,EAAS4K,EAAM6I,EAAajL,IAE1E4V,EAAMsE,mBAGVrE,EAAc/R,QAAQiT,aAAc,CAAK,GAE3C,CACEvE,EACAhb,EACA+G,EACA6D,EACAyT,EACAV,EACAzS,EACAgS,EACA9R,EACA6U,EACAxM,IAMEkP,EAAkB7W,eACrBsS,IACC,MAAMgE,EAAWC,mBAAiBD,SAC5BQ,EAA8D,CAClE,IAAK,SAAU7R,GACgB,MAAzBiK,EAAc1O,UACG,MAAfpB,IACG3H,GAAwC,MAA1B0c,GACjBjD,GACEhC,EAAc1O,QACdtM,EACA+G,EACAqL,GAAmBrB,EAAM/Q,EAASkL,IAClC,EACA+U,EACA/C,EACA9R,GAIa,MAAfqI,GACQ,MAAR7I,GACA4I,GACEwH,EAAc1O,QACdtM,EACA4K,EACA6I,EACA2K,EAAM5V,OACN0C,IAGFkT,EAAMsE,mBAGVtE,EAAMyE,iBAET,EACDC,MAAO,WACwB,MAAzB9H,EAAc1O,UACG,MAAfpB,IAEe,MAAfuI,GACQ,MAAR7I,GACqB,SAArBM,EAAYsB,MACZgH,GACEwH,EAAc1O,QACdtM,EACA4K,EACA6I,EACA2K,EAAM5V,OACN0C,KAKD3H,GACwB,MAAzB8J,GACqB,WAArBnC,EAAYsB,MLjatB,SACJzF,EACArE,EACA2K,EACA6B,GAEA,IAAK,MAAM3G,KAAUxB,EACnB,GAAIwB,EAAOU,MAAQvG,EAAW,CAC5B,GAA8B,YAA1B6F,EAAO5B,MAAMwG,SAAwB,CACvC,IAAIC,EACJ,GAAqB,MAAjB8B,EACF,IAAK,MAAMK,KAAaL,EACtB,GAAIK,EAAUtG,MAAQV,EAAOU,IAAK,CAChCmE,EAAgBmC,EAAUnC,cAC1B,KACD,CAKL,OADAC,EAAsB,CAAC,CAAEpE,IAAKvG,EAAW0K,cADF,cAAlBA,EAAgC,aAAe,gBAE7D,CACR,CACD,KACD,CAEH,OAAO,CACT,CKwYgB2V,CACEhc,EACAmE,EAAYxI,UACZ2K,EACA6B,KATFkP,EAAMsE,kBAeVtE,EAAMyE,iBAET,EACDG,QAAS,SAAUjS,GACY,MAAzBiK,EAAc1O,UACX/I,GAA6B,MAAf2H,GAAmD,MAA5B6U,IAEjB,SAArB7U,EAAYsB,MACZ4R,EAAMmD,UACoB,MAA1BtB,GACuB,aAAvB/C,GAAe5U,IAEfoV,GACE1C,EAAc1O,QACdtM,EACA+G,EACAuU,EACAvK,GACA,EACA7F,EACAyS,EACAsC,EACA9b,EACA0R,EACAqH,EACA9R,GAGFiQ,GACEtK,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACA5b,EACA0R,IAINuI,EAAMyE,iBAET,EACDI,UAAW,SAAUlS,GACU,MAAzBiK,EAAc1O,UACX/I,GAA6B,MAAf2H,GAAmD,MAA5B6U,IAEjB,SAArB7U,EAAYsB,MACZ4R,EAAMmD,UACoB,MAA1BtB,GACuB,aAAvB/C,GAAe5U,IAEfoV,GACE1C,EAAc1O,QACdtM,EACA+G,EACAuU,EACAvK,GACA,EACA7F,EACAyS,EACAsC,EACA9b,EACA0R,EACAqH,EACA9R,GAGFiQ,GACEtK,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACA5b,EACA0R,IAINuI,EAAMyE,iBAET,EACDK,UAAW,SAAUnS,GACU,MAAzBiK,EAAc1O,UACX/I,GAA6B,MAAf2H,GAAmD,MAA5B6U,IAEhB,WAArB7U,EAAYsB,MAA0C,WAArBtB,EAAYsB,OAC9C4R,EAAMmD,UACoB,MAA1BtB,GAC0B,aAA1B/C,GAAe3U,OAkBfkU,GACE1L,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACC5b,EACDA,EACA0R,GAzBF6H,GACE1C,EAAc1O,QACdtM,EACA+G,EACAuU,EACAvK,GACA,EACA7F,EACAyS,EACAsC,EACA9b,EACA0R,EACAqH,EACA9R,IAgBNgT,EAAMyE,iBAET,EACDM,WAAY,SAAUpS,GACS,MAAzBiK,EAAc1O,UACX/I,GAA6B,MAAf2H,GAAmD,MAA5B6U,IAEhB,WAArB7U,EAAYsB,MAA0C,WAArBtB,EAAYsB,OAC9C4R,EAAMmD,UACoB,MAA1BtB,GAC0B,aAA1B/C,GAAe3U,OAkBfkU,GACE1L,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,EACA5b,EACAA,EACA0R,GAzBF6H,GACE1C,EAAc1O,QACdtM,EACA+G,EACAuU,EACAvK,GACA,EACA7F,EACAyS,EACAsC,EACA9b,EACA0R,EACAqH,EACA9R,IAgBNgT,EAAMyE,iBAET,EACDO,OAAQ,SAAUrS,GACXxN,GAA6B,MAAf2H,GAAmD,MAA5B6U,GACxC7D,GACEnL,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACA5b,EACA0R,GAGJuI,EAAMyE,gBACP,EACDQ,SAAU,SAAUtS,GACbxN,GAA6B,MAAf2H,GAAmD,MAA5B6U,GACxC7D,GACEnL,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACA5b,EACA0R,GAGJuI,EAAMyE,gBACP,EACDS,KAAM,SAAUvS,GACTxN,GAA6B,MAAf2H,GAAmD,MAA5B6U,GACxCjD,GACE/L,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACa,QAAbqC,EAAqBhE,EAAMoE,QAAUpE,EAAMqE,QAC3Cte,EACA0R,GAGJuI,EAAMyE,gBACP,EACDU,IAAK,SAAUxS,GACRxN,GAA6B,MAAf2H,GAAmD,MAA5B6U,GACxCjD,GACE/L,EACA/Q,EACA+G,EACAuU,EACApQ,EACA6U,GACA,EACa,QAAbqC,EAAqBhE,EAAMoE,QAAUpE,EAAMqE,QAC3Cte,EACA0R,GAGJuI,EAAMyE,gBACP,GAECW,OAAOhc,KAAKob,GAAaa,SAASrF,EAAMnV,MAAiC,MAAzB+R,EAAc1O,SAChEsW,EAAYxE,EAAMnV,KAAK+R,EAAc1O,QACtC,GAEH,CACE0O,EACAhb,EACA4K,EACAzG,EACAZ,EACAwD,EACAuU,EACAqC,EACA9H,EACA3K,EACA6U,EACA7C,EACA9R,EACA6U,EACAxM,EACAvE,EACA7B,IAKEqW,EAAiB5X,EAAAA,aAAY,KACJ,MAAzBkP,EAAc1O,SAAuC,MAApBuJ,GACnCmD,GACEgC,EAAc1O,QACdtM,EACAmE,EACA4C,EACA8O,EACAoD,EACA+B,EAAc1O,QAAQ8J,WAEzB,GACA,CAAC4E,EAAehb,EAASmE,EAAO4C,EAAckS,EAAuBpD,IAexE,MAAO,CACL8N,wBAd8BC,EAAAA,WAAWxD,EAAmBG,EAAgB,CAC5EsD,OAAQpD,EACRqD,QAASnD,EACToD,cAAe9C,EACf+C,cAAe5C,EACf6C,YAAarC,EACbsC,eAAgBrC,EAChBsC,eAAgBnC,EAChBoC,QAASjC,EACTkC,UAAW1B,EACX2B,SAAUZ,IAKVzD,yBACA7Y,gBACA+Y,wBACAtV,yBACAwV,yBAEJ,CCrvBgB,SAAAkE,GACdC,EACAxkB,EACAykB,EACAC,EACAC,EACA5d,EACA6d,GAEA,GAAIH,EACF,OAwCJ,SACEE,EACA5d,EACA6d,GAEA,MAAMC,EAAwB,EACxBC,EAA2B,IAC3BC,OAA2B/b,EAEjC,IAAIgc,GAAuB,EACvBC,EAAqB,EACrBC,EAAmB,EACnBC,EAAoB,EACxB,MAAMC,EAAuB,GACvBC,EAAqB,GACrBC,EAA0B,GAC1BC,EAAuB,GACvBC,EAA2B,GACjC,IAAK,IAAI7b,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAAK,CAC5C,MAAMpB,EAASxB,EAAa4C,GAC5B,IAAI8b,EAAiBld,EAAO5B,MAAM+e,UACZ,MAAlBD,GAA0BA,GAAkB,KAC9CA,EAAiBX,GAEnB,IAAIa,EAAiBpd,EAAO5B,MAAMif,UACZ,MAAlBD,GAA0BA,EAAiBF,KAC7CE,EAAiBZ,GAEnBK,EAAqB1M,KAAKiN,GAC1B,IAAIE,EAAetd,EAAO5B,MAAMmf,QACZ,MAAhBD,GAAwBA,EAAe,KACzCA,EAAehB,GAEjBQ,EAAmB3M,KAAKmN,GACxB,MAAM1lB,EAAoC,MAAtBykB,EAA6BA,EAAmBrc,EAAOU,UAAOD,EAC/D,MAAf7I,GACF+kB,GAAoB/kB,EACpBglB,GAAqBhlB,EACrBmlB,EAAwB5M,KAAKvY,GAC7BolB,EAAqB7M,KAAKvY,GAC1BqlB,EAAyB9M,KAAKvY,KAE9B6kB,GAAuB,EACvBG,GAAqBM,EACrBR,GAAsBY,EACtBP,EAAwB5M,UAAK1P,GAC7Buc,EAAqB7M,KAAK+M,GAC1BD,EAAyB9M,KAAK+M,GAEjC,CAGGT,GAAwBG,EAAoBR,GAmBlD,SACE5d,EACA4d,EACAM,EACAC,EACAI,EACAD,EACAD,EACAG,EACAC,GAKA,IAAIO,GAAmB,EACvB,KAAOA,GAAkB,CACvBA,GAAmB,EACnBC,GACEjf,EACA4d,EACAM,EACAC,EACAI,EACAD,EACAE,EACAC,GAEF,IAAIL,EAAoB,EACxB,IAAK,IAAIxb,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAAK,CAC5C,GAAkC,MAA9B2b,EAAwB3b,GAAY,CACtC,MAAMic,EAAWR,EAAqBzb,GACtB,MAAZic,GAAoBL,EAAqB5b,GAAKic,IAChDG,GAAmB,EACnBT,EAAwB3b,GAAKic,EAC7BV,GAAoBU,EACpBX,GAAsBI,EAAmB1b,GACzC4b,EAAqB5b,GAAKic,EAC1BJ,EAAyB7b,GAAKic,EAEjC,CACDT,GAAqBI,EAAqB5b,EAC3C,CACDoc,EAAmBA,GAAoBZ,EAAoBR,CAC5D,CACH,CA9DIsB,CACElf,EACA4d,EACAM,EACAC,EACAI,EACAD,EACAD,EACAG,EACAC,GAGJ,OAAOU,GAAoBnf,EAAcwe,EAC3C,CA1GWY,CAA4BxB,EAAgB5d,EAAc6d,GAEnE,IAAIwB,EAAkBC,GACpB7B,EACAxkB,EACA0kB,EACAC,EACA5d,EACA6d,GAEF,IAAwB,IAApBD,EAAuB,CACzB,IAAI2B,EAAa,EACjB,MAAMC,EAAc,GACpB,IAAK,IAAI5c,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAAK,CAC5C,MAAM6c,EAAQJ,EAAgBrf,EAAa4C,GAAGV,KAC9Csd,EAAY7N,KAAK8N,GACjBF,GAAcE,CACf,EA2bL,SACEzV,EACA/Q,EACAumB,EACAD,GAEA,MAAMG,EAAY1V,EAAKE,iBAAiB,uBAAuBjR,OAC/D,IAAK,IAAI2J,EAAI,EAAGA,EAAI8c,EAAUpd,OAAQM,IAAK,CACxB8c,EAAU9c,GAClBpJ,MAAMimB,MAAQ,GAAGD,EAAY5c,MACvC,CACD,MAAM+c,EAAiB3V,EAAKE,iBAC1B,+BAA+BjR,OAC/B,GACF0mB,EAAenmB,MAAMimB,MAAQ,GAAGF,MAChCI,EAAenmB,MAAMomB,YAAc,OACrC,CAxcIC,CAAmBpC,EAAmBxkB,EAASumB,EAAaD,GAC5D3B,EAAiBH,EAAkB5K,YAC/B/E,KAAKC,IAAIwR,EAAa3B,GAAkB,IAC1CyB,EAAkBC,GAChB7B,EACAxkB,EACA0kB,EACAC,EACA5d,EACA6d,GAGL,CACD,OAAOwB,CACT,CA+HA,SAASC,GACP7B,EACAxkB,EACA0kB,EACAC,EACA5d,EACA6d,GAKA,IAAII,GAAuB,EAC3B,MAAM6B,EAAuB,GACvBzB,EAAuB,GACvBE,EAA0B,GAC1BC,EAAuB,GAC7B,IAAK,IAAI5b,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAAK,CAC5C,MAAMpB,EAASxB,EAAa4C,GAC5B,IAAI8b,EAAiBld,EAAO5B,MAAM+e,UACZ,MAAlBD,GAA0BA,GAAkB,KAC9CA,EAZ6Bzc,WAc/B6d,EAAqBnO,KAAK+M,GAC1B,IAAIE,EAAiBpd,EAAO5B,MAAMif,UACZ,MAAlBD,GAA0BA,GAAoC,MAAlBF,EAAyBA,EAAiB,MACxFE,EAhB6B3c,WAkB/Boc,EAAqB1M,KAAKiN,GAC1B,MAAMxlB,EAAoC,MAAtBykB,EAA6BA,EAAmBrc,EAAOU,UAAOD,EAC/D,MAAf7I,GACFmlB,EAAwB5M,KAAKvY,GAC7BolB,EAAqB5b,GAAKxJ,IAE1B6kB,GAAuB,EACvBM,EAAwB5M,UAAK1P,GAEhC,CAGD,GAAIgc,EAAsB,CAGxB,IAAIE,EAAmB,EACnBC,EAAoB,EACpB2B,EAAsB,EACtB7B,EAAqB,EACrB8B,EAAuB,EAC3B,MAAMC,EAAgBtC,EAAuBpY,QACvC2a,EAAwB,GACxBC,EAA2B,GAC3B1B,EAA2B,GACjC,GAAqB,MAAjBwB,EACF,IAAK,IAAIrd,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACvCsd,EAAsBvO,KAAKsO,EAAcG,UAAUpgB,EAAa4C,GAAGV,MACnEie,EAAyBxO,KAAKsO,EAAcI,aAAargB,EAAa4C,GAAGV,UAEtE,CACLyb,EAAuBpY,QAAU,CAC/B6a,UAAW,CAAqB,EAChCC,aAAc,CAAqB,GAErC,MAAM9U,EAAiBkS,EAAkBvT,iBACvC,+BAA+BjR,OAIjC,IAAK,IAAI2J,EAAI,EAAGA,EAAI2I,EAAejJ,OAAQM,IAAK,CAC9C,MAAM0d,EAAsB/U,EAAe3I,GAAmBmJ,wBAAwB0T,MACtFU,EAAyBxO,KAAK2O,GAC9B3C,EAAuBpY,QAAQ8a,aAAargB,EAAa4C,GAAGV,KAAOoe,CACpE,CAED7C,EAAkBjK,UAAU+M,OAAOC,EAAWA,YAACC,iBAC/C,IAAK,IAAI7d,EAAI,EAAGA,EAAI2I,EAAejJ,OAAQM,IAAK,CAC9C,MAAM8d,EAAmBnV,EAAe3I,GAAmBmJ,wBAAwB0T,MACnFS,EAAsBvO,KAAK+O,GAC3B/C,EAAuBpY,QAAQ6a,UAAUpgB,EAAa4C,GAAGV,KAAOwe,CACjE,CACF,CAED,IAAK,IAAI9d,EAAI,EAAGA,EAAIsd,EAAsB5d,OAAQM,IAAK,CACrD,MAAM+d,EAAcpC,EAAwB3b,GAC5C,GAAmB,MAAf+d,EAAqB,CACvB,IAAIvnB,EACJ,MAAMsnB,EAAkBR,EAAsBtd,GACxC+b,EAAWmB,EAAqBld,GAChCic,EAAWR,EAAqBzb,GAEpCxJ,EADc,MAAZulB,GAAoBA,GAAY+B,EACpB/B,EACO,MAAZE,GAAoB6B,GAAmB7B,EAClCA,EAEA6B,EAEhBtC,GAAqBhlB,EAErB,MAAM0lB,EACQ,MAAZH,GAAoBA,GAAYwB,EAAyBvd,GACrD+b,EACAwB,EAAyBvd,GAC/Bud,EAAyBvd,GAAKkc,EAC9BiB,GACc,MAAZlB,GAAoBA,GAAYC,EAAeD,EAAWC,EAC5DZ,GAAsBY,EACtBkB,GAAwBlB,EAAe1lB,EAEvColB,EAAqB5b,GAAKxJ,EAC1BqlB,EAAyB9M,KAAKvY,EAC/B,MACC+kB,GAAoBwC,EACpBvC,GAAqBuC,EACrBZ,GAAuBY,EACvBlC,EAAyB9M,KAAKgP,EAEjC,EAEuB,IAApB/C,IACFA,EAAiBmC,GAEf3B,EAAoBR,GAuB5B,SACE5d,EACA4d,EACAmC,EACAC,EACA9B,EACA0C,EACAzC,EACAI,EACAD,EACAD,EACAG,EACAC,GAKA,IAAIO,GAAmB,EACvB,KAAOA,GAAkB,CACvBA,GAAmB,EACfe,EAAsBnC,EACxBiD,GACE7gB,EACA4d,EAAiBgD,EACjBZ,EACA1B,EACAC,EACAC,EACAC,GAGFQ,GACEjf,EACA4d,EACAM,EACAC,EACAI,EACAD,EACAE,EACAC,GAIJ,IAAIL,EAAoB,EACxB,IAAK,IAAIxb,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IAAK,CAC5C,GAAkC,MAA9B2b,EAAwB3b,GAAY,CACtC,MAAMic,EAAWR,EAAqBzb,GACtB,MAAZic,GAAoBL,EAAqB5b,GAAKic,IAChDG,GAAmB,EACnBT,EAAwB3b,GAAKic,EAC7BV,GAAoBU,EACpB+B,GAA4B/B,EAAWJ,EAAyB7b,GAChEsb,GAAsBI,EAAmB1b,GACzC4b,EAAqB5b,GAAKic,EAC1BJ,EAAyB7b,GAAKic,EAEjC,CACDT,GAAqBI,EAAqB5b,EAC3C,CACDoc,EAAmBA,GAAoBZ,EAAoBR,CAC5D,CACH,CAnFMkD,CACE9gB,EACA4d,EACAmC,EACAC,EACA9B,EACAE,EACAD,EACAI,EACA4B,EACA9B,EACAG,EACAC,EAGL,CACD,OAAOU,GAAoBnf,EAAcwe,EAC3C,CAuEA,SAASqC,GACP7gB,EACA+gB,EACAf,EACA1B,EACAC,EACAC,EACAC,GAEA,GAAIsC,EAAoB,EAAG,CACzB,IAAInD,EAAiBmD,EACjBC,EAAqBhB,EACzB,IAAK,IAAIpd,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACvC,GAAIoe,EAAqB,GAAmC,MAA9BzC,EAAwB3b,GAAY,CAChE,MAAMqe,EAAgB3C,EAAmB1b,GAAK6b,EAAyB7b,GACjEse,EAAeD,EAAgBD,EAAsBpD,EAC3DY,EAAqB5b,GAAKse,EAAczC,EAAyB7b,GACjEgb,GAAkBsD,EAClBF,GAAsBC,CACvB,CAEJ,CACH,CAKA,SAAShC,GACPjf,EACA4d,EACAuD,EACAhD,EACAI,EACAD,EACAE,EACAC,GAEA,MAAM2C,EAA4B,GAClC,IAAIC,GAAmB,EACvB,KAAOA,GAAkB,CACvBA,GAAmB,EACnB,IAAIL,EAAqBG,EACrBG,EAAY1D,EAAiBO,EACjC,GAAImD,EAAY,EACd,IAAK,IAAI1e,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACvC,GACEoe,EAAqB,GACS,MAA9BzC,EAAwB3b,IACQ,MAAhCwe,EAA0Bxe,GAC1B,CACA,MAAMqe,EAAgB3C,EAAmB1b,GACnC2e,EAAYN,EAAgBD,EAAsBM,EAGlD3C,EAAWF,EAAyB7b,GAC1C,GAAI2e,EAAW5C,EAAU,CAEvByC,EAA0Bxe,GAAK+b,EAC/BR,GAAoBQ,EACpBH,EAAqB5b,GAAK+b,EAC1B0C,GAAmB,EACnBF,GAAeF,EACf,KACD,CACDzC,EAAqB5b,GAAK2e,EAC1BD,GAAaC,EACbP,GAAsBC,CACvB,CAGN,CACH,CAKA,SAAS9B,GACPnf,EACA9G,GAEA,MAAMsoB,EAAe,CAAA,EACrB,IAAK,IAAI5e,EAAI,EAAGA,EAAI5C,EAAasC,OAAQM,IACvC4e,EAAaxhB,EAAa4C,GAAGV,KAAOhJ,EAAkB0J,GAExD,OAAO4e,CACT,CCzWA,MAAMC,GAAmB,CACvBlgB,IAAK,CAAEf,KAAK,EAAOC,KAAM,IAAIC,KAC7Bc,OAAQ,CAAEhB,KAAK,EAAOC,KAAM,IAAIC,MAOrBghB,GAAQC,EAAAA,YAAW,UAE5B,aAAcC,EACd,kBAAmBC,EAAcje,wBACjCA,EAAuBke,QACvBA,EAAOC,YACPA,EAAWP,aACXA,EAAYQ,OACZA,EAAS,WAAUne,KACnBA,EAAIE,UACJA,EAASC,QACTA,GAAU,EAAKC,WACfA,EAAa,SAAQE,YACrBA,EAAWsQ,oBACXA,EAAmBrQ,kBACnBA,EAAiB6d,UACjBA,EAAS9L,cACTA,EAAa9R,SACbA,EAAWod,GAA2D5gB,kBACtEA,EAAiB6L,YACjBA,EAAWvE,cACXA,EAAa7B,sBACbA,EAAqB4b,iCACrBA,EAAgCC,+BAChCA,EAA8BC,wBAC9BA,EAAuBzJ,iBACvBA,EAAgBZ,eAChBA,EAAczT,eACdA,EAAc+d,OACdA,GAEFC,GAEA,MAAMrpB,EAAUuG,EAAAA,QACVyU,EAAgBzP,SAAuB,MACvC+P,EAAgB/P,EAAMA,OAAa,CAAE+d,iBAAiB,KACrDzK,EAAqB0K,GAA0BxoB,EAAQA,YACvDwW,EAAeiS,GAAoBzoB,EAAQA,WAC5C0oB,EAAsBle,UAAgB,GACtCmZ,GAAyBnZ,EAAAA,SACzBme,GAA8Bne,EAAAA,SAC9Boe,GAA4Bpe,EAAAA,SAE5B0N,GAAwB1N,EAAAA,OAAyC,CACrE0O,WAAOjR,EACPkR,SAAKlR,IAGDqV,GAAgB9S,EAAAA,OAA4B,CAChDwT,YAAY,EACZ5P,eAAe,EACfoQ,aAAa,KAGTqK,UAAEA,IAAcC,EAAAA,UAChB1lB,GAAsB,QAAdylB,GACRE,GAAcC,YAAUX,GAExBriB,GAAeiZ,EAAAA,SAAQ,KAC3B,MAAMgK,EAAkB,GACxB,GAAmB,MAAflB,EACF,IAAK,MAAM7f,KAAO6f,EACI,MAAhBD,EAAQ5f,IACV+gB,EAAgBtR,KAAK,CACnBzP,IAAKA,EACLtC,MAAOkiB,EAAQ5f,UAKrB,IAAK,MAAOA,EAAKtC,KAAU6c,OAAOyG,QAAQpB,GACxCmB,EAAgBtR,KAAK,CACnBzP,IAAKA,EACLtC,MAAOA,IAIb,OAAOqjB,CAAe,GACrB,CAAClB,EAAaD,IAEjB,IAAIqB,IAAmB,EACvB,MAAMjqB,GAAoB,GAC1B,GAA2B,MAAvB4e,EACF,IAAK,IAAIlV,EAAI,EAAGA,EAAI5C,GAAasC,OAAQM,IAAK,CAC5C,MAAMV,EAAMlC,GAAa4C,GAAGV,IACtBkhB,EAAetL,EAAoB5V,GACnCmhB,EAA8B,MAAhB7B,EAAuBA,EAAatf,QAAOD,EAC/D,GAAoB,MAAhBmhB,GAAwC,MAAfC,GAAuBA,IAAgBD,EAAe,CACjFD,IAAmB,EACnB,KACD,CACDjqB,GAAkByY,KAAKyR,EACxB,MAEDD,IAAmB,EAErB,MAAMG,GAAa,CACjBH,iBAAkBA,GAClBjqB,kBAAmBiqB,QAAmBlhB,EAAY/I,IAGpDqqB,EAAmBA,oBACjBjB,GACA,KACS,CACLnT,4BAA6B,IACvBmU,GAAWH,iBACN,GAEFhU,GACL8E,EAAc1O,QACdvF,GACAsjB,GAAWpqB,mBAGfyW,0BAA2B,IACrB2T,GAAWH,iBACN,GAEFxT,GAA0BsE,EAAc1O,QAAUtM,MAI/D,CAACA,EAAS+G,GAAcsjB,GAAWH,iBAAkBG,GAAWpqB,oBAGlE,MAAMwf,GAAkB3T,eACrBZ,IACC,IAAI9G,GAAc,EAClB,GAAyB,WAArB8G,EAAYsB,KACdpI,EAAgC,MAAlBiH,OAEd,IAAK,MAAM9C,KAAUxB,GACnB,GAAIwB,EAAOU,MAAQiC,EAAYxI,UAAW,CACf,SAArBwI,EAAYsB,KACdpI,EAAuC,MAAzBmE,EAAO5B,MAAMjD,SACG,WAArBwH,EAAYsB,KACrBpI,EAA6C,MAA/BmE,EAAO5B,MAAM+I,eACG,WAArBxE,EAAYsB,OACrBpI,EAA6C,MAA/BmE,EAAO5B,MAAM0J,gBAE7B,KACD,CAGL,OAAOjM,CAAW,GAEpB,CAAC2C,GAAcsE,KAGXsY,wBACJA,GAAuB1D,uBACvBA,GAAsB7Y,cACtBA,GAAa+Y,sBACbA,GAAqBtV,uBACrBA,GAAsBwV,uBACtBA,IACEb,GAAsB,CACxBxE,gBACAhb,UACA4K,OACAzG,SACA4C,gBACA8X,oBAAqBA,EACrBvD,gBACA+C,iBACApF,yBACAwG,mBACA5J,iBAAkBwU,GAAWH,sBAAmBlhB,EAAYqhB,GAAWpqB,kBACvEyf,mBACAZ,iBACA5T,cACAsQ,sBACA0B,gBACA9R,WACAxD,oBACA6L,cACAvE,gBACA7B,0BAGFrM,EAAAA,WAAU,KAGmB,MAAzBga,EAAc1O,SACc,MAA5BzB,MACA0f,EAAgBA,iBAACvP,EAAc1O,WAAake,EAAAA,eAAexP,EAAc1O,UAEzE0O,EAAc1O,QAAQwU,MAAM,CAAEC,eAAe,GAC9C,IAIH0J,EAAAA,iBAAgB,KACd/F,GAAuBpY,aAAUtD,EACjCugB,OAAuBvgB,EAAU,GAChC,CAAC6f,IAGJ4B,EAAAA,iBAAgB,KACd,MAAMC,EAAc1P,EAAc1O,QAClC,GACiB,MAAfoe,IACCpP,EAAchP,QAAQgd,iBACvBe,GAAWH,iBACX,CACA,MAAM5D,EACO,UAAXyC,EACIzN,EAAchP,QAAQ8L,SAAWkD,EAAchP,QAAQqe,uBACtD,EACDvE,EAAkB7B,GACtBmG,EACA1qB,EACW,UAAX+oB,EACArE,GACA4B,EACAvf,GACAwhB,GAEFgB,EAAuBnD,EACxB,IACA,CAACpmB,EAAS+G,GAAcwhB,EAAcQ,EAAQsB,GAAWH,mBAG5D,MAAMU,GAA4Brf,EAAAA,SAClCqf,GAA0Bte,QAAWue,IACnC,GAA6B,MAAzB7P,EAAc1O,QAAiB,CACjC,IAAIqY,EACJ,MAAMmG,EAAkBD,EAAME,eAAe,GAAGC,WAC1CC,EAAmBJ,EAAME,eAAe,GAAGG,UAC3CC,EAAcN,EAAMO,cAAc,GAAGJ,WACrCK,EAAeR,EAAMO,cAAc,GAAGF,UAExC5P,EAAchP,QAAQgd,iBACxB3E,EAA4B,UAAXoE,EAAqB+B,GAAmB,EACzDxP,EAAchP,QAAU,CACtBgd,iBAAiB,EACjBjR,aAAcyS,EACd1S,SAAU+S,EACV5T,cAAe0T,EACf3T,UAAW+T,EACXV,sBAAuBQ,EAAcL,EACrCQ,uBAAwBD,EAAeJ,KAGzCtG,EAAiB8E,EAAoBnd,QACjCwe,EACAK,EAAc7P,EAAchP,QAAQqe,sBACxCrP,EAAchP,QAAQ+L,aAAeyS,EACrCxP,EAAchP,QAAQ8L,SAAW+S,EACjC7P,EAAchP,QAAQiL,cAAgB0T,EACtC3P,EAAchP,QAAQgL,UAAY+T,GAEpC,MAAMjF,EAAkB7B,GACtBvJ,EAAc1O,QACdtM,EACW,UAAX+oB,EACArE,GACAC,EACA5d,GACAwhB,GAEFgB,EAAuBnD,GACnB7O,IAAkB0T,GACpBzB,EAAiByB,EAEpB,GAGH,MAAMM,GAA+Bzf,eAAa+e,IAChDD,GAA0Bte,QAASue,EAAM,GACxC,IACHW,EAAiBA,kBAAC,CAAEnC,IAAKrO,EAAeyQ,SAAUF,KAGlDd,EAAAA,iBAAgB,KACd,GAC2B,MAAzBzP,EAAc1O,UACbgP,EAAchP,QAAQgd,iBACN,MAAjB/R,EACA,CACA,MAAMyH,EAAahE,EAAc1O,QAAQqG,cACvC,+BAA+B3S,OAEjC,GAAkB,MAAdgf,EAAoB,CACtB,MAAM0M,EAAsBnU,EAAgByH,EAAWlM,wBAAwB/Q,OAC3E0nB,EAAoBnd,UAAYof,IAClCjC,EAAoBnd,QAAUof,EAC1BA,GACF1Q,EAAc1O,QAAQiO,UAAU+M,OAAOC,EAAWA,YAACoE,kBACnD3Q,EAAc1O,QAAQiO,UAAUqR,IAAIrE,EAAWA,YAACsE,kBAEhD7Q,EAAc1O,QAAQiO,UAAU+M,OAAOC,EAAWA,YAACsE,gBACnD7Q,EAAc1O,QAAQiO,UAAUqR,IAAIrE,EAAWA,YAACoE,mBAGrD,CACF,IACA,CAAC3rB,EAASuX,EAAe3M,EAAMS,EAAgBwT,IAGlD4L,EAAAA,iBAAgB,KAEZf,GAA4Bpd,UAAY2c,GACvCoB,GAAWH,mBAEZtU,GACEoF,EAAc1O,QACdvF,GACAsjB,GAAWpqB,kBACXkE,GACA8kB,GAEFS,GAA4Bpd,QAAU2c,EACvC,GACA,CACDjpB,EACA+G,GACAsjB,GAAWH,iBACXG,GAAWpqB,kBACXgpB,EACA9kB,KAIFsmB,EAAAA,iBAAgB,KAEZd,GAA0Brd,UAAY4c,GACrCmB,GAAWH,mBAEZ7T,GAA0B2E,EAAc1O,QAAUtM,EAASkpB,GAC3DS,GAA0Brd,QAAU4c,EACrC,GACA,CAAClpB,EAASqqB,GAAWH,iBAAkBhB,IAG1CuB,EAAAA,iBAAgB,KACe,MAAzBzP,EAAc1O,SAAoB+d,GAAWH,kBN2BrC,SACdnZ,EACA/Q,EACAmE,EACA4C,EACA8O,EACAoD,EACAC,GAEA,IAAItB,EACAkU,EAAoB,EACpBC,EAAkB,EAEtB,MAAMxS,EAAsB5B,GAAwB5Q,GAAc,GAClE,IAAK,IAAI4C,EAAI,EAAGA,EAAI4P,EAAoBlQ,OAAQM,IAC9CiO,EAAc2B,EAAoB5P,GAClCgP,GAAyB5H,EAAM/Q,EAASmE,EAAOyT,EAAakU,GAAmB,GAC/EA,GAAqBjW,EAAiB+B,GAExC,MAAMkC,EAAoBnC,GAAwB5Q,GAAc,GAChE,IAAK,IAAI4C,EAAImQ,EAAkBzQ,OAAS,EAAGM,GAAK,EAAGA,IACjDiO,EAAckC,EAAkBnQ,GAChCgP,GAAyB5H,EAAM/Q,EAASmE,EAAOyT,EAAamU,GAAiB,GAC7EA,GAAmBlW,EAAiB+B,GAGtCoB,GACEjI,EACA/Q,EACAmE,EACA4C,EACA8O,EACAoD,OACAjQ,EACAkQ,EAEJ,CM9DM8S,CACEhR,EAAc1O,QACdtM,EACAmE,GACA4C,GACAsjB,GAAWpqB,kBACXgZ,IACA,EAEH,GACA,CAACjZ,EAAS+G,GAAcsjB,GAAWH,iBAAkBG,GAAWpqB,kBAAmBkE,KAGtF,MAAQE,QAASC,IAAiBC,EAAAA,kBAAuC0nB,EAAAA,kBAAmB,CAC1FC,YAAa5Q,EAAchP,QAAQgd,gBAAkB,gBAAkB,iBACvEuC,eAAgBpC,EAAoBnd,QAAU,mBAAqB,oBACnEkb,gBACa,aAAXuB,QAA4D/f,IAAnC0b,GAAuBpY,QAC5C,oBACA,uBAGFjI,GAAUlD,EAAAA,WAAW,CAACmD,KACtB6nB,GAAehrB,EAAUA,WAAC,CAACirB,EAAAA,iBAAiB/qB,OAC5CgrB,GAAsBlrB,EAAUA,WAAC,CAACmrB,EAAAA,mBAAmBjrB,OAG3DL,EAAAA,WAAU,KACR,GAA6B,MAAzBga,EAAc1O,SAAkC,MAAfpB,EAAqB,CACxD,MAAMuG,EAAcW,GAAmB4I,EAAc1O,QAAStM,EAASkL,GACpD,MAAfuG,GACFuJ,EAAc1O,QAAQigB,aAAa,wBAAyB9a,EAAYnL,GAE3E,IACA,CAACtG,EAASkL,IAGb,MAAMshB,GAAazlB,GAAa0lB,MAAMlkB,GACE,MAA/BA,EAAO5B,MAAM0J,gBAAqD,MAA3B9H,EAAO5B,MAAMiJ,aAEvD8c,GAAuB,MAAR9hB,OAAe5B,EAAY+B,GAAW,EAAIH,EAAKvB,QAAUmjB,GAAa,EAAI,GAEzF3kB,GAAkBoR,GAAsB3M,SAAS2N,MACjDnS,GAAgBmR,GAAsB3M,SAAS4N,IAE/ClX,GAA+C,YAAxBgmB,GAAW2D,SAClC1pB,GAAmD,WAA1B+lB,GAAW4D,WAEpChpB,GACmB,WAAvBsZ,GAAe5U,KAA2C,aAAvB4U,GAAe5U,IAC9C2G,GACsB,WAA1BiO,GAAe3U,QAAiD,aAA1B2U,GAAe3U,OA6HjDskB,GAAkB/gB,eACrBzD,IAKCykB,EAAyBA,0BACvBzkB,EAAO0kB,eACP1kB,EAAO2kB,iBACP3M,GACD,GAEH,CAACA,KAGG4M,GAAmBnhB,eACtBzD,IACC6kB,EAAAA,2BAA0B,EAAM7kB,EAAO2kB,iBAAkB3M,GAAuB,GAElF,CAACA,KAGG8M,GAAiBrhB,eACpBzD,IACC6kB,EAAAA,2BAA0B,EAAO7kB,EAAO2kB,iBAAkB3M,GAAuB,GAEnF,CAACA,KAGH,OACEjgB,EAAAE,IAAA,MAAA,IACMwpB,GACJT,IAAKrO,EAAa,gBACHjU,GAAasC,OAAM,aACtBsf,EAAS,kBACJC,EAAc,gBAChB8D,MACgB,aAA1BxP,GAAe3U,QAAgD,aAAvB2U,GAAe5U,IACxD,CAAE,wBAAwB,GAC1B,CAAE,EACNhH,MAAO+C,GACP3C,KAAM,OACN8E,SAAU,KACNmd,GACJniB,SAAAoN,EAAAwe,KAACC,EAAYA,aACX,CAAAC,WAAYjB,GACZle,WAAYgS,QAAsBnX,GAClCikB,iBAAkBA,GAClBE,eAAgBA,GAChBN,gBAAiBA,GACjBrrB,SAAA,CAAAoN,EAAAA,KAAA,QAAA,CACEtN,MAAO6qB,GACPzqB,KAAM,eACNnB,MAzEc,MACpB,IAAIgtB,EAAc,GACdC,EAAe,GACnB,GAAKnD,GAAWH,iBASdqD,EAAyB,aAAXxE,EAAwB,eAAiB,iBATvB,CAChC,IAAIzC,EAAa,EACjB,IAAK,IAAI3c,EAAI,EAAGA,EAAI0gB,GAAWpqB,kBAAkBoJ,OAAQM,IACvD2c,GAAc+D,GAAWpqB,kBAAkB0J,GAE7C4jB,EAAc,UAAUjH,2BACzB,CAQD,OAHqB,MAAjB/O,IACFiW,EAAuB,MAAR5iB,GAAgC,IAAhBA,EAAKvB,OAAe,eAAekO,OAAqB,IAElF,GAAGgW,IAAcC,GAAc,EAwDzBC,GACoB,4BAAAztB,YAC3BI,EAAAA,IAACL,MAvJqB,MAC5B,IAAIE,EACJ,GAAKoqB,GAAWH,iBAET,CACLjqB,EAAoB,GACpB,IAAK,IAAI0J,EAAI,EAAGA,EAAI5C,GAAasC,OAAQM,IACvC1J,EAAkB0J,QAAKX,CAE1B,MANC/I,EAAoBoqB,GAAWpqB,kBAOjC,MAAO,CACLD,QAASA,EACTC,kBAAmBA,EACpB,EA0IwBytB,KACnBttB,EAAAE,IAACyO,EAAgB,IAxIG,MAC1B,MAAMxC,EAAe1B,KACfxD,EAA8C,WAAvBkF,GAAcC,KAC3C,MAAO,CACLxM,QAASA,EACT+G,aAAcA,GACd/D,qBAAsBA,GACtBgM,WAAkC,WAAtB9D,GAAasB,KAAoBtB,EAAYxI,eAAYsG,EACrErB,mBAAoByD,EAAS7C,OAC7BjB,gBAAiB8D,EAAS9C,IAC1B2G,yBAA0BA,GAC1BrL,sBAAuBA,GACvByD,qBAAsBA,EACtBO,kBAAmBqY,GACnB/Q,cAAeA,EACf7B,sBAAuBA,EACvBjG,cAAeA,GACfS,gBAAiBA,GACjBC,cAAeA,GACfqH,cAAekP,GAAc/R,QAAQ6C,cACrChL,MAAOA,GACR,EAmHsBwpB,KACjBvtB,MAACsK,EAAS,CAlLd1K,QAASA,EACT4K,KAAMA,EACN7D,aAAcA,GACd4D,wBAAyBA,EACzB3H,qBAAsBA,GACtBC,uBAAwBA,GACxBmI,SAAUA,EACVxH,sBAAuBA,GACvBuD,4BAAoD,WAAvB+V,GAAe5U,IAC5C4C,YAAaA,EACbC,kBAAmBA,EACnBN,uBAAwBA,GACxBzD,cAAeA,GACf0D,UAAWA,EACXC,QAASA,EACTC,WAAYA,EACZK,eAAgBA,EAChBJ,eAAgB8P,GAAkBC,GAClCpT,kBAAmBqY,GACnBpY,gBAAiBA,GACjBC,cAAeA,GACf3D,MAAOA,KA8JH/D,EAAAA,IAAC4P,OAlHmB,MAC1B,MAAMzD,EAAe1B,KACfxD,EAA8C,WAAvBkF,GAAcC,KAC3C,MAAO,CACLxM,QAASA,EACTiQ,WAAYuc,GACZzlB,aAAcA,GACd/D,qBAAsBA,GACtBgM,WAAkC,WAAtB9D,GAAasB,KAAoBtB,EAAYxI,eAAYsG,EACrED,aAAcqC,EAAS7C,OACvB0G,yBAA0BA,GAC1B5H,qBAAsBA,EACtBD,cAAeA,GACfS,gBAAiBA,GACjBC,cAAeA,GACf3D,MAAOA,GACR,EAkGsBypB,QA/FK,MAC5B,GAA+B,MAA3BzE,IAAoCkB,GAAWH,iBAAkB,CACnE,IAAI3Z,EAAW,EACf,IAAK,IAAI5G,EAAI,EAAGA,EAAI5C,GAAasC,OAAQM,IAEvC,GADA4G,GAAY8Z,GAAWpqB,kBAAkB0J,GACrC5C,GAAa4C,GAAGV,MAAQkgB,EAAwBlgB,IAAK,CAClB,MAAjCkgB,EAAwB/J,QAC1B7O,GAAY4Y,EAAwB/J,OAEtC,KACD,CAEH,OAAOhf,EAAAA,IAACkQ,GAAkB,CAACC,SAAUA,EAAUpM,MAAOA,IACvD,CACe,EAmFX0pB,OAIT"}