{"version":3,"file":"OverflowTabBar-339f34cf.js","sources":["../../src/UNSAFE_OverflowTabBar/OverflowTabBar.tsx"],"sourcesContent":["import { ComponentProps, createRef } from 'preact';\nimport { useCallback, useMemo, useRef, useState } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { OverflowTabBarItem, RemovableTabBarItem, TabBar, TabBarItem } from '../UNSAFE_TabBar';\nimport { CloseDetail, Item } from '../UNSAFE_TabBarCommon';\nimport { styles } from './themes/OverflowTabBarStyles.css';\nimport { useDetectHorizontalOverflow } from '../hooks/PRIVATE_useDetectHorizontalOverflow';\n\ntype OverflowTabBarProps<K extends string | number> = {\n  /**\n   * An array of data to render individual tabs\n   */\n  items: Item<K>[];\n  /**\n   * The truncation configuration for tab labels.\n   * 'progressive' will restrict the width of each tab label to allow all tabs to fit if enough space is not available to display all of the tabs.\n   * Labels that are truncated are displayed with ellipses. However the width of each tab label will not be truncated below a specific threshold.\n   * 'none' tabs always take up the space needed by the labels even if enough space is not available to display all of the tabs.\n   */\n  truncation?: 'none' | 'progressive';\n} & Omit<ComponentProps<typeof TabBar>, 'children' | 'aria-describedby' | 'ref'>;\n\n/**\n * OverflowTabBar handles the rendering of overflowing tab items.\n */\nexport function OverflowTabBar<K extends string | number>({\n  items,\n  layout = 'stretch',\n  display = 'standard',\n  size = 'md',\n  edge = 'top',\n  selection,\n  truncation,\n  onSelect,\n  onRemove,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledby,\n  testId\n}: OverflowTabBarProps<K> & TestIdProps) {\n  const displayStackProps = {\n    display: display\n  };\n  const displayNonStackProps = {\n    display: display,\n    size: size\n  };\n\n  const displayProps = display === 'stacked' ? displayStackProps : displayNonStackProps;\n  const rootRef = useRef<HTMLDivElement>(null);\n  const tabBarRef = createRef<HTMLDivElement>();\n\n  const [isDropDownOpen, setIsDropDownOpen] = useState<boolean>(false);\n\n  const isOutsideMouseDown = useRef<boolean>(false);\n\n  const handleClose = (e: CloseDetail) => {\n    if (tabBarRef.current && ['itemAction', 'dismissed'].includes(e.reason)) {\n      tabBarRef?.current?.focus();\n    }\n    if (e.reason === 'outsideMousedown') {\n      isOutsideMouseDown.current = true;\n    }\n    setIsDropDownOpen(false);\n  };\n\n  const handleSelect = useCallback<Required<ComponentProps<typeof TabBar>>['onSelect']>(\n    (e: { value: string | number }) => {\n      if (e.value === 'more') {\n        //If overflow item is clicked after dropdown is open, the reason is outsideMouseDown and it needs to be closed\n        if (isOutsideMouseDown.current) {\n          setIsDropDownOpen(false);\n        } else {\n          setIsDropDownOpen(true);\n        }\n      } else {\n        onSelect?.(e);\n      }\n      isOutsideMouseDown.current = false;\n    },\n    [onSelect]\n  );\n\n  const overflowItemKey = 'more' as K;\n\n  const keysArray = useMemo(() => items.map((item) => item.itemKey) as K[], [items]);\n\n  const { visibleItemKeys, overflowItemKeys, maxWidths } = useDetectHorizontalOverflow({\n    rootRef: tabBarRef,\n    keysArray,\n    isTruncationDisabled: !(truncation && truncation === 'progressive')\n  });\n\n  const overflowTabBarClass = classNames([styles.overflowTabBarBase]);\n\n  return (\n    <div ref={rootRef} class={overflowTabBarClass}>\n      <TabBar\n        ref={tabBarRef}\n        selection={selection}\n        onSelect={handleSelect}\n        {...displayProps}\n        layout={layout}\n        edge={edge}\n        onRemove={onRemove}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledby}\n        testId={testId}>\n        {visibleItemKeys != null &&\n          visibleItemKeys.length > 0 &&\n          items\n            .filter((item) => visibleItemKeys?.includes(item.itemKey))\n            .map((item: Item<K>) =>\n              item.isRemovable ? (\n                <RemovableTabBarItem\n                  itemKey={item.itemKey}\n                  label={item.label}\n                  icon={item.icon}\n                  badge={item.badge}\n                  metadata={item.metadata}\n                  severity={item.severity}\n                  aria-controls={item.tabPanelId}\n                  labelMaxWidth={maxWidths?.get(item.itemKey)}\n                />\n              ) : (\n                <TabBarItem\n                  itemKey={item.itemKey}\n                  label={item.label}\n                  icon={item.icon}\n                  badge={item.badge}\n                  metadata={item.metadata}\n                  severity={item.severity}\n                  aria-controls={item.tabPanelId}\n                  labelMaxWidth={maxWidths?.get(item.itemKey)}\n                />\n              )\n            )}\n        {overflowItemKeys != null && overflowItemKeys.length > 0 && (\n          <OverflowTabBarItem\n            isOpen={isDropDownOpen}\n            onClose={handleClose}\n            overflowItemKey={overflowItemKey}\n            overflowItems={items.filter((item) => overflowItemKeys?.includes(item.itemKey))}\n          />\n        )}\n      </TabBar>\n    </div>\n  );\n}\n"],"names":["items","layout","display","size","edge","selection","truncation","onSelect","onRemove","ariaLabel","ariaLabelledby","testId","displayProps","rootRef","useRef","tabBarRef","createRef","isDropDownOpen","setIsDropDownOpen","useState","isOutsideMouseDown","handleSelect","useCallback","e","value","current","keysArray","useMemo","map","item","itemKey","visibleItemKeys","overflowItemKeys","maxWidths","useDetectHorizontalOverflow","isTruncationDisabled","overflowTabBarClass","classNames","styles","overflowTabBarBase","_jsx","ref","class","children","_jsxs","TabBar","length","filter","includes","isRemovable","RemovableTabBarItem","label","icon","badge","metadata","severity","tabPanelId","labelMaxWidth","get","TabBarItem","OverflowTabBarItem","isOpen","onClose","reason","focus","overflowItemKey","overflowItems"],"mappings":"iXA0B0DA,MACxDA,EAAKC,OACLA,EAAS,UAASC,QAClBA,EAAU,WAAUC,KACpBA,EAAO,KAAIC,KACXA,EAAO,MAAKC,UACZA,EAASC,WACTA,EAAUC,SACVA,EAAQC,SACRA,EACA,aAAcC,EACd,kBAAmBC,EAAcC,OACjCA,IAEA,MAQMC,EAA2B,YAAZV,EARK,CACxBA,QAASA,GAEkB,CAC3BA,QAASA,EACTC,KAAMA,GAIFU,EAAUC,SAAuB,MACjCC,EAAYC,EAAAA,aAEXC,EAAgBC,GAAqBC,EAAQA,UAAU,GAExDC,EAAqBN,UAAgB,GAYrCO,EAAeC,eAClBC,IACiB,SAAZA,EAAEC,MAEAJ,EAAmBK,QACrBP,GAAkB,GAElBA,GAAkB,GAGpBX,IAAWgB,GAEbH,EAAmBK,SAAU,CAAK,GAEpC,CAAClB,IAKGmB,EAAYC,EAAAA,SAAQ,IAAM3B,EAAM4B,KAAKC,GAASA,EAAKC,WAAiB,CAAC9B,KAErE+B,gBAAEA,EAAeC,iBAAEA,EAAgBC,UAAEA,GAAcC,EAAAA,4BAA4B,CACnFrB,QAASE,EACTW,YACAS,uBAAwB7B,GAA6B,gBAAfA,KAGlC8B,EAAsBC,EAAUA,WAAC,CAACC,EAAAA,OAAOC,qBAE/C,OACEC,EAAAA,WAAKC,IAAK5B,EAAS6B,MAAON,EACxBO,SAAAC,EAAAA,KAACC,EAAAA,OACC,CAAAJ,IAAK1B,EACLV,UAAWA,EACXE,SAAUc,KACNT,EACJX,OAAQA,EACRG,KAAMA,EACNI,SAAUA,EACE,aAAAC,EACK,kBAAAC,EACjBC,OAAQA,EAAMgC,SAAA,CACM,MAAnBZ,GACCA,EAAgBe,OAAS,GACzB9C,EACG+C,QAAQlB,GAASE,GAAiBiB,SAASnB,EAAKC,WAChDF,KAAKC,GACJA,EAAKoB,YACHT,MAACU,EAAAA,qBACCpB,QAASD,EAAKC,QACdqB,MAAOtB,EAAKsB,MACZC,KAAMvB,EAAKuB,KACXC,MAAOxB,EAAKwB,MACZC,SAAUzB,EAAKyB,SACfC,SAAU1B,EAAK0B,SAAQ,gBACR1B,EAAK2B,WACpBC,cAAexB,GAAWyB,IAAI7B,EAAKC,WAGrCU,MAACmB,aAAU,CACT7B,QAASD,EAAKC,QACdqB,MAAOtB,EAAKsB,MACZC,KAAMvB,EAAKuB,KACXC,MAAOxB,EAAKwB,MACZC,SAAUzB,EAAKyB,SACfC,SAAU1B,EAAK0B,yBACA1B,EAAK2B,WACpBC,cAAexB,GAAWyB,IAAI7B,EAAKC,aAIxB,MAApBE,GAA4BA,EAAiBc,OAAS,GACrDN,MAACoB,EAAAA,mBACC,CAAAC,OAAQ5C,EACR6C,QApFWvC,IACfR,EAAUU,SAAW,CAAC,aAAc,aAAauB,SAASzB,EAAEwC,SAC9DhD,GAAWU,SAASuC,QAEL,qBAAbzC,EAAEwC,SACJ3C,EAAmBK,SAAU,GAE/BP,GAAkB,EAAM,EA8EhB+C,gBA1Dc,OA2DdC,cAAelE,EAAM+C,QAAQlB,GAASG,GAAkBgB,SAASnB,EAAKC,iBAMlF"}