{"version":3,"file":"useSelection-0c4c6e5c.js","sources":["../../src/hooks/PRIVATE_useVisSelection/useSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useRef } from 'preact/hooks';\n\nexport type SelectionMode = 'none' | 'single' | 'multiple';\nexport type SelectionDetail<K> = {\n  ids: K[];\n};\ntype SelectionBehavior = 'toggle' | 'replace';\n\nconst NAVKEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n/**\n * The constant that defines time to wait to change selection after pointer up is fired.\n * If double click didn't happen\n */\nconst DBLCLICK_THRESHOLD = 250;\n\n/**\n * Compares if two sets are equal.\n */\nconst isEqual = <T>(setA: Set<T>, setB: Set<T>) => {\n  return setA.size === setB.size && [...setA].every((value) => setB.has(value));\n};\n\n/**\n * Handles the selection.\n * @param itemId The id of the item.\n * @param selectedIds The set of selected item ids.\n * @param selectionMode The selection mode.\n * @param selectionBehavior The selection behavior. If 'toggle', unselected item will be selected and\n * vice versa. If 'replace', the item will replace the previous selection.\n * @param onChange The callback to trigger when selection changes.\n */\nconst handleSelect = <K>(\n  itemId: K | undefined,\n  selectedIds: Set<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  onChange?: (detail: SelectionDetail<K>) => void\n) => {\n  let ids = new Set<K>([]);\n  if (itemId != null) {\n    ids = new Set(selectedIds);\n    const isSelected = selectedIds.has(itemId);\n\n    if (selectionBehavior === 'toggle') {\n      if (isSelected) {\n        ids.delete(itemId);\n      } else if (selectionMode === 'single') {\n        ids = new Set([itemId]); // only selection\n      } else {\n        ids.add(itemId); // add to selection in \"multiple\" selectionMode\n      }\n    } else if (!isSelected) {\n      // In \"multiple\" selection mode, only replace selection if unselected item is selected.\n      // In \"single\" selection mode, only need to replace if unselected item is selected.\n      ids = new Set([itemId]);\n    }\n  }\n\n  if (!isEqual(ids, selectedIds)) {\n    onChange?.({ ids: [...ids] });\n  }\n};\n\ntype Props<K> = {\n  selection?: K[];\n  selectionMode?: SelectionMode;\n  idExtracter: (event: Event) => K | undefined;\n  onChange?: (detail: SelectionDetail<K>) => void;\n  isKeyboardSelection?: (event: KeyboardEvent) => boolean;\n  isDrillEnabled?: boolean;\n};\n\n/**\n * The hook to handle the selection behavior in vizualization components.\n */\nexport function useSelection<K>({\n  selection = [],\n  selectionMode = 'none',\n  idExtracter,\n  onChange,\n  isDrillEnabled,\n  isKeyboardSelection\n}: Props<K>) {\n  const setTimeOutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const onPointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (setTimeOutRef.current && isDrillEnabled) {\n        clearTimeout(setTimeOutRef.current);\n        setTimeOutRef.current = undefined;\n        // doubleClick happened\n        return;\n      }\n\n      const key = idExtracter(event);\n      const isMeta = event.metaKey;\n      const isCtrl = event.ctrlKey;\n      // If there was a previous pointerUp event that occurred that should prevent selection,\n      // event.preventDefault was called\n      if (event.defaultPrevented || (key == null && (isMeta || isCtrl))) {\n        return;\n      }\n\n      // TODO: Encorporate more logic of dvt.EventManager.prototype._onClick\n      // this is a simple version of EventManager.prototype._onClick. Currently we are not checking\n      // for event.pageX, event.pageY to determine if they are exactly clicked on the same point.\n      // for now, the assumption is that if the pointerups are within 250ms, they are for a same double click.\n      if (isDrillEnabled) {\n        setTimeOutRef.current = setTimeout(() => {\n          // double pointer up didn't happen\n          handleSelect(\n            key,\n            new Set(selection),\n            selectionMode,\n            isMeta || isCtrl || event.pointerType === 'touch' ? 'toggle' : 'replace',\n            onChange\n          );\n          setTimeOutRef.current = undefined;\n        }, DBLCLICK_THRESHOLD);\n      } else {\n        handleSelect(\n          key,\n          new Set(selection),\n          selectionMode,\n          isMeta || isCtrl || event.pointerType === 'touch' ? 'toggle' : 'replace',\n          onChange\n        );\n      }\n    },\n    [selection, selectionMode, onChange, idExtracter, isDrillEnabled]\n  );\n\n  const onContextMenu = useCallback(\n    (event: MouseEvent) => {\n      const key = idExtracter(event);\n      const isCtrl = event.ctrlKey;\n      handleSelect(key, new Set(selection), selectionMode, isCtrl ? 'toggle' : 'replace', onChange);\n    },\n    [selection, selectionMode, onChange, idExtracter]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      const isShift = event.shiftKey;\n      const isSpaceCtrl = event.ctrlKey && event.key === ' ';\n      const isArrowKey = NAVKEYS.indexOf(event.key) !== -1;\n      const itemKey = idExtracter(event);\n\n      if (isArrowKey || isSpaceCtrl || (isKeyboardSelection && isKeyboardSelection(event))) {\n        const behavior = isShift || isSpaceCtrl ? 'toggle' : 'replace';\n        handleSelect(itemKey, new Set(selection), selectionMode, behavior, onChange);\n      }\n    },\n    [selection, selectionMode, onChange, idExtracter, isKeyboardSelection]\n  );\n\n  return selectionMode === 'none' || onChange == null\n    ? {}\n    : { onKeyUp, onContextMenu, onPointerUp };\n}\n"],"names":["NAVKEYS","handleSelect","itemId","selectedIds","selectionMode","selectionBehavior","onChange","ids","Set","isSelected","has","delete","add","setA","setB","size","every","value","selection","idExtracter","isDrillEnabled","isKeyboardSelection","setTimeOutRef","useRef","onPointerUp","useCallback","event","current","clearTimeout","undefined","key","isMeta","metaKey","isCtrl","ctrlKey","defaultPrevented","setTimeout","pointerType","onContextMenu","onKeyUp","isShift","shiftKey","isSpaceCtrl","isArrowKey","indexOf","itemKey","behavior"],"mappings":"8DAgBA,MAAMA,EAAU,CAAC,UAAW,YAAa,YAAa,cAwBhDC,EAAe,CACnBC,EACAC,EACAC,EACAC,EACAC,KAEA,IAAIC,EAAM,IAAIC,IAAO,IACrB,GAAc,MAAVN,EAAgB,CAClBK,EAAM,IAAIC,IAAIL,GACd,MAAMM,EAAaN,EAAYO,IAAIR,GAET,WAAtBG,EACEI,EACFF,EAAII,OAAOT,GACgB,WAAlBE,EACTG,EAAM,IAAIC,IAAI,CAACN,IAEfK,EAAIK,IAAIV,GAEAO,IAGVF,EAAM,IAAIC,IAAI,CAACN,IAElB,CAtCa,IAAIW,EAAcC,IAwCdX,GAxCAU,EAwCLN,GAvCDQ,OAASD,EAAKC,MAAQ,IAAIF,GAAMG,OAAOC,GAAUH,EAAKJ,IAAIO,MAwCpEX,IAAW,CAAEC,IAAK,IAAIA,IACvB,2BAe6BW,UAC9BA,EAAY,GAAEd,cACdA,EAAgB,OAAMe,YACtBA,EAAWb,SACXA,EAAQc,eACRA,EAAcC,oBACdA,IAEA,MAAMC,EAAgBC,EAAAA,SAEhBC,EAAcC,eACjBC,IACC,GAAIJ,EAAcK,SAAWP,EAI3B,OAHAQ,aAAaN,EAAcK,cAC3BL,EAAcK,aAAUE,GAK1B,MAAMC,EAAMX,EAAYO,GAClBK,EAASL,EAAMM,QACfC,EAASP,EAAMQ,QAGjBR,EAAMS,kBAA4B,MAAPL,IAAgBC,GAAUE,KAQrDb,EACFE,EAAcK,QAAUS,YAAW,KAEjCnC,EACE6B,EACA,IAAItB,IAAIU,GACRd,EACA2B,GAAUE,GAAgC,UAAtBP,EAAMW,YAA0B,SAAW,UAC/D/B,GAEFgB,EAAcK,aAAUE,CAAS,GAxGhB,KA2GnB5B,EACE6B,EACA,IAAItB,IAAIU,GACRd,EACA2B,GAAUE,GAAgC,UAAtBP,EAAMW,YAA0B,SAAW,UAC/D/B,GAEH,GAEH,CAACY,EAAWd,EAAeE,EAAUa,EAAaC,IAG9CkB,EAAgBb,eACnBC,IACC,MAAMI,EAAMX,EAAYO,GAClBO,EAASP,EAAMQ,QACrBjC,EAAa6B,EAAK,IAAItB,IAAIU,GAAYd,EAAe6B,EAAS,SAAW,UAAW3B,EAAS,GAE/F,CAACY,EAAWd,EAAeE,EAAUa,IAGjCoB,EAAUd,eACbC,IACC,MAAMc,EAAUd,EAAMe,SAChBC,EAAchB,EAAMQ,SAAyB,MAAdR,EAAMI,IACrCa,GAA6C,IAAhC3C,EAAQ4C,QAAQlB,EAAMI,KACnCe,EAAU1B,EAAYO,GAE5B,GAAIiB,GAAcD,GAAgBrB,GAAuBA,EAAoBK,GAAS,CACpF,MAAMoB,EAAWN,GAAWE,EAAc,SAAW,UACrDzC,EAAa4C,EAAS,IAAIrC,IAAIU,GAAYd,EAAe0C,EAAUxC,EACpE,IAEH,CAACY,EAAWd,EAAeE,EAAUa,EAAaE,IAGpD,MAAyB,SAAlBjB,GAAwC,MAAZE,EAC/B,CAAE,EACF,CAAEiC,UAASD,gBAAed,cAChC"}