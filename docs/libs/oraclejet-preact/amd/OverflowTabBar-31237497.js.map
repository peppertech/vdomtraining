{"version":3,"file":"OverflowTabBar-31237497.js","sources":["../../src/UNSAFE_OverflowTabBar/OverflowTabBar.tsx"],"sourcesContent":["import { ComponentProps, createRef } from 'preact';\nimport { useCallback, useMemo, useRef, useState } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { OverflowTabBarItem, RemovableTabBarItem, TabBar, TabBarItem } from '../UNSAFE_TabBar';\nimport { CloseDetail, Item } from '../UNSAFE_TabBarCommon';\nimport { styles } from './themes/OverflowTabBarStyles.css';\nimport { useDetectHorizontalOverflow } from '../hooks/PRIVATE_useDetectHorizontalOverflow';\nimport { findElementByKey } from '../utils/PRIVATE_collectionUtils';\n\ntype OverflowTabBarProps<K extends string | number> = {\n  /**\n   * An array of data to render individual tabs\n   */\n  items: Item<K>[];\n} & Omit<ComponentProps<typeof TabBar>, 'children' | 'aria-describedby' | 'ref'>;\n\n/**\n * OverflowTabBar handles the rendering of overflowing tab items.\n */\nexport function OverflowTabBar<K extends string | number>({\n  items,\n  layout = 'stretch',\n  display = 'standard',\n  size = 'md',\n  edge = 'top',\n  selection,\n  onSelect,\n  onRemove,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledby,\n  testId\n}: OverflowTabBarProps<K> & TestIdProps) {\n  const displayStackProps = {\n    display: display\n  };\n  const displayNonStackProps = {\n    display: display,\n    size: size\n  };\n  const itemSelector = '[role=\"tab\"]';\n  const displayProps = display === 'stacked' ? displayStackProps : displayNonStackProps;\n  const rootRef = useRef<HTMLDivElement>(null);\n  const tabBarRef = createRef<HTMLDivElement>();\n\n  const [isDropDownOpen, setIsDropDownOpen] = useState<boolean>(false);\n\n  const isOutsideMouseDown = useRef<boolean>(false);\n\n  const handleClose = (e: CloseDetail) => {\n    if (tabBarRef.current && ['itemAction', 'dismissed'].includes(e.reason)) {\n      tabBarRef?.current?.focus();\n    }\n    if (e.reason === 'outsideMousedown') {\n      isOutsideMouseDown.current = true;\n    }\n    setIsDropDownOpen(false);\n  };\n\n  const handleSelect = useCallback<Required<ComponentProps<typeof TabBar>>['onSelect']>(\n    (e: { value: string | number }) => {\n      if (e.value === 'more') {\n        //If overflow item is clicked after dropdown is open, the reason is outsideMouseDown and it needs to be closed\n        if (isOutsideMouseDown.current) {\n          setIsDropDownOpen(false);\n        } else {\n          setIsDropDownOpen(true);\n        }\n      } else {\n        onSelect?.(e);\n      }\n      isOutsideMouseDown.current = false;\n    },\n    [onSelect]\n  );\n\n  const overflowItemKey = 'more' as K;\n\n  const keysArray = useMemo(() => items.map((item) => item.itemKey) as K[], [items]);\n\n  const getWidth = useCallback(\n    <K extends string | number>(itemKey: K | undefined) => {\n      const elem = findElementByKey(rootRef.current as HTMLElement, itemKey as K, itemSelector);\n      const isLastKey = itemKey === (keysArray[keysArray.length - 1] as string | number);\n      //If it is lastKey we need not account for gap after it\n      const gapBetweenItems = !isLastKey ? 32 : 0;\n      return elem! ? elem.getBoundingClientRect().width + gapBetweenItems : 0;\n    },\n    [keysArray]\n  );\n\n  const { visibleItemKeys, overflowItemKeys } = useDetectHorizontalOverflow({\n    rootRef,\n    getWidth,\n    keysArray\n  });\n\n  const overflowTabBarClass = classNames([styles.overflowTabBarBase]);\n\n  return (\n    <div ref={rootRef} class={overflowTabBarClass}>\n      <TabBar\n        ref={tabBarRef}\n        selection={selection}\n        onSelect={handleSelect}\n        {...displayProps}\n        layout={layout}\n        edge={edge}\n        onRemove={onRemove}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledby}\n        testId={testId}>\n        {visibleItemKeys != null &&\n          visibleItemKeys.length > 0 &&\n          items\n            .filter((item) => visibleItemKeys?.includes(item.itemKey))\n            .map((item: Item<K>) =>\n              item.isRemovable ? (\n                <RemovableTabBarItem\n                  itemKey={item.itemKey}\n                  label={item.label}\n                  icon={item.icon}\n                  badge={item.badge}\n                  metadata={item.metadata}\n                  severity={item.severity}\n                  aria-controls={item.tabPanelId}\n                />\n              ) : (\n                <TabBarItem\n                  itemKey={item.itemKey}\n                  label={item.label}\n                  icon={item.icon}\n                  badge={item.badge}\n                  metadata={item.metadata}\n                  severity={item.severity}\n                  aria-controls={item.tabPanelId}\n                />\n              )\n            )}\n        {overflowItemKeys != null && overflowItemKeys.length > 0 && (\n          <OverflowTabBarItem\n            isOpen={isDropDownOpen}\n            onClose={handleClose}\n            overflowItemKey={overflowItemKey}\n            overflowItems={items.filter((item) => overflowItemKeys?.includes(item.itemKey))}\n          />\n        )}\n      </TabBar>\n    </div>\n  );\n}\n"],"names":["items","layout","display","size","edge","selection","onSelect","onRemove","ariaLabel","ariaLabelledby","testId","displayProps","rootRef","useRef","tabBarRef","createRef","isDropDownOpen","setIsDropDownOpen","useState","isOutsideMouseDown","handleSelect","useCallback","e","value","current","keysArray","useMemo","map","item","itemKey","getWidth","elem","findElementByKey","gapBetweenItems","length","getBoundingClientRect","width","visibleItemKeys","overflowItemKeys","useDetectHorizontalOverflow","overflowTabBarClass","classNames","styles","overflowTabBarBase","_jsx","ref","class","children","_jsxs","TabBar","filter","includes","isRemovable","RemovableTabBarItem","label","icon","badge","metadata","severity","tabPanelId","jsx","TabBarItem","OverflowTabBarItem","isOpen","onClose","reason","focus","overflowItemKey","overflowItems"],"mappings":"gZAoB0DA,MACxDA,EAAKC,OACLA,EAAS,UAASC,QAClBA,EAAU,WAAUC,KACpBA,EAAO,KAAIC,KACXA,EAAO,MAAKC,UACZA,EAASC,SACTA,EAAQC,SACRA,EACA,aAAcC,EACd,kBAAmBC,EAAcC,OACjCA,IAEA,MAQMC,EAA2B,YAAZT,EARK,CACxBA,QAASA,GAEkB,CAC3BA,QAASA,EACTC,KAAMA,GAIFS,EAAUC,SAAuB,MACjCC,EAAYC,EAAAA,aAEXC,EAAgBC,GAAqBC,EAAQA,UAAU,GAExDC,EAAqBN,UAAgB,GAYrCO,EAAeC,eAClBC,IACiB,SAAZA,EAAEC,MAEAJ,EAAmBK,QACrBP,GAAkB,GAElBA,GAAkB,GAGpBX,IAAWgB,GAEbH,EAAmBK,SAAU,CAAK,GAEpC,CAAClB,IAKGmB,EAAYC,EAAAA,SAAQ,IAAM1B,EAAM2B,KAAKC,GAASA,EAAKC,WAAiB,CAAC7B,IAErE8B,EAAWT,eACaQ,IAC1B,MAAME,EAAOC,EAAAA,iBAAiBpB,EAAQY,QAAwBK,EA1C7C,gBA6CXI,EAFYJ,IAAaJ,EAAUA,EAAUS,OAAS,GAElB,EAAL,GACrC,OAAOH,EAAQA,EAAKI,wBAAwBC,MAAQH,EAAkB,CAAC,GAEzE,CAACR,KAGGY,gBAAEA,EAAeC,iBAAEA,GAAqBC,8BAA4B,CACxE3B,UACAkB,WACAL,cAGIe,EAAsBC,EAAUA,WAAC,CAACC,EAAAA,OAAOC,qBAE/C,OACEC,EAAAA,WAAKC,IAAKjC,EAASkC,MAAON,EACxBO,SAAAC,EAAAA,KAACC,EAAAA,OACC,CAAAJ,IAAK/B,EACLT,UAAWA,EACXC,SAAUc,KACNT,EACJV,OAAQA,EACRG,KAAMA,EACNG,SAAUA,EACE,aAAAC,EACK,kBAAAC,EACjBC,OAAQA,EAAMqC,SAAA,CACM,MAAnBV,GACCA,EAAgBH,OAAS,GACzBlC,EACGkD,QAAQtB,GAASS,GAAiBc,SAASvB,EAAKC,WAChDF,KAAKC,GACJA,EAAKwB,YACHR,EAAAA,IAACS,EAAmBA,qBAClBxB,QAASD,EAAKC,QACdyB,MAAO1B,EAAK0B,MACZC,KAAM3B,EAAK2B,KACXC,MAAO5B,EAAK4B,MACZC,SAAU7B,EAAK6B,SACfC,SAAU9B,EAAK8B,SACA,gBAAA9B,EAAK+B,aAGtBf,EAACgB,IAAAC,EAAUA,WACT,CAAAhC,QAASD,EAAKC,QACdyB,MAAO1B,EAAK0B,MACZC,KAAM3B,EAAK2B,KACXC,MAAO5B,EAAK4B,MACZC,SAAU7B,EAAK6B,SACfC,SAAU9B,EAAK8B,SACA,gBAAA9B,EAAK+B,eAIT,MAApBrB,GAA4BA,EAAiBJ,OAAS,GACrDU,MAACkB,EAAAA,mBAAkB,CACjBC,OAAQ/C,EACRgD,QA7FW1C,IACfR,EAAUU,SAAW,CAAC,aAAc,aAAa2B,SAAS7B,EAAE2C,SAC9DnD,GAAWU,SAAS0C,QAEL,qBAAb5C,EAAE2C,SACJ9C,EAAmBK,SAAU,GAE/BP,GAAkB,EAAM,EAuFhBkD,gBAnEc,OAoEdC,cAAepE,EAAMkD,QAAQtB,GAASU,GAAkBa,SAASvB,EAAKC,iBAMlF"}