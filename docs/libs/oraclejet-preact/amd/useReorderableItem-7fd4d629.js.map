{"version":3,"file":"useReorderableItem-7fd4d629.js","sources":["../../src/hooks/PRIVATE_useReorderable/useReorderable.ts","../../src/hooks/PRIVATE_useReorderable/useReorderableItem.ts"],"sourcesContent":["import { RefObject } from 'preact';\nimport { useRef, useCallback, useState } from 'preact/hooks';\nimport { useId } from '#hooks/UNSAFE_useId';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useTranslationBundle } from '#/hooks/UNSAFE_useTranslationBundle';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { getItemKeysArray } from '#utils/PRIVATE_collectionUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { ReorderProps } from '#UNSAFE_Collection/Reorderable.types';\n\ntype useReorderableProps<K> = ReorderProps<K> & {\n  rootRef: RefObject<HTMLDivElement>;\n  itemSelector: string;\n  isDisabled?: boolean;\n  columns?: number;\n};\n\n/**\n * Implements keyboard reorder behavior for list-like components, e.g. TabBar, ListView, CardView\n */\nexport function useReorderable<K extends string | number>(options: useReorderableProps<K>) {\n  const { onReorder, rootRef, itemSelector, isDisabled, columns } = options;\n\n  const currentItemKey = useRef<K | undefined>();\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const reorderInstructionsId = 'reorderable_' + useId();\n  const { deviceType, platform } = getClientHints();\n  const keyPressed =\n    platform === 'windows' ? translations.accControlKey() : translations.accCommandKey();\n  const reorderInstructions =\n    deviceType === 'phone' || deviceType === 'tablet'\n      ? ''\n      : translations.accReorderInstructions({\n          keyPressed: keyPressed\n        });\n  const [reorderStatus, setReorderStatus] = useState<string | undefined>('');\n\n  const onKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      const keyHandlers = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n      if (\n        (e.metaKey || e.ctrlKey) &&\n        e.shiftKey &&\n        keyHandlers.includes(e.key) &&\n        onReorder &&\n        rootRef.current\n      ) {\n        if (e.metaKey) {\n          e.preventDefault();\n        }\n        const itemKeysArray = getItemKeysArray(rootRef.current, itemSelector);\n        const newArray = [...itemKeysArray];\n        const lastIndex = newArray.length - 1;\n        const currentItemIndex = newArray.indexOf(currentItemKey.current);\n        // get reference item index and reordered keys\n        const referenceItemIndex = getReferenceItemIndex(\n          e.key,\n          isRtl,\n          currentItemIndex,\n          lastIndex,\n          columns\n        );\n        if (referenceItemIndex !== undefined && currentItemIndex !== referenceItemIndex) {\n          const referenceKey = newArray[referenceItemIndex]?.toString();\n          newArray.splice(currentItemIndex, 1);\n          newArray.splice(referenceItemIndex as number, 0, currentItemKey.current);\n          onReorder?.({\n            reorderedKeys: newArray as K[],\n            itemKeys: [currentItemKey.current as K],\n            // If the dragged items were dropped at the very beginning, the referenceKey will be null.\n            referenceKey: referenceItemIndex === 0 ? null : (newArray[referenceItemIndex - 1] as K)\n          });\n          // set acc status\n          const isPrev = e.key === 'ArrowLeft' || e.key === 'ArrowUp' ? true : false;\n          const position = isPrev\n            ? translations.accPositionBefore()\n            : translations.accPositionAfter();\n          const itemKeyString = currentItemKey?.current?.toString();\n          if (referenceKey && position && itemKeyString) {\n            setReorderStatus(\n              translations.accAnnounceMovedKey({\n                itemKey: itemKeyString,\n                position: position,\n                referenceKey: referenceKey\n              })\n            );\n          }\n        }\n      }\n    },\n    [currentItemKey, onReorder, columns, isRtl, itemSelector, rootRef, translations]\n  );\n\n  const eventProps = isDisabled ? {} : { onKeyDown };\n\n  return {\n    reorderProps: eventProps,\n    reorderContext: {\n      currentItemKey\n    },\n    reorderInstructionsId,\n    reorderInstructions,\n    reorderStatus\n  } as const;\n}\n\n/**\n * A helper function to get referenceItemIndex during keyboard reordering\n *\n * @param eventKey the arrow event keys\n * @param isRtl whether RTL is enabled\n * @param currentItemIndex the index of current item\n * @param lastIndex the last index\n * @param columns optional param to specify the number of columns, for keyboard reordering by arrow up/down keys.\n */\nconst getReferenceItemIndex = (\n  eventKey: string,\n  isRtl: boolean,\n  currentItemIndex: number,\n  lastIndex: number,\n  columns?: number\n) => {\n  const leftDropIndex = currentItemIndex > 0 ? currentItemIndex - 1 : 0;\n  const rightDropIndex = currentItemIndex < lastIndex ? currentItemIndex + 1 : lastIndex;\n  switch (eventKey) {\n    case 'ArrowLeft':\n      return isRtl ? rightDropIndex : leftDropIndex;\n    case 'ArrowRight':\n      return isRtl ? leftDropIndex : rightDropIndex;\n    case 'ArrowUp':\n      if (columns) {\n        // if the current item is at the top row, arrow up should not move anywhere\n        return currentItemIndex < columns ? currentItemIndex : currentItemIndex - columns;\n      }\n    case 'ArrowDown':\n      if (columns) {\n        // if the current item is at the bottom row, arrow down should not move anywhere\n        return currentItemIndex > lastIndex - columns\n          ? currentItemIndex\n          : currentItemIndex + columns;\n      }\n    default:\n      return undefined;\n  }\n};\n","import { RefObject } from 'preact';\nimport { useState, useRef, useCallback, useEffect } from 'preact/hooks';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { createDragImage } from '#utils/PRIVATE_dndUtils';\nimport { getKey, getItemKeysArray } from '#utils/PRIVATE_collectionUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useReorderableContext } from './useReorderableContext';\nimport { ReorderableItemProps } from '#UNSAFE_Collection/Reorderable.types';\nimport { styles } from './themes/ReorderableItemStyles.css';\n\nexport type useReorderableOptions<K extends string | number> = Omit<\n  ReorderableItemProps<K>,\n  'children'\n> & {\n  draggable: boolean;\n  isDisabled: boolean;\n  ref: RefObject<HTMLDivElement>;\n  currentKey: K | undefined;\n  getItem: () => Element | null | undefined; // a function to get the reorderable item\n  setTransferData: (event: DragEvent) => void; // a function to set the transfer data and type\n  itemStyles: {\n    // component specific style for two overlay divs, e.g. component has different gap sizes\n    itemOverlayFront: string;\n    itemOverlayRear: string;\n    itemDragger?: string; // component specific style for drag image\n  };\n  itemSelector: string;\n  isVertical?: boolean; // used when the component is vertical and has one column, e.g. ListView\n};\n\n/**\n * Implements mouse reorder behavior for list-like components, e.g. TabBar, ListView, CardView\n */\nexport function useReorderableItem<K extends string | number>(options: useReorderableOptions<K>) {\n  const {\n    isDisabled,\n    draggable,\n    dragKey,\n    setDragKey,\n    onReorder,\n    ref,\n    rootRef,\n    currentKey,\n    itemStyles,\n    getItem,\n    setTransferData,\n    itemSelector,\n    isVertical\n  } = options;\n\n  const item = getItem();\n  const itemKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n\n  const [position, setPosition] = useState<'before' | 'after' | undefined>();\n  const pendingPositionRef = useRef<typeof position>();\n  const dragImgRef = useRef<HTMLElement | undefined>(undefined);\n\n  const itemDraggerClasses = classNames([styles.itemDragger, itemStyles.itemDragger]);\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const handleDragStart = useCallback(\n    (e: DragEvent) => {\n      const item = getItem();\n      const currentDragKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n      //create drag image clone of the item and show it\n      if (ref?.current && setDragKey) {\n        dragImgRef.current = createDragImage(ref.current, itemDraggerClasses);\n        //if there is drag icon, set the drag image at the drag icon position\n        const dragIcon = ref.current.querySelector('[draggable=true]') as HTMLElement;\n        if (dragIcon != null) {\n          e?.dataTransfer?.setDragImage(\n            dragImgRef.current,\n            dragIcon.offsetLeft + dragIcon.offsetWidth / 2,\n            dragIcon.offsetTop + dragIcon.offsetHeight / 2\n          );\n        } else {\n          e?.dataTransfer?.setDragImage(dragImgRef.current, 0, 0);\n        }\n        setTransferData(e);\n        setDragKey(currentDragKey as K);\n      }\n    },\n    [getItem, setTransferData, itemDraggerClasses, ref, setDragKey]\n  );\n\n  const handleDragOver = useCallback(\n    (e: DragEvent) => {\n      if (dragKey) {\n        e.preventDefault();\n      }\n    },\n    [dragKey]\n  );\n\n  //Once drag is over, reset styling of dragged item to it's original styling\n  const handleDragEnd = useCallback(() => {\n    setDragKey?.(undefined);\n    document.body.removeChild(dragImgRef.current as HTMLElement);\n  }, [setDragKey]);\n\n  // detect drop target position on the overlay divs and render drop target\n  const handleDragEnterBeforeZone = () => {\n    setPosition('before');\n    pendingPositionRef.current = 'before';\n  };\n\n  const handleDragLeaveBeforeZone = () => {\n    if (pendingPositionRef.current === 'before') {\n      setPosition(undefined);\n    }\n  };\n\n  const handleDragEnterAfterZone = () => {\n    setPosition('after');\n    pendingPositionRef.current = 'after';\n  };\n\n  const handleDragLeaveAfterZone = () => {\n    if (pendingPositionRef.current === 'after') {\n      setPosition(undefined);\n    }\n  };\n\n  const handleDrop = useCallback(() => {\n    if (rootRef?.current) {\n      const item = getItem();\n      const currentDropKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n      const reference = currentDropKey;\n      const itemKeys = getItemKeysArray(rootRef.current, itemSelector);\n      let insertPos;\n      const newArray = [...itemKeys];\n      const dragIndex = newArray.indexOf(dragKey);\n      if (reference != null) {\n        const dropIndex = newArray.indexOf(reference);\n        if (dragIndex != null && dropIndex != null && dragIndex != dropIndex) {\n          if (!isRtl) {\n            if (dragIndex < dropIndex) {\n              insertPos = position === 'before' ? dropIndex - 1 : dropIndex;\n            } else {\n              insertPos = position === 'before' ? dropIndex : dropIndex + 1;\n            }\n          } else {\n            if (dragIndex < dropIndex) {\n              insertPos = position === 'before' ? dropIndex : dropIndex - 1;\n            } else {\n              insertPos = position === 'before' ? dropIndex + 1 : dropIndex;\n            }\n          }\n        }\n      }\n      if (insertPos !== undefined && dragIndex !== insertPos) {\n        const sourceData = itemKeys[dragIndex];\n        newArray.splice(dragIndex, 1);\n        newArray.splice(insertPos as number, 0, sourceData);\n        onReorder?.({\n          reorderedKeys: newArray as K[],\n          itemKeys: [dragKey as K],\n          // If the dragged items were dropped at the very beginning, the referenceKey will be null.\n          referenceKey: insertPos === 0 ? null : (newArray[insertPos - 1] as K)\n        });\n        setPosition(undefined);\n        setDragKey(undefined);\n      }\n    }\n  }, [dragKey, position, getItem, isRtl, itemSelector, onReorder, rootRef, setDragKey]);\n\n  const { currentItemKey } = useReorderableContext();\n\n  useEffect(() => {\n    if (currentKey === itemKey) {\n      currentItemKey.current = currentKey;\n    }\n  }, [currentKey, itemKey, currentItemKey]);\n\n  if (isDisabled) {\n    return {};\n  }\n\n  //change dragged item visual to appear disable\n  const isDragged = itemKey != null && itemKey === dragKey;\n\n  const dndItemClasses = classNames([styles.itemDnd, isDragged && styles.itemDragged]);\n\n  const itemOverlayClassesBefore = classNames([\n    itemStyles.itemOverlayFront,\n    isVertical ? styles.itemOverlayVertical : styles.itemOverlay,\n    position === 'before' && styles.itemOverlayBefore,\n    position === 'before' && isRtl && styles.itemOverlayBeforeRtl\n  ]);\n  const itemOverlayClassesAfter = classNames([\n    itemStyles.itemOverlayFront,\n    itemStyles.itemOverlayRear,\n    isVertical ? styles.itemOverlayVertical : styles.itemOverlay,\n    position === 'after' && styles.itemOverlayAfter,\n    position === 'after' && isRtl && styles.itemOverlayAfterRtl\n  ]);\n\n  return {\n    rootProps: mergeProps({\n      ref: ref,\n      draggable: draggable,\n      onDragStart: handleDragStart,\n      onDragEnd: handleDragEnd,\n      onDragOver: handleDragOver,\n      onDrop: handleDrop,\n      isDisabled: isDisabled,\n      class: dndItemClasses\n    }),\n    isDragged: isDragged,\n    overlayZoneBeforeProps: mergeProps({\n      onDragEnter: handleDragEnterBeforeZone,\n      onDragLeave: handleDragLeaveBeforeZone,\n      class: itemOverlayClassesBefore\n    }),\n    overlayZoneAfterProps: mergeProps({\n      onDragEnter: handleDragEnterAfterZone,\n      onDragLeave: handleDragLeaveAfterZone,\n      class: itemOverlayClassesAfter\n    })\n  } as const;\n}\n"],"names":["getReferenceItemIndex","eventKey","isRtl","currentItemIndex","lastIndex","columns","leftDropIndex","rightDropIndex","options","onReorder","rootRef","itemSelector","isDisabled","currentItemKey","useRef","direction","useUser","translations","useTranslationBundle","reorderInstructionsId","useId","deviceType","platform","getClientHints","keyPressed","accControlKey","accCommandKey","reorderInstructions","accReorderInstructions","reorderStatus","setReorderStatus","useState","onKeyDown","useCallback","e","metaKey","ctrlKey","shiftKey","includes","key","current","preventDefault","newArray","getItemKeysArray","length","indexOf","referenceItemIndex","undefined","referenceKey","toString","splice","reorderedKeys","itemKeys","position","accPositionBefore","accPositionAfter","itemKeyString","accAnnounceMovedKey","itemKey","reorderProps","reorderContext","draggable","dragKey","setDragKey","ref","currentKey","itemStyles","getItem","setTransferData","isVertical","item","getKey","setPosition","pendingPositionRef","dragImgRef","itemDraggerClasses","classNames","styles","itemDragger","handleDragStart","currentDragKey","createDragImage","dragIcon","querySelector","dataTransfer","setDragImage","offsetLeft","offsetWidth","offsetTop","offsetHeight","handleDragOver","handleDragEnd","document","body","removeChild","handleDrop","reference","insertPos","dragIndex","dropIndex","sourceData","useReorderableContext","useEffect","isDragged","dndItemClasses","itemDnd","itemDragged","itemOverlayClassesBefore","itemOverlayFront","itemOverlayVertical","itemOverlay","itemOverlayBefore","itemOverlayBeforeRtl","itemOverlayClassesAfter","itemOverlayRear","itemOverlayAfter","itemOverlayAfterRtl","rootProps","mergeProps","onDragStart","onDragEnd","onDragOver","onDrop","class","overlayZoneBeforeProps","onDragEnter","onDragLeave","overlayZoneAfterProps"],"mappings":"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"}