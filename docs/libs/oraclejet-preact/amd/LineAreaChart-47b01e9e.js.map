{"version":3,"file":"LineAreaChart-47b01e9e.js","sources":["../../src/UNSAFE_LineAreaChart/AreaSeries.tsx","../../src/PRIVATE_Chart/Markers.tsx","../../src/UNSAFE_LineAreaChart/LineSeries.tsx","../../src/UNSAFE_LineAreaChart/LineAreaChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForArea } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { Scale } from '../utils/UNSAFE_visTypes/chart';\nimport { dvtVars } from '../Common/themes/themeContract.css';\n\ntype AreaSeriesProps = {\n  yScale: Scale;\n  color: ColorProps['color'];\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  isLog: boolean;\n  areaColorOpacity: number;\n  lineSegments: Point[][];\n  bottomCoords?: Point[];\n  isHighlighted: boolean;\n  isBottomSegmentCurved: boolean;\n  seriesIndex: number;\n};\n\nexport function AreaSeries({\n  yScale,\n  lineType = 'straight',\n  color,\n  isHorizontal,\n  isLog,\n  areaColorOpacity,\n  lineSegments,\n  bottomCoords,\n  isHighlighted,\n  isBottomSegmentCurved,\n  seriesIndex\n}: AreaSeriesProps) {\n  const style = {\n    fill: color,\n    opacity: isHighlighted\n      ? areaColorOpacity\n      : `calc(${dvtVars.dimmedOpacity} * ${areaColorOpacity})`\n  };\n  return (\n    <>\n      {lineSegments.map((lineSegment: Point[]) => {\n\n        if (lineSegment.length < 2) {\n          return;\n        }\n\n        let baseCoords;\n        if (bottomCoords) {\n          // custom bottom coords. eg: top of last series in stacked area\n          baseCoords = bottomCoords;\n        } else {\n          // TODO: make this more generic when we support apps setting baseline\n          // for log assume domain min is the baseline, otherwise use 0 baseline\n          const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);\n          baseCoords = isHorizontal\n            ? ([\n                [baselineCoord, lineSegment[0][1]],\n                [baselineCoord, lineSegment[lineSegment.length - 1][1]]\n              ] as Point[])\n            : ([\n                [lineSegment[0][0], baselineCoord],\n                [lineSegment[lineSegment.length - 1][0], baselineCoord]\n              ] as Point[]);\n        }\n        const cmds = getCmdsForArea(\n          lineSegment,\n          baseCoords,\n          lineType,\n          isHorizontal,\n          isBottomSegmentCurved\n        );\n        return (\n          <path d={cmds} style={style} data-oj-series-index={seriesIndex} data-oj-object={'area'} />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { LineAreaItem } from '../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { Marker, MARKER_PADDING } from '../PRIVATE_SvgShapes';\nimport { MarkerShapes } from '../utils/UNSAFE_visTypes/common';\nimport { getGroupCenterCoord } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { ChartSeriesData, Scale, Group } from '../utils/UNSAFE_visTypes/chart';\nimport { getMarkerFillAndStroke } from '../utils/PRIVATE_chartUtils/utils';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaLabel } from '../utils/PRIVATE_chartUtils/accUtils';\nimport { supportsMobileScreenReader } from '../utils/UNSAFE_visUtils';\n\nconst MARKER_DEFAULT_SIZE = 10;\ntype MarkersProps<K, D> = {\n  yScale: Scale;\n  xScale: Scale;\n  startIndex: number;\n  endIndex: number;\n  seriesIndex: number;\n  series: ChartSeriesData<K, D>;\n  markerType: MarkerShapes;\n  data: (number | undefined) [];\n  color: ColorProps['color'];\n  groups: Group[];\n  focusedItemIndex?: number;\n  isSelectionEnabled: boolean;\n  hoveredItemIndex?: number;\n  selectedIds?: Set<string | number>;\n  hiddenIds?: Set<string | number>;\n  activeId?: string;\n  orientation: 'horizontal' | 'vertical';\n  isDrillEnabled: boolean;\n  isLog: boolean;\n  isPointInsideMarquee: ((id: K, point: { x: number; y: number }) => boolean) | undefined;\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined;\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency';\n};\n\nexport function Markers<K extends string | number, D extends LineAreaItem<K>>({\n  yScale,\n  xScale,\n  color,\n  seriesIndex,\n  startIndex,\n  endIndex,\n  hiddenIds,\n  selectedIds,\n  orientation,\n  isLog,\n  data,\n  markerType,\n  getDataItem,\n  focusedItemIndex,\n  hoveredItemIndex,\n  isDrillEnabled,\n  activeId,\n  isSelectionEnabled,\n  timeAxisType,\n  isPointInsideMarquee,\n  series,\n  groups\n}: MarkersProps<K, D>) {\n  const isHoriz = orientation === 'horizontal';\n  const items = [];\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex++) {\n    const item = getDataItem(seriesIndex, groupIndex);\n    const value = data[groupIndex];\n    if (!item || value == null || hiddenIds?.has(item.id) || (isLog && value <= 0)) {\n      continue;\n    }\n    const x = isHoriz\n      ? yScale.transform(value)\n      : getGroupCenterCoord<K, D>(groups[groupIndex], groupIndex, xScale, item, timeAxisType);\n    const y = isHoriz\n      ? getGroupCenterCoord<K, D>(groups[groupIndex], groupIndex, xScale, item, timeAxisType)\n      : yScale.transform(value);\n    const isFocused = focusedItemIndex === groupIndex;\n    const isHovered = hoveredItemIndex === groupIndex;\n    const isSelected = !!(selectedIds?.has(item.id!) || isPointInsideMarquee?.(item.id, { x, y }));\n    const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);\n    const { fill, stroke, outerStroke } = getMarkerFillAndStroke(\n      !!item.isMarkerDisplayed,\n      isSelectionEnabled,\n      isHovered,\n      isFocused,\n      isSelected,\n      color,\n      item.markerColor\n    );\n    const itemMarkerType = item.isMarkerDisplayed ? item.markerType || markerType : markerType;\n    const isActive = isFocused || isHovered;\n    const ariaLabel =\n      supportsMobileScreenReader || isActive\n        ? getItemAriaLabel(\n            translations,\n            series.name || series.id.toString(),\n            groups[groupIndex].name || groups[groupIndex].id,\n            item.value,\n            isSelectionEnabled,\n            isSelected,\n            isDrillable,\n            item.accessibleLabel\n          )\n        : undefined;\n\n    const dataInfo = {\n      'data-oj-series-index': seriesIndex,\n      'data-oj-group-index': groupIndex,\n      'data-oj-object': 'item',\n      id: isActive ? activeId : undefined,\n      role: ariaLabel ? 'img' : undefined,\n      'aria-label': ariaLabel\n    };\n\n    const markerSize = (item.markerSize || MARKER_DEFAULT_SIZE) + 2 * MARKER_PADDING;\n    items.push(\n      <Marker\n        type={itemMarkerType}\n        tx={x}\n        ty={y}\n        isInteractive={isDrillable || isSelectionEnabled}\n        scale={1}\n        fill={fill}\n        stroke={stroke}\n        outerStroke={outerStroke}\n        width={markerSize}\n        height={markerSize}\n        dataInfo={dataInfo}\n        preserveRectAspectRatio\n      />\n    );\n  }\n  return <>{items}</>;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForLine } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { rgba } from '../UNSAFE_Theme';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { styles } from '../PRIVATE_Chart/themes/ChartStyles.css';\nimport { Property } from 'csstype';\n\ntype LineSeriesProps = {\n  color: ColorProps['color'];\n  lineStyle?: 'dotted' | 'dashed' | 'solid';\n  lineColor?: Property.Color;\n  lineWidth?: number;\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  lineSegmentCoords: Point[][];\n  isHighlighted: boolean;\n  seriesIndex: number;\n};\n\nexport function LineSeries({\n  color,\n  isHorizontal,\n  lineType = 'straight',\n  lineColor,\n  lineStyle,\n  lineWidth = 3,\n  isHighlighted,\n  lineSegmentCoords,\n  seriesIndex\n}: LineSeriesProps) {\n  const style = {\n    stroke: lineColor || color,\n    strokeDasharray: lineStyle === 'dotted' ? 3 : lineStyle === 'dashed' ? 6 : undefined,\n    strokeWidth: lineWidth,\n    fill: rgba(colorSchemeVars.palette.neutral[0], 0)\n  };\n\n  return (\n    <>\n      {lineSegmentCoords.map((value: Point[]) => {\n        if (value.length < 2) {\n          return;\n        }\n        const cmds = getCmdsForLine(value, lineType, isHorizontal);\n        return lineType === 'straight' ? (\n          <polyline\n            points={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        ) : (\n          <path\n            d={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\nimport { findNearestDataPoint } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from './AreaSeries';\nimport { getCumulativeSeries, getMarkers, getSeriesData } from '../utils/PRIVATE_chartUtils/utils';\nimport { Markers } from '../PRIVATE_Chart/Markers';\nimport { getLineAreaChartNavUtil } from '../utils/PRIVATE_chartUtils/navUtils';\nimport { Chart } from '../PRIVATE_Chart';\nimport { Scale, TimeAxisProps } from '../utils/UNSAFE_visTypes/chart';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getColorRamp } from '../utils/UNSAFE_visUtils';\nimport { LineSeries } from './LineSeries';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '../utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { getItemColor, getMarkerType } from '../utils/PRIVATE_chartUtils/dataStyleUtils';\n\nconst AXIS_OFFSET = 0.2;\nconst LINE_WITH_AREA_OPACITY = 0.2;\n\n/**\n * The LineAreaChart displays information graphically using lines and filled areas, making relationships among the data easier to understand.\n */\nexport function LineAreaChart<K extends string | number, D extends LineAreaItem<K>>({\n  width,\n  height,\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  type = 'line',\n  ...props\n}: LineAreaChartProps<K, D>) {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  const renderedSeries = isStacked\n    ? getCumulativeSeries(series.length, groups.length, getDataItem, hiddenSet, isLog)\n    : getSeriesData<K, D>(series?.length, groups?.length, getDataItem, hiddenSet, isLog);\n\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number): D | undefined => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    } as D;\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    return getLineAreaChartNavUtil<K, D>(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale) => {\n    return (seriesIndex: number, groupIndex: number) => {\n      const value = renderedSeries[seriesIndex][groupIndex];\n      if (value == null) {\n        return;\n      }\n      let xVal = groupIndex;\n      if (timeAxisType) {\n        const val =\n          timeAxisType === 'mixedFrequency'\n            ? getDataItem(seriesIndex, groupIndex)?.x\n            : groups[groupIndex].id;\n        xVal = new Date(val!).getTime();\n      }\n      const x = isHoriz ? yScale.transform(value) : xScale.transform(xVal);\n      const y = isHoriz ? xScale.transform(xVal) : yScale.transform(value);\n      return { x, y, height: 0, width: 0 };\n    };\n  };\n\n  const getMarkerColorAndType = (seriesIndex: number, groupIndex: number) => {\n    return {\n      color: getItemColor<K, D>(seriesIndex, groupIndex, series, getDataItem),\n      type: getMarkerType<K>(seriesIndex, groupIndex, 'lineWithArea', getDataItem)\n    };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint<K, D>(\n      series,\n      groups,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet,\n      timeAxisType\n    );\n  };\n  const markers = getMarkers();\n  const areaOpacity = type === 'lineWithArea' ? LINE_WITH_AREA_OPACITY : 1;\n  const isAreaRendered = type === 'area' || type === 'lineWithArea';\n  const isContrastLineNeeded = type === 'area';\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedSet}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      series={series}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      getMarkerInfo={getMarkerColorAndType}\n      renderGridLinesInFront={isAreaRendered}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      offset={AXIS_OFFSET}\n      isRtl={isRtl}\n      {...props}>\n      {({\n        xStartIndex,\n        xEndIndex,\n        xScale,\n        yScale,\n        activeId,\n        focusedItemInfo,\n        hoveredItemInfo,\n        isPointInsideMarquee\n      }) => {\n        return (\n          <>\n            {renderedSeries.map((lineAreaSeries, index) => {\n              if (lineAreaSeries.length === 0) {\n                /* TODO: need a better way to handle when a series is hidden. */\n                return;\n              }\n              const seriesItem = series[index];\n              const lineSegmentCoords: Point[][] = getLineAreaSegments<K, D>(\n                yScale,\n                xScale,\n                lineAreaSeries,\n                xStartIndex,\n                xEndIndex,\n                isHoriz,\n                isLog,\n                groups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                seriesItem.lineType === 'curved' &&\n                isStacked &&\n                renderedSeries.length > 1 &&\n                index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined || highlightedSet.has(seriesItem.id);\n\n              const prevCoords =\n                isStacked && index != 0\n                  ? allLineSegmentCoords.reduce((prevValue, newValue, j) => {\n                    // find the index i such that i < index, and series i  has at least \n                    // one or more data item unhidden. Only such series will can be \n                    // used as bottomCoord for current series. Otherwise we have to use \n                    // baseline coord\n                      if (j >= index) {\n                        return prevValue;\n                      }\n                      if (newValue.length > 0) {\n                        return j;\n                      }\n                      return prevValue;\n                    }, 0)\n                  : undefined;\n\n              return (\n                <>\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={yScale}\n                      lineType={seriesItem.lineType}\n                      color={seriesItem.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={areaOpacity}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={prevCoords !== undefined && allLineSegmentCoords[prevCoords].some((value) => value != null) ? allLineSegmentCoords[prevCoords] : undefined}\n                      lineSegments={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  <LineSeries\n                    lineType={seriesItem.lineType}\n                    /* TODO: confirm with UX if this is contrastLine (changes depending on dark/light mode) or always white. \n                        It's always white in legacy.*/\n                    lineColor={\n                      isContrastLineNeeded ? colorSchemeVars.dvt.contrastLine : seriesItem.lineColor\n                    }\n                    /* The area generated in legacy are bit apart and not touching when stacked. Preact areas are a bit closer than legacy when curved. \n                      Increased the contrast linewidth (to 2.5 from legacy 1.25) to give legacy visual treatment.\n                      TODO: investivage why legacy areas are not touching. maybe we want to do the same in preact svg utils that\n                      generates this curve.\n                     */\n                    lineWidth={\n                      isContrastLineNeeded ? (isStacked ? 2.5 : 1.25) : seriesItem.lineWidth\n                    }\n                    lineStyle={seriesItem.lineStyle}\n                    color={seriesItem.lineColor || colors[index % colors.length]}\n                    lineSegmentCoords={lineSegmentCoords}\n                    isHorizontal={isHoriz}\n                    isHighlighted={isHighlighted}\n                    seriesIndex={index}\n                  />\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (\n                      <Markers\n                        yScale={yScale}\n                        xScale={xScale}\n                        groups={groups}\n                        series={seriesItem}\n                        timeAxisType={timeAxisType}\n                        data={lineAreaSeries}\n                        color={\n                          seriesItem.lineColor ||\n                          seriesItem.areaColor ||\n                          colors[\n                            index % colors.length\n                          ] /* TODO : make this use getItemColor function from dataStyleUtils. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        isPointInsideMarquee={isPointInsideMarquee}\n                        selectedIds={selectedSet}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index &&\n                          focusedItemInfo.isFocusVisible &&\n                          !(props.isDataCursorEnabled && props.dataCursorStyle?.isMarkerDisplayed)\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n            {isStacked &&\n              renderedSeries.map((lineAreaSeries, index) => {\n                if (lineAreaSeries.length === 0) {\n                  /* TODO: need a better way to handle when a series is hidden.*/\n                  return;\n                }\n                const seriesItem = series[index];\n                return (\n                  <Markers\n                    yScale={yScale}\n                    series={series[index]}\n                    xScale={xScale}\n                    groups={groups}\n                    timeAxisType={timeAxisType}\n                    data={lineAreaSeries}\n                    color={\n                      seriesItem.lineColor || seriesItem.areaColor || colors[index % colors.length]\n                    }\n                    seriesIndex={index}\n                    isPointInsideMarquee={isPointInsideMarquee}\n                    startIndex={xStartIndex}\n                    endIndex={xEndIndex}\n                    markerType={markers[index % markers.length]}\n                    orientation={orientation}\n                    isLog={isLog}\n                    activeId={activeId}\n                    getDataItem={getDataItem}\n                    selectedIds={selectedSet}\n                    focusedItemIndex={\n                      focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                        ? focusedItemInfo.groupIndex\n                        : undefined\n                    }\n                    hoveredItemIndex={\n                      hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                        ? hoveredItemInfo.groupIndex\n                        : undefined\n                    }\n                    isSelectionEnabled={selectionMode === 'single' || selectionMode === 'multiple'}\n                    isDrillEnabled={drilling === 'on'}\n                  />\n                );\n              })}\n          </>\n        );\n      }}\n    </Chart>\n  );\n}\n"],"names":["AreaSeries","yScale","lineType","color","isHorizontal","isLog","areaColorOpacity","lineSegments","bottomCoords","isHighlighted","isBottomSegmentCurved","seriesIndex","style","fill","opacity","dvtVars","dimmedOpacity","_jsx","map","lineSegment","length","baseCoords","baselineCoord","transform","domain","cmds","getCmdsForArea","d","MARKER_DEFAULT_SIZE","Markers","xScale","startIndex","endIndex","hiddenIds","selectedIds","orientation","data","markerType","getDataItem","focusedItemIndex","hoveredItemIndex","isDrillEnabled","activeId","isSelectionEnabled","timeAxisType","isPointInsideMarquee","series","groups","isHoriz","items","translations","useTranslationBundle","groupIndex","item","value","has","id","x","getGroupCenterCoord","y","isFocused","isHovered","isSelected","isDrillable","drilling","stroke","outerStroke","getMarkerFillAndStroke","isMarkerDisplayed","markerColor","itemMarkerType","isActive","ariaLabel","supportsMobileScreenReader","getItemAriaLabel","name","toString","accessibleLabel","undefined","dataInfo","role","markerSize","MARKER_PADDING","push","jsx","Marker","type","tx","ty","isInteractive","scale","width","height","preserveRectAspectRatio","_Fragment","Fragment","children","LineSeries","lineColor","lineStyle","lineWidth","lineSegmentCoords","strokeDasharray","strokeWidth","rgba","colorSchemeVars","palette","neutral","getCmdsForLine","points","className","styles","dimmed","highlightedIds","hideAndShowBehavior","yAxis","isStacked","selectionMode","props","direction","useUser","isRtl","xAxis","hiddenSet","Set","selectedSet","highlightedSet","colors","getColorRamp","renderedSeries","getCumulativeSeries","getSeriesData","renderedGetDataItem","markers","getMarkers","areaOpacity","isAreaRendered","isContrastLineNeeded","allLineSegmentCoords","Chart","findNearest","findNearestDataPoint","offset","dataWidth","getDataItemPos","xVal","val","Date","getTime","getMarkerInfo","getItemColor","getMarkerType","renderGridLinesInFront","getNavUtil","getLineAreaChartNavUtil","getGapRatio","xStartIndex","xEndIndex","focusedItemInfo","hoveredItemInfo","_jsxs","jsxs","lineAreaSeries","index","seriesItem","getLineAreaSegments","prevCoords","reduce","prevValue","newValue","j","areaColor","some","dvt","contrastLine","isFocusVisible","isDataCursorEnabled","dataCursorStyle","isCurrent"],"mappings":"4ZA4BM,SAAUA,GAAWC,OACzBA,EAAMC,SACNA,EAAW,WAAUC,MACrBA,EAAKC,aACLA,EAAYC,MACZA,EAAKC,iBACLA,EAAgBC,aAChBA,EAAYC,aACZA,EAAYC,cACZA,EAAaC,sBACbA,EAAqBC,YACrBA,IAEA,MAAMC,EAAQ,CACZC,KAAMV,EACNW,QAASL,EACLH,EACA,QAAQS,EAAAA,QAAQC,mBAAmBV,MAEzC,OACEW,EAAAA,yBACGV,EAAaW,KAAKC,IAEjB,GAAIA,EAAYC,OAAS,EACvB,OAGF,IAAIC,EACJ,GAAIb,EAEFa,EAAab,MACR,CAGL,MAAMc,EAAgBrB,EAAOsB,UAAUlB,EAAQJ,EAAOuB,SAAS,GAAK,GACpEH,EAAajB,EACR,CACC,CAACkB,EAAeH,EAAY,GAAG,IAC/B,CAACG,EAAeH,EAAYA,EAAYC,OAAS,GAAG,KAErD,CACC,CAACD,EAAY,GAAG,GAAIG,GACpB,CAACH,EAAYA,EAAYC,OAAS,GAAG,GAAIE,GAEhD,CACD,MAAMG,EAAOC,EAAAA,eACXP,EACAE,EACAnB,EACAE,EACAM,GAEF,OACEO,MAAA,OAAA,CAAMU,EAAGF,EAAMb,MAAOA,yBAA6BD,EAAW,iBAAkB,QAChF,KAIV,CClEA,MAAMiB,EAAsB,GA0BtB,SAAUC,GAA8D5B,OAC5EA,EAAM6B,OACNA,EAAM3B,MACNA,EAAKQ,YACLA,EAAWoB,WACXA,EAAUC,SACVA,EAAQC,UACRA,EAASC,YACTA,EAAWC,YACXA,EAAW9B,MACXA,EAAK+B,KACLA,EAAIC,WACJA,EAAUC,YACVA,EAAWC,iBACXA,EAAgBC,iBAChBA,EAAgBC,eAChBA,EAAcC,SACdA,EAAQC,mBACRA,EAAkBC,aAClBA,EAAYC,qBACZA,EAAoBC,OACpBA,EAAMC,OACNA,IAEA,MAAMC,EAA0B,eAAhBb,EACVc,EAAQ,GAERC,EAAeC,uBAAiC,4BAEtD,IAAK,IAAIC,EAAarB,EAAYqB,EAAapB,EAAW,EAAGoB,IAAc,CACzE,MAAMC,EAAOf,EAAY3B,EAAayC,GAChCE,EAAQlB,EAAKgB,GACnB,IAAKC,GAAiB,MAATC,GAAiBrB,GAAWsB,IAAIF,EAAKG,KAAQnD,GAASiD,GAAS,EAC1E,SAEF,MAAMG,EAAIT,EACN/C,EAAOsB,UAAU+B,GACjBI,EAAmBA,oBAAOX,EAAOK,GAAaA,EAAYtB,EAAQuB,EAAMT,GACtEe,EAAIX,EACNU,EAAmBA,oBAAOX,EAAOK,GAAaA,EAAYtB,EAAQuB,EAAMT,GACxE3C,EAAOsB,UAAU+B,GACfM,EAAYrB,IAAqBa,EACjCS,EAAYrB,IAAqBY,EACjCU,KAAgB5B,GAAaqB,IAAIF,EAAKG,MAAQX,IAAuBQ,EAAKG,GAAI,CAAEC,IAAGE,OACnFI,EAAgC,OAAlBV,EAAKW,UAAuC,OAAjBX,EAAKW,UAAqBvB,GACnE5B,KAAEA,EAAIoD,OAAEA,EAAMC,YAAEA,GAAgBC,EAAAA,yBAClCd,EAAKe,kBACPzB,EACAkB,EACAD,EACAE,EACA3D,EACAkD,EAAKgB,aAEDC,EAAiBjB,EAAKe,mBAAoBf,EAAKhB,YAA2BA,EAC1EkC,EAAWX,GAAaC,EACxBW,EACJC,EAAAA,4BAA8BF,EAC1BG,mBACExB,EACAJ,EAAO6B,MAAQ7B,EAAOU,GAAGoB,WACzB7B,EAAOK,GAAYuB,MAAQ5B,EAAOK,GAAYI,GAC9CH,EAAKC,MACLX,EACAmB,EACAC,EACAV,EAAKwB,sBAEPC,EAEAC,EAAW,CACf,uBAAwBpE,EACxB,sBAAuByC,EACvB,iBAAkB,OAClBI,GAAIe,EAAW7B,OAAWoC,EAC1BE,KAAMR,EAAY,WAAQM,EAC1B,aAAcN,GAGVS,GAAc5B,EAAK4B,YAAcrD,GAAuB,EAAIsD,iBAClEjC,EAAMkC,KACJlE,EAACmE,IAAAC,EAAMA,QACLC,KAAMhB,EACNiB,GAAI9B,EACJ+B,GAAI7B,EACJ8B,cAAe1B,GAAepB,EAC9B+C,MAAO,EACP7E,KAAMA,EACNoD,OAAQA,EACRC,YAAaA,EACbyB,MAAOV,EACPW,OAAQX,EACRF,SAAUA,EACVc,yBACA,IAEL,CACD,OAAO5E,EAAAmE,IAAAU,EAAAC,SAAA,CAAAC,SAAG/C,GACZ,CCpHM,SAAUgD,GAAW9F,MACzBA,EAAKC,aACLA,EAAYF,SACZA,EAAW,WAAUgG,UACrBA,EAASC,UACTA,EAASC,UACTA,EAAY,EAAC3F,cACbA,EAAa4F,kBACbA,EAAiB1F,YACjBA,IAEA,MAAMC,EAAQ,CACZqD,OAAQiC,GAAa/F,EACrBmG,gBAA+B,WAAdH,EAAyB,EAAkB,WAAdA,EAAyB,OAAIrB,EAC3EyB,YAAaH,EACbvF,KAAM2F,EAAIA,KAACC,kBAAgBC,QAAQC,QAAQ,GAAI,IAGjD,OACE1F,EAAAA,yBACGoF,EAAkBnF,KAAKoC,IACtB,GAAIA,EAAMlC,OAAS,EACjB,OAEF,MAAMK,EAAOmF,EAAcA,eAACtD,EAAOpD,EAAUE,GAC7C,MAAoB,aAAbF,EACLe,EAAAmE,IAAA,WAAA,CACEyB,OAAQpF,EACRb,MAAOA,EACPkG,UAAWrG,OAAgBqE,EAAYiC,EAAAA,OAAOC,OAAM,uBAC9BrG,EACN,iBAAA,SAGlBM,EAAAA,YACEU,EAAGF,EACHb,MAAOA,EACPkG,UAAWrG,OAAgBqE,EAAYiC,EAAAA,OAAOC,OAAM,uBAC9BrG,EAAW,iBACjB,QAEnB,KAIT,iBC3CM,UAA8EgF,MAClFA,EAAKC,OACLA,EAAM1D,YACNA,EAAc,GAAED,UAChBA,EAAY,GAAEgF,eACdA,EAAcC,oBACdA,EAAsB,OAAM/E,YAC5BA,EAAc,WAAUgF,MACxBA,EAAKrE,OACLA,EAAMC,OACNA,EAAMqE,UACNA,GAAY,EAAK9E,YACjBA,EAAW+E,cACXA,EAAgB,OAAMrD,SACtBA,EAAW,MAAKsB,KAChBA,EAAO,UACJgC,IAEH,MAAMC,UAAEA,GAAcC,EAAAA,UAChBC,EAAsB,QAAdF,EACRlH,EAAyB,QAAjB8G,GAAOzB,MACf9C,EAAgB0E,EAAMI,OAAyB9E,aAC/C+E,EAAY,IAAIC,IAAI3F,GACpB4F,EAAc,IAAID,IAAI1F,GACtB4F,EAAiB,IAAIF,IAAIX,GACzBjE,EAA0B,eAAhBb,EACV4F,EAASC,EAAAA,eACTC,EAAiBb,EACnBc,EAAmBA,oBAACpF,EAAO1B,OAAQ2B,EAAO3B,OAAQkB,EAAaqF,EAAWtH,GAC1E8H,gBAAoBrF,GAAQ1B,OAAQ2B,GAAQ3B,OAAQkB,EAAaqF,EAAWtH,GAE1E+H,EAAsB,CAACzH,EAAqByC,IAC3CgE,EACE,IACF9E,EAAY3B,EAAayC,GAC5BE,MAAO2E,EAAetH,GAAayC,IAHdd,EAAY3B,EAAayC,GA6E5CiF,EAAUC,EAAAA,aACVC,EAAuB,iBAATjD,EAnHS,GAmH0C,EACjEkD,EAA0B,SAATlD,GAA4B,iBAATA,EACpCmD,EAAgC,SAATnD,EACvBoD,EAAkC,GACxC,OACEzH,EAACmE,IAAAuD,EAAKA,MACJ,CAAAhD,MAAOA,EACPC,OAAQA,EACR1D,YAAa2F,EACb5F,UAAWA,EACXiF,oBAAqBA,EACrB/E,YAAaA,EACbgF,MAAOA,EACPrE,OAAQA,EACRC,OAAQA,EACRsE,cAAeA,EACfrD,SAAUA,EACVoD,UAAWA,EACX9E,YAAaA,EACbsG,YA/CgB,CAAC9G,EAAe7B,IAY3B4I,EAAoBA,qBACzB/F,EACAC,EACAjB,EACA7B,EACAmI,EACAhB,GAjBwB,KACjB,CACL0B,OAAQ,EACRC,UAAW,MAIG,CAACzF,EAAerD,IACzBA,EAAOsB,UAAU+B,IAYxBjD,EACA,EACAsH,EACA/E,GAwBAoG,eA3EmB,CAAClH,EAAe7B,IAC9B,CAACU,EAAqByC,KAC3B,MAAME,EAAQ2E,EAAetH,GAAayC,GAC1C,GAAa,MAATE,EACF,OAEF,IAAI2F,EAAO7F,EACX,GAAIR,EAAc,CAChB,MAAMsG,EACa,mBAAjBtG,EACIN,EAAY3B,EAAayC,IAAaK,EACtCV,EAAOK,GAAYI,GACzByF,EAAO,IAAIE,KAAKD,GAAME,SACvB,CAGD,MAAO,CAAE3F,EAFCT,EAAU/C,EAAOsB,UAAU+B,GAASxB,EAAOP,UAAU0H,GAEnDtF,EADFX,EAAUlB,EAAOP,UAAU0H,GAAQhJ,EAAOsB,UAAU+B,GAC/CsC,OAAQ,EAAGD,MAAO,EAAG,EA4DpC0D,cAxD0B,CAAC1I,EAAqByC,KAC3C,CACLjD,MAAOmJ,EAAAA,aAAmB3I,EAAayC,EAAYN,EAAQR,GAC3DgD,KAAMiE,EAAAA,cAAiB5I,EAAayC,EAAY,eAAgBd,KAsDhEkH,uBAAwBhB,EACxBiB,WA1FyB,CAAC1H,EAAoBC,IACzC0H,EAAuBA,wBAC5BpH,EACAQ,EAAO1B,OACPW,EACAC,EACAoF,EACAK,EACAzE,GAmFA2G,YA/FgB,IACX,EA+FLb,OA7Ic,GA8IdrB,MAAOA,KACHH,WACH,EACCsC,cACAC,YACA/H,SACA7B,SACAyC,WACAoH,kBACAC,kBACAlH,0BAGEmH,EACGC,KAAAnE,EAAAC,SAAA,CAAAC,SAAA,CAAAiC,EAAe/G,KAAI,CAACgJ,EAAgBC,KACnC,GAA8B,IAA1BD,EAAe9I,OAEjB,OAEF,MAAMgJ,EAAatH,EAAOqH,GACpB9D,EAA+BgE,EAAmBA,oBACtDpK,EACA6B,EACAoI,EACAN,EACAC,EACA7G,EACA3C,EACA0C,EACAoH,EACA/B,EACAxF,GAEF8F,EAAqByB,GAAS9D,EAAkB,GAChD,MAAM3F,EACoB,WAAxB0J,EAAWlK,UACXkH,GACAa,EAAe7G,OAAS,GACxB+I,EAAQ,EAEJ1J,OACeqE,IAAnBmC,GAAgCa,EAAevE,IAAI6G,EAAW5G,IAE1D8G,EACJlD,GAAsB,GAAT+C,EACTzB,EAAqB6B,QAAO,CAACC,EAAWC,EAAUC,IAK5CA,GAAKP,EACAK,EAELC,EAASrJ,OAAS,EACbsJ,EAEFF,GACN,QACH1F,EAEN,OACEkF,6BACGxB,GACCvH,EAAAA,IAACjB,EACC,CAAAC,OAAQA,EACRC,SAAUkK,EAAWlK,SACrBC,MAAOiK,EAAWO,WAAa5C,EAAOoC,EAAQpC,EAAO3G,QACrDhB,aAAc4C,EACd1C,iBAAkBiI,EAClB7H,sBAAuBA,EACvBF,kBAA6BsE,IAAfwF,GAA4B5B,EAAqB4B,GAAYM,MAAMtH,GAAmB,MAATA,IAAiBoF,EAAqB4B,QAAcxF,EAC/IvE,aAAc8F,EACdhG,MAAOA,EACPI,cAAeA,EACfE,YAAawJ,IAGjBlJ,EAAAA,IAACgF,GACC/F,SAAUkK,EAAWlK,SAGrBgG,UACEuC,EAAuBhC,EAAeA,gBAACoE,IAAIC,aAAeV,EAAWlE,UAOvEE,UACEqC,EAAwBrB,EAAY,IAAM,KAAQgD,EAAWhE,UAE/DD,UAAWiE,EAAWjE,UACtBhG,MAAOiK,EAAWlE,WAAa6B,EAAOoC,EAAQpC,EAAO3G,QACrDiF,kBAAmBA,EACnBjG,aAAc4C,EACdvC,cAAeA,EACfE,YAAawJ,KAKZ/C,GACCnG,EAAAmE,IAACvD,EACC,CAAA5B,OAAQA,EACR6B,OAAQA,EACRiB,OAAQA,EACRD,OAAQsH,EACRxH,aAAcA,EACdR,KAAM8H,EACN/J,MACEiK,EAAWlE,WACXkE,EAAWO,WACX5C,EACEoC,EAAQpC,EAAO3G,QAGnBT,YAAawJ,EACbpI,WAAY6H,EACZ5H,SAAU6H,EACVxH,WAAYgG,EAAQ8B,EAAQ9B,EAAQjH,QACpCe,YAAaA,EACb9B,MAAOA,EACPqC,SAAUA,EACVJ,YAAaA,EACbO,qBAAsBA,EACtBX,YAAa2F,EACbtF,iBACEuH,EAAgBnJ,cAAgBwJ,IAChCL,EAAgBiB,gBACdzD,EAAM0D,qBAAuB1D,EAAM2D,iBAAiB7G,uBAElDU,EADAgF,EAAgB1G,WAGtBZ,iBACEuH,GAAiBmB,WAAanB,EAAgBpJ,cAAgBwJ,EAC1DJ,EAAgB3G,gBAChB0B,EAENnC,mBACoB,WAAlB0E,GAAgD,aAAlBA,EAEhC5E,eAA6B,OAAbuB,MAKxB,IAEHoD,GACCa,EAAe/G,KAAI,CAACgJ,EAAgBC,KAClC,GAA8B,IAA1BD,EAAe9I,OAEjB,OAEF,MAAMgJ,EAAatH,EAAOqH,GAC1B,OACElJ,MAACY,EAAO,CACN5B,OAAQA,EACR6C,OAAQA,EAAOqH,GACfrI,OAAQA,EACRiB,OAAQA,EACRH,aAAcA,EACdR,KAAM8H,EACN/J,MACEiK,EAAWlE,WAAakE,EAAWO,WAAa5C,EAAOoC,EAAQpC,EAAO3G,QAExET,YAAawJ,EACbtH,qBAAsBA,EACtBd,WAAY6H,EACZ5H,SAAU6H,EACVxH,WAAYgG,EAAQ8B,EAAQ9B,EAAQjH,QACpCe,YAAaA,EACb9B,MAAOA,EACPqC,SAAUA,EACVJ,YAAaA,EACbJ,YAAa2F,EACbtF,iBACEuH,EAAgBnJ,cAAgBwJ,GAASL,EAAgBiB,eACrDjB,EAAgB1G,gBAChB0B,EAENtC,iBACEuH,GAAiBmB,WAAanB,EAAgBpJ,cAAgBwJ,EAC1DJ,EAAgB3G,gBAChB0B,EAENnC,mBAAsC,WAAlB0E,GAAgD,aAAlBA,EAClD5E,eAA6B,OAAbuB,GAElB,QAOlB"}