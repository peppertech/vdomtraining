{"version":3,"file":"List-3ebac3fc.js","sources":["../../src/PRIVATE_List/ListRoles.ts","../../src/PRIVATE_List/ListItem.tsx","../../src/PRIVATE_List/SkeletonContainer.tsx","../../src/PRIVATE_List/Sparkle.tsx","../../src/PRIVATE_List/usePromotedSection.ts","../../src/PRIVATE_List/ListUtils.ts","../../src/PRIVATE_List/useSelectionAndNavigation.ts","../../src/PRIVATE_List/useFocusTabbableMode.ts","../../src/PRIVATE_List/List.tsx","../../src/PRIVATE_List/useCurrentItemOverride.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Roles } from '../UNSAFE_ListView';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\n\n/**\n * List Roles need to be kept in matching sets, this module encapsulates the sets\n *\n * @param ariaRole\n * @returns matching, valid set of roles\n */\n\nconst getListViewRoles = (\n  ariaRole: Roles\n): {\n  list: HTMLAttributesSignalExcluded['role'];\n  item: HTMLAttributesSignalExcluded['role'];\n  cell: HTMLAttributesSignalExcluded['role'];\n} => {\n  switch (ariaRole) {\n    case 'listbox':\n      return { list: 'listbox', item: 'presentation', cell: 'option' };\n    case 'treegrid':\n      return { list: 'treegrid', item: 'row', cell: 'gridcell' };\n    default:\n      return { list: 'grid', item: 'row', cell: 'gridcell' };\n  }\n};\n\nexport { getListViewRoles };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useRef, useMemo } from 'preact/hooks';\nimport { memo } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { SelectionMode, CurrentItemVariant, ListItemRendererContext } from '../UNSAFE_Collection';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { Roles } from '../UNSAFE_ListView';\nimport { getListViewRoles } from './ListRoles';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { flexitemInterpolations } from '../utils/UNSAFE_interpolations/flexitem';\nimport type { FlexitemProps } from '../utils/UNSAFE_interpolations/flexitem';\nimport { listItemStyles, listItemMultiVariantStyles } from './themes/ListStyles.css';\nimport { compareListItemContext } from '../utils/PRIVATE_collectionUtils';\n\nexport const ITEM_SELECTOR = '[data-oj-key]';\n\n/**\n * Props for the ListViewItem Component\n */\nexport type Props<K, D> = {\n  children: (context: ListItemRendererContext<K, D>) => ComponentChildren;\n  context: ListItemRendererContext<K, D>;\n  itemDepth?: number;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isActive: boolean;\n  isGridlineVisible: boolean;\n  isSelected: boolean;\n  isTopGridlineVisible?: boolean;\n  isTabbable?: boolean;\n  role: Roles;\n  selectionMode: SelectionMode;\n  suggestion?: 'end' | true;\n  currentItemVariant?: CurrentItemVariant;\n};\n\n/**\n * The internal component used to render a single item in ListView.\n */\nexport function ListViewItem<K extends string | number, D>({\n  children,\n  context,\n  itemDepth,\n  isFocused,\n  isFocusRingVisible,\n  isActive,\n  isGridlineVisible,\n  isSelected,\n  isTopGridlineVisible = false,\n  isTabbable = false,\n  role,\n  selectionMode,\n  suggestion,\n  currentItemVariant\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const roles = useMemo(() => getListViewRoles(role), [role]);\n  const itemKey = context.metadata.key;\n  const itemIndex = context.index;\n\n  // some roles come with related aria attributes which need to be set\n  const cellRoleAttributes =\n    roles.cell === 'option'\n      ? {\n          role: roles.cell,\n          'aria-posinset': itemIndex + 1,\n          'aria-setsize': -1\n        }\n      : {\n          role: roles.cell\n        };\n\n  // don't bubble Arrow Up and Down events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (isTabbable && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {\n      event.stopPropagation();\n    }\n  };\n\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const variantClasses = listItemMultiVariantStyles({\n    selectable: isSelectable(selectionMode, isSelected) ? 'isSelectable' : 'notSelectable',\n    selected: isSelected ? 'isSelected' : 'notSelected',\n    selectedSingle:\n      isSelected && selectionMode === 'single' ? 'isSelectedSingle' : 'notSelectedSingle',\n    needsEventsHover: applyHoverStyle ? 'isNeedsEventsHover' : 'notNeedsEventsHover',\n    pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n    active: applyActiveStyle || isActive ? 'isActive' : 'notActive',\n    focusHighlight:\n      currentItemVariant === 'highlight' && isFocused ? 'isFocusHighlight' : 'notFocusHighlight',\n    focusRingVisible:\n      isFocusRingVisible && isFocused ? 'isFocusRingVisible' : 'notFocusRingVisible',\n    gridlineTop: isTopGridlineVisible ? 'visible' : 'hidden',\n    gridlineBottom:\n      isGridlineVisible ||\n      (suggestion === 'end' && !isGridlineVisible && (!isSelected || selectionMode !== 'single'))\n        ? 'visible'\n        : 'hidden'\n  });\n  const classes = classNames([variantClasses]);\n  const styleInterpolations = mergeInterpolations<FlexitemProps>([\n    ...Object.values(flexitemInterpolations)\n  ]);\n  const { class: cls, ...cellStyles } = styleInterpolations({\n    flex: '1 1 auto',\n    alignSelf: 'center'\n  });\n  const cellClasses = classNames([\n    cls,\n    selectionMode === 'multiple' && listItemStyles.checkboxContainer\n  ]);\n\n  // todo: use translated text for selector\n  // note cannot put focus on gridcell div since JAWS will not read the aria-rowindex\n  // correctly, so unfortunately needed another div\n  return (\n    <div\n      aria-rowindex={role === 'grid' ? itemIndex + 1 : undefined}\n      aria-level={itemDepth}\n      data-oj-key={itemKey}\n      class={classes}\n      ref={rootRef}\n      role={roles.item}\n      {...(suggestion && { 'data-oj-suggestion': true })}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...interactionProps}>\n      <div\n        id={useId()}\n        style={cellStyles}\n        class={cellClasses}\n        aria-posinset={role === 'grid' ? undefined : itemIndex + 1}\n        aria-setsize={role === 'grid' ? undefined : -1}\n        onKeyDown={handleKeyDown}\n        aria-colindex={role === 'grid' ? 1 : undefined}\n        aria-selected={selectionMode !== 'none' ? isSelected : undefined}\n        {...cellRoleAttributes}>\n        <TabbableModeContext.Provider value={{ isTabbable }}>\n          <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n            {children(context)}\n          </FocusTrap>\n        </TabbableModeContext.Provider>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Helper method to determine whether item is selectable\n * @returns true if item is selectable (show hover effect), false otherwise\n */\nconst isSelectable = (selectionMode: SelectionMode, isItemSelected: boolean) => {\n  return selectionMode !== 'none' && (selectionMode === 'multiple' || !isItemSelected);\n};\n\nexport const MemoizeListViewItem = memo(ListViewItem, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.children === next.children &&\n      prev.isFocused === next.isFocused &&\n      prev.isFocusRingVisible === next.isFocusRingVisible &&\n      prev.isSelected === next.isSelected &&\n      prev.isTabbable === next.isTabbable &&\n      prev.isActive === next.isActive &&\n      prev.suggestion === next.suggestion &&\n      prev.isGridlineVisible === next.isGridlineVisible &&\n      prev.isTopGridlineVisible === next.isTopGridlineVisible &&\n      compareListItemContext(prev.context, next.context)\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { skeletonStyles } from './themes/ListStyles.css';\n\ntype Props = {\n  /**\n   * Allows to pass and access the properties from child elements\n   **/\n  children?: (index: number) => ComponentChildren;\n  /**\n   * Allows to specify number of skeletons to be rendered on initial load\n   **/\n  minimumCount?: number;\n};\n\n/**\n * Allows to specify the time delay for rendering the component\n **/\nconst timerValue = 50;\n\n/**\n * SkeletonContainer renders 'minimumCount' number of skeletons\n * of the variant specified from its child element - Skeleton's prop after\n * 'timerValue' ms delay\n **/\nexport function SkeletonContainer({ children, minimumCount = 1 }: Props) {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsVisible(true);\n    }, timerValue);\n  }, []);\n\n  const containerClasses = classNames([skeletonStyles.container]);\n  return isVisible && children ? (\n    <div class={containerClasses} role=\"presentation\">\n      {[...Array(minimumCount)].map((_element, index) => children(index))}\n    </div>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { globalImages } from '#/ImageVars.css';\nimport { sparkleStyles } from './themes/ListStyles.css';\nimport { useTheme } from '#/hooks/UNSAFE_useTheme';\n\nconst SPARKLE_STYLE_CLASS = 'oj-collection-sparkle';\n\n/**\n * A sparkle component for smart suggestion indicator in ListView\n * @param sparkleHeight the height of sparkle\n */\nexport function Sparkle({ sparkleHeight }: { sparkleHeight: number }) {\n  const { name } = useTheme();\n  if (sparkleHeight <= 0) {\n    return null;\n  }\n\n  const height = sparkleHeight + 'px';\n  const sparkleClasses = classNames([sparkleStyles.base]);\n  const containerClasses = classNames([\n    sparkleStyles.container,\n    SPARKLE_STYLE_CLASS,\n    // TODO: this component should create separate theme definitions to only show the image in redwood\n    name === 'redwood' && globalImages\n  ]);\n\n  return (\n    <div key=\"sparkle\" class={containerClasses}>\n      <div class={sparkleClasses} style={{ height }}></div>\n    </div>\n  );\n}\n","import { RefObject } from 'preact';\nimport { useState, useEffect, useMemo } from 'preact/hooks';\nimport { Props as ListViewProps } from '../UNSAFE_ListView';\nimport { PLACEHOLDER_STYLE_CLASS } from '../PRIVATE_VirtualizedCollection';\nimport { Metadata } from '../UNSAFE_Collection';\n\nexport const usePromotedSection = <K extends string | number, D>(\n  data: ListViewProps<K, D>['data'],\n  promotedSection: ListViewProps<K, D>['promotedSection'],\n  rootRef: RefObject<HTMLDivElement>\n) => {\n  // tracking sparkle height\n  const [sparkleHeight, setSparkleHeight] = useState<number>(0);\n\n  const suggestions = useMemo(\n    () => data && promotedSection && findSuggestions(data.data, promotedSection.count),\n    [data, promotedSection]\n  );\n\n  useEffect(() => {\n    // update sparkleHeight only when we have suggestions\n    // avoid unnecessary iterating through elements\n    if (suggestions) {\n      const placeholder = rootRef.current?.querySelector(\n        '.' + PLACEHOLDER_STYLE_CLASS\n      ) as HTMLElement;\n      let height = placeholder?.offsetHeight || 0;\n      const suggestionItems = rootRef.current?.querySelectorAll('[data-oj-suggestion]');\n      suggestionItems?.forEach((item) => (height += (item as HTMLElement).offsetHeight));\n      setSparkleHeight(height);\n    }\n  }, [rootRef, suggestions]);\n\n  return { sparkleHeight, suggestions };\n};\n\n/**\n * A helper function that finds the data with suggestions, and\n * returns the corresponding keys\n * @param dataState\n */\nconst findSuggestions = <K, D>(data: { data: D; metadata: Metadata<K> }[], count: number) => {\n  if (count === 0) {\n    return null;\n  }\n\n  const suggestionsData = data.slice(0, count);\n  return suggestionsData.reduce((suggestions, value, index) => {\n    const key = value.metadata.key;\n\n    if (index === count - 1) {\n      suggestions.set(key, 'end');\n    } else {\n      suggestions.set(key, true);\n    }\n\n    return suggestions;\n  }, new Map<K, 'end' | true>());\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { FlattenedDataState } from '../UNSAFE_Collection';\nimport { Keys } from '../utils/UNSAFE_keys';\n\n/**\n * Helper function to only include keys of leaf items.\n */\nexport const excludeGroup = <K, D>(data: FlattenedDataState<K, D>, keys: Keys<K>) => {\n  if (!keys.all) {\n    const groups = data.data\n      .filter((dataMetadata) => {\n        return !dataMetadata.metadata.isLeaf;\n      })\n      .map((dataMetadata) => {\n        return dataMetadata.metadata.key;\n      });\n    const leafOnly = Array.from(keys.keys.values()).filter((key: K) => {\n      return !groups.includes(key);\n    });\n    return { ...keys, keys: new Set(leafOnly) };\n  }\n  return keys;\n};\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nexport const scrollToVisible = (elem: Element, scroller: Element, offset: number) => {\n  if (elem && scroller) {\n    if ((elem as any).scrollIntoViewIfNeeded) {\n      // for Safari, we'll need the non-standard scrollIntoViewIfNeeded\n      (elem as any).scrollIntoViewIfNeeded();\n    } else {\n      elem.scrollIntoView({ block: 'nearest' });\n    }\n    if (offset > 0) {\n      const scrollerBounds = scroller.getBoundingClientRect();\n      const elemBounds = elem.getBoundingClientRect();\n      const diff = scrollerBounds.top + offset - elemBounds.top;\n      if (diff > 0) {\n        scroller.scrollTop = scroller.scrollTop - diff;\n      }\n    }\n  }\n};\n","import { RefObject } from 'preact';\nimport { useEffect, useCallback, useRef, useMemo } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { Keys } from '../utils/UNSAFE_keys';\nimport {\n  DataState,\n  Metadata,\n  Range,\n  SelectionDetail,\n  CurrentKeyDetail\n} from '../UNSAFE_Collection';\nimport { getListViewRoles } from './ListRoles';\nimport { SelectionRangeDetail, useSelection } from '../hooks/PRIVATE_useSelection';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useCollectionInteractionContext } from '../hooks/UNSAFE_useCollectionInteractionContext';\nimport { useItemAction } from '../hooks/PRIVATE_useItemAction';\nimport { Props as ListViewProps } from '../UNSAFE_ListView';\nimport { getPrevNextKey, findElementByKey, keyExtractor } from '../utils/PRIVATE_collectionUtils';\nimport { ITEM_SELECTOR } from './ListItem';\nimport { scrollToVisible } from './ListUtils';\n\nexport const useSelectionAndNavigation = <K extends string | number, D>(\n  currentKey: K | undefined,\n  selectedKeys: Keys<K>,\n  selectionMode: ListViewProps<K, D>['selectionMode'] = 'none',\n  onCurrentKeyChange: ((detail: CurrentKeyDetail<K>) => void) | undefined,\n  onSelectionChange: ListViewProps<K, D>['onSelectionChange'],\n  onItemAction: ListViewProps<K, D>['onItemAction'],\n  data: ListViewProps<K, D>['data'],\n  viewportConfig: ListViewProps<K, D>['viewportConfig'],\n  role: ListViewProps<K, D>['role'] = 'grid',\n  scrollToVisibleOffset: ListViewProps<K, D>['scrollToVisibleOffset'],\n  rootRef: RefObject<HTMLDivElement>,\n  pendingSelectionCallback: (detail: SelectionRangeDetail<K>, value: Range) => void,\n  isCurrentItemOverridden: boolean\n) => {\n  const listRoles = useMemo(() => getListViewRoles(role), [role]);\n\n  // tracking the anchor key which is used for shift+click selection\n  const anchorKey = useRef<K | undefined>();\n\n  const collectionInteraction = useCollectionInteractionContext();\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    selectionMode !== 'multiple',\n    getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR),\n    undefined,\n    undefined,\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, ['ArrowUp', 'ArrowDown']);\n\n  useEffect(() => {\n    if (currentKey != null && rootRef.current) {\n      const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n      if (elem) {\n        const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n        const cell = elem.querySelector(`[role=${listRoles.cell}]`);\n        if (cell && activeDescendant !== cell.id) {\n          // update aria-activedescendant for screenreader\n          rootRef.current.setAttribute('aria-activedescendant', cell.id);\n\n          // scroll the current item into view only when the current item is updated internally\n          // or when the collection interaction is 'embedded' if the current item is updated by the app\n          if (!isCurrentItemOverridden || collectionInteraction === 'embedded') {\n            const scroller = viewportConfig?.scroller();\n            const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n            // make sure item is visible\n            scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n          }\n        }\n      }\n    }\n    // listen to data because the current item would re-render when the virtualizer\n    // is fetching data or updating the data, i.e. the id of current item would be updated,\n    // so the currentKey itself couldn't guarantee the root has latest aria-activedescendant\n  }, [\n    currentKey,\n    data,\n    listRoles.cell,\n    viewportConfig,\n    scrollToVisibleOffset,\n    rootRef,\n    isCurrentItemOverridden\n  ]);\n\n  const handleSelectionChange = useCallback(\n    (detail: SelectionDetail<K>) => {\n      if (onSelectionChange) {\n        if (detail.value.all === false && detail.value.keys.size > 0) {\n          // during regular selection, the last key selected by a user gesture is the anchor key\n          anchorKey.current = Array.from(detail.value.keys.values()).pop();\n        }\n        onSelectionChange(detail);\n      }\n    },\n    [anchorKey, onSelectionChange]\n  );\n\n  const handleSelectionRangeChange = useCallback(\n    (detail: SelectionRangeDetail<K>) => {\n      if (data && onSelectionChange) {\n        const value = handleSelectionRange(detail, data);\n        if (Array.isArray(value)) {\n          if (detail.eventType === 'shiftSpace') {\n            // during range selection by shift+space, the first key selected by a user gesture is the anchor key\n            anchorKey.current = detail.value.start;\n          } else {\n            // during range selection by shift+click/arrow keys, the last key selected by a user gesture is the anchor key\n            anchorKey.current = detail.value.end;\n          }\n          onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n        } else {\n          pendingSelectionCallback(detail, value);\n        }\n      }\n    },\n    [data, onSelectionChange, pendingSelectionCallback]\n  );\n\n  const { selectionProps } = useSelection(\n    (element: HTMLElement) => {\n      if (element === rootRef.current) {\n        return currentKey === undefined ? null : currentKey;\n      }\n      return keyExtractor(element, ITEM_SELECTOR) as K;\n    },\n    selectedKeys,\n    selectionMode,\n    false,\n    'replace',\n    collectionInteraction === 'embedded',\n    handleSelectionChange,\n    anchorKey.current,\n    currentKey,\n    (currentKey: K | undefined, isPrev: boolean) =>\n      getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR),\n    undefined,\n    (key: K) => {\n      if (rootRef.current) {\n        const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n        if (elem) {\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        }\n      }\n    },\n    handleSelectionRangeChange\n  );\n\n  const itemActionProps = useItemAction(\n    currentKey,\n    data,\n    onItemAction,\n    ITEM_SELECTOR,\n    collectionInteraction === 'embedded'\n  );\n\n  return {\n    eventProps: mergeProps(currentKeyProps, focusRingProps, selectionProps, itemActionProps),\n    showFocusRing,\n    handleSelectionChange\n  };\n};\n\nexport const handleSelectionRange = <K, D>(\n  detail: SelectionRangeDetail<K>,\n  dataState: DataState<K, D>\n) => {\n  const keys = dataState.data.map((value: { data: D; metadata: Metadata<K> }) => {\n    return value.metadata.key;\n  });\n  const startIndex = keys.indexOf(detail.value.start);\n  const endIndex = keys.indexOf(detail.value.end);\n  const minIndex = Math.min(startIndex, endIndex);\n  const maxIndex = Math.max(startIndex, endIndex);\n  if (minIndex === -1) {\n    // return a range to fetch so we can find all the keys, maxIndex should not be -1\n    return { offset: 0, count: dataState.totalSize };\n  } else {\n    // range of keys are in the current viewport, return them\n    return keys.slice(minIndex, maxIndex + 1);\n  }\n};\n","import { RefObject } from 'preact';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { Props as ListViewProps } from '../UNSAFE_ListView';\nimport { CurrentKeyDetail } from '../UNSAFE_Collection';\nimport { getFirstVisibleKey, keyExtractor } from '../utils/PRIVATE_collectionUtils';\nimport { isKeyDefined } from '../utils/UNSAFE_keys';\nimport { ITEM_SELECTOR } from './ListItem';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { findElementByKey } from '../utils/PRIVATE_collectionUtils';\nimport { scrollToVisible } from './ListUtils';\n\nexport const useFocusTabbableMode = <K extends string | number, D>(\n  currentKey: K | undefined,\n  onCurrentKeyChange: ((detail: CurrentKeyDetail<K>) => void) | undefined,\n  allowTabbableMode: ListViewProps<K, D>['allowTabbableMode'],\n  rootRef: RefObject<HTMLDivElement>,\n  viewportConfig: ListViewProps<K, D>['viewportConfig'],\n  scrollToVisibleOffset: ListViewProps<K, D>['scrollToVisibleOffset']\n) => {\n  const pendingCurrentKey = useRef<K>();\n\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    rootRef,\n    (element) => {\n      // we don't want List to go into Tabbable mode when user clicks on expander\n      return isExpander(element) ? null : (keyExtractor(element, ITEM_SELECTOR) as K);\n    },\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const handleInitialFocus = useCallback(() => {\n    if (\n      rootRef.current &&\n      onCurrentKeyChange &&\n      (!allowTabbableMode || isCurrentTabbableKey(undefined))\n    ) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  }, [rootRef, onCurrentKeyChange, allowTabbableMode, isCurrentTabbableKey]);\n\n  const handleFocus = useCallback(\n    (event: FocusEvent) => {\n      if (isExpander(event.target as HTMLElement)) {\n        rootRef.current?.focus();\n        const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n        if (onCurrentKeyChange && isKeyDefined(key)) {\n          onCurrentKeyChange({ value: key as K });\n        }\n        return;\n      }\n      if (!isKeyDefined(currentKey)) {\n        onCurrentKeyChange && handleInitialFocus();\n      } else if (rootRef.current) {\n        // if currentKey is defined, make sure scroll the current item into view when listview regains focus\n        const elem = findElementByKey(rootRef.current, currentKey as K, ITEM_SELECTOR);\n        if (elem) {\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        } else {\n          // if elem is not found, meaning the currentKey is not valid, we should pick the first item as current item\n          onCurrentKeyChange && handleInitialFocus();\n        }\n      }\n    },\n    [currentKey, handleInitialFocus, onCurrentKeyChange, rootRef]\n  );\n\n  /**\n   * Need to track pointer down element to set currentItem when initial focus happens\n   */\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n    if (isKeyDefined(key)) {\n      pendingCurrentKey.current = key as K;\n    }\n  }, []);\n\n  return {\n    eventProps: mergeProps(allowTabbableMode ? tabbableModeProps : {}, {\n      onFocus: handleFocus,\n      onPointerDown: handlePointerDown\n    }),\n    isCurrentTabbableKey\n  };\n};\n\nconst isExpander = (elem: HTMLElement) => {\n  if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {\n    return true;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { useRef, useCallback, useState, useImperativeHandle } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport { DataState, ItemContext, ListItemRendererContext, Range } from '../UNSAFE_Collection';\nimport { LoadMoreCollection, LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { VirtualizedCollection } from '../PRIVATE_VirtualizedCollection';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { ListViewItem, ITEM_SELECTOR, MemoizeListViewItem } from './ListItem';\n\nimport { SelectionRangeDetail } from '../hooks/PRIVATE_useSelection';\nimport { SkeletonContainer } from './SkeletonContainer';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { Flex } from '../UNSAFE_Flex';\nimport { Selector } from '../UNSAFE_Selector';\nimport { Props } from '../UNSAFE_ListView';\nimport { Sparkle } from './Sparkle';\nimport { listStyles } from './themes/ListStyles.css';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\nimport { usePromotedSection } from './usePromotedSection';\nimport { useSelectionAndNavigation, handleSelectionRange } from './useSelectionAndNavigation';\nimport { useFocusTabbableMode } from './useFocusTabbableMode';\nimport { useCurrentItemOverride } from './useCurrentItemOverride';\nimport { Inset } from '../UNSAFE_Inset';\n// TODO: add this import due to issue JET-67485, need to update once Stable is introduced\nimport './themes/redwood/ListBaseTheme.css';\n\n/**\n * Component that renders items as a flat list.\n * In order to maximize performance, only items that are visible in the viewport are rendered.\n */\nexport function List<K extends string | number, D>({\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  allowTabbableMode = true,\n  children,\n  data,\n  gridlines,\n  loadingIndicator = defaultLoadingIndicator,\n  currentItemOverride,\n  onPersistCurrentItem,\n  onLoadRange,\n  onSelectionChange,\n  onItemAction,\n  rangeExtractor,\n  role = 'grid',\n  selectedKeys = emptyKeys as Keys<K>,\n  selectionMode = 'none',\n  viewportConfig,\n  currentItemVariant = 'none',\n  promotedSection,\n  isVirtualized = false,\n  customItemRenderer,\n  scrollToVisibleOffset,\n  testId,\n  scrollerRef,\n  reorderProps,\n  contextMenuTriggerProps,\n  ...props\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n\n  // tracking pending selection key that is not in current data\n  const pendingSelection = useRef<{ detail: SelectionRangeDetail<K>; range: Range }>();\n\n  const [active, setActive] = useState<boolean>(false);\n\n  const showGridline = (index: number) => {\n    // show bottom gridlines for each item, and for the last item if specified\n    return (\n      gridlines?.item === 'visible' &&\n      (index + 1 !== data?.totalSize || gridlines?.bottom === 'visible')\n    );\n  };\n\n  const showGridlineTop = () => {\n    // show the top gridline for the first item\n    return gridlines?.item === 'visible' && gridlines?.top === 'visible';\n  };\n\n  const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n  const ariaRowCount =\n    data === null ? undefined : data.sizePrecision === 'exact' ? data.totalSize : -1;\n\n  const classes = classNames([listStyles.base]);\n\n  const pendingSelectionCallback = useCallback(\n    (detail: SelectionRangeDetail<K>, value: Range) => {\n      if (data) {\n        pendingSelection.current = {\n          detail: detail,\n          range: { offset: data.offset, count: data.data.length }\n        };\n        onLoadRange(value);\n      }\n    },\n    [data, onLoadRange]\n  );\n\n  const { currentKey, onCurrentKeyChange, isCurrentItemOverridden } = useCurrentItemOverride(\n    currentItemOverride,\n    onPersistCurrentItem\n  );\n\n  const { eventProps, showFocusRing, handleSelectionChange } = useSelectionAndNavigation(\n    currentKey,\n    selectedKeys,\n    selectionMode,\n    onCurrentKeyChange,\n    onSelectionChange,\n    onItemAction,\n    data,\n    viewportConfig,\n    role,\n    scrollToVisibleOffset,\n    rootRef,\n    pendingSelectionCallback,\n    isCurrentItemOverridden\n  );\n\n  const { eventProps: focusTabbableProps, isCurrentTabbableKey } = useFocusTabbableMode(\n    currentKey,\n    onCurrentKeyChange,\n    allowTabbableMode,\n    rootRef,\n    viewportConfig,\n    scrollToVisibleOffset\n  );\n\n  if (data && pendingSelection.current !== undefined && onSelectionChange) {\n    const keys = handleSelectionRange(pendingSelection.current.detail, data);\n    if (Array.isArray(keys)) {\n      onSelectionChange({ value: { all: false, keys: new Set(keys) }, target: null });\n    }\n    const range = pendingSelection.current\n      ? pendingSelection.current.range\n      : { offset: data.offset, count: data.data.length };\n    data = adjustDataState(data, range);\n    pendingSelection.current = undefined;\n    onLoadRange(range);\n  }\n\n  const { sparkleHeight, suggestions } = usePromotedSection(data, promotedSection, rootRef);\n\n  // TODO: check suggestions before Sparkle would cause a scrolling issue\n  const sparkleIndicator = <Sparkle sparkleHeight={sparkleHeight}></Sparkle>;\n\n  // Collection generic is of this type\n  type DataStateData = DataState<K, D>['data'][number];\n\n  // returns an ListItemContext based on ItemContext (added metadata and selector)\n  // note the type for ItemContext, this is the context coming from Collection\n  const getItemContext = useCallback(\n    (context: ItemContext<DataStateData>) => {\n      const dataStateData = context.data;\n      const selectorRenderer =\n        selectionMode === 'multiple'\n          ? () => (\n              <Selector\n                onChange={handleSelectionChange}\n                rowKey={dataStateData.metadata.key}\n                selectedKeys={selectedKeys}></Selector>\n            )\n          : undefined;\n\n      return {\n        index: context.index,\n        data: dataStateData.data,\n        metadata: dataStateData.metadata,\n        selector: selectorRenderer\n      };\n    },\n    [selectionMode, selectedKeys, handleSelectionChange]\n  );\n\n  const ItemComponent = isVirtualized ? ListViewItem : MemoizeListViewItem;\n\n  const childrenComponent = (context: ItemContext<DataStateData>) => {\n    const listItemContext = getItemContext(context);\n    const suggestion = suggestions?.get(listItemContext.metadata.key);\n    const isTabbable = allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key);\n    const isFocused = currentKey === listItemContext.metadata.key && !isTabbable;\n    const isActive = isFocused && active;\n    const isSelected = containsKey(selectedKeys, listItemContext.metadata.key);\n    const isFocusRingVisible = isFocused && showFocusRing;\n    const listItemFunc = (ctx: ListItemRendererContext<K, D>, otherProps?: any) => (\n      <ItemComponent\n        key={listItemContext.metadata.key}\n        context={ctx}\n        isFocused={isFocused}\n        isFocusRingVisible={isFocusRingVisible}\n        isActive={isActive}\n        isGridlineVisible={showGridline(listItemContext.index)}\n        isSelected={isSelected}\n        isTabbable={allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key)}\n        role={role}\n        selectionMode={selectionMode}\n        currentItemVariant={currentItemVariant}\n        {...(suggestion && { suggestion })}\n        {...(listItemContext.index === 0 && { isTopGridlineVisible: showGridlineTop() })}\n        {...otherProps}>\n        {children}\n      </ItemComponent>\n    );\n\n    // if customItemRenderer is specified (ExpandableList and GroupedList)\n    // create a custom context with additional info including a function\n    // that helps create the default item component\n    if (customItemRenderer) {\n      const customRendererContext = {\n        listItemContext,\n        isFocused,\n        isFocusRingVisible,\n        isSelected,\n        isTabbable,\n        isActive,\n        defaultListItem: listItemFunc\n      };\n      return customItemRenderer(customRendererContext);\n    }\n    return listItemFunc(listItemContext);\n  };\n\n  viewportConfig = getViewportConfig(rootRef, viewportConfig);\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === ' ' && isKeyDefined(currentKey) && selectionMode !== 'none') {\n        setActive(true);\n      }\n    },\n    [currentKey, selectionMode, setActive]\n  );\n\n  const handleKeyUp = useCallback(() => {\n    setActive(false);\n  }, [setActive]);\n\n  useImperativeHandle(scrollerRef!, () => rootRef.current);\n\n  // if data is not specified, listview should show loading indicator\n  // todo: replace placeholder with actual SkeletonContainer component (Ash is working on)\n  const testIdProps = useTestId(testId);\n  return (\n    <div\n      {...mergeProps(\n        eventProps,\n        focusTabbableProps,\n        contextMenuTriggerProps || {},\n        reorderProps || {},\n        {\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp\n        },\n        props\n      )}\n      {...testIdProps}\n      role={role}\n      aria-rowcount={role === 'grid' ? ariaRowCount : undefined}\n      aria-colcount={role === 'grid' ? 1 : undefined}\n      ref={rootRef}\n      class={classes}\n      tabIndex={0}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-multiselectable={ariaMultiSelectable}>\n      {data == null ? (\n        loadingIndicator\n      ) : isVirtualized ? (\n        <VirtualizedCollection\n          data={data}\n          itemSelector={ITEM_SELECTOR}\n          loadMoreIndicator={defaultLoadMoreIndicator}\n          onLoadRange={onLoadRange}\n          rangeExtractor={rangeExtractor}\n          suggestions={sparkleIndicator}\n          viewportConfig={viewportConfig}>\n          {childrenComponent}\n        </VirtualizedCollection>\n      ) : (\n        <LoadMoreCollection\n          data={data.data}\n          loadMoreIndicator={defaultLoadMoreIndicator}\n          hasMore={data.sizePrecision === 'atLeast' && data.data.length <= data.totalSize}\n          onLoadMore={() => {\n            data && onLoadRange({ offset: 0, count: data.data.length + 25 });\n          }}\n          suggestions={sparkleIndicator}\n          viewportConfig={viewportConfig}>\n          {childrenComponent}\n        </LoadMoreCollection>\n      )}\n    </div>\n  );\n}\n\nconst getViewportConfig = (rootRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return rootRef.current;\n      }\n    }\n  );\n};\n\nconst emptyKeys = { all: false, keys: new Set() };\n\nconst defaultLoadingIndicator = (\n  <SkeletonContainer minimumCount={25}>\n    {() => {\n      return (\n        <Inset variant=\"listview\">\n          <Flex height=\"6x\" align=\"center\">\n            <Skeleton height=\"4x\" />\n          </Flex>\n        </Inset>\n      );\n    }}\n  </SkeletonContainer>\n);\n\nconst defaultLoadMoreIndicator = (\n  <div class={LOADMORE_STYLE_CLASS}>\n    <SkeletonContainer minimumCount={3}>\n      {() => {\n        return (\n          <Inset variant=\"listview\">\n            <Flex height=\"6x\" align=\"center\">\n              <Skeleton height=\"4x\" />\n            </Flex>\n          </Inset>\n        );\n      }}\n    </SkeletonContainer>\n  </div>\n);\n\n/**\n * Adjust the DataState as needed if it contains more than needed for the specified range\n */\nconst adjustDataState = <K, D>(dataState: DataState<K, D>, range: Range | null) => {\n  if (range) {\n    // prevent range offset from being larger than the data state\n    const safeRangeOffset = Math.min(range.offset, dataState.offset + dataState.totalSize);\n    const diff = safeRangeOffset - dataState.offset;\n    if (diff > 0) {\n      dataState = {\n        offset: safeRangeOffset,\n        data: dataState.data.slice(diff, diff + range.count),\n        totalSize: dataState.totalSize,\n        sizePrecision: dataState.sizePrecision\n      };\n    }\n  }\n  return dataState;\n};\n","import { useRef, useMemo, useState, useEffect } from 'preact/hooks';\nimport { Props as ListProps } from '../UNSAFE_ListView';\nimport { CurrentKeyDetail, Item, CurrentItemDetail } from '../UNSAFE_Collection';\nimport { useReorderableContext } from '#hooks/PRIVATE_useReorderable/useReorderableContext';\n\n/**\n * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to\n * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and\n * also triggers an update when a new currentItemOverride is passed by the app\n *\n * @param currentItemOverride\n * @param onPersistCurrentItem\n */\nexport const useCurrentItemOverride = <K extends string | number, D>(\n  currentItemOverride: ListProps<K, D>['currentItemOverride'],\n  onPersistCurrentItem: ListProps<K, D>['onPersistCurrentItem']\n) => {\n  // the internal state of current item\n  const [currentItem, setCurrentItem] = useState<Item<K>>();\n  // track the currentItemOverride props\n  const currentItemOverrideRef = useRef<Item<K>>();\n  // whether the current item is overridden by the app\n  const isCurrentItemOverridden = useRef(false);\n  // update current item key for reorderable list\n  const reorderContext = useReorderableContext();\n\n  // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately\n  const handleCurrentItemChanged = useMemo(() => {\n    return (detail: CurrentItemDetail<K>) => {\n      setCurrentItem(detail.value);\n      onPersistCurrentItem?.(detail);\n      if (reorderContext?.currentItemKey != null) {\n        reorderContext.currentItemKey.current = detail.value?.rowKey;\n      }\n    };\n  }, [onPersistCurrentItem, reorderContext?.currentItemKey]);\n\n  // ensure any new currentItemOverride settings are applied only on that render\n  // (same as how Table handles the changes)\n  if (currentItemOverrideRef.current !== currentItemOverride) {\n    currentItemOverrideRef.current = currentItemOverride;\n    if (currentItem?.rowKey !== currentItemOverride?.rowKey) {\n      isCurrentItemOverridden.current = true;\n      handleCurrentItemChanged({ value: currentItemOverride });\n    }\n  }\n\n  useEffect(() => {\n    isCurrentItemOverridden.current = false;\n  });\n\n  return {\n    currentKey: currentItem?.rowKey,\n    onCurrentKeyChange: (detail: CurrentKeyDetail<K>) => {\n      handleCurrentItemChanged({ value: { rowKey: detail.value } });\n    },\n    isCurrentItemOverridden: isCurrentItemOverridden.current\n  };\n};\n"],"names":["getListViewRoles","ariaRole","list","item","cell","ITEM_SELECTOR","ListViewItem","children","context","itemDepth","isFocused","isFocusRingVisible","isActive","isGridlineVisible","isSelected","isTopGridlineVisible","isTabbable","role","selectionMode","suggestion","currentItemVariant","rootRef","useRef","roles","useMemo","itemKey","metadata","key","itemIndex","index","cellRoleAttributes","interactionProps","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","useInteractionStyle","variantClasses","listItemMultiVariantStyles","selectable","isSelectable","selected","selectedSingle","needsEventsHover","pseudoHover","active","focusHighlight","focusRingVisible","gridlineTop","gridlineBottom","classes","classNames","styleInterpolations","mergeInterpolations","Object","values","flexitemInterpolations","class","cls","cellStyles","flex","alignSelf","cellClasses","listItemStyles","checkboxContainer","_jsx","jsx","undefined","ref","id","useId","style","onKeyDown","event","stopPropagation","TabbableModeContext","Provider","value","FocusTrap","isDisabled","restoreFocusRef","isItemSelected","MemoizeListViewItem","memo","prev","next","compareListItemContext","SkeletonContainer","minimumCount","isVisible","setIsVisible","useState","useEffect","setTimeout","containerClasses","skeletonStyles","container","Array","map","_element","SPARKLE_STYLE_CLASS","Sparkle","sparkleHeight","name","useTheme","height","sparkleClasses","sparkleStyles","base","globalImages","findSuggestions","data","count","slice","reduce","suggestions","set","Map","scrollToVisible","elem","scroller","offset","scrollIntoViewIfNeeded","scrollIntoView","block","scrollerBounds","getBoundingClientRect","elemBounds","diff","top","scrollTop","handleSelectionRange","detail","dataState","keys","startIndex","indexOf","start","endIndex","end","minIndex","Math","min","maxIndex","max","totalSize","isExpander","parentElement","classList","contains","getViewportConfig","config","current","emptyKeys","all","Set","defaultLoadingIndicator","Inset","variant","Flex","align","Skeleton","defaultLoadMoreIndicator","LOADMORE_STYLE_CLASS","adjustDataState","range","safeRangeOffset","sizePrecision","ariaLabel","ariaLabelledBy","allowTabbableMode","gridlines","loadingIndicator","currentItemOverride","onPersistCurrentItem","onLoadRange","onSelectionChange","onItemAction","rangeExtractor","selectedKeys","viewportConfig","promotedSection","isVirtualized","customItemRenderer","scrollToVisibleOffset","testId","scrollerRef","reorderProps","contextMenuTriggerProps","props","pendingSelection","setActive","ariaMultiSelectable","ariaRowCount","listStyles","pendingSelectionCallback","useCallback","length","currentKey","onCurrentKeyChange","isCurrentItemOverridden","currentItem","setCurrentItem","currentItemOverrideRef","reorderContext","useReorderableContext","handleCurrentItemChanged","currentItemKey","rowKey","useCurrentItemOverride","eventProps","showFocusRing","handleSelectionChange","listRoles","anchorKey","collectionInteraction","useCollectionInteractionContext","currentKeyProps","useCurrentKey","element","keyExtractor","getPrevNextKey","focusRingProps","useCollectionFocusRing","findElementByKey","activeDescendant","getAttribute","querySelector","setAttribute","size","from","pop","handleSelectionRangeChange","isArray","eventType","target","selectionProps","useSelection","isPrev","itemActionProps","useItemAction","mergeProps","useSelectionAndNavigation","focusTabbableProps","isCurrentTabbableKey","pendingCurrentKey","tabbableModeProps","useTabbableModeSet","handleInitialFocus","firstKey","getFirstVisibleKey","isKeyDefined","handleFocus","focus","handlePointerDown","onFocus","onPointerDown","useFocusTabbableMode","setSparkleHeight","placeholder","PLACEHOLDER_STYLE_CLASS","offsetHeight","suggestionItems","querySelectorAll","forEach","usePromotedSection","sparkleIndicator","getItemContext","dataStateData","selectorRenderer","Selector","onChange","selector","ItemComponent","childrenComponent","listItemContext","get","containsKey","listItemFunc","ctx","otherProps","bottom","defaultListItem","handleKeyDown","handleKeyUp","useImperativeHandle","testIdProps","useTestId","onKeyUp","tabIndex","VirtualizedCollection","itemSelector","loadMoreIndicator","LoadMoreCollection","hasMore","onLoadMore","groups","filter","dataMetadata","isLeaf","leafOnly","includes"],"mappings":"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"}