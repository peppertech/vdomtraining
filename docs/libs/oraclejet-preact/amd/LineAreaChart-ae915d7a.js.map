{"version":3,"file":"LineAreaChart-ae915d7a.js","sources":["../../src/UNSAFE_LineAreaChart/OverviewLineWithAreaChart.tsx","../../src/UNSAFE_LineAreaChart/LineAreaChart.tsx"],"sourcesContent":["import { LineAreaChart } from './LineAreaChart';\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\n\nexport function OverviewLineAreaChart<K extends string | number, D extends LineAreaItem<K>>(\n  props: LineAreaChartProps<K, D>\n) {\n  return (\n    <LineAreaChart\n      datatip={() => ({ content: '' })}\n      zoomAndScroll=\"off\"\n      overview=\"off\"\n      plotArea={{\n        yMajorTick: {\n          isRendered: false\n        }\n      }}\n      xAxis={{\n        tickLabel: {\n          autoRotate: false,\n          // @ts-ignore\n          isRendered: props.xAxis?.timeAxisType ? true : false\n        }\n      }}\n      series={props.series}\n      groups={props.groups}\n      getDataItem={props.getDataItem}\n      yAxis={{\n        tickLabel: {\n          isRendered: false\n        }\n      }}\n      type={props.type}\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\nimport { findNearestDataPoint } from '#utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from '#PRIVATE_LineAreaComponents/AreaSeries';\nimport { getCumulativeSeries, getMarkers, getSeriesData } from '#utils/PRIVATE_chartUtils/utils';\nimport { MarkersWithLabel } from '#PRIVATE_Chart/MarkersWithLabel';\nimport { getLineAreaChartNavUtil } from '#utils/PRIVATE_chartUtils/navUtils';\nimport { Chart } from '#PRIVATE_Chart';\nimport { Scale, TimeAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { getColorRamp } from '#utils/UNSAFE_visUtils';\nimport { LineSeries } from '#PRIVATE_LineAreaComponents/LineSeries';\nimport { Point } from '#utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '#utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '#Common/themes/themeContract.css';\nimport { getItemColor, getMarkerType } from '#utils/PRIVATE_chartUtils/dataStyleUtils';\nimport { getLineAreaChartItemPosition } from '#PRIVATE_LineAreaComponents/utils/chartUtils';\nimport { OverviewLineAreaChart } from './OverviewLineWithAreaChart';\n\nconst AXIS_OFFSET = 0.2;\nconst LINE_WITH_AREA_OPACITY = 0.2;\n\n/**\n * The LineAreaChart displays information graphically using lines and filled areas, making relationships among the data easier to understand.\n */\nexport function LineAreaChart<K extends string | number, D extends LineAreaItem<K>>({\n  width,\n  height,\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  type = 'line',\n  overview = 'off',\n  dataLabelEffect = 'outline',\n  ...props\n}: LineAreaChartProps<K, D>) {\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const isTestEnv = props.testId !== undefined;\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  const renderedSeries = isStacked\n    ? getCumulativeSeries(series.length, groups.length, getDataItem, hiddenSet, isLog)\n    : getSeriesData(series?.length, groups?.length, getDataItem, hiddenSet, isLog);\n\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number): D | undefined => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    } as D;\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    // TODO: JET-71332\n    //@ts-ignore\n    return getLineAreaChartNavUtil<D>(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale) => {\n    return (seriesIndex: number, groupIndex: number) => {\n      return getLineAreaChartItemPosition(\n        seriesIndex,\n        groupIndex,\n        renderedSeries,\n        getDataItem,\n        groups,\n        isHoriz,\n        xScale,\n        yScale,\n        timeAxisType\n      );\n    };\n  };\n\n  const getMarkerColorAndType = (seriesIndex: number, groupIndex: number) => {\n    return {\n      color: getItemColor(seriesIndex, groupIndex, series, getDataItem),\n      type: getMarkerType(seriesIndex, groupIndex, getDataItem)\n    };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint<K, D>(\n      series,\n      groups,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet,\n      timeAxisType\n    );\n  };\n  const markers = getMarkers();\n  const areaOpacity = type === 'lineWithArea' ? LINE_WITH_AREA_OPACITY : 1;\n  const isAreaRendered = type === 'area' || type === 'lineWithArea';\n  const isContrastLineNeeded = type === 'area';\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedSet}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      series={series}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      getMarkerInfo={getMarkerColorAndType}\n      renderGridLinesInFront={isAreaRendered}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      offset={AXIS_OFFSET}\n      isRtl={isRtl}\n      overview={overview}\n      defaultOverviewContentRenderer={() => {\n        return (\n          <OverviewLineAreaChart\n            series={series}\n            groups={groups}\n            getDataItem={getDataItem}\n            type={type}\n          />\n        );\n      }}\n      {...props}>\n      {({\n        xStartIndex,\n        xEndIndex,\n        xScale,\n        yScale,\n        activeId,\n        focusedItemInfo,\n        hoveredItemInfo,\n        isPointInsideMarquee,\n        defaultFontSize,\n        getTextDimensions\n      }) => {\n        return (\n          <>\n            {renderedSeries.map((lineAreaSeries, index) => {\n              if (lineAreaSeries.length === 0) {\n                /* TODO: need a better way to handle when a series is hidden. */\n                return;\n              }\n              const seriesItem = series[index];\n              const lineSegmentCoords: Point[][] = getLineAreaSegments<K, D>(\n                yScale,\n                xScale,\n                lineAreaSeries,\n                xStartIndex,\n                xEndIndex,\n                isHoriz,\n                isLog,\n                groups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                seriesItem.lineType === 'curved' &&\n                isStacked &&\n                renderedSeries.length > 1 &&\n                index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined ||\n                highlightedIds.length === 0 ||\n                highlightedSet.has(seriesItem.id);\n\n              const prevCoords =\n                isStacked && index != 0\n                  ? allLineSegmentCoords.reduce((prevValue, newValue, j) => {\n                      // find the index i such that i < index, and series i  has at least\n                      // one or more data item unhidden. Only such series will can be\n                      // used as bottomCoord for current series. Otherwise we have to use\n                      // baseline coord\n                      if (j >= index) {\n                        return prevValue;\n                      }\n                      if (newValue.length > 0) {\n                        return j;\n                      }\n                      return prevValue;\n                    }, 0)\n                  : undefined;\n\n              return (\n                <>\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={yScale}\n                      lineType={seriesItem.lineType}\n                      color={seriesItem.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={areaOpacity}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={\n                        prevCoords !== undefined &&\n                        allLineSegmentCoords[prevCoords].some((value) => value != null)\n                          ? allLineSegmentCoords[prevCoords]\n                          : undefined\n                      }\n                      lineSegments={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  <LineSeries\n                    lineType={seriesItem.lineType}\n                    /* TODO: confirm with UX if this is contrastLine (changes depending on dark/light mode) or always white. \n                        It's always white in legacy.*/\n                    lineColor={\n                      isContrastLineNeeded ? colorSchemeVars.dvt.contrastLine : seriesItem.lineColor\n                    }\n                    /* The area generated in legacy are bit apart and not touching when stacked. Preact areas are a bit closer than legacy when curved. \n                      Increased the contrast linewidth (to 2.5 from legacy 1.25) to give legacy visual treatment.\n                      TODO: investivage why legacy areas are not touching. maybe we want to do the same in preact svg utils that\n                      generates this curve.\n                     */\n                    lineWidth={\n                      isContrastLineNeeded ? (isStacked ? 2.5 : 1.25) : seriesItem.lineWidth\n                    }\n                    lineStyle={seriesItem.lineStyle}\n                    color={seriesItem.lineColor || colors[index % colors.length]}\n                    lineSegmentCoords={lineSegmentCoords}\n                    isHorizontal={isHoriz}\n                    isHighlighted={isHighlighted}\n                    seriesIndex={index}\n                  />\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (\n                      <MarkersWithLabel\n                        yScale={yScale}\n                        xScale={xScale}\n                        groups={groups}\n                        series={seriesItem}\n                        timeAxisType={timeAxisType}\n                        color={\n                          seriesItem.lineColor ||\n                          seriesItem.areaColor ||\n                          colors[\n                            index % colors.length\n                          ] /* TODO : make this use getItemColor function from dataStyleUtils. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        isPointInsideMarquee={isPointInsideMarquee}\n                        selectedIds={selectedSet}\n                        highlightedIds={highlightedIds !== undefined ? highlightedSet : undefined}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index &&\n                          focusedItemInfo.isFocusVisible &&\n                          !(props.isDataCursorEnabled && props.dataCursorStyle?.isMarkerDisplayed)\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                        defaultFontSize={defaultFontSize}\n                        dataLabelEffect={dataLabelEffect}\n                        isHighContrast={isHighContrast}\n                        isTestEnv={isTestEnv}\n                        getTextDimensions={getTextDimensions}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n            {isStacked &&\n              renderedSeries.map((lineAreaSeries, index) => {\n                if (lineAreaSeries.length === 0) {\n                  /* TODO: need a better way to handle when a series is hidden.*/\n                  return;\n                }\n                const seriesItem = series[index];\n                return (\n                  <MarkersWithLabel\n                    yScale={yScale}\n                    series={series[index]}\n                    xScale={xScale}\n                    groups={groups}\n                    timeAxisType={timeAxisType}\n                    color={\n                      seriesItem.lineColor || seriesItem.areaColor || colors[index % colors.length]\n                    }\n                    seriesIndex={index}\n                    isPointInsideMarquee={isPointInsideMarquee}\n                    startIndex={xStartIndex}\n                    endIndex={xEndIndex}\n                    markerType={markers[index % markers.length]}\n                    orientation={orientation}\n                    isLog={isLog}\n                    activeId={activeId}\n                    getDataItem={getDataItem}\n                    selectedIds={selectedSet}\n                    focusedItemIndex={\n                      focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                        ? focusedItemInfo.groupIndex\n                        : undefined\n                    }\n                    hoveredItemIndex={\n                      hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                        ? hoveredItemInfo.groupIndex\n                        : undefined\n                    }\n                    isSelectionEnabled={selectionMode === 'single' || selectionMode === 'multiple'}\n                    isDrillEnabled={drilling === 'on'}\n                    defaultFontSize={defaultFontSize}\n                    dataLabelEffect={dataLabelEffect}\n                    isHighContrast={isHighContrast}\n                    isTestEnv={isTestEnv}\n                    getTextDimensions={getTextDimensions}\n                  />\n                );\n              })}\n          </>\n        );\n      }}\n    </Chart>\n  );\n}\n"],"names":["OverviewLineAreaChart","props","_jsx","jsx","LineAreaChart","datatip","content","zoomAndScroll","overview","plotArea","yMajorTick","isRendered","xAxis","tickLabel","autoRotate","timeAxisType","series","groups","getDataItem","yAxis","type","AXIS_OFFSET","LINE_WITH_AREA_OPACITY","width","height","selectedIds","hiddenIds","highlightedIds","hideAndShowBehavior","orientation","isStacked","selectionMode","drilling","dataLabelEffect","direction","forcedColors","useUser","isHighContrast","isTestEnv","undefined","testId","isRtl","isLog","scale","hiddenSet","Set","selectedSet","highlightedSet","isHoriz","colors","getColorRamp","renderedSeries","getCumulativeSeries","length","getSeriesData","renderedGetDataItem","seriesIndex","groupIndex","value","markers","getMarkers","areaOpacity","isAreaRendered","isContrastLineNeeded","allLineSegmentCoords","Chart","findNearest","xScale","yScale","findNearestDataPoint","offset","dataWidth","transform","getDataItemPos","getLineAreaChartItemPosition","getMarkerInfo","color","getItemColor","getMarkerType","renderGridLinesInFront","getNavUtil","startIndex","endIndex","getLineAreaChartNavUtil","getGapRatio","defaultOverviewContentRenderer","children","xStartIndex","xEndIndex","activeId","focusedItemInfo","hoveredItemInfo","isPointInsideMarquee","defaultFontSize","getTextDimensions","_jsxs","jsxs","_Fragment","Fragment","map","lineAreaSeries","index","seriesItem","lineSegmentCoords","getLineAreaSegments","isBottomSegmentCurved","lineType","isHighlighted","has","id","prevCoords","reduce","prevValue","newValue","j","AreaSeries","areaColor","isHorizontal","areaColorOpacity","bottomCoords","some","lineSegments","LineSeries","lineColor","colorSchemeVars","dvt","contrastLine","lineWidth","lineStyle","MarkersWithLabel","markerType","focusedItemIndex","isFocusVisible","isDataCursorEnabled","dataCursorStyle","isMarkerDisplayed","hoveredItemIndex","isCurrent","isSelectionEnabled","isDrillEnabled"],"mappings":"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"}