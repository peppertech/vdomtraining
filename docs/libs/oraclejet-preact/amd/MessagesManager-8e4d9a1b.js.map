{"version":3,"file":"MessagesManager-8e4d9a1b.js","sources":["../../src/PRIVATE_Message/MessageTransition.tsx","../../src/PRIVATE_Message/MessagesManager.tsx"],"sourcesContent":["import { JSX, RenderableProps } from 'preact';\nimport { useCallback, useLayoutEffect, useRef, useState } from 'preact/hooks';\nimport { useAnimation, UseAnimationConfig } from '../hooks/UNSAFE_useAnimation';\nimport { useMessagesContext } from '../hooks/UNSAFE_useMessagesContext';\nimport { Transition, TransitionProps } from '../PRIVATE_TransitionGroup';\n\ntype State = 'entering' | 'exiting';\ntype AnimationStates = UseAnimationConfig<State, HTMLDivElement>['animationStates'];\ntype AnimationCallback = UseAnimationConfig<State, HTMLDivElement>['onAnimationEnd'];\ntype Props = RenderableProps<TransitionProps> & {\n  animationStates?: AnimationStates;\n  initialAnimationStyles?: JSX.HTMLAttributes<HTMLDivElement>['style'];\n};\n\nconst DEFAULT_ANIMATION_STATES = {};\n\n/**\n * A intermediary component that handles animation for the messages component.\n *\n * The expected flow is as follows:\n * 1. message removed from the data\n * 2. onExiting called and a callback is passed which needs to be called to complete the transition\n * 3. state set to \"exiting\" in this component\n * 4. triggers useAnimation to perform the exit animation\n * 5. onAnimationEnd is called after the animation, which invokes the callback provided earlier\n * 6. onExited is called (done when the callback mentioned above is called)\n * 7. message is removed from the UI\n *\n * @param param0 Props of the message component\n */\nexport function MessageTransition({\n  animationStates = DEFAULT_ANIMATION_STATES,\n  initialAnimationStyles,\n  onEntering,\n  onExiting,\n  ...transitionProps\n}: Props) {\n  const [state, setState] = useState<State>('entering');\n  const animationCallbackRef = useRef<() => void>();\n  const busyStateResolveRef = useRef<() => void>();\n  const { controller, nodeRef } = useAnimation(state, {\n    animationStates,\n    isAnimatedOnMount: true,\n    onAnimationEnd: useCallback<NonNullable<AnimationCallback>>(() => {\n      // resolve animation callbacks & busyStates\n      animationCallbackRef.current?.();\n      animationCallbackRef.current = undefined;\n      busyStateResolveRef.current?.();\n      busyStateResolveRef.current = undefined;\n    }, [])\n  });\n  const { addBusyState } = useMessagesContext();\n\n  const onEnteringCallback = useCallback<NonNullable<TransitionProps['onEntering']>>(\n    (node, callback, metadata) => {\n      // cancel any existing animation\n      if (animationCallbackRef.current) {\n        animationCallbackRef.current = undefined;\n        controller.cancel();\n      }\n\n      // resolve any existing busyState\n      busyStateResolveRef.current?.();\n      busyStateResolveRef.current = undefined;\n\n      onEntering?.(node, undefined, metadata);\n      // start the animation and set the callback & busyState\n      setState('entering');\n\n      // if there is no animation configured, resolve immediately\n      if (\n        animationStates['entering'] === undefined &&\n        animationStates['exiting => entering'] === undefined\n      ) {\n        callback?.();\n        return;\n      }\n      animationCallbackRef.current = callback;\n      busyStateResolveRef.current = addBusyState?.('messages animating');\n    },\n    [animationStates, controller, addBusyState, onEntering]\n  );\n\n  const onExitingCallback = useCallback<NonNullable<TransitionProps['onExiting']>>(\n    (node, callback, metadata) => {\n      // cancel any existing animation\n      if (animationCallbackRef.current) {\n        animationCallbackRef.current = undefined;\n        controller.cancel();\n      }\n\n      // resolve any existing busyState\n      busyStateResolveRef.current?.();\n      busyStateResolveRef.current = undefined;\n\n      onExiting?.(node, undefined, metadata);\n      // start the animation and set the callback & busyState\n      setState('exiting');\n\n      // if there is no animation configured, resolve immediately\n      if (\n        animationStates['exiting'] === undefined &&\n        animationStates['entering => exiting'] === undefined\n      ) {\n        callback?.();\n        return;\n      }\n      animationCallbackRef.current = callback;\n      busyStateResolveRef.current = addBusyState?.('messages animating');\n    },\n    [animationStates, controller, addBusyState, onExiting]\n  );\n\n  // if animation is interrupted, the busyState may be left hanging. So clear that on unmount\n  // Note: When using a class-based component inside a functional component, the timings of\n  // componentDidMount and useEffect might differ. So, in order to guarantee the registration\n  // of the cleanup function, use useLayoutEffect instead of useEffect. This way we can make sure\n  // the cleanup registers at all times.\n  useLayoutEffect(() => () => busyStateResolveRef.current?.(), []);\n\n  return (\n    <div ref={nodeRef} style={initialAnimationStyles}>\n      <Transition\n        {...transitionProps}\n        onEntering={onEnteringCallback}\n        onExiting={onExitingCallback}\n      />\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChild, ComponentProps, Fragment } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { TransitionGroup } from '../PRIVATE_TransitionGroup';\nimport { Item } from '../utils/UNSAFE_dataProvider';\nimport { MessageTransition } from './MessageTransition';\n\n/**\n * Metadata passed on to the Transition component\n */\ntype TransitionMetadata<K> = {\n  index: number;\n  key: K;\n};\n\n/**\n * Type of the render context passed on to render individual message\n */\ntype MessageRenderContext<Key, Data> = {\n  /**\n   * The index of the current message\n   */\n  index: number;\n\n  /**\n   * The message item with all the necessary data in it\n   */\n  item: Item<Key, Data>;\n};\n\ntype PickedPropsFromMessageTransition = Pick<\n  ComponentProps<typeof MessageTransition>,\n  'animationStates' | 'initialAnimationStyles'\n>;\n\n/**\n * Props for the Message Component\n */\ntype Props<Key, Data> = PickedPropsFromMessageTransition & {\n  /**\n   * A render function that renders individual child.\n   */\n  children?: (context: MessageRenderContext<Key, Data>) => ComponentChild;\n\n  /**\n   * Data for the messages. This data is used for rendering each message.\n   */\n  data: Item<Key, Data>[];\n\n  /**\n   * A callback function that gets called before a message is removed\n   */\n  onMessageWillRemove?: (key: Key, index: number, node?: Element) => void;\n};\n\n/**\n * The component that renders individual messages for the provided data.\n */\nexport function MessagesManager<K extends string | number = string | number, D = any>({\n  data,\n  animationStates,\n  children,\n  initialAnimationStyles,\n  onMessageWillRemove\n}: Props<K, D>) {\n  /**\n   * Handles when a message has finished to exit.\n   *\n   * @param node The corresponding message element\n   * @param callback A callback function to be called after the animation is complete\n   */\n  const handleExited = useCallback(\n    async (node?: Element, metadata?: TransitionMetadata<K>) => {\n      metadata && onMessageWillRemove?.(metadata.key, metadata.index, node);\n    },\n    [onMessageWillRemove]\n  );\n\n  return (\n    <TransitionGroup elementType={Fragment}>\n      {data.map((item, index) => (\n        <MessageTransition\n          animationStates={animationStates}\n          initialAnimationStyles={initialAnimationStyles}\n          key={item.key}\n          metadata={{ index, key: item.key }}\n          onExited={handleExited}>\n          {children?.({ index, item })}\n        </MessageTransition>\n      ))}\n    </TransitionGroup>\n  );\n}\n"],"names":["DEFAULT_ANIMATION_STATES","MessageTransition","animationStates","initialAnimationStyles","onEntering","onExiting","transitionProps","state","setState","useState","animationCallbackRef","useRef","busyStateResolveRef","controller","nodeRef","useAnimation","isAnimatedOnMount","onAnimationEnd","useCallback","current","undefined","addBusyState","useMessagesContext","onEnteringCallback","node","callback","metadata","cancel","onExitingCallback","useLayoutEffect","_jsx","ref","style","children","Transition","data","onMessageWillRemove","handleExited","async","key","index","TransitionGroup","elementType","Fragment","map","item","onExited"],"mappings":"sPAcA,MAAMA,EAA2B,CAAA,WAgBjBC,GAAkBC,gBAChCA,EAAkBF,EAAwBG,uBAC1CA,EAAsBC,WACtBA,EAAUC,UACVA,KACGC,IAEH,MAAOC,EAAOC,GAAYC,EAAQA,SAAQ,YACpCC,EAAuBC,EAAAA,SACvBC,EAAsBD,EAAAA,UACtBE,WAAEA,EAAUC,QAAEA,GAAYC,EAAAA,aAAaR,EAAO,CAClDL,kBACAc,mBAAmB,EACnBC,eAAgBC,EAAWA,aAAiC,KAE1DR,EAAqBS,YACrBT,EAAqBS,aAAUC,EAC/BR,EAAoBO,YACpBP,EAAoBO,aAAUC,CAAS,GACtC,OAECC,aAAEA,GAAiBC,EAAAA,qBAEnBC,EAAqBL,EAAWA,aACpC,CAACM,EAAMC,EAAUC,KAEXhB,EAAqBS,UACvBT,EAAqBS,aAAUC,EAC/BP,EAAWc,UAIbf,EAAoBO,YACpBP,EAAoBO,aAAUC,EAE9BhB,IAAaoB,OAAMJ,EAAWM,GAE9BlB,EAAS,iBAIyBY,IAAhClB,EAA0B,eACiBkB,IAA3ClB,EAAgB,wBAKlBQ,EAAqBS,QAAUM,EAC/Bb,EAAoBO,QAAUE,IAAe,uBAJ3CI,KAIgE,GAEpE,CAACvB,EAAiBW,EAAYQ,EAAcjB,IAGxCwB,EAAoBV,EAAWA,aACnC,CAACM,EAAMC,EAAUC,KAEXhB,EAAqBS,UACvBT,EAAqBS,aAAUC,EAC/BP,EAAWc,UAIbf,EAAoBO,YACpBP,EAAoBO,aAAUC,EAE9Bf,IAAYmB,OAAMJ,EAAWM,GAE7BlB,EAAS,gBAIwBY,IAA/BlB,EAAyB,cACkBkB,IAA3ClB,EAAgB,wBAKlBQ,EAAqBS,QAAUM,EAC/Bb,EAAoBO,QAAUE,IAAe,uBAJ3CI,KAIgE,GAEpE,CAACvB,EAAiBW,EAAYQ,EAAchB,IAU9C,OAFAwB,EAAAA,iBAAgB,IAAM,IAAMjB,EAAoBO,aAAa,IAG3DW,EAAAA,IAAK,MAAA,CAAAC,IAAKjB,EAASkB,MAAO7B,EAAsB8B,SAC9CH,EAAAA,IAACI,EAAAA,eACK5B,EACJF,WAAYmB,EACZlB,UAAWuB,KAInB,mBCjEgB,UAAsEO,KACpFA,EAAIjC,gBACJA,EAAe+B,SACfA,EAAQ9B,uBACRA,EAAsBiC,oBACtBA,IAQA,MAAMC,EAAenB,EAAAA,aACnBoB,MAAOd,EAAgBE,KACrBA,GAAYU,IAAsBV,EAASa,IAAKb,EAASc,MAAOhB,EAAK,GAEvE,CAACY,IAGH,OACEN,EAAAA,IAACW,EAAAA,gBAAe,CAACC,YAAaC,EAAAA,SAAQV,SACnCE,EAAKS,KAAI,CAACC,EAAML,IACfV,EAAAA,IAAC7B,EAAiB,CAChBC,gBAAiBA,EACjBC,uBAAwBA,EAExBuB,SAAU,CAAEc,QAAOD,IAAKM,EAAKN,KAC7BO,SAAUT,WACTJ,IAAW,CAAEO,QAAOK,UAHhBA,EAAKN,QAQpB"}