{"version":3,"file":"PieChart-cbe2806f.js","sources":["../../src/UNSAFE_PieChart/utils.ts","../../src/UNSAFE_PieChart/PieSlice.tsx","../../src/UNSAFE_PieChart/PieChartWithDimensions.tsx","../../src/UNSAFE_PieChart/pieNavUtils.ts","../../src/UNSAFE_PieChart/PieChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ItemInfo } from '../hooks/PRIVATE_usePieChartNav';\nimport { arcTo, closePath, lineTo, moveTo } from '../utils/PRIVATE_visSVGUtils';\nimport type { PieChartItemData, PieSliceInfo } from './pieChart.types';\n\ntype Bounds = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nconst RADIUS_RATIO = 0.45;\nconst RADIUS_RATIO_WITH_LABELS = 0.38;\nconst SLICE_GAP_RATIO = 3;\nconst MIN_ARC_LENGTH = 1.5;\nconst START_ANGLE = 90;\n\n/**\n * Converts the angle from degrees to radians.\n * @param degree The angle in degrees\n * @returns\n */\nexport function degreesToRads(degree: number) {\n  return degree * (Math.PI / 180);\n}\n\n/**\n * Calculates the angle between two vectors.\n * @param vector1X The x component of first vector.\n * @param vector1Y The y component of first vector.\n * @param vector2X The x component of second vector.\n * @param vector2Y The y component of second vector.\n * @returns\n */\nexport function calculateAngleBetweenTwoVectors(\n  vector1X: number,\n  vector1Y: number,\n  vector2X: number,\n  vector2Y: number\n) {\n  const angle = Math.atan2(vector2Y, vector2X) - Math.atan2(vector1Y, vector1X);\n  return angle < 0 ? angle + 2 * Math.PI : angle;\n}\n\n/**\n * Get the center coord of the pie chart.\n * @param availSpace The available space.\n * @returns\n */\nexport function getPieCenter(availSpace: Bounds) {\n  return {\n    cx: availSpace.x + Math.floor(availSpace.width / 2),\n    cy: availSpace.y + Math.floor(availSpace.height / 2)\n  };\n}\n\n/**\n * Returns the radius of the pie chart.\n * @param availSpace The available space.\n * @param labelPosition The position of labels.\n * @returns\n */\nexport function getRadius(availSpace: Bounds, isLabelOutside: boolean) {\n  const radiusScale = isLabelOutside ? RADIUS_RATIO_WITH_LABELS : RADIUS_RATIO;\n  return Math.floor(Math.min(availSpace.width, availSpace.height) * radiusScale);\n}\n\n/**\n * Returns the total value of the pie chart.\n * @param items\n */\nexport function getPieChartInfo(items: PieChartItemData[]) {\n  return items.reduce(\n    ({ totalValue, isLabelOutside }, item) => {\n      return {\n        totalValue: totalValue + item.value,\n        isLabelOutside\n      };\n    },\n    { totalValue: 0, isLabelOutside: false }\n  );\n}\n\n/**\n * Returns the startAngle and angleOffset for the rendered items.\n * @param items\n * @param totalValue\n */\nexport function getSliceInfo(items: PieChartItemData[], totalValue: number) {\n  let anchorOffset = START_ANGLE;\n  let percentage;\n  const sliceInfo = [];\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const value = item.value;\n    if (value === totalValue) {\n      percentage = 100;\n    } else if (totalValue === 0) {\n      percentage = 0;\n    } else {\n      // if value is not 100%, cap it at 99.99%\n      percentage = Math.min((value / totalValue) * 100, 99.99);\n    }\n    const arc = percentage * 3.6;\n    let angle = anchorOffset - arc;\n    if (angle < 0) angle += 360;\n    sliceInfo.push({\n      index: i,\n      startAngle: angle,\n      angleExtent: arc,\n      ...item\n    });\n\n    anchorOffset = angle;\n  }\n  return sliceInfo;\n}\n\n/**\n * Returns the pie slice gaps.\n * @param  pieSliceGap The ratio of maximum supported pie slice gap.\n * @returns\n */\nexport function getPieSliceGap(pieSliceGap: number) {\n  return SLICE_GAP_RATIO * pieSliceGap;\n}\n\n/**\n * Returns the array of layouts to render without skipping.\n * @param layouts\n * @param hasLargeItemCount\n * @param radius\n * @returns\n */\nexport function getRenderedSlices(\n  itemInfo: PieSliceInfo[],\n  hasLargeItemCount: boolean,\n  radius: number\n): PieSliceInfo[] {\n  if (!hasLargeItemCount) {\n    return itemInfo;\n  }\n\n  const perimeter = 2 * Math.PI * radius;\n  let prevEndCoord = 0;\n\n  return itemInfo.filter(({ startAngle, angleExtent }) => {\n    const arcLength = (angleExtent / 360) * perimeter;\n    const endCoord = ((angleExtent + startAngle) / 360) * perimeter;\n    if (arcLength < MIN_ARC_LENGTH && Math.abs(prevEndCoord - endCoord) < MIN_ARC_LENGTH) {\n      return false;\n    } else {\n      prevEndCoord = endCoord;\n      return true;\n    }\n  });\n}\n\n/**\n * Returns the path of the pie slice wedge.\n * @param inset The inset.\n * @param cx The x coordinate of the center of the pie chart.\n * @param cy The y coordinate of the center of the pie chart.\n * @param radiusX The x radius of the slice.\n * @param radiusY The y radius of the slice.\n * @param innerRadius The inner radius.\n * @param angleExtent The angle extent.\n * @param wedgeGap The gap beteen the pie slices.\n * @param startAngle The start angle of the pie slice.\n * @returns\n */\nexport function makeWedgePath(\n  inset: number,\n  cx: number,\n  cy: number,\n  radiusX: number,\n  radiusY: number,\n  innerRadius: number,\n  angleExtent: number,\n  wedgeGap: number,\n  startAngle: number\n) {\n  const rx = Math.max(radiusX - inset, 0);\n  const ry = Math.max(radiusY - inset, 0);\n  const gap = angleExtent == 360 || rx < inset ? 0 : wedgeGap + 2 * inset;\n\n  const ir = innerRadius ? innerRadius + inset : 0;\n  // if angle extent is not 360, cap it  at 359.99\n  const angleExtentRads = angleExtent == 360 ? degreesToRads(359.99) : degreesToRads(angleExtent);\n\n  const startAngleRads = degreesToRads(startAngle);\n  const dataItemGaps = gap / 2;\n\n  const gapAngle = dataItemGaps < rx ? Math.asin(dataItemGaps / rx) : 0;\n  const centerLineAngle = -angleExtentRads / 2 - startAngleRads;\n\n  // cap at 5* dataItemsGap. logic from legacy dvt toolkit\n  const distanceToStartPointX = Math.min(\n    dataItemGaps * 5,\n    angleExtentRads > 0 ? Math.abs(dataItemGaps / Math.sin(angleExtentRads / 2)) : 0\n  );\n  const distanceToStartPointY = rx == 0 ? distanceToStartPointX : (distanceToStartPointX * ry) / rx;\n\n  const startPointX = cx + Math.cos(centerLineAngle) * distanceToStartPointX;\n  const startPointY = cy + Math.sin(centerLineAngle) * distanceToStartPointY;\n\n  const arcPointX = cx + Math.cos(-gapAngle - startAngleRads) * rx;\n  const arcPointY = cy + Math.sin(-gapAngle - startAngleRads) * ry;\n\n  const arcPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + gapAngle) * rx;\n  const arcPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + gapAngle) * ry;\n\n  let outerAngle = calculateAngleBetweenTwoVectors(\n    arcPoint2X - cx,\n    arcPoint2Y - cy,\n    arcPointX - cx,\n    arcPointY - cy\n  );\n  outerAngle = Math.min(outerAngle, angleExtentRads);\n  let pathCommands: string;\n  if (ir > 0) {\n    const innerGapAngle = dataItemGaps < ir ? Math.asin(dataItemGaps / ir) : 0;\n    const innerPointX = cx + Math.cos(-innerGapAngle - startAngleRads) * ir;\n    const innerPointY = cy + Math.sin(-innerGapAngle - startAngleRads) * ir;\n\n    const innerPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + innerGapAngle) * ir;\n    const innerPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + innerGapAngle) * ir;\n\n    let innerAngle = calculateAngleBetweenTwoVectors(\n      innerPoint2X - cx,\n      innerPoint2Y - cy,\n      innerPointX - cx,\n      innerPointY - cy\n    );\n    innerAngle = Math.min(innerAngle, outerAngle, angleExtentRads);\n\n    if (angleExtent == 360) {\n      pathCommands = moveTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += moveTo(innerPointX, innerPointY);\n      pathCommands += arcTo(ir, ir, angleExtentRads, 0, innerPoint2X, innerPoint2Y);\n    } else {\n      pathCommands = moveTo(innerPoint2X, innerPoint2Y);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);\n      pathCommands += lineTo(innerPointX, innerPointY);\n      pathCommands += arcTo(ir, ir, innerAngle, 0, innerPoint2X, innerPoint2Y);\n    }\n  } else {\n    if (angleExtent == 360) {\n      pathCommands = moveTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);\n    } else {\n      pathCommands = moveTo(startPointX, startPointY);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);\n    }\n  }\n\n  pathCommands += closePath();\n  return pathCommands;\n}\n\n/**\n * Returns the pie chart center context.\n * @param cx The x coordinate of the center of the pie chart.\n * @param cy The y coordinate of the center of the pie chart.\n * @param innerRadius The inner radius of the pie chart.\n * @returns\n */\nexport function getCenterContext(cx: number, cy: number, innerRadius: number) {\n  return {\n    innerBounds: {\n      width: Math.sqrt(2) * innerRadius,\n      height: Math.sqrt(2) * innerRadius,\n      x: cx - innerRadius / Math.sqrt(2),\n      y: cy - innerRadius / Math.sqrt(2)\n    },\n    outerBounds: {\n      width: 2 * innerRadius,\n      height: 2 * innerRadius,\n      x: cx - innerRadius,\n      y: cy - innerRadius\n    }\n  };\n}\n\n/**\n * Returns the position of the datatip for a given slice.\n * @param startAngle The start angle of the pie slice.\n * @param angleExtent The angle extent of the pie slice.\n * @param cx The x coordinate of the center of the pie slice.\n * @param cy The y coordinate of the center of the pie slice.\n * @param innerRadius The inner radius.\n * @param radius The radius of the pie slice.\n * @returns\n */\nexport function getPieItemCenterCoord(\n  startAngle: number,\n  angleExtent: number,\n  cx: number,\n  cy: number,\n  innerRadius: number,\n  radius: number\n) {\n  const angle = startAngle + angleExtent / 2;\n  const theta = (angle / 180) * Math.PI;\n  const r = (innerRadius + radius) / 2;\n\n  return {\n    x: cx + r * Math.cos(theta),\n    y: cy - r * Math.sin(theta),\n    width: 0,\n    height: 0\n  };\n}\n\n/**\n * Returns the element bound for active item.\n * @param renderedSlices The array of info for rendered slices.\n * @param cx The x coordinate of pie chart center.\n * @param cy The y coordinate of pie chart center.\n * @param ir The inner radius of the pie chart.\n * @param radius The radius of the pie chart.\n * @param activeItem The active item.\n * @returns\n */\nexport function getElementBounds(\n  renderedSlices: PieSliceInfo[],\n  cx: number,\n  cy: number,\n  ir: number,\n  radius: number,\n  activeItem?: ItemInfo\n) {\n  return activeItem\n    ? getPieItemCenterCoord(\n        renderedSlices[activeItem.itemIndex].startAngle,\n        renderedSlices[activeItem.itemIndex].angleExtent,\n        cx,\n        cy,\n        ir,\n        radius\n      )\n    : undefined;\n}\n\n/**\n * Returns default border color for datatip.\n * @param colors The color ramp.\n * @param activeItem The active item info.\n * @param activeData The active pie chart data item.\n * @returns\n */\nexport function getDefaultBorderColor(\n  colors: string[],\n  activeItem?: ItemInfo,\n  activeData?: PieChartItemData\n) {\n  return activeData?.color || activeItem?.itemIndex != undefined\n    ? colors[activeItem!.itemIndex]\n    : undefined;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { makeWedgePath } from './utils';\nimport { styles } from './themes/PieChartStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\n\n/**\n * The props for pie slice.\n */\ntype PieSliceProps = {\n  /**\n   * The x coordinate of the center of the slice.\n   */\n  cx: number;\n\n  /**\n   * The y coordinate of the center of the slice.\n   */\n  cy: number;\n\n  /**\n   * The radius of the pie slice.\n   */\n  r: number;\n\n  /**\n   * The start angle of the pie slice.\n   */\n  startAngle: number;\n\n  /**\n   * The angle extent of the pie slice.\n   */\n  angleExtent: number;\n\n  /**\n   * The gaps to keep between the pie slice items.\n   */\n  gap: number;\n\n  /**\n   * The inner radius of the pie slice.\n   */\n  innerRadius: number;\n\n  /**\n   * The color of the pie slice.\n   */\n  color: ColorProps['color'];\n\n  /**\n   * Whether the slice is focused.\n   */\n  isFocused?: boolean;\n\n  /**\n   * Whether the slice is hovered.\n   */\n  isHovered?: boolean;\n\n  /**\n   * The id of the pie slice.\n   */\n  id?: string;\n\n  /**\n   * The index of the item among rendered series.\n   */\n  itemIndex: number;\n\n  /**\n   * The aria label of the pie slice.\n   */\n  accessibleLabel?: string;\n};\n\n/**\n * The Pie Slice component.\n */\nexport function PieSlice({\n  cx,\n  cy,\n  r,\n  startAngle,\n  angleExtent,\n  gap,\n  innerRadius,\n  color,\n  id,\n  itemIndex,\n  isFocused = false,\n  isHovered = false,\n  ...props\n}: PieSliceProps) {\n  const path = makeWedgePath(0, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);\n  let innerPath;\n  if (isFocused) {\n    innerPath = makeWedgePath(2, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);\n    return (\n      <g\n        id={id}\n        role={props.accessibleLabel ? 'img' : undefined}\n        data-oj-item-index={itemIndex}\n        data-oj-object=\"pieSlice\"\n        aria-label={props.accessibleLabel}>\n        <path d={path} fill={color} stroke={color} className={styles.innerShapes} />\n        <path\n          d={innerPath}\n          fill={color}\n          className={classNames([styles.contrastBorder, styles.innerShapes])}\n        />\n      </g>\n    );\n  }\n  return (\n    <path\n      role={props.accessibleLabel ? 'img' : undefined}\n      aria-label={props.accessibleLabel}\n      d={path}\n      data-oj-object=\"pieSlice\"\n      fill={color}\n      id={id}\n      data-oj-item-index={itemIndex}\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { styles } from './themes/PieChartStyles.css';\nimport {\n  getDefaultBorderColor,\n  getElementBounds,\n  getPieCenter,\n  getRadius,\n  getRenderedSlices,\n  getPieChartInfo,\n  getPieSliceGap,\n  getSliceInfo\n} from './utils';\nimport { getAvailSpace } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { PieSlice } from './PieSlice';\nimport { getCenterContext } from './utils';\nimport { getPieChartNavUtils } from './pieNavUtils';\nimport { ItemInfo, usePieChartNav } from '../hooks/PRIVATE_usePieChartNav';\nimport { calculateOffset, useDatatip } from '../hooks/PRIVATE_useDatatip';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { VisTabularDatatip } from '../PRIVATE_VisTabularDatatip';\nimport type { PieChartProps, PieChartItemData } from './pieChart.types';\nimport { getColorRamp } from '../utils/UNSAFE_visUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { useRef } from 'preact/hooks';\nimport { merge } from '#utils/UNSAFE_stringUtils';\n\ntype PieChartWithDimensionsProps = Omit<PieChartProps, 'width' | 'height'> & {\n  width: number;\n  height: number;\n  data: PieChartItemData[];\n};\n\nconst NUM_PIE_SLICE_THRESHOLD = 100;\nexport function PieChartWithDimensions({\n  width,\n  height,\n  testId,\n  innerRadius = 0,\n  ...props\n}: PieChartWithDimensionsProps) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const colors = getColorRamp();\n  const { totalValue, isLabelOutside } = getPieChartInfo(props.data);\n  const sliceInfos = getSliceInfo(props.data, totalValue);\n\n  // default data item gaps is 0.5. TODO: replace 0.5 with pie dataItemGaps/pieSliceGaps\n  const pieSliceGap = getPieSliceGap(0.5);\n  const hasLargeSeriesCount = props.data.length > NUM_PIE_SLICE_THRESHOLD;\n  const { direction } = useUser();\n  const testIdProps = useTestId(testId);\n  const availSpace = getAvailSpace(width, height);\n  const { cx, cy } = getPieCenter(availSpace);\n  const radius = getRadius(availSpace, isLabelOutside);\n  const ir = innerRadius * radius;\n  const renderedSlices = getRenderedSlices(sliceInfos, hasLargeSeriesCount, radius);\n  const getNextChartItem = getPieChartNavUtils(renderedSlices, direction === 'rtl');\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures: false,\n    rootRef\n  });\n  const { activeId, navProps, focusedItemInfo, hoveredItemInfo } = usePieChartNav({\n    touchResponse,\n    getNextChartItem\n  });\n  const activeItem = focusedItemInfo.isFocusVisible ? focusedItemInfo : hoveredItemInfo;\n  const activeData = activeItem\n    ? props.data[renderedSlices[activeItem.itemIndex].index]\n    : undefined;\n\n  const defaultDatatip = (activeData?: PieChartItemData, activeItem?: ItemInfo) => {\n    if (!activeData) {\n      return {\n        content: undefined,\n        borderColor: undefined\n      };\n    }\n    if (activeData.accessibleLabel) {\n      return {\n        content: activeData.accessibleLabel,\n        borderColor: getDefaultBorderColor(colors, activeItem, activeData)\n      };\n    }\n    return {\n      content: (\n        <VisTabularDatatip\n          tableData={[\n            {\n              key: 'Value',\n              value: activeData.value\n            }\n          ]}\n        />\n      ),\n      borderColor: getDefaultBorderColor(colors, activeItem, activeData)\n    };\n  };\n\n  const { content: datatipString, borderColor } =\n    activeData && props.datatip\n      ? props.datatip({ data: activeData })\n      : defaultDatatip(activeData, activeItem);\n\n  const anchor = focusedItemInfo.isFocusVisible ? 'element' : 'pointer';\n  const elementBounds = activeItem?.isFocusVisible\n    ? getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem)\n    : undefined;\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatipString,\n    offset: calculateOffset(direction === 'rtl', width, elementBounds),\n    anchor,\n    placement: 'top-start',\n    borderColor,\n    touchResponse\n  });\n\n  datatipProps['aria-describedby'] = merge([\n    props['aria-describedby'],\n    datatipProps['aria-describedby']\n  ]);\n\n  const mergedProps = mergeProps(navProps, datatipProps);\n  return (\n    <div\n      ref={rootRef}\n      tabIndex={0}\n      aria-label={props['aria-label']}\n      aria-labelledby={props['aria-labelledby']}\n      aria-activedescendant={activeId}\n      role=\"application\"\n      {...mergedProps}\n      {...testIdProps}\n      className={styles.chart}\n      style={{\n        width,\n        height,\n        ...touchResponseStyle\n      }}>\n      {renderedSlices.length > 0 && (\n        <svg className={styles.svg}>\n          {renderedSlices.map((item, index: number) => {\n            return (\n              <PieSlice\n                cx={cx}\n                cy={cy}\n                itemIndex={index}\n                id={activeItem?.itemIndex === index ? activeId : undefined}\n                isFocused={focusedItemInfo?.itemIndex === index && focusedItemInfo?.isFocusVisible}\n                isHovered={hoveredItemInfo?.itemIndex === index}\n                r={radius}\n                startAngle={item.startAngle}\n                gap={pieSliceGap}\n                innerRadius={ir}\n                angleExtent={item.angleExtent}\n                color={item.color || colors[index % colors.length]}\n                key={item.id}\n                accessibleLabel={item.accessibleLabel}\n              />\n            );\n          })}\n        </svg>\n      )}\n      {props.children?.(getCenterContext(cx, cy, ir))}\n      {datatipContent}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { PieChartItemData } from './pieChart.types';\n\n/**\n * Returns the nav util for pie chart.\n * @param data\n * @param isRtl\n * @returns\n */\nexport function getPieChartNavUtils(data: PieChartItemData[], isRtl: boolean) {\n  const getNextChartItem = (\n    { itemIndex }: { itemIndex: number },\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ): { itemIndex: number } => {\n    let newItemIndex = itemIndex;\n\n    if (\n      (isRtl && (arrow === 'ArrowRight' || arrow === 'ArrowUp')) ||\n      (!isRtl && (arrow === 'ArrowLeft' || arrow === 'ArrowDown'))\n    ) {\n      newItemIndex = itemIndex - 1;\n    } else {\n      newItemIndex = itemIndex + 1;\n    }\n    return {\n      itemIndex: ((newItemIndex % data.length) + data.length) % data.length\n    };\n  };\n\n  return getNextChartItem;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { dimensionStyle } from './themes/PieChartStyles.css';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { PieChartWithDimensions } from './PieChartWithDimensions';\nimport type { PieChartProps } from './pieChart.types';\n\n/**\n * Pie charts are useful for visualizing parts of a whole, but do not display zero or negative values so they are not recommended for data sets that may have negative or null data\n */\nexport function PieChart({ width, height, ...props }: PieChartProps) {\n  return (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(width, height) => <PieChartWithDimensions width={width} height={height} {...props} />}\n    </TrackResizeContainer>\n  );\n}\n"],"names":["RADIUS_RATIO","RADIUS_RATIO_WITH_LABELS","SLICE_GAP_RATIO","MIN_ARC_LENGTH","START_ANGLE","degreesToRads","degree","Math","PI","calculateAngleBetweenTwoVectors","vector1X","vector1Y","vector2X","vector2Y","angle","atan2","makeWedgePath","inset","cx","cy","radiusX","radiusY","innerRadius","angleExtent","wedgeGap","startAngle","rx","max","ry","gap","ir","angleExtentRads","startAngleRads","dataItemGaps","gapAngle","asin","centerLineAngle","distanceToStartPointX","min","abs","sin","distanceToStartPointY","startPointX","cos","startPointY","arcPointX","arcPointY","arcPoint2X","arcPoint2Y","pathCommands","outerAngle","innerGapAngle","innerPointX","innerPointY","innerPoint2X","innerPoint2Y","innerAngle","moveTo","arcTo","lineTo","closePath","getCenterContext","innerBounds","width","sqrt","height","x","y","outerBounds","getElementBounds","renderedSlices","radius","activeItem","theta","r","getPieItemCenterCoord","itemIndex","undefined","getDefaultBorderColor","colors","activeData","color","PieSlice","id","isFocused","isHovered","props","path","innerPath","_jsxs","role","accessibleLabel","children","_jsx","d","fill","stroke","className","styles","innerShapes","classNames","contrastBorder","jsx","NUM_PIE_SLICE_THRESHOLD","PieChartWithDimensions","testId","rootRef","useRef","getColorRamp","totalValue","isLabelOutside","data","reduce","item","value","sliceInfos","items","percentage","anchorOffset","sliceInfo","i","length","arc","push","index","getSliceInfo","pieSliceGap","getPieSliceGap","hasLargeSeriesCount","direction","useUser","testIdProps","useTestId","availSpace","getAvailSpace","floor","getPieCenter","radiusScale","getRadius","itemInfo","hasLargeItemCount","perimeter","prevEndCoord","filter","endCoord","getRenderedSlices","getNextChartItem","isRtl","arrow","newItemIndex","touchResponse","touchResponseStyle","useVisTouchResponse","type","supportsTouchDragGestures","activeId","navProps","focusedItemInfo","hoveredItemInfo","usePieChartNav","isFocusVisible","content","datatipString","borderColor","datatip","VisTabularDatatip","tableData","key","defaultDatatip","anchor","elementBounds","datatipContent","datatipProps","useDatatip","offset","calculateOffset","placement","merge","mergedProps","mergeProps","ref","tabIndex","chart","style","svg","map","TrackResizeContainer","class","dimensionStyle"],"mappings":"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"}