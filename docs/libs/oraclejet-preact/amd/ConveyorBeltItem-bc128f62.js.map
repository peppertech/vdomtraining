{"version":3,"file":"ConveyorBeltItem-bc128f62.js","sources":["../../src/UNSAFE_ConveyorBelt/ConveyorBelt.tsx","../../src/UNSAFE_ConveyorBelt/ConveyorBeltItem.tsx"],"sourcesContent":["import { ComponentChildren, Ref } from 'preact';\nimport { useEffect, useRef, useState, useCallback, useMemo } from 'preact/hooks';\nimport { BaseButton } from '../UNSAFE_BaseButton';\nimport { ButtonLabelLayout } from '../UNSAFE_ButtonLabelLayout';\nimport { ChevronLeft } from '../UNSAFE_RedwoodIcons/ChevronLeft';\nimport { ChevronRight } from '../UNSAFE_RedwoodIcons/ChevronRight';\nimport { ChevronUp } from '../UNSAFE_RedwoodIcons/ChevronUp';\nimport { ChevronDown } from '../UNSAFE_RedwoodIcons/ChevronDown';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { ConveyorBeltContext } from './ConveyorBeltContext';\nimport { TestIdProps, useTestId } from '../hooks/UNSAFE_useTestId';\nimport { forwardRef, useImperativeHandle } from 'preact/compat';\nimport { ConveyorBeltVariantOptions } from './themes/ConveyorBeltStyles.css';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { ConveyorBeltRedwoodTheme } from './themes/redwood/ConveyorBeltTheme';\n\nexport type ConveyorBeltProps = TestIdProps & {\n  /**\n   * ConveyorBelt Component content\n   */\n  children?: ComponentChildren;\n  /**\n   * Sets the number of pixels that an element's content is scrolled from its initial position.\n   */\n  scrollPosition?: number;\n  /**\n   * Callback that is executed every time conveyor belt is scrolled and the scroll position is changed.\n   * @param value The value is the new scroll position of the conveyor belt.\n   * @returns\n   */\n  onScrollPositionChanged?: (value?: number) => void;\n  /**\n   * Indicates whether overflow content arrows are visible or hidden.\n   * \"auto\" show overflow arrows on desktop, hide on mobile.\n   * \"visible\" always show overflow arrows.\n   * \"hidden\" never show overflow arrows.\n   */\n  arrowVisibility?: 'auto' | 'visible' | 'hidden';\n\n  /**\n   * Specify the orientation of the conveyorBelt.\n   * \"horizontal\" Orient the conveyorBelt horizontally.\n   * \"vertical\" Orient the conveyorBelt vertically.\n   */\n  orientation?: 'horizontal' | 'vertical';\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if runnning on a mobile device, false otherwise\n */\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone';\n}\n\ntype ConveyorItemElement = {\n  item: HTMLElement;\n  isVisible: boolean;\n  isCurrent: boolean;\n  index: number;\n};\n\n// utility hook that calculates which conveyorbelt items are visible inside conveyorbelt viewport\n// and which are hidden\nconst useConveyorElementsVisible = (\n  root: HTMLDivElement,\n  orientation: 'horizontal' | 'vertical',\n  prevBtn?: HTMLDivElement,\n  nextBtn?: HTMLDivElement,\n  direction?: 'ltr' | 'rtl'\n) => {\n  const observerRef = useRef<IntersectionObserver>();\n  const targetsRef = useRef<ConveyorItemElement[]>([]);\n  const [targets] = useState<ConveyorItemElement[]>([]);\n  const addTarget = useCallback(\n    (target: ConveyorItemElement) => {\n      if (targetsRef.current !== null) {\n        targetsRef.current.push(target);\n        targets.push(target);\n      }\n    },\n    [targets]\n  );\n\n  useEffect(() => {\n    if (targets && targets.length > 0 && root) {\n      // IntersectionObserver calls visibility change only when item is\n      // fully visible inside (threshold: 1)\n      // conveyorbelt viewport (root),\n      // taking arrow buttons into the account\n      // and viewport should be smaller by the buttons width (rootMargin)\n      const rootMargin =\n        orientation === 'horizontal'\n          ? direction === 'ltr'\n            ? `0px ${nextBtn ? -nextBtn.offsetWidth : 0}px 0px ${\n                prevBtn ? -prevBtn.offsetWidth : 0\n              }px`\n            : `0px ${prevBtn ? -prevBtn.offsetWidth : 0}px 0px ${\n                nextBtn ? -nextBtn.offsetWidth : 0\n              }px`\n          : `${nextBtn ? -nextBtn.offsetHeight : 0}px 0px ${\n              prevBtn ? -prevBtn.offsetHeight : 0\n            }px 0px`;\n\n      observerRef.current = new IntersectionObserver(onVisibilityChange, {\n        root,\n        rootMargin: rootMargin,\n        threshold: 1\n      });\n      for (const target of targets) {\n        if (target != null) observerRef.current.observe(target.item);\n      }\n    }\n    return () => {\n      for (const target of targets) {\n        if (observerRef.current && target != null) observerRef.current.unobserve(target.item);\n      }\n    };\n  }, [targets, targets.length, root, nextBtn, prevBtn, direction]);\n\n  // handle visibility changes\n  const onVisibilityChange = (entries: IntersectionObserverEntry[]) => {\n    const newItems: ConveyorItemElement[] = targetsRef.current.map((conveyorItem, index) => {\n      const foundEntry = entries.find((entry) => entry.target === conveyorItem.item);\n      // if visibility changed for the item, change isVisible property,\n      // otherwise just return the original\n      if (foundEntry) {\n        return {\n          item: foundEntry.target as HTMLDivElement,\n          isVisible: foundEntry.isIntersecting,\n          isCurrent: conveyorItem.isCurrent,\n          index: index\n        };\n      } else {\n        return conveyorItem;\n      }\n    });\n    targetsRef.current = newItems;\n  };\n\n  return useMemo(\n    () => ({\n      itemElementsRef: targetsRef,\n      addItem: addTarget\n    }),\n    [targetsRef, addTarget]\n  );\n};\n\nexport type ScrollableHandle = {\n  scrollElementIntoView: (element: HTMLElement) => void;\n};\n\n/**\n * The Conveyor belt component is a container element that manages\n * overflow for its child elements and allows scrolling among them\n */\nexport const ConveyorBelt = forwardRef(\n  (\n    {\n      children,\n      scrollPosition,\n      onScrollPositionChanged,\n      arrowVisibility = 'auto',\n      orientation = 'horizontal',\n      testId\n    }: ConveyorBeltProps,\n    ref: Ref<ScrollableHandle> = null\n  ) => {\n    const [canPaginateNext, setCanPaginateNext] = useState(false);\n    const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);\n    const overflowContainerRef = useRef<HTMLDivElement | null>(null);\n    const contentContainerRef = useRef<HTMLDivElement | null>(null);\n    const nextButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const prevButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const baseRef = useRef<HTMLDivElement | null>(null);\n    const leftRef = useRef<HTMLDivElement | null>(null);\n    const rightRef = useRef<HTMLDivElement | null>(null);\n    const observerRef = useRef<any>(null);\n    const currentItemRef = useRef<HTMLElement | null>(null);\n    const [currentItem, _setCurrentItem] = useState<HTMLElement | null>(null);\n    const [buttonsHidden, setButtonsHidden] = useState(\n      (isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden'\n    );\n    const { direction } = useUser();\n    const { itemElementsRef, addItem } = useConveyorElementsVisible(\n      overflowContainerRef.current!,\n      orientation,\n      prevButtonContainerRef.current!,\n      nextButtonContainerRef.current!,\n      direction\n    );\n\n    useImperativeHandle(ref, () => ({\n      scrollElementIntoView: (element: HTMLElement) => {\n        scrollIntoView(element);\n      },\n      scrollPrevious: () => {\n        scrollToPreviousPage();\n      },\n      scrollNext: () => {\n        scrollToNextPage();\n      }\n    }));\n\n    const testIdProps = useTestId(testId);\n    const leftArrowTestIdProps = 'leftArrow' + testId;\n    const rightArrowTestIdProps = 'rightArrow' + testId;\n\n    const { variantClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        orientation\n      }\n    );\n\n    const { variantClasses: contentClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        content: orientation\n      }\n    );\n\n    const { variantClasses: overflowClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        pagination:\n          canPaginateNext && canPaginatePrevious\n            ? 'both'\n            : canPaginateNext\n            ? 'next'\n            : canPaginatePrevious\n            ? 'previous'\n            : 'none',\n        direction,\n        orientation,\n        overflow: orientation,\n        arrowVisibility: buttonsHidden === true ? 'hidden' : 'visible'\n      }\n    );\n\n    const { classes: nextButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        nextButton: orientation,\n        direction\n      }\n    );\n\n    const { classes: previousButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        previousButton: orientation,\n        direction\n      }\n    );\n\n    // utility method to get all conveyorbelt items\n    const _getConveyorItems = () => {\n      const conveyorContentChildren = contentContainerRef.current\n        ? Array.from(contentContainerRef.current.querySelectorAll('[data-oj-conveyorbelt-item]'))\n        : [];\n      if (conveyorContentChildren) {\n        let index = -1;\n        for (const child of conveyorContentChildren) {\n          index++;\n          const element = child as HTMLElement;\n          if (element) {\n            const item = itemElementsRef.current.find((item) => item.item === element);\n            if (item == null) {\n              addItem({\n                item: element!,\n                isVisible: false,\n                index: index,\n                isCurrent: false\n              });\n            }\n          }\n        }\n      }\n    };\n\n    useEffect(() => {\n      _getConveyorItems();\n    });\n\n    const scrollEndHandler = useCallback(() => {\n      if (onScrollPositionChanged)\n        onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);\n    }, [onScrollPositionChanged]);\n\n    useEffect(() => {\n      setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');\n    }, [arrowVisibility]);\n\n    useEffect(() => {\n      if (!overflowContainerRef.current) return;\n      overflowContainerRef.current.scrollTo({\n        left: scrollPosition\n      });\n    }, [scrollPosition]);\n\n    // useEffect hook that calculates when arrow buttons should become visible or hidden\n    // using IntersectionObserver\n    useEffect(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const leftGuard = leftRef.current;\n      const rightGuard = rightRef.current;\n\n      if (overflowContainer && leftGuard && rightGuard) {\n        if (!buttonsHidden) {\n          observerRef.current = new IntersectionObserver(\n            (entries) => {\n              entries.forEach((entry) => {\n                if (entry.target.getAttribute('data-intersection-id') === 'left') {\n                  setCanPaginatePrevious(!entry.isIntersecting);\n                } else {\n                  setCanPaginateNext(!entry.isIntersecting);\n                }\n              });\n            },\n            {\n              root: overflowContainer\n            }\n          );\n          observerRef.current.observe(leftGuard);\n          observerRef.current.observe(rightGuard);\n        }\n        overflowContainer.addEventListener('scrollend', scrollEndHandler);\n      }\n\n      // Clean-up\n      return () => {\n        if (!overflowContainer) return;\n        overflowContainer.removeEventListener('scrollend', scrollEndHandler);\n        observerRef.current?.unobserve(leftGuard);\n        observerRef.current?.unobserve(rightGuard);\n      };\n    }, [buttonsHidden, scrollEndHandler]);\n\n    const scrollIntoView = useCallback(\n      (element: HTMLElement) => {\n        // utility method to check if the element is closer to the end edge of the conveyorbelt\n        const _shouldSnapToTheEndEdge = (\n          ltr: boolean,\n          orientation: 'horizontal' | 'vertical',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let right;\n          let left;\n          let bottom;\n\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            bottom = document.documentElement.clientHeight;\n          } else {\n            const scrollerBounds = scroller.getBoundingClientRect();\n            right = canPaginateNext\n              ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.right;\n            left = canPaginateNext\n              ? scrollerBounds.left - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.left;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? ltr\n              ? bounds.right > right\n              : bounds.left < left\n            : bounds.bottom > bottom;\n        };\n\n        // utility method to check that an element is fully visible inside conveyorbelt\n        const _isElementInsideScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let left;\n          let right;\n          let top;\n          let bottom;\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            top = 0;\n            bottom = document.documentElement.clientHeight;\n          } else {\n            const scrollerBounds = scroller.getBoundingClientRect();\n            left = canPaginatePrevious\n              ? scrollerBounds.left + prevButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.left;\n            right = canPaginateNext\n              ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n              : scrollerBounds.right;\n            top = canPaginatePrevious\n              ? scrollerBounds.top + prevButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.top;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextButtonContainerRef.current?.offsetHeight!\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? bounds.left <= right &&\n                bounds.right <= right &&\n                bounds.left >= left &&\n                bounds.right >= left\n            : bounds.top <= bottom &&\n                bounds.bottom <= bottom &&\n                bounds.top >= top &&\n                bounds.bottom >= top;\n        };\n\n        const _isElementOverflowingScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          const bounds = elem.getBoundingClientRect();\n          const scrollerBounds = scroller.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? bounds.width > scrollerBounds.width\n            : bounds.height > scrollerBounds.height;\n        };\n\n        const isElementVisible = _isElementInsideScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (isElementVisible) {\n          return;\n        }\n        const isElementOverflowing = _isElementOverflowingScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n\n        if (!overflowContainerRef.current || !contentContainerRef.current) return;\n        const shouldSnapEnd = _shouldSnapToTheEndEdge(\n          direction === 'ltr',\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (orientation === 'vertical') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              top:\n                element.offsetTop +\n                element.offsetHeight -\n                overflowContainerRef.current.offsetHeight +\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              top:\n                element.offsetTop -\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n\n        if (direction === 'ltr') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                element.offsetLeft +\n                element.offsetWidth -\n                overflowContainerRef.current.offsetWidth +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                element.offsetLeft -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                element.offsetLeft -\n                contentContainerRef.current?.offsetWidth! +\n                overflowContainerRef.current.offsetWidth -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                element.offsetLeft +\n                element.offsetWidth -\n                contentContainerRef.current?.offsetWidth! +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      },\n      [canPaginateNext, canPaginatePrevious, direction]\n    );\n\n    const getNextInvisible = useCallback(() => {\n      const nextInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index >= 1 &&\n          itemElementsRef.current[item.index - 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return nextInvisible?.item;\n    }, [itemElementsRef]);\n\n    const getPreviousInvisible = useCallback(() => {\n      const previousInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index < itemElementsRef.current.length - 1 &&\n          itemElementsRef.current[item.index + 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return previousInvisible?.item;\n    }, [itemElementsRef]);\n\n    // paginates to the previous partially visible or hidden item in the conveyorbelt,\n    // so that it is the last visible of the conveyorbelt view port\n    const scrollToPreviousPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const previousInvisible: HTMLElement | undefined = getPreviousInvisible();\n        if (orientation === 'vertical') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                previousInvisible.offsetTop +\n                previousInvisible.offsetHeight -\n                overflowContainer.offsetHeight +\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                previousInvisible.offsetLeft +\n                previousInvisible.offsetWidth -\n                overflowContainer.offsetWidth +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                previousInvisible.offsetLeft -\n                contentContainerRef.current?.offsetWidth! +\n                overflowContainer.offsetWidth -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getPreviousInvisible]);\n\n    // paginates to the next partially visible or hidden item in the conveyorbelt,\n    // so that it is the first at the start of the conveyorbelt view port\n    const scrollToNextPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const nextInvisible: HTMLElement | undefined = getNextInvisible();\n        if (orientation === 'vertical') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                (nextInvisible?.offsetTop ?? 0) -\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                (nextInvisible?.offsetLeft ?? 0) -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                -(contentContainerRef.current?.offsetWidth! - (nextInvisible?.offsetLeft ?? 0)) +\n                (nextInvisible?.offsetWidth ?? 0) +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getNextInvisible]);\n\n    const setCurrentItem = useCallback(\n      (node: HTMLElement | null) => {\n        if (currentItemRef.current !== node) {\n          // this logic below is needed to make sure only one item is current\n          const item = itemElementsRef.current.find((item) => item.item === node);\n          const currentItem = itemElementsRef.current.find((item) => item.isCurrent === true);\n          if (item === currentItem || !item) return;\n          if (currentItem) currentItem.isCurrent = false;\n          item!.isCurrent = true;\n\n          currentItemRef.current = node;\n          _setCurrentItem(node);\n        }\n      },\n      [itemElementsRef]\n    );\n\n    useEffect(() => {\n      if (currentItem && currentItemRef.current) {\n        scrollIntoView(currentItemRef.current);\n      }\n    }, [currentItem]); // eslint warning about scrollIntoView should be ignored.\n\n    const onFocus = useCallback(\n      (event: FocusEvent) => {\n        if (baseRef.current?.isEqualNode(event.target as HTMLElement)) {\n          return;\n        }\n        if (itemElementsRef.current.length > 0) {\n          const item = itemElementsRef.current.find((item) => item.item === event.target);\n          if (item) scrollIntoView(item.item);\n        } else {\n          scrollIntoView(event.target as HTMLElement);\n        }\n      },\n      [scrollIntoView, itemElementsRef]\n    );\n\n    const previousButtonStyle = clsx([styles.buttonContainer, previousButtonClasses]);\n\n    const nextButtonStyle = clsx([styles.buttonContainer, nextButtonClasses]);\n\n    return (\n      <ConveyorBeltContext.Provider value={{ setCurrentItem }}>\n        <div\n          onFocus={onFocus}\n          ref={baseRef}\n          className={clsx([styles.conveyorStyle, variantClasses])}\n          {...testIdProps}>\n          {canPaginatePrevious && !buttonsHidden && (\n            <div ref={prevButtonContainerRef} class={previousButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToPreviousPage()}\n                aria-hidden={true}\n                testId={leftArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronLeft />\n                      ) : (\n                        <ChevronRight />\n                      )\n                    ) : (\n                      <ChevronUp />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n          <div\n            className={clsx([styles.overflowContainer, overflowClasses])}\n            ref={overflowContainerRef}>\n            <div\n              className={clsx([styles.contentContainer, variantClasses, contentClasses])}\n              ref={contentContainerRef}>\n              <div\n                data-intersection-id=\"left\"\n                ref={leftRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n              {children}\n              <div\n                data-intersection-id=\"right\"\n                ref={rightRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n            </div>\n          </div>\n          {canPaginateNext && !buttonsHidden && (\n            <div ref={nextButtonContainerRef} class={nextButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToNextPage()}\n                aria-hidden={true}\n                testId={rightArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronRight />\n                      ) : (\n                        <ChevronLeft />\n                      )\n                    ) : (\n                      <ChevronDown />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n        </div>\n      </ConveyorBeltContext.Provider>\n    );\n  }\n);\n","import { ComponentChildren } from 'preact';\nimport { useConveyorBeltItem } from './useConveyorBeltItem';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\n\ntype ConveyorBeltItemProps = {\n  /**\n   * The ConveyorBeltItem content\n   */\n  children?: ComponentChildren;\n  /**\n   * Specifies the current item which should be scrolled into view\n   */\n  isCurrent?: boolean;\n};\n/**\n * A wrapper component for one conveyor belt item/child element.\n * It takes care of correctly mark the child components as conveyor belt items.\n * @param param0 ConveyorBeltItemProps\n * @returns\n */\nexport const ConveyorBeltItem = ({ children, isCurrent }: ConveyorBeltItemProps) => {\n  const props = useConveyorBeltItem({\n    isCurrent: isCurrent\n  });\n  return (\n    <div className={clsx([styles.conveyorBeltItemStyle])} {...props}>\n      {children}\n    </div>\n  );\n};\n"],"names":["isMobile","getClientHints","deviceType","ConveyorBelt","forwardRef","children","scrollPosition","onScrollPositionChanged","arrowVisibility","orientation","testId","ref","canPaginateNext","setCanPaginateNext","useState","canPaginatePrevious","setCanPaginatePrevious","overflowContainerRef","useRef","contentContainerRef","nextButtonContainerRef","prevButtonContainerRef","baseRef","leftRef","rightRef","observerRef","currentItemRef","currentItem","_setCurrentItem","buttonsHidden","setButtonsHidden","direction","useUser","itemElementsRef","addItem","root","prevBtn","nextBtn","targetsRef","targets","addTarget","useCallback","target","current","push","useEffect","length","rootMargin","offsetWidth","offsetHeight","IntersectionObserver","onVisibilityChange","threshold","observe","item","unobserve","entries","newItems","map","conveyorItem","index","foundEntry","find","entry","isVisible","isIntersecting","isCurrent","useMemo","useConveyorElementsVisible","useImperativeHandle","scrollElementIntoView","element","scrollIntoView","scrollPrevious","scrollToPreviousPage","scrollNext","scrollToNextPage","testIdProps","useTestId","leftArrowTestIdProps","rightArrowTestIdProps","variantClasses","useComponentTheme","ConveyorBeltRedwoodTheme","contentClasses","content","overflowClasses","pagination","overflow","classes","nextButtonClasses","nextButton","previousButtonClasses","previousButton","conveyorContentChildren","Array","from","querySelectorAll","child","_getConveyorItems","scrollEndHandler","scrollLeft","scrollTo","left","overflowContainer","leftGuard","rightGuard","forEach","getAttribute","addEventListener","removeEventListener","isElementVisible","elem","scroller","right","top","bottom","document","documentElement","clientWidth","clientHeight","scrollerBounds","getBoundingClientRect","bounds","_isElementInsideScrollerBounds","isElementOverflowing","width","height","_isElementOverflowingScrollerBounds","shouldSnapEnd","ltr","_shouldSnapToTheEndEdge","offsetLeft","behavior","offsetTop","getNextInvisible","nextInvisible","getPreviousInvisible","previousInvisible","scrollAmount","scrollTop","setCurrentItem","node","onFocus","event","isEqualNode","previousButtonStyle","clsx","styles","buttonContainer","nextButtonStyle","_jsx","ConveyorBeltContext","Provider","value","_jsxs","className","conveyorStyle","jsx","class","BaseButton","elementDetails","type","isFocusable","styling","size","variant","onAction","ButtonLabelLayout","display","startIcon","ChevronLeft","ChevronRight","SvgChevronRight","ChevronUp","SvgChevronUp","contentContainer","style","minWidth","minHeight","ChevronDown","SvgChevronDown","props","useConveyorBeltItem","classNames","conveyorBeltItemStyle"],"mappings":"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"}