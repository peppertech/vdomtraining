{"version":3,"file":"meterUtils-9d026b15.js","sources":["../../src/utils/PRIVATE_meterUtils/meterUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ReferenceLine,\n  Threshold,\n  ThresholdDisplay,\n  getVisThresholdColor\n} from '../UNSAFE_meterUtils';\nimport { HTMLAttributesSignalExcluded } from '../UNSAFE_attributeUtils';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { xUnits } from '#UNSAFE_Theme';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { typographyVars } from '#Common/themes/themeContract.css';\n\n/**\n * Validates the min, max, value and step passed to the meter are in appropriate range.\n * @throws { RangeError }\n * @param min The minimum value of the meter.\n * @param max The maximum value of the meter.\n * @param value The metric value of the meter.\n * @param step The step value of the meter.\n */\nexport function validateRange(\n  min: number,\n  max: number,\n  value: number,\n  step: number,\n  baseline?: number\n): void {\n  if (min > max) {\n    throw new RangeError('The min must be lower or equal to max.');\n  }\n\n  if (value < min || value > max) {\n    throw new RangeError('The value must be between min and max.');\n  }\n\n  if (step > max - min) {\n    throw new RangeError('The step value must be less than the difference of max and min.');\n  }\n\n  if (baseline !== undefined) {\n    if (baseline < min || baseline > max) {\n      throw new RangeError('Baseline is outside min and max value.');\n    }\n  }\n}\n\n/**\n * Returns the threshold that the current value belongs to. Returns undefined if the current value does not belong to\n * any threshold or if thresholds is undefined.\n * @param value The value in meter.\n * @param thresholds The list of thresholds.\n * @returns The Threshold that current value belongs to.\n */\nexport function findThreshold(value: number, thresholds?: Threshold[]): Threshold | undefined {\n  if (!thresholds) {\n    return;\n  }\n  if (value <= thresholds[0].max) {\n    return thresholds[0];\n  }\n  let minValue = thresholds[0].max;\n  for (let i = 1; i < thresholds.length; i++) {\n    if (minValue < value && value <= thresholds[i].max) {\n      return thresholds[i];\n    }\n    minValue = thresholds[i].max;\n  }\n  return;\n}\n\n/**\n * Returns the color of track for the meter.\n * @param trackColor The color provided via trackColor prop of the meter.\n * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param currentThreshold Current threshold for the meter value.\n * @returns The color of the track for the meter.\n */\nfunction getTrackColor(\n  thresholdDisplay: ThresholdDisplay,\n  currentThreshold: Threshold | undefined,\n  trackColor?: ColorProps['color']\n): string | undefined {\n  if (thresholdDisplay === 'track' && currentThreshold?.color) {\n    return getVisThresholdColor(currentThreshold?.color);\n  }\n  return trackColor;\n}\n\n/**\n * Returns the color of indicator for the meter.\n * @param indicatorColor The color provided via indicatorColor prop of the meter.\n * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param currentThreshold Current threshold for the meter value.\n * @returns The color of the indicator of the meter.\n */\nfunction getIndicatorColor(\n  thresholdDisplay: ThresholdDisplay,\n  currentThreshold: Threshold | undefined,\n  indicatorColor?: ColorProps['color']\n): string | undefined {\n  if (currentThreshold?.color && thresholdDisplay === 'indicator') {\n    return getVisThresholdColor(currentThreshold.color);\n  }\n  return indicatorColor;\n}\n\n/**\n * Returns the color of track and indicator of the meter.\n * @param value The value of the meter.\n * @param trackColor The color provided via trackColor prop.\n * @param indicatorColor The color provided via indicatorColor prop.\n * @param thresholdDisplay Specifies whether current threshold to display in track, indicator or all thresholds in track.\n * @param thresholds The thresholds for metric value of the meter.\n * @returns The color of the indicator and track of the meter.\n */\nexport function getTrackAndIndicatorColor(\n  value: number,\n  thresholdDisplay: ThresholdDisplay,\n  trackColor?: ColorProps['color'],\n  indicatorColor?: ColorProps['color'],\n  thresholds?: Threshold[]\n): {\n  trackColor?: ColorProps['color'];\n  indicatorColor?: ColorProps['color'];\n} {\n  const currentThreshold = findThreshold(value, thresholds);\n  return {\n    trackColor: getTrackColor(thresholdDisplay, currentThreshold, trackColor),\n    indicatorColor: getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor)\n  };\n}\n\n/**\n * Returns the aria properties of the meter bar.\n * @param value The value of the meter bar.\n * @param min The minimum value of the meter bar.\n * @param max The maximum value of the meter bar.\n * @param ariaLabel The aria label of the meter bar.\n * @param ariaLabelledby The ariaLabelledBy of the meter bar.\n * @param thresholds The thresholds values for the meter bar.\n * @param isDisabled The gauge is disabled or not.\n * @param isReadonly the gauge is readonly or not.\n * @param tooltip The tooltip values for the rating gauge.\n * @returns The aria properties of the meter\n */\nexport function getMeterAriaProps(\n  value: number,\n  min: number,\n  max: number,\n  ariaLabel?: string,\n  ariaLabelledby?: string,\n  thresholds?: Threshold[],\n  isDisabled?: boolean,\n  isReadonly?: boolean,\n  tooltip?: string\n): {\n  'aria-label'?: HTMLAttributesSignalExcluded['aria-label'];\n  'aria-valuenow': HTMLAttributesSignalExcluded['aria-valuenow'];\n  'aria-valuemin': HTMLAttributesSignalExcluded['aria-valuemin'];\n  'aria-valuetext': HTMLAttributesSignalExcluded['aria-valuetext'];\n  'aria-valuemax': HTMLAttributesSignalExcluded['aria-valuemax'];\n  'aria-labelledby'?: HTMLAttributesSignalExcluded['aria-labelledby'];\n  'aria-disabled'?: HTMLAttributesSignalExcluded['aria-disabled'];\n  'aria-readonly'?: HTMLAttributesSignalExcluded['aria-readonly'];\n  role: HTMLAttributesSignalExcluded['role'];\n} {\n  const currentThreshold = findThreshold(value, thresholds);\n  const ariaValueText = currentThreshold?.accessibleLabel\n    ? `${value} ${currentThreshold.accessibleLabel}`\n    : `${value}`;\n  const ariaLabelText = ariaLabel\n    ? ariaLabel\n    : tooltip && isReadonly && !isDisabled\n    ? tooltip\n    : undefined;\n  return {\n    'aria-label': ariaLabelText,\n    'aria-valuenow': value,\n    'aria-valuemin': min,\n    'aria-valuetext': ariaValueText,\n    'aria-valuemax': max,\n    'aria-labelledby': ariaLabelledby,\n    'aria-disabled': isDisabled ? true : undefined,\n    'aria-readonly': isReadonly && !isDisabled ? true : undefined,\n    role: 'slider'\n  };\n}\n\n/**\n * Returns the threshold color that the current value belongs to. Returns component color if the current value does not belong to\n * any threshold or if thresholds is undefined.\n * @param value The value in meter.\n * @param thresholds The list of thresholds.\n * @returns The threshold color that current value belongs to.\n */\nexport function getThresholdColorFromValue(value: number, color: any, thresholds?: Threshold[]) {\n  const currentThreshold = findThreshold(value, thresholds);\n  if (currentThreshold?.color) {\n    return currentThreshold?.color;\n  }\n  return color;\n}\n\n/**\n * Returns the resolved values for the legend vars.\n */\nexport const meterVars = [\n  {\n    tokenVar: xUnits(1),\n    key: 'unit',\n    cssProp: 'padding'\n  }\n];\n\n/**\n * Returns the default label font size for given breakpoint.\n */\nexport function getDefaultReferenceLineLabelFontSize(breakPoint: 'min' | 'xs' | 'sm' | 'md') {\n  if (breakPoint === 'min') {\n    return typographyVars.body.xs.fontSize;\n  } else if (breakPoint === 'xs' || breakPoint === 'sm') {\n    return typographyVars.body.md.fontSize;\n  } else {\n    return typographyVars.body.lg.fontSize;\n  }\n}\n\n/**\n * Returns if the list of reference line has a label.\n * @param lines\n * @returns\n */\nexport function hasLabelledReferenceLine(lines?: ReferenceLine[]) {\n  return !!lines?.reduce((prev, cur) => {\n    return !!cur.label || prev;\n  }, false);\n}\n\n/**\n * Returns the maximum dimensions of reference lines labels.\n */\nexport function getMaxRefLabelDims(\n  fontSize: string,\n  lineHeight: string,\n  refLines?: ReferenceLine[],\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!hasLabelledReferenceLine(refLines) || !getTextDimensions || !refLines) {\n    return { dims: [], maxRefLabelDims: { width: 0, height: 0 } };\n  }\n\n  const dims = refLines.map((line) => {\n    const { label, labelStyle } = line;\n    const dims = label\n      ? getTextDimensions(label, { fontSize, lineHeight, ...labelStyle })\n      : { width: 0, height: 0 };\n    return dims;\n  });\n  const maxRefLabelDims = dims.reduce(\n    (acc, cur) => {\n      return {\n        width: Math.max(cur.width, acc.width),\n        height: Math.max(cur.height, acc.height)\n      };\n    },\n    { width: 0, height: 0 }\n  );\n\n  return { dims, maxRefLabelDims };\n}\n"],"names":["findThreshold","value","thresholds","max","minValue","i","length","getTrackColor","thresholdDisplay","currentThreshold","trackColor","color","getVisThresholdColor","getIndicatorColor","indicatorColor","hasLabelledReferenceLine","lines","reduce","prev","cur","label","xUnits","breakPoint","typographyVars","body","xs","fontSize","md","lg","lineHeight","refLines","getTextDimensions","dims","maxRefLabelDims","width","height","map","line","labelStyle","acc","Math","min","ariaLabel","ariaLabelledby","isDisabled","isReadonly","tooltip","undefined","accessibleLabel","role","step","baseline","RangeError"],"mappings":"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"}