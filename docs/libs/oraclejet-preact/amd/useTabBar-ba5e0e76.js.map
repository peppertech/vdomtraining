{"version":3,"file":"useTabBar-ba5e0e76.js","sources":["../../src/hooks/PRIVATE_useTabBar/useTabBar.ts"],"sourcesContent":["import { useState, useRef, useEffect } from 'preact/hooks';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  getPrevNextKeyUsingRef,\n  getFirstVisibleKey,\n  getKey,\n  keyExtractor,\n  findElementByKey\n} from '../../utils/PRIVATE_collectionUtils';\nimport { useCollectionFocusRing } from '../PRIVATE_useCollectionFocusRing';\nimport { useCurrentKey } from '../PRIVATE_useCurrentKey';\nimport { useId } from '../UNSAFE_useId';\n\nimport { ComponentProps, ContextType, RefObject } from 'preact';\nimport type { TabBarContext, TabBarLayout } from '../../UNSAFE_TabBarCommon';\n\ntype TabBarContextValue = ContextType<typeof TabBarContext>;\n\nexport type useTabBarOptions = {\n  class?: string;\n  display?: TabBarContextValue['display'];\n  edge?: 'bottom' | 'top';\n  onRemove?: TabBarContextValue['onRemove'];\n  onSelect?: TabBarContextValue['onSelect'];\n  ref?: RefObject<HTMLDivElement>;\n  selection?: TabBarContextValue['selection'];\n  size?: TabBarContextValue['size'];\n  children?: ComponentProps<typeof TabBarLayout>['children'];\n};\n\nconst ITEM_SELECTOR = '[role=\"tab\"]';\nconst REMOVABLE_ICON_SELECTOR = '[data-oj-tabbar-item-remove-icon=\"true\"]';\nconst REMOVABLE_ITEM_ATTRIBUTE = 'data-oj-removable';\n\n/**\n * Implements TabBar behavior for focus and keyboad handling\n */\nexport function useTabBar<K extends string | number>(options: useTabBarOptions) {\n  const {\n    children,\n    class: className,\n    display,\n    edge = 'top',\n    selection,\n    onSelect,\n    onRemove,\n    ref: rootRef = useRef<HTMLDivElement>(null),\n    size\n  } = options;\n\n  const tabId = useId();\n  const [currentKey, setCurrentKey] = useState<K | undefined>(selection as K);\n\n  const tabItemPrefix = tabId + '_';\n\n  /**\n   * A reference to the previous set of tab keys that this TabBar\n   * contains before children were re-rendered. In the event the \"current\" tab\n   * is removed and the \"currentKey\" reference is broken, we can redirect\n   * the \"currentKey\" to another tab based on the index of the removed tab.\n   */\n  const prevTabKeys = useRef<(string | number | undefined)[]>();\n\n  useEffect(() => {\n    if (rootRef.current) {\n      const tabKeys = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR)).map((elem) =>\n        getKey(elem as HTMLElement)\n      );\n      if (currentKey && !tabKeys.includes(currentKey as K)) {\n        //If prevTabs does not exist set the first visible key as currentKey\n        prevTabKeys.current\n          ? setCurrentKey(findNextValidKey(currentKey, tabKeys, prevTabKeys.current) as K)\n          : setCurrentKey(tabKeys[0] as K);\n      }\n      prevTabKeys.current = tabKeys;\n    }\n  }, [children, currentKey]);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n    'ArrowRight',\n    'ArrowLeft',\n    'Home',\n    'End'\n  ]);\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) =>\n      onRemove\n        ? extractOnlyItemKey(element, ITEM_SELECTOR, REMOVABLE_ICON_SELECTOR)\n        : keyExtractor(element, ITEM_SELECTOR),\n    false,\n    undefined,\n    undefined,\n    getPrevNextKeyUsingRef(rootRef, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKeyUsingRef(rootRef, currentKey, false, ITEM_SELECTOR),\n    currentKey,\n    (detail) => setCurrentKey(detail.value as K)\n  );\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (rootRef.current && currentKey) {\n      if (event.key === 'Home' || event.key === 'End') {\n        const tabBarItemKey = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR), (elem) =>\n          getKey(elem as HTMLElement)\n        );\n        event.preventDefault();\n        setCurrentKey?.(tabBarItemKey[event.key === 'Home' ? 0 : tabBarItemKey.length - 1] as K);\n      }\n      if (event.key === 'Enter' || event.key === ' ') {\n        event.preventDefault();\n        onSelect?.({ value: currentKey });\n      }\n      if (event.key === 'Delete') {\n        const tabBarItem = findElementByKey(\n          rootRef.current,\n          currentKey,\n          ITEM_SELECTOR\n        ) as HTMLElement;\n        if (tabBarItem.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n          onRemove?.({ value: currentKey });\n        }\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (rootRef.current && currentKey === undefined) {\n      const key = getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);\n      if (key) {\n        setCurrentKey(key as K);\n      }\n    }\n  };\n\n  const eventProps = { onKeyDown, onFocus };\n\n  return {\n    rootProps: mergeProps(\n      {\n        'aria-activedescendant': currentKey ? tabItemPrefix + currentKey : '',\n        'aria-multiselectable': false,\n        class: className,\n        ref: rootRef,\n        role: 'tablist',\n        tabIndex: 0\n      },\n      currentKeyProps,\n      focusRingProps,\n      eventProps\n    ),\n    tabBarContext: {\n      currentKey,\n      display,\n      isEdgeBottom: edge === 'bottom',\n      layout: 'condense',\n      onRemove,\n      onSelect,\n      showFocusRing,\n      selection,\n      size,\n      tabItemPrefix\n    }\n  } as const;\n}\n\n//useCurrentKey use click capture that captures first click, which is on remove button\n//when we remove and sets the item being removed to currentKey. So we should not allow\n//this if click is on remove button\nconst extractOnlyItemKey = (element: HTMLElement, itemSelector: string, itemEliminator: string) => {\n  const tabBarItem = element.closest(itemSelector);\n  if (tabBarItem?.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n    const removeButton = element.closest(itemEliminator);\n    if (removeButton && tabBarItem?.contains(removeButton)) {\n      return null;\n    }\n  }\n  return getKey(tabBarItem as HTMLElement);\n};\n\nconst findNextValidKey = <K>(currentKey: K, currTabs: K[], prevTabs: K[]) => {\n  const index = prevTabs.indexOf(currentKey);\n  // update current key to be the first one if currentKey is invalid\n  if (index === -1) {\n    return currTabs[0];\n  }\n  let nextIndex = 0;\n  let isLastKey = false;\n  if (index === prevTabs.length - 1) {\n    nextIndex = index - 1;\n    isLastKey = true;\n  } else {\n    nextIndex = index + 1;\n  }\n  while (nextIndex !== index) {\n    const nextKey = prevTabs[nextIndex];\n    if (currTabs.indexOf(nextKey) !== -1) {\n      return nextKey;\n    }\n    isLastKey ? nextIndex-- : nextIndex++;\n  }\n  // update current key to be the first one if we can't find a suitable next key\n  return currTabs[0];\n};\n"],"names":["ITEM_SELECTOR","REMOVABLE_ITEM_ATTRIBUTE","extractOnlyItemKey","element","itemSelector","itemEliminator","tabBarItem","closest","hasAttribute","removeButton","contains","getKey","findNextValidKey","currentKey","currTabs","prevTabs","index","indexOf","nextIndex","isLastKey","length","nextKey","options","children","class","className","display","edge","selection","onSelect","onRemove","ref","rootRef","useRef","size","tabId","useId","setCurrentKey","useState","tabItemPrefix","prevTabKeys","useEffect","current","tabKeys","Array","from","querySelectorAll","map","elem","includes","showFocusRing","focusRingProps","useCollectionFocusRing","currentKeyProps","useCurrentKey","keyExtractor","undefined","getPrevNextKeyUsingRef","detail","value","eventProps","onKeyDown","event","key","tabBarItemKey","preventDefault","findElementByKey","onFocus","getFirstVisibleKey","rootProps","mergeProps","role","tabIndex","tabBarContext","isEdgeBottom","layout"],"mappings":"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"}