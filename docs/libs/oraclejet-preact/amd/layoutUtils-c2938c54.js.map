{"version":3,"file":"layoutUtils-c2938c54.js","sources":["../../src/PRIVATE_Axis/dataAxisInfo.ts","../../src/PRIVATE_Axis/utils/axisUtils.ts","../../src/PRIVATE_Axis/utils/titleUtils.ts","../../src/utils/PRIVATE_chartUtils/numberFomatUtils.ts","../../src/PRIVATE_Axis/utils/dataAxisUtil.ts","../../src/PRIVATE_Axis/timeAxis.ts","../../src/utils/PRIVATE_chartUtils/dataUtils.ts","../../src/utils/PRIVATE_chartUtils/layoutUtils.ts","../../src/PRIVATE_Axis/groupAxis.ts","../../src/utils/PRIVATE_chartUtils/overviewUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ScaleLog, ScaleLinear } from '#utils/PRIVATE_chartUtils';\nimport { DataAxisInfoProps } from '#utils/UNSAFE_visTypes/chart';\n\nconst MAX_NUMBER_OF_GRIDS_AUTO = 10;\nconst MINOR_TICK_COUNT = 2;\nconst MAJOR_TICK_INCREMENT_BUFFER = 0.0000000001;\nconst MAX_ZOOM = 64;\n\nexport class DataAxisInfo {\n  dataMin!: number;\n  dataMax!: number;\n  viewportMin?: number;\n  viewportMax?: number;\n  min?: number;\n  max?: number;\n  isLog: boolean;\n  majorTickCount!: number;\n  minorTickCount!: number;\n  majorIncrement?: number;\n  minorIncrement?: number;\n  minMajorIncrement?: number;\n  isZeroBaseline: boolean;\n\n  constructor({\n    scale = 'linear',\n    baselineScaling = 'zero',\n    dataMax,\n    dataMin,\n    min,\n    max,\n    viewportMin,\n    viewportMax,\n    ...options\n  }: DataAxisInfoProps) {\n    this.isLog = scale === 'log';\n    this.isZeroBaseline = !this.isLog && baselineScaling === 'zero';\n\n    this.setDataRange(dataMin!, dataMax!);\n    this.setViewportRange(viewportMin, viewportMax, min, max);\n\n    this.majorIncrement = this.actualToLinear(options.step);\n    this.minorIncrement = this.actualToLinear(options.minorStep);\n    this.minMajorIncrement = this.actualToLinear(options.minStep);\n\n    this.calcAxisExtents();\n  }\n\n  /**\n   * Set the dataMin and dataMax.\n   * @param dataMin The minimum of the data.\n   * @param dataMax The maximum of the data.\n   */\n  setDataRange(dataMin: number, dataMax: number) {\n    this.dataMin = this.actualToLinear(dataMin)!;\n    this.dataMax = this.actualToLinear(dataMax)!;\n\n    if (this.isZeroBaseline) {\n      this.dataMin = Math.min(0, this.dataMin);\n      this.dataMax = Math.max(0, this.dataMax!);\n    }\n  }\n\n  setViewportRange(viewportMin?: number, viewportMax?: number, min?: number, max?: number) {\n    this.min = this.actualToLinear(min);\n    this.max = this.actualToLinear(max);\n    this.viewportMin = viewportMin == null ? this.min : this.actualToLinear(viewportMin);\n    this.viewportMax = viewportMax == null ? this.max : this.actualToLinear(viewportMax);\n  }\n\n  setDefaultMin(scaleUnit: number) {\n    // if already set in setViewportRange\n    if (this.min != null) {\n      return;\n    }\n\n    if (this.isZeroBaseline && this.dataMin >= 0) {\n      this.min = 0;\n    } else if (!this.isZeroBaseline && this.max != null) {\n      this.min = this.max - scaleUnit * (Math.floor((this.max - this.dataMin) / scaleUnit) + 1);\n    } else {\n      this.min = (Math.ceil(this.dataMin / scaleUnit) - 1) * scaleUnit;\n    }\n\n    // If all data points are positive, the axis min shouldn't be less than zero\n    if (this.dataMin >= 0 && !this.isLog) {\n      this.min = Math.max(this.min, 0);\n    }\n  }\n\n  setDefaultMax(scaleUnit: number) {\n    if (this.max != null) {\n      return;\n    }\n    if (this.isZeroBaseline && this.dataMax <= 0) {\n      this.max = 0;\n    } else if (!this.isZeroBaseline && this.min != null) {\n      this.max = this.min + scaleUnit * (Math.floor((this.dataMax - this.min) / scaleUnit) + 1);\n    } else {\n      this.max = (Math.floor(this.dataMax / scaleUnit) + 1) * scaleUnit;\n    }\n    // If all data points are negative, the axis max shouldn't be more that zero\n    if (this.dataMax <= 0) {\n      this.max = Math.min(this.max, 0);\n    }\n  }\n\n  calcAxisExtents() {\n    const maxValue = this.max != null ? this.max : this.dataMax;\n    const minValue = this.min != null ? this.min : this.dataMin;\n    const axisStep = this.calcAxisStep(minValue, maxValue);\n    let scaleUnit = this.minMajorIncrement ? Math.max(axisStep, this.minMajorIncrement) : axisStep;\n\n    // If there's only a single value on the axis, we need to adjust the\n    // this.dataMin and this.dataMax to produce a nice looking axis with around 6 ticks.\n    if (this.dataMin === this.dataMax) {\n      if (this.dataMin === 0) {\n        this.dataMax += 5 * scaleUnit;\n      } else {\n        this.dataMin -= 2 * scaleUnit;\n        this.dataMax += 2 * scaleUnit;\n      }\n    }\n\n    this.setDefaultMin(scaleUnit);\n\n    this.setDefaultMax(scaleUnit);\n\n    if (this.max === this.min) {\n      // happens if this.dataMin === this.dataMax === 0\n      this.max = 100;\n      this.min = 0;\n      scaleUnit = (this.max - this.min) / MAX_NUMBER_OF_GRIDS_AUTO;\n    }\n\n    if (\n      (this.viewportMin !== this.min || this.viewportMax !== this.max) &&\n      this.viewportMax != null &&\n      this.viewportMin != null\n    ) {\n      scaleUnit = this.calcAxisStep(this.viewportMin, this.viewportMax);\n    }\n\n    if (this.viewportMin == null) {\n      this.viewportMin = this.min;\n    }\n\n    if (this.viewportMax == null) {\n      this.viewportMax = this.max;\n    }\n\n    this.calcMajorMinorSteps(scaleUnit);\n  }\n\n  /**\n   * Determines the number of major and minor tick counts and increments for the axis if values were not given.\n   * The default minor tick count is 2.\n   * @param {number} scaleUnit The scale unit of the axis.\n   * @private\n   */\n\n  calcMajorMinorSteps(scaleUnit: number) {\n    if (this.max == null || this.min == null) {\n      return;\n    }\n    if (!this.majorIncrement) {\n      if (this.majorTickCount) {\n        this.majorIncrement = (this.viewportMax! - this.viewportMin!) / this.majorTickCount;\n      } else {\n        this.majorIncrement = this.minMajorIncrement\n          ? Math.max(scaleUnit, this.minMajorIncrement!)\n          : scaleUnit;\n      }\n    }\n\n    if (!this.majorTickCount) {\n      this.majorTickCount = (this.viewportMax! - this.viewportMin!) / this.majorIncrement;\n\n      // Check if we have a floating point inaccuracy that causes the tick count to be undercalculated\n      // within the allowable buffer. If so, tick count is supposed to be the rounded up integer.\n      if (Math.ceil(this.majorTickCount) - this.majorTickCount < MAJOR_TICK_INCREMENT_BUFFER) {\n        this.majorTickCount = Math.ceil(this.majorTickCount);\n      }\n    }\n\n    if (!this.minorTickCount) {\n      if (this.minorIncrement) {\n        this.minorTickCount = this.majorIncrement / this.minorIncrement;\n      } else if (this.isLog) {\n        this.minorTickCount = this.majorIncrement;\n      } else {\n        this.minorTickCount = MINOR_TICK_COUNT;\n      }\n    }\n\n    if (!this.minorIncrement) {\n      this.minorIncrement = this.majorIncrement / this.minorTickCount;\n    }\n  }\n\n  calcAxisStep(minValue: number, maxValue: number) {\n    if (this.majorIncrement) {\n      return this.majorIncrement;\n    }\n\n    const spread = maxValue - minValue;\n\n    if (spread === 0) {\n      if (minValue === 0) {\n        return 10;\n      }\n      return Math.pow(10, Math.floor(Math.log10(minValue)) - 1);\n    }\n\n    if (this.isLog) {\n      return Math.floor(spread / 8) + 1;\n    }\n\n    if (this.majorTickCount) {\n      const increment = spread / this.majorTickCount;\n      const testVal = Math.pow(10, Math.ceil(Math.log10(increment) - 1));\n      let firstDigit = increment / testVal;\n      if (firstDigit > 1 && firstDigit <= 1.5) {\n        firstDigit = 1.5;\n      } else if (firstDigit > 5) {\n        firstDigit = 10;\n      } else {\n        firstDigit = Math.ceil(firstDigit);\n      }\n      return firstDigit * testVal;\n    }\n    return this.getDefaultAxisStep(spread);\n  }\n\n  /**\n   * Aesthetically choose a step depending of the spread value.\n   * @param spread The spread of the data values.\n   * @returns The step for the axis.\n   */\n  getDefaultAxisStep(spread: number): number {\n    const t = Math.log10(spread);\n    const testVal = Math.pow(10, Math.ceil(t) - 2);\n    const first2Digits = Math.round(spread / testVal);\n\n    let scaleFactor = 1;\n    if (first2Digits >= 10 && first2Digits <= 14) {\n      scaleFactor = 2;\n    } else if (first2Digits >= 15 && first2Digits <= 19) {\n      scaleFactor = 3;\n    } else if (first2Digits >= 20 && first2Digits <= 24) {\n      scaleFactor = 4;\n    } else if (first2Digits >= 25 && first2Digits <= 45) {\n      scaleFactor = 5;\n    } else if (first2Digits >= 46 && first2Digits <= 80) {\n      scaleFactor = 10;\n    } else {\n      scaleFactor = 20;\n    }\n    return scaleFactor * testVal;\n  }\n\n  linearToActual(value: number) {\n    return this.isLog ? Math.pow(10, value) : value;\n  }\n\n  actualToLinear(value?: number) {\n    if (value == null) {\n      return;\n    }\n\n    if (this.isLog) {\n      return Math.log10(value);\n    }\n    return value;\n  }\n\n  getScale(range: [number, number]) {\n    const { viewportMin, viewportMax } = this.getAxisViewport();\n    const domain: [number, number] = [\n      this.linearToActual(viewportMin),\n      this.linearToActual(viewportMax)\n    ];\n    if (this.isLog) {\n      return new ScaleLog(domain, range);\n    }\n    return new ScaleLinear(domain, range);\n  }\n\n  getFirstTick() {\n    if (this.isZeroBaseline) {\n      return Math.ceil(this.viewportMin! / this.majorIncrement!) * this.majorIncrement!;\n    }\n    return (\n      this.min! +\n      Math.ceil((this.viewportMin! - this.min!) / this.majorIncrement!) * this.majorIncrement!\n    );\n  }\n\n  getAxisViewport() {\n    return {\n      viewportMin: this.viewportMin!,\n      viewportMax: this.viewportMax!\n    };\n  }\n\n  /**\n   * Returns the min and max extent of the axis.\n   */\n  getAxisExtent() {\n    return {\n      min: this.min!,\n      max: this.max!\n    };\n  }\n  /**\n   * Returns the major ticks.\n   */\n  getTicks() {\n    let firstTick = this.getFirstTick();\n    const ticks = [];\n\n    while (firstTick <= this.viewportMax!) {\n      ticks.push(this.linearToActual(firstTick));\n      firstTick += this.majorIncrement!;\n    }\n    return ticks;\n  }\n\n  getMinorTicks() {\n    const coords = [];\n    for (let i = -1; i <= this.majorTickCount; i++) {\n      const value = i * this.majorIncrement! + this.getFirstTick();\n      if (this.isLog && this.majorIncrement == 1 && this.minorIncrement == 1) {\n        // draw linear ticks from 2 to 9\n        for (let j = 2; j <= 9; j++) {\n          const linearValue = value + Math.log10(j);\n          if (linearValue > this.max!) break;\n          if (linearValue < this.min!) continue;\n          coords.push(this.linearToActual(linearValue));\n        }\n      } else {\n        for (let j = 1; j < this.minorTickCount; j++) {\n          const minorValue = value + j * this.minorIncrement!;\n          if (minorValue > this.max!) break;\n          if (minorValue < this.min!) continue;\n\n          coords.push(minorValue);\n        }\n      }\n    }\n    return coords;\n  }\n\n  getStep() {\n    return this.majorIncrement!;\n  }\n\n  getMinExtent() {\n    return (this.max! - this.min!) / MAX_ZOOM;\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, DataAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { VisTextStyle } from '#utils/UNSAFE_visUtils';\nimport type { Font, GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\n\n// increased the axis max ratio temporarily before chart can support\n// axis label truncation. This provides more space to chart axis for\n// really long tick labels for smaller decimal values.\nconst AXIS_MAX_RATIO = 0.3;\n\n/**\n * Returns resolved axis position.\n */\nexport function getAxesPosition(\n  yAxis: DataAxisProps | undefined,\n  isHoriz: boolean,\n  isRtl: boolean\n): {\n  xAxisPosition: AxisPosition;\n  yAxisPosition: AxisPosition;\n} {\n  let xAxisPosition, yAxisPosition: AxisPosition;\n\n  if (isHoriz) {\n    yAxisPosition = yAxis?.position === 'top' ? 'top' : 'bottom';\n    xAxisPosition = (isRtl ? 'right' : 'left') as AxisPosition;\n  } else {\n    xAxisPosition = 'bottom' as AxisPosition;\n    const isYEnd = yAxis?.position === 'end';\n    yAxisPosition = isYEnd ? (isRtl ? 'left' : 'right') : isRtl ? 'right' : 'left';\n  }\n  return { xAxisPosition, yAxisPosition };\n}\n\n/**\n * Returns the tick label anchor position for axis.\n * @param position\n * @param isRtl\n */\nexport function getTickLabelAnchor(position: AxisPosition, isRtl: boolean) {\n  if (!isRtl) {\n    return position === 'left' ? 'end' : position === 'right' ? 'start' : 'middle';\n  }\n  return position === 'left' ? 'start' : position === 'right' ? 'end' : 'middle';\n}\n\n/**\n * Returns the scale for the axis.\n * @param availSpace\n * @param axisViewportMin\n * @param axisViewportMax\n * @param position\n * @returns\n */\nexport function getAxisRange(availSpace: Dimension, position: AxisPosition, isRtl: boolean) {\n  const { x, y, width, height } = availSpace;\n  const y2 = y + height;\n  const x2 = x + width;\n\n  let rangeStart: number;\n  let rangeEnd: number;\n\n  if (position === 'left' || position === 'right') {\n    rangeStart = y2;\n    rangeEnd = y;\n  } else {\n    rangeStart = isRtl ? x2 : x;\n    rangeEnd = isRtl ? x : x2;\n  }\n\n  return [rangeStart, rangeEnd];\n}\n\n/**\n * Returns the maximum possible size of the axis.\n * @param availSpace The available space.\n * @param isHoriz If the axis is horizontal.\n * @param axisSize The ratio of axis to the chart.\n * @returns\n */\nexport function getAxisMaxSize(availSpace: Dimension, isHoriz: boolean, axisSize?: number) {\n  const size = Math.max(0, Math.min(1, axisSize != undefined ? axisSize : AXIS_MAX_RATIO));\n  return (isHoriz ? availSpace.height : availSpace.width) * size;\n}\n\n/**\n * Returns the width of a group for given availableSpace, axisposition and axis extents.\n * @param availSpace The available space to render the axis\n * @param position The position of the axis\n * @param min The minimum value of axis coord\n * @param max The maximum value of axis coord\n * @returns\n */\nexport function getGroupWidth(\n  availSpace: Dimension,\n  position: AxisPosition,\n  min: number,\n  max: number\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  if (isHoriz) {\n    return availSpace.width / (max - min);\n  } else {\n    return availSpace.height / (max - min);\n  }\n}\n\n/**\n * Returns the num of labels to skip safely.\n * @param groupWidth\n * @param tickLabelStyle\n * @param getTextDimensions\n * @returns\n */\nexport function getSafeSkips(\n  groupWidth: number,\n  tickLabelStyle: VisTextStyle,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!getTextDimensions) {\n    return 0;\n  }\n  const textDims = getTextDimensions('MW', tickLabelStyle as Font);\n  const gaps = AXIS_DEFAULTS.labelGap;\n  return Math.floor((0.5 * textDims.width + gaps) / (2 * groupWidth));\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getSectionDims } from '#utils/PRIVATE_visLayoutUtils';\nimport { getTextInfo, positionMultilineText } from '#PRIVATE_VisSVGText/utils/utils';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\nimport { AxisPosition } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\n\nconst defaultTitleProps = {\n  text: '',\n  lines: [],\n  lineProps: [],\n  titleDim: 0,\n  dims: {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  },\n  isTruncated: false,\n  isRotated: false\n};\n\n/**\n * Returns the title props.\n * @returns\n */\nexport function getTitleProps(\n  title: string | undefined,\n  titleStyle: Record<string, any>,\n  maxHeight: number,\n  availSpace: Dimension,\n  position: AxisPosition,\n  isRtl: boolean,\n  getTextDimensions?: GetTextDimensionsType\n): TextProps & { titleDim: number } {\n  if (!title || !getTextDimensions) {\n    return defaultTitleProps;\n  }\n\n  const isHoriz = position === 'top' || position === 'bottom';\n\n  const maxWidth = isHoriz ? availSpace.width : availSpace.height;\n\n  const { lines, height, width, dims, lineHeight, isTruncated } = getTextInfo(\n    title,\n    titleStyle,\n    maxWidth,\n    maxHeight,\n    true,\n    getTextDimensions\n  );\n\n  if (height > maxHeight || width === 0 || height === 0) {\n    // title does not fit or not rendered\n    return defaultTitleProps;\n  }\n  const isRotated = position === 'left' || position === 'right';\n  const lineProps = positionMultilineText(lines, dims, lineHeight, position, availSpace, isRtl);\n  const textDim = getSectionDims(availSpace, position, width, height);\n  return {\n    text: title,\n    dims: textDim,\n    titleDim: height,\n    isTruncated,\n    lines: position === 'left' || position === 'top' ? lines : lines.reverse(),\n    lineProps,\n    isRotated\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nconst SCALING_FACTOR_DIFFERENCE = 3;\n\nconst scales = ['none', 'thousand', 'million', 'billion', 'trillion', 'quadrillion'] as const;\n\nconst scalesOrder = scales.map((_, i) => ({ scaleFactor: i * SCALING_FACTOR_DIFFERENCE }));\n\nexport type Scale = (typeof scales)[number];\n\nexport function getLinearAxisValueFormatter(\n  minValue: number,\n  maxValue: number,\n  tickStep: number,\n  locale: string\n) {\n  const scaleFactor = getScaleFactor(minValue, maxValue);\n  const decimalPlaces = getDecimalPlaces(minValue, maxValue, tickStep, scaleFactor);\n\n  const scale = Math.pow(10, scaleFactor);\n  const scaleConverterOptions = {\n    style: 'decimal' as const,\n    notation: 'compact' as const,\n    numberingSystem: 'latn' as const,\n    useGrouping: false\n  };\n  let defaultConverter = new Intl.NumberFormat(locale, scaleConverterOptions);\n\n  // Formatting for scale\n  const _SCALE_REGEXP = /(\\d+)(.*$)/;\n  const formattedScale = defaultConverter.format(scale);\n  const formattedScaleParts = _SCALE_REGEXP.exec(formattedScale);\n\n  const numberConverterOptions = {\n    style: 'decimal' as const,\n    minimumFractionDigits: decimalPlaces,\n    maximumFractionDigits: decimalPlaces\n  };\n  defaultConverter = new Intl.NumberFormat(locale, numberConverterOptions);\n\n  return (value: number) => {\n    if (!formattedScaleParts) {\n      return '';\n    }\n    const suffix = formattedScaleParts[2]; // Reset the suffix\n    const fsn = (Number(formattedScaleParts[1]) / scale) * value;\n    let formattedScaledNumber = fsn.toString();\n    formattedScaledNumber = defaultConverter.format(fsn);\n\n    // Add the scale factor suffix, unless value is zero\n    if (typeof suffix === 'string' && value !== 0) {\n      formattedScaledNumber += suffix;\n    }\n    return formattedScaledNumber;\n  };\n}\n\n/**\n * Returns the number of decimal places to use for given minValue, maxValue, tickStep, scaleFactor.\n * @param minValue The minValue of the axis.\n * @param maxValue The maxValue of the axis.\n * @param tickStep The step of the axis.\n * @param scaleFactor The scale factor of the scaling of the axis.\n * @returns\n */\nfunction getDecimalPlaces(\n  minValue: number,\n  maxValue: number,\n  tickStep: number,\n  scaleFactor: number\n) {\n  let decimalPlaces;\n  if (tickStep === 0 && minValue === maxValue) {\n    const valuePowerOfTen = getPowerOfTen(maxValue);\n    const scaleFactorDiff = scaleFactor - valuePowerOfTen;\n    if (scaleFactorDiff <= 0) {\n      // Value is same or larger than the scale factor, ensure 4 significant digits.\n      // Make sure that the number of decimal places is at least zero. Bug 18677330\n      decimalPlaces = Math.max(scaleFactorDiff + 3, 0);\n    } else {\n      // Value is smaller, ensure enough decimals to show 1 significant digit\n      decimalPlaces = Math.max(scaleFactorDiff, 4);\n    }\n  } else {\n    // get the number of decimal places in the number by subtracting\n    // the order of magnitude of the tick step from the order of magnitude\n    // of the scale factor\n    // (e.g.: scale to K, tick step of 50 -> 3 - 1 = 2 decimal places)\n    const tickStepPowerOfTen = getPowerOfTen(tickStep);\n    decimalPlaces = Math.max(scaleFactor - tickStepPowerOfTen, 0);\n  }\n\n  return decimalPlaces;\n}\n\n/**\n * Returns scale factor of scale given by scale name.\n * @param {string} scaleName\n * @return {number} scale factor of scale given by scale name\n */\nfunction getScaleFactor(minValue: number, maxValue: number) {\n  const absMax = Math.max(Math.abs(minValue), Math.abs(maxValue));\n  const power = getPowerOfTen(absMax);\n  return findNearestLEScaleFactor(power);\n}\n\n/**\n * Returns the log base 10 for a given value.\n * @param {number} value\n * @returns\n */\nfunction getPowerOfTen(value: number) {\n  // more comprehensive and easier than working with\n  // value returned by Math.log(value)/Math.log(10)\n  let val = value >= 0 ? value : -value;\n  let power = 0;\n\n  // Check for degenerate and zero values\n  if (val < 1e-15) {\n    return 0;\n  } else if (val === Infinity) {\n    return Number.MAX_VALUE;\n  }\n\n  if (val >= 10) {\n    // e.g. for 1000 the power should be 3\n    while (val >= 10) {\n      power += 1;\n      val /= 10;\n    }\n  } else if (val < 1) {\n    while (val < 1) {\n      power -= 1;\n      val *= 10;\n    }\n  }\n  return power;\n}\n\n/**\n * Finds a scale factor 'x' such that x <= value (e.g. if value equals 4 then returned scale factor equals 3)\n * @param {number} value value representing an order of magnitude\n * @return {number} a scale factor 'x' such that x <= value\n */\nfunction findNearestLEScaleFactor(value: number) {\n  let scaleFactor = 0;\n\n  if (value <= scalesOrder[0].scaleFactor) {\n    // if the number is less than 10, don't scale\n    scaleFactor = scalesOrder[0].scaleFactor;\n  } else if (value >= scalesOrder[scalesOrder.length - 1].scaleFactor) {\n    // if the data is greater than or equal to 10 quadrillion, scale to quadrillions\n    scaleFactor = scalesOrder[scalesOrder.length - 1].scaleFactor;\n  } else {\n    // else find the nearest scaleFactor such that scaleFactor <= value\n    const end = scalesOrder.length - 1;\n    for (let i = end; i >= 0; i--) {\n      if (scalesOrder[i].scaleFactor <= value) {\n        scaleFactor = scalesOrder[i].scaleFactor;\n        break;\n      }\n    }\n  }\n  return scaleFactor;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, DataAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { DataAxisInfo } from '../dataAxisInfo';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { getAxisMaxSize, getAxisRange, getTickLabelAnchor } from './axisUtils';\nimport { getDataAxisLabelsInfo, getTickLabelInfo, updateLabelsDims } from './labelUtils';\nimport { getTitleProps } from './titleUtils';\nimport type { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getLinearAxisValueFormatter } from '#utils/PRIVATE_chartUtils/numberFomatUtils';\nimport { ScaleLinear, ScaleLog } from '#utils/PRIVATE_chartUtils';\n\n/**\n * The function that returns the y axis properties.\n * @param dataAxisInfo The DataAxisInfo.\n * @param dataAxis The dataAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getDataAxisProps(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  locale: string,\n  dataAxis?: DataAxisProps,\n  dataAxisInfo?: DataAxisInfo,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  const axisInfo = dataAxisInfo || new DataAxisInfo({ ...dataAxis });\n  const scale = axisInfo.getScale([start, end]);\n\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, dataAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...dataAxis?.titleStyle };\n  const { titleDim, ...titleProps } = getTitleProps(\n    dataAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  const axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: dataAxis?.tickLabel?.style?.color,\n    ...dataAxis?.tickLabel?.style,\n    textAnchor: getTickLabelAnchor(position, isRtl),\n    dominantBaseline: 'middle'\n  };\n  const ticks = axisInfo.getTicks();\n\n  const linearFormatter = getLinearAxisValueFormatter(\n    ticks[0],\n    ticks[ticks.length - 1],\n    axisInfo.getStep(),\n    locale\n  );\n\n  let isLabelRendered = dataAxis?.tickLabel?.isRendered != false;\n\n  const labels = isLabelRendered\n    ? ticks.map((i) => {\n        if (dataAxis?.tickLabel?.format) {\n          return dataAxis.tickLabel.format(i);\n        }\n\n        if (dataAxis?.scale === 'log') {\n          const formatter = getLinearAxisValueFormatter(i, i, i, locale);\n          return formatter(i);\n        }\n        return linearFormatter(i);\n      })\n    : [];\n\n  const maxLabelHeight = axisMaxDim - axisDim - AXIS_DEFAULTS.labelGap;\n\n  const getLabelInfo = (tick: string | undefined, index: number, _: boolean) => {\n    const coord = scale.transform(ticks[index]);\n    return getTickLabelInfo(\n      coord,\n      tick,\n      tickLabelStyle,\n      isHoriz,\n      false,\n      false,\n      false,\n      isHoriz ? maxLabelHeight : axisMaxDim - axisDim,\n      isHoriz ? axisMaxDim - axisDim : maxLabelHeight,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const { maxWidth, maxHeight, tickLabels } = getDataAxisLabelsInfo(labels, getLabelInfo, isHoriz);\n\n  isLabelRendered =\n    isLabelRendered && isHoriz\n      ? maxHeight + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim\n      : maxWidth + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim;\n\n  const getAxisPos = (index: number) => {\n    return scale.transform(ticks[index]);\n  };\n\n  let labelDims = 0;\n  if (isLabelRendered) {\n    updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position);\n    labelDims = isHoriz ? maxHeight + AXIS_DEFAULTS.labelGap : maxWidth + AXIS_DEFAULTS.labelGap;\n  }\n\n  const formatYValue = (value: number) => {\n    if (dataAxis?.scale === 'log') {\n      const formatter = getLinearAxisValueFormatter(value, value, value, locale);\n      return formatter(value);\n    }\n    return linearFormatter(value);\n  };\n  return {\n    title: isTitleRendered ? dataAxis?.title : undefined,\n    titleStyle,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    axisDim: isTitleRendered ? labelDims + axisDim : labelDims,\n    tickLabels,\n    tickLabelStyle,\n    scale,\n    formatYValue,\n    groupWidth: 0,\n    formatAxisLabel: undefined // TODO : JET-69997 - groupAxis support formatLabel\n  };\n}\n\nexport function getMaxAvailHeight(ticks: number[], scale: ScaleLinear | ScaleLog) {\n  const range = scale.range();\n  return Math.abs(range[1] - range[0]) / ticks.length;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, Group, TimeAxisProps, ChartSeriesData } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { getLocale } from '#utils/UNSAFE_getLocale';\nimport { getAxisMaxSize, getAxisRange, getSafeSkips } from './utils/axisUtils';\nimport { getTitleProps } from './utils/titleUtils';\nimport {\n  getGroupAxisLabelsInfo,\n  getTickLabelInfo,\n  skipLabelsGreedy,\n  updateLabelsDims\n} from './utils/labelUtils';\nimport { AXIS_DEFAULTS } from './utils/axisDefaults';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { merge } from '#utils/UNSAFE_stringUtils';\n\nconst TIME_SECOND = 1000;\nconst TIME_MINUTE = 60 * TIME_SECOND;\nconst TIME_HOUR = 60 * TIME_MINUTE;\nconst TIME_DAY = 24 * TIME_HOUR;\nconst TIME_MONTH_MIN = 28 * TIME_DAY;\nconst TIME_MONTH_MAX = 31 * TIME_DAY;\nconst TIME_YEAR_MIN = 365 * TIME_DAY;\nconst TIME_YEAR_MAX = 366 * TIME_DAY;\n\nexport function getTimeAxisProps(\n  groups: Group[],\n  position: AxisPosition,\n  availSpace: Dimension,\n  viewportMin: number,\n  viewportMax: number,\n  averageInterval: number,\n  isRtl: boolean,\n  xAxis?: TimeAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, xAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...xAxis?.titleStyle };\n  const timeAxisType = xAxis?.timeAxisType || 'regular';\n  const { titleDim, ...titleProps } = getTitleProps(\n    xAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  let axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: xAxis?.tickLabel?.style?.color,\n    ...xAxis?.tickLabel?.style,\n    textAnchor: position === 'left' ? 'end' : position === 'bottom' ? 'middle' : 'start',\n    dominantBaseline: 'middle'\n  };\n\n  const valueToCoord = (value: number) => {\n    return getCoordFromValue(\n      value,\n      viewportMin,\n      viewportMax,\n      start,\n      end,\n      averageInterval,\n      groups,\n      xAxis?.timeAxisType!\n    );\n  };\n\n  const locale = getLocale();\n  let axisStep = xAxis?.step;\n  const gap = AXIS_DEFAULTS.labelGap;\n\n  let times: number[] = [];\n  if (axisStep != null) {\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else if (timeAxisType === 'mixedFrequency') {\n    axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else {\n    for (let i = 0; i < groups.length; i++) {\n      const date = new Date(groups[i].id).getTime();\n      if (date >= viewportMin && date <= viewportMax) times.push(date);\n    }\n    axisStep = averageInterval;\n  }\n\n  const level1Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[0]\n    : xAxis?.tickLabel?.format;\n  const level2Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[1]\n    : undefined;\n\n  if (timeAxisType != 'skipGaps') {\n    const granularity = calculateGranularity(axisStep, viewportMax - viewportMin);\n    times = treatMissingValues(times, granularity);\n\n    if (times.length > 1) {\n      // Since the contents of the times array might have been updated, the step value should\n      // be updated.\n      // The step value is approximated to the estimated average of the intervals in the updated\n      // times array.\n      // It is safe to do so even when there were no missing values as it should not have any side-effects\n      // on rendering the axis.\n      // If there are less than 2 values in the times array, proceed with the existing step value.\n      axisStep = (times[times.length - 1] - times[0]) / (times.length - 1);\n    }\n    const label = formatAxisLabel(\n      new Date(times[0] || viewportMin),\n      undefined,\n      !isHoriz,\n      false,\n      locale,\n      granularity,\n      level1Formatter,\n      level2Formatter\n    )[0];\n    const labelDims = getTextDimensions?.(label!, tickLabelStyle);\n    if (labelDims) {\n      const labelDim = isHoriz ? labelDims.width : labelDims.height;\n      const totalWidth =\n        (labelDim + getTickLabelGap(labelDims.height, isHoriz)) * (times.length - 1);\n      if (totalWidth > Math.abs(end - start)) {\n        axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n        times = getLabelPos(viewportMin, viewportMax, axisStep);\n      }\n    }\n  }\n\n  if (times.length === 0) {\n    times = [viewportMin];\n  }\n\n  const granularity = calculateGranularity(axisStep!, viewportMax - viewportMin);\n\n  const isLabelRendered = xAxis?.tickLabel?.isRendered != false;\n  let isLabel1Rendered = isLabelRendered;\n  let isLabel2Rendered = isLabelRendered;\n\n  let tickLabels: any[] = [];\n  const groupWidth = Math.abs(end - start) / times.length;\n\n  if (isLabelRendered) {\n    const { labelInfos1, labelInfos2 } = generateLabels(\n      times,\n      granularity,\n      valueToCoord,\n      level1Formatter,\n      level2Formatter\n    );\n\n    const numOfSafeSkips = getSafeSkips(groupWidth, tickLabelStyle, getTextDimensions);\n\n    const getLabel1Dims = (label: string | undefined, index: number) => {\n      const rangeValue = labelInfos1[index].coord;\n      if (!rangeValue || !label) {\n        return {\n          text: '',\n          dims: { width: 0, height: 0, x: 0, y: 0 },\n          lines: [],\n          isTruncated: false,\n          didNotFit: false,\n          lineProps: []\n        };\n      }\n      return getTickLabelInfo(\n        rangeValue,\n        label,\n        tickLabelStyle,\n        isHoriz,\n        false,\n        false,\n        false,\n        Infinity,\n        Infinity,\n        availSpace,\n        getTextDimensions\n      );\n    };\n\n    const getLabel2Dims = (label: string | undefined, index: number) => {\n      const rangeValue = labelInfos2[index]?.coord;\n      if (!rangeValue || !label) {\n        return {\n          text: '',\n          dims: { width: 0, height: 0, x: 0, y: 0 },\n          lines: [],\n          lineProps: [],\n          didNotFit: false,\n          isTruncated: false\n        };\n      }\n\n      return getTickLabelInfo(\n        rangeValue,\n        label,\n        tickLabelStyle,\n        isHoriz,\n        false,\n        false,\n        false,\n        Infinity,\n        Infinity,\n        availSpace,\n        getTextDimensions\n      );\n    };\n\n    const {\n      maxWidth: label1MaxWidth,\n      maxHeight: label1MaxHeight,\n      tickLabels: tickLabels1\n    } = getGroupAxisLabelsInfo(\n      labelInfos1.map((i) => i.text),\n      getLabel1Dims,\n      isHoriz,\n      false,\n      false,\n      numOfSafeSkips\n    );\n\n    axisDim = isHoriz ? label1MaxHeight + gap : label1MaxWidth + gap;\n\n    isLabel1Rendered =\n      isTitleRendered && isHoriz\n        ? axisDim < axisMaxDim - titleHeight\n        : axisDim < axisMaxDim - titleHeight;\n\n    const {\n      maxWidth: label2MaxWidth,\n      maxHeight: label2MaxHeight,\n      tickLabels: tickLabels2\n    } = skipLabelsGreedy(\n      labelInfos2.map((i) => i.label2),\n      getLabel2Dims,\n      isHoriz\n    );\n\n    const level2AxisDim = isHoriz\n      ? axisDim + label2MaxHeight + gap\n      : axisDim + label2MaxWidth + gap;\n\n    isLabel2Rendered = isHoriz\n      ? level2AxisDim < axisMaxDim - titleHeight\n      : level2AxisDim < axisMaxDim - titleHeight;\n\n    if (isLabel1Rendered) {\n      const getAxisPos = (index: number) => {\n        return labelInfos1[index].coord;\n      };\n      updateLabelsDims(\n        label1MaxWidth,\n        label1MaxHeight,\n        tickLabels1,\n        getAxisPos,\n        availSpace,\n        position\n      );\n      tickLabels = tickLabels.concat(tickLabels1);\n      axisDim = axisDim + titleHeight;\n    }\n\n    if (isLabel2Rendered) {\n      const getAxisPos = (index: number) => {\n        return labelInfos2[index].coord;\n      };\n      updateLabelsDims(\n        label2MaxWidth,\n        label2MaxHeight,\n        tickLabels2,\n        getAxisPos,\n        availSpace,\n        position\n      );\n      tickLabels.forEach((value) => {\n        if (value.lineProps[0]) {\n          value.lineProps[0].y -= value.lineProps[0].height;\n        }\n      });\n      tickLabels = tickLabels.concat(tickLabels2);\n      axisDim = level2AxisDim + titleHeight;\n    }\n  }\n\n  const scale = {\n    transform: valueToCoord,\n    range: () => {\n      return [start, end];\n    },\n    domain: () => {\n      return [viewportMin, viewportMax];\n    },\n    invert: (coord: number) => {\n      return getValueFromCoord(\n        coord,\n        start,\n        end,\n        viewportMin,\n        viewportMax,\n        averageInterval,\n        groups,\n        xAxis?.timeAxisType || 'enabled'\n      );\n    }\n  };\n\n  const formatLabel = (axisValue: number) => {\n    const date = new Date(axisValue);\n    const twoLabels = formatAxisLabel(\n      date,\n      undefined,\n      false,\n      false,\n      locale,\n      granularity,\n      level1Formatter,\n      level2Formatter\n    );\n    return merge(twoLabels as string[]) as string;\n  };\n\n  return {\n    formatAxisLabel: formatLabel,\n    title: isTitleRendered ? xAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    titleStyle,\n    axisDim,\n    scale,\n    tickLabels,\n    groupWidth,\n    tickLabelStyle\n  };\n}\n\n/**\n * Calculates the granularity of the time axis.\n * @param step The step of the axis.\n * @param timeRange The time range of the axis.\n * @returns\n */\nexport function calculateGranularity(step: number, timeRange: number) {\n  if (step >= TIME_YEAR_MIN || timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n\n  if (step >= TIME_MONTH_MIN || timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n\n  if (step >= TIME_DAY || timeRange >= 6 * TIME_DAY) return TIME_DAY;\n\n  if (step >= TIME_HOUR || timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n\n  if (step >= TIME_MINUTE || timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n\n  return TIME_SECOND;\n}\n\n/**\n * Returns the step for mixed frequency time range.\n * @param timeRange\n * @returns\n */\nexport function getMixedFrequencyStep(timeRange: number) {\n  if (timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n  if (timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n  if (timeRange >= 6 * TIME_DAY) return TIME_DAY;\n  if (timeRange >= TIME_DAY) return 3 * TIME_HOUR;\n  if (timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n  if (timeRange >= TIME_HOUR) return 15 * TIME_MINUTE;\n  if (timeRange >= 30 * TIME_MINUTE) return 5 * TIME_MINUTE;\n  if (timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n  if (timeRange >= TIME_MINUTE) return 15 * TIME_SECOND;\n  if (timeRange >= 30 * TIME_SECOND) return 5 * TIME_SECOND;\n  return TIME_SECOND;\n}\n\nexport function formatLabelWithFormatter(\n  date: Date,\n  prevDate: Date | undefined,\n  formatter?: (date: number) => string\n) {\n  if (!formatter) {\n    return '';\n  }\n\n  const label = formatter(date.getTime());\n  const prevLabel = prevDate ? formatter?.(prevDate.getTime()) : undefined;\n\n  if (prevLabel !== label || label == null) {\n    return label;\n  }\n  // TODO: JET-65541. This is not as straightforward for format function. See old jet logic formatLabelWithConverter.\n  // do not skip label when it is same as prevLabel checking for granularity\n  // for eg. if June and July both convert to 'J' and granularity is TIME_MONTH_MIN, we want to keep both 'J's\n  // for eg. if Saturday and Sunday both convert to 'S' and granularity is TIME_MONTH_DAY, we want to keep both 'S's\n\n  return '';\n}\n\nexport function formatAxisLabel(\n  date: Date,\n  prevDate: Date | undefined,\n  bOneLabel: boolean,\n  isVert: boolean,\n  locale: string,\n  granularity: number,\n  label1Formatter?: (date: number) => string,\n  label2Formatter?: (date: number) => string\n) {\n  let label1 = null; // level 1 label\n  let label2 = null; // level 2 label\n\n  // If dateTimeFormatter is used, use it\n  if (label1Formatter || label2Formatter) {\n    if (label1Formatter) label1 = formatLabelWithFormatter(date, prevDate, label1Formatter);\n    if (label2Formatter) label2 = formatLabelWithFormatter(date, prevDate, label2Formatter);\n\n    return [label1, label2];\n  }\n\n  if (granularity === TIME_YEAR_MIN) {\n    label1 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_MONTH_MIN) {\n    if (prevDate == null || prevDate.getMonth() != date.getMonth())\n      label1 = formatDate(date, locale, false, true, false); // Month\n\n    if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n      label2 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_DAY) {\n    if (bOneLabel) {\n      label1 = formatDate(date, locale, true, true, true); // Day, Month, Year\n    } else {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label1 = formatDate(date, locale, true, false, false); // Day\n\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, false, true, true); // Year, Month\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, false, true, false); // Month\n    }\n  } else {\n    if (granularity === TIME_HOUR) {\n      if (prevDate == null || prevDate.getHours() != date.getHours())\n        label1 = formatTime(date, locale, false, false); // HH AM/PM or HH:MM\n    } else if (granularity === TIME_MINUTE) {\n      if (prevDate == null || prevDate.getMinutes() != date.getMinutes())\n        label1 = formatTime(date, locale, true, false); // HH:MM\n    } else {\n      if (prevDate == null || prevDate.getSeconds() != date.getSeconds())\n        label1 = formatTime(date, locale, true, true); // HH:MM:SS\n    }\n\n    if (isVert) {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n    } else {\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, true, true, true); // Year, Month, Day\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n      else if (prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, false, false); // Day\n    }\n  }\n\n  return [label1, label2];\n}\n\n/**\n * Returns the formatted date string.\n * @param date\n * @param locale\n * @param showDay\n * @param showMonth\n * @param showYear\n * @returns\n */\nexport function formatDate(\n  date: Date,\n  locale: string,\n  showDay: boolean,\n  showMonth: boolean,\n  showYear: boolean\n) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    year: showYear ? ('numeric' as const) : undefined,\n    month: showMonth ? ('short' as const) : undefined,\n    day: showDay ? ('numeric' as const) : undefined\n  };\n\n  return date.toLocaleDateString(locale, options);\n}\n\n/**\n * Returns the formatted time string.\n * @param date\n * @param locale\n * @param showMinute\n * @param showSecond\n * @returns\n */\nexport function formatTime(date: Date, locale: string, showMinute: boolean, showSecond: boolean) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    hour: '2-digit' as const,\n    minute: showMinute ? ('2-digit' as const) : undefined,\n    second: showSecond ? ('2-digit' as const) : undefined\n  };\n\n  return date.toLocaleTimeString(locale, options);\n}\n\nexport function getLabelPos(start: number, end: number, step: number) {\n  // The time positions has to be at even intervals from the beginning of a year (January 1, 12:00:00 AM), otherwise\n  // we may have labels such as [2013, 2014, 2015, ...] that are drawn at [June 8 2013, June 8 2014, June 8 2015, ...],\n  // which is data misrepresentation.\n  const anchor = new Date(start);\n  const initialTimezoneOffset = anchor.getTimezoneOffset();\n  anchor.setMonth(0, 1); // January 1\n  anchor.setHours(0, 0, 0, 0); // 00:00:00\n  let time = anchor.getTime();\n\n  const times = [];\n  if (step >= TIME_YEAR_MIN && step <= TIME_YEAR_MAX) {\n    // Assume that the step is one year, which can mean different # of days depending on the year\n    while (time < start) time = addOneYear(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneYear(time);\n    }\n  } else if (step >= TIME_MONTH_MIN && step <= TIME_MONTH_MAX) {\n    // Assume that the step is one month, which can mean different # of days depending on the month\n    while (time < start) time = addOneMonth(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneMonth(time);\n    }\n  } else {\n    // Bug 26396791. Correction is needed due to daylight savings.\n    // Only apply daylight correction when step is less than a month. Daylight savings does not impact any step higher than month.\n    // JET-52348 - Ideally we should be using Date api to add and substract date offsets to calculate labels since\n    // Date will automatically handle daylight savings. This approach should solve issues for steps greater than month but we could encounter\n    // offsets in axis labels when dataset values are in different daylight savings and chart step is low (eg day or hour);\n    const timezoneCorrection = (initialTimezoneOffset - anchor.getTimezoneOffset()) * 60 * 1000;\n    const correction = step < TIME_MONTH_MIN ? timezoneCorrection : 0;\n    time += Math.ceil((start - time - correction) / step) * step + correction;\n    while (time <= end) {\n      times.push(time);\n      time += step;\n    }\n  }\n  return times;\n}\n\nexport function generateLabels(\n  times: number[],\n  granularity: number,\n  getCoordFromValue: (time: number) => number,\n  label1Formatter?: (time: number) => string,\n  label2Formatter?: (time: number) => string\n) {\n  const locale = getLocale();\n\n  const labelInfos1 = [];\n  const coords1 = [];\n\n  const labelInfos2 = [];\n  const coords2 = [];\n  let isOneLevel = true;\n  let prevDate = undefined;\n  for (let i = 0; i < times.length; i++) {\n    const time = times[i];\n    const coord = getCoordFromValue(time);\n    const date = new Date(time);\n    const [label1, label2] = formatAxisLabel(\n      date,\n      prevDate,\n      false,\n      false,\n      locale,\n      granularity,\n      label1Formatter,\n      label2Formatter\n    );\n    if (label1 != null) {\n      labelInfos1.push({ text: label1, coord });\n      coords1.push(coord);\n    }\n\n    if (label2 != null) {\n      labelInfos2.push({ label2, coord });\n      coords2.push(coord);\n      isOneLevel = false;\n    }\n\n    prevDate = date;\n  }\n  return {\n    labelInfos1,\n    labelInfos2,\n    coords1,\n    coords2,\n    isOneLevel\n  };\n}\n/**\n * Adds the time by one year, e.g. 2014 January 15 -> 2015 January 15 -> ...\n */\nexport function addOneYear(time: number) {\n  const date = new Date(time);\n  date.setFullYear(date.getFullYear() + 1);\n  return date.getTime();\n}\n\n/**\n * Adds the time by one month, e.g. January 15 -> February 15 -> March 15 -> ...\n */\nexport function addOneMonth(time: number) {\n  const date = new Date(time);\n  date.setMonth(date.getMonth() + 1);\n  return date.getTime();\n}\n\n/**\n * Returns the corresponding index for the given time in time axis.\n * @param time The time stamp.\n * @param averageInterval The average interval of the time axis.\n * @param groups The groups array.\n * @returns\n */\nexport function timeToIndex(time: number, averageInterval: number, groups: Group[]) {\n  let endIndex = groups.length;\n  // TODO: can do binary search to make this fast\n  for (let i = 0; i < groups.length; i++) {\n    if (time <= new Date(groups[i].id).getTime()) {\n      endIndex = i;\n      break;\n    }\n  }\n  const startIndex = endIndex - 1;\n\n  const startTime =\n    groups[startIndex] !== undefined\n      ? new Date(groups[startIndex].id).getTime()\n      : new Date(groups[0].id).getTime() - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? new Date(groups[endIndex].id).getTime()\n      : new Date(groups[groups.length - 1].id).getTime() + averageInterval;\n\n  return startIndex + (time - startTime) / (endTime - startTime);\n}\n\n/**\n * Returns the time stamp for given index.\n * @param index The index.\n * @param averageInterval The average interval of the axis.\n * @param groups The groups array.\n * @returns\n */\nexport function indexToTime(index: number, averageInterval: number, groups: Group[]) {\n  const endIndex = Math.min(Math.max(Math.ceil(index), 0), groups.length);\n  const startIndex = endIndex - 1;\n  const startTime =\n    groups[startIndex] !== undefined\n      ? getTime(groups[startIndex].id)\n      : getTime(groups[0].id) - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? getTime(groups[endIndex].id)\n      : getTime(groups[groups.length - 1].id) + averageInterval;\n\n  return startTime + (index - startIndex) * (endTime - startTime);\n}\n\nexport function getTime(uxTime: string | number) {\n  return new Date(uxTime).getTime();\n}\n\nexport function getCoordFromValue(\n  value: number,\n  minValue: number,\n  maxValue: number,\n  startCoord: number,\n  endCoord: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'mixedFrequency' | 'enabled'\n) {\n  let ratio;\n  if (timeAxisType === 'skipGaps') {\n    if (groups.length < 1) {\n      return startCoord;\n    }\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    const val = timeToIndex(value, averageInterval, groups);\n    ratio = (val - minVal) / (maxVal - minVal);\n  } else {\n    ratio = (value - minValue) / (maxValue - minValue);\n  }\n\n  return startCoord + ratio * (endCoord - startCoord);\n}\n\nexport function getValueFromCoord(\n  coord: number,\n  startCoord: number,\n  endCoord: number,\n  minValue: number,\n  maxValue: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'enabled' | 'mixedFrequency'\n) {\n  const ratio = (coord - startCoord) / (endCoord - startCoord);\n\n  if (timeAxisType === 'skipGaps') {\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    return indexToTime(minVal + ratio * (maxVal - minVal), averageInterval, groups);\n  } else return minValue + ratio * (maxValue - minValue);\n}\n\nexport function isoToNumber(dateString?: string) {\n  if (!dateString) {\n    return;\n  }\n  return new Date(dateString).getTime();\n}\n\n/**\n * Returns the average interval for the time axis.\n * @param groups The number of groups.\n * @param start The earliest time among all data points.\n * @param end The latest time among all data points.\n * @returns\n */\nexport function getAverageInterval(groups: Group[], start: number, end: number) {\n  if (end != start && groups.length > 1) {\n    return (end - start) / (groups.length - 1);\n  } else if (end - start > 0) {\n    return end - start;\n  }\n\n  return 6 * TIME_MINUTE;\n}\n\n/**\n * Returns the time axis info.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the axis.\n * @param timeAxisRange The start and end of the time range.\n * @returns\n */\nexport function getTimeAxisInfo(\n  groups: Group[],\n  xAxis: TimeAxisProps = {},\n  offset: number,\n  timeAxisRange: { start?: number; end?: number }\n) {\n  let { start, end } = timeAxisRange;\n  const { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n\n  let minValue = isoToNumber((viewportMin || viewportStartGroup) as string);\n  let maxValue = isoToNumber((viewportMax || viewportEndGroup) as string);\n\n  const axisType = xAxis.timeAxisType;\n  // if start or end are undefined, use the application set viewport settings\n  if (start == undefined) {\n    start = minValue;\n  }\n\n  if (end == undefined) {\n    end = maxValue;\n  }\n\n  const averageInterval = getAverageInterval(groups, start!, end!);\n\n  const axisOffset = offset * averageInterval;\n  const globalMin = start! - axisOffset;\n  const globalMax = end! + axisOffset;\n\n  minValue = minValue || globalMin;\n  maxValue = maxValue || globalMax;\n\n  let startIndex = 0;\n  let endIndex = Math.max(0, groups.length - 1);\n\n  // TODO: since groups is expected to be sorted, can binary search here\n  groups.forEach((group: Group, index: number) => {\n    const timeStamp = new Date(group.id).getTime();\n\n    if (timeStamp < minValue!) {\n      startIndex = index;\n    }\n\n    if (timeStamp < maxValue!) {\n      endIndex = index;\n    }\n  });\n\n  return {\n    viewportMin: minValue,\n    viewportMax: maxValue,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex,\n    endIndex,\n    min: globalMin,\n    max: globalMax,\n    averageInterval,\n    minAxisExtent:\n      axisType === 'skipGaps'\n        ? 1\n        : axisType === 'mixedFrequency'\n        ? Math.min(globalMax - globalMin / 8, averageInterval)\n        : averageInterval\n  };\n}\n\n/**\n * Returns the maximum of time stamps for the given dataset\n * and time axis type.\n * @param groups The array of groups.\n * @param series The array of series.\n * @param getDataItem The function that returns item for given seriesIndex and groupIndex.\n * @param timeAxisType The time axis type.\n * @returns\n */\nexport function getStartAndEndTime<K extends string | number, D extends { x?: number | string }>(\n  groups: Group[],\n  series: ChartSeriesData<K, D>[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxis: TimeAxisProps\n) {\n  const range: { start?: number; end?: number } = {\n    start: Number.MAX_VALUE,\n    end: -Number.MAX_VALUE\n  };\n  const numGroups = groups.length;\n  const timeAxisType = timeAxis.timeAxisType;\n\n  if (timeAxisType != 'mixedFrequency' && numGroups > 0) {\n    range.start = isoToNumber(groups[0].id) as number;\n    range.end = isoToNumber(groups[numGroups - 1].id) as number;\n  } else {\n    // TODO: this is inefficient. We should precompute all the repeated necessary\n    // infomation and reuse whereever needed.\n    series.forEach((_: ChartSeriesData<K, D>, seriesIndex: number) => {\n      groups.forEach((_: Group, groupIndex) => {\n        const itemX = getDataItem(seriesIndex, groupIndex)?.x;\n        if (typeof itemX == 'number') return;\n        const num = isoToNumber(itemX);\n        if (num) {\n          range.start = Math.min(range.start!, num);\n          range.end = Math.max(range.end!, num);\n        }\n      });\n    });\n  }\n  // if we can't determine valid range, let the application set viewportMin and viewportMax\n  // or viewportStartGroup, viewportEndGroup to determine the axis range.\n  if (range.start === Number.MAX_VALUE && range.end === -Number.MAX_VALUE) {\n    range.start = undefined;\n    range.end = undefined;\n  }\n  return range;\n}\n\n/**\n * Treat missing values when there are large gaps in time axis.\n * @param times\n * @param granularity\n * @returns\n */\nfunction treatMissingValues(times: number[], granularity: number) {\n  let initialInterval;\n  const intervals: Set<number> = new Set();\n  let hasMissingValues = false;\n  let ret = times; // If there are no missing values, the original array will be returned.\n  const intervalsCache = [];\n\n  const timeLength = times.length;\n  let previousDate = new Date(times[0]);\n  for (let i = 1; i < timeLength; i++) {\n    // Calculate the current interval.\n    const currentDate = new Date(times[i]);\n    const currentInterval = calculateGranularInterval(previousDate, currentDate, granularity);\n    previousDate = currentDate;\n\n    // Cache the result so as to not calculate again while filling the missing values\n    // Since the cache is only used for filling in the missing values, and the operation\n    // is performed in the same order as this one, having the cache key in the format\n    // '1546318800000-1514782800000' should be fine.\n    intervalsCache.push(currentInterval);\n\n    // Proceed only if the current interval is greater than the current\n    // granularity level.\n    if (currentInterval <= 0) {\n      continue;\n    }\n\n    // Add the current interval to the set.\n    // The GCD of all the intervals will be used to fill in the missing the\n    // values.\n    intervals.add(currentInterval);\n\n    // During the initial iteration, we will not have any information on intervals,\n    // so, store the current interval and continue.\n    if (!initialInterval) {\n      initialInterval = currentInterval;\n      continue;\n    }\n\n    // Check if the current interval is regular.\n    if (currentInterval !== initialInterval) {\n      hasMissingValues = true;\n    }\n  }\n\n  // If missing values are present, treat them.\n  if (hasMissingValues) {\n    // Get the GCD of intervals and it will be the minimum interval in the new set of times\n    const minimumInterval = getGCDInterval([...intervals]);\n    ret = [];\n    ret.push(times[0]);\n    for (let i = 1; i < timeLength; i++) {\n      const currentValue = times[i];\n      let previousValue = times[i - 1];\n\n      // Retrieve the interval from cache.\n      // As we are looping through the same array the cache will have the interval value\n      // and will never be undefined.\n      const currentInterval = intervalsCache[i - 1];\n\n      // If no values are missing in this interval,\n      // add current value to the return array and continue.\n      // Note: Values are considered missing only when the interval is greater than the current granularity level (minimumInterval).\n      // Example: Jan 1, Jan 15, Feb 1, Mar 1, May 1, Jun 1\n      // Granularity = Month; Minimum Interval = 1 (1 month)\n      // Mar 1, May 1 => has one missing value: Apr\n      // Jan 1, Jan 15 => has no missing value\n      if (currentInterval <= minimumInterval) {\n        ret.push(currentValue);\n        continue;\n      }\n\n      // Calculate the interval at which the values are to be filled\n      const ratioOfCurrentIntervalToMinimumInterval = currentInterval / minimumInterval; // Should be a round number as minimumInterval is a divisor of currentInterval\n      const numMissingValues = ratioOfCurrentIntervalToMinimumInterval - 1;\n      const fillIntervalInMilliseconds = Math.round(\n        (currentValue - previousValue) / ratioOfCurrentIntervalToMinimumInterval\n      );\n\n      // Fill in the missing values\n      for (let j = 1; j <= numMissingValues; j++) {\n        previousValue += fillIntervalInMilliseconds;\n        ret.push(previousValue);\n      }\n      ret.push(currentValue); // Finally, add the current value\n      previousValue = currentValue; // Update the previous value\n    }\n  }\n  return ret;\n}\n\n/**\n * Calculates the granual interval.\n * @param previousDate\n * @param currentDate\n * @param granularity\n * @returns\n */\nfunction calculateGranularInterval(previousDate: Date, currentDate: Date, granularity: number) {\n  // Treat times for the day light savings.\n  const prevTimezoneOffset = previousDate.getTimezoneOffset();\n  const currentTimezoneOffset = currentDate.getTimezoneOffset();\n  const currentTime = currentDate.getTime();\n  const currentTimezoneOffsetCorrection = (prevTimezoneOffset - currentTimezoneOffset) * 1000 * 60;\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime + currentTimezoneOffsetCorrection);\n  }\n\n  let granularInterval;\n  if (granularity === TIME_YEAR_MIN)\n    granularInterval = currentDate.getFullYear() - previousDate.getFullYear();\n  else if (granularity === TIME_MONTH_MIN)\n    granularInterval =\n      12 * (currentDate.getFullYear() - previousDate.getFullYear()) +\n      (currentDate.getMonth() - previousDate.getMonth());\n  else\n    granularInterval = Math.round((currentDate.getTime() - previousDate.getTime()) / granularity);\n\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime); // reset to original value\n  }\n\n  return granularInterval;\n}\n\n/**\n * Returns the greatest common denominator.\n * @param interval1\n * @param interval2\n * @returns\n */\nfunction gcd(interval1: number, interval2: number): number {\n  if (interval1 === 0) return interval2;\n  return gcd(interval2 % interval1, interval1);\n}\n\n/**\n * Returns the gcd of the intervals.\n * @param intervals\n * @returns\n */\nfunction getGCDInterval(intervals: number[]) {\n  let result = intervals[0];\n  for (let i = 1; i < intervals.length; i++) {\n    result = gcd(result, intervals[i]);\n    if (result === 1) return 1;\n  }\n  return result;\n}\n\n/**\n * Retuns the tick label gap.\n * @param labelHeight The height of the label.\n * @param isHoriz Whether the axis is horizontal.\n * @returns\n */\nfunction getTickLabelGap(labelHeight: number, isHoriz: boolean) {\n  // legacy numbers.\n  return isHoriz ? labelHeight * 0.79 : labelHeight * 0.28;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartSeriesData, DataAxisProps, Group } from '../UNSAFE_visTypes/chart';\nimport { BarItemData, BarSeriesData } from '../../UNSAFE_BarChart/barChart.types';\nimport { getTime } from '../../PRIVATE_Axis/timeAxis';\nimport { LineAreaItem } from '#UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { ScatterItem } from '#UNSAFE_ScatterChart/scatterChart.types';\n\n/**\n * Returns the min and max value among the items rendered in the viewport.\n * @param series The array of chart series.\n * @param viewportMin The current viewport min.\n * @param viewportMax The current viewport max.\n * @returns\n */\nexport function getDataMinMax<\n  K extends string | number,\n  D extends LineAreaItem<K> | ScatterItem<K> | BarItemData<K>\n>(\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  xStartIndex: number,\n  xEndIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  isLog: boolean,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale'\n) {\n  let dataMin = Number.MAX_VALUE;\n  let dataMax = -Number.MAX_VALUE;\n  let xMin = Number.MAX_VALUE;\n  let xMax = -Number.MAX_VALUE;\n  let yMin = Number.MAX_VALUE;\n  let yMax = -Number.MAX_VALUE;\n  const idToDataMap = new Map<K, D>();\n  for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n    let posCumulValue = 0;\n    let negCumulValue = 0;\n\n    series.forEach((_: BarSeriesData<K, D>, seriesIndex: number) => {\n      const item = getDataItem(seriesIndex, groupIndex);\n      const itemHasValue = item && 'value' in item;\n      if (\n        !item ||\n        (itemHasValue && item.value == null && item.x == null && 'y' in item && item.y == null)\n      ) {\n        return;\n      }\n      idToDataMap.set(item.id, item);\n      if (groupIndex >= xStartIndex && groupIndex <= xEndIndex) {\n        const skipData =\n          item?.id != null && hiddenSet.has(item.id) && hideAndShowBehavior === 'withRescale';\n        if (skipData || (itemHasValue && item.value !== undefined && item.value <= 0 && isLog)) {\n          return;\n        }\n        if (isStacked) {\n          if (itemHasValue && item.value !== undefined) {\n            posCumulValue += item.value > 0 ? item.value : 0;\n            negCumulValue += item.value < 0 ? item.value : 0;\n          }\n          dataMin = Math.min(isLog ? posCumulValue : negCumulValue, dataMin);\n          dataMax = Math.max(posCumulValue, dataMax);\n        } else {\n          if (itemHasValue && item.value !== undefined) {\n            dataMin = Math.min(dataMin, item.value);\n            dataMax = Math.max(dataMax, item.value);\n          }\n          if ('x' in item && item.x !== undefined && 'y' in item && item.y !== undefined) {\n            xMin = Math.min(xMin, item.x);\n            xMax = Math.max(xMax, item.x);\n            yMin = Math.min(yMin, item.y);\n            yMax = Math.max(yMax, item.y);\n          }\n        }\n      }\n    });\n  }\n  return { dataMin, dataMax, xMin, xMax, yMin, yMax, idToDataMap };\n}\n\n/**\n * Returns the dataMin and dataMax, used for axis extend calculations, from the chart data.\n * @param series\n * @param hiddenIds\n * @param xStartIndex\n * @param xEndIndex\n * @param yAxis\n * @returns\n */\nexport function getDataExtent<\n  K extends string | number,\n  D extends LineAreaItem<K> | ScatterItem<K> | BarItemData<K>\n>(\n  series: BarSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  xStartIndex: number,\n  xEndIndex: number,\n  isStacked: boolean,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  yAxis?: DataAxisProps\n) {\n  let dataMin = yAxis?.dataMin;\n  let dataMax = yAxis?.dataMax;\n  //TODO: For performance optimization we can return early if we donot need idToDataMap i.e when selectionMode is off.\n  // if (dataMin != null && dataMax != null) {\n  //   return { dataMin, dataMax };\n  // }\n  const data = getDataMinMax<K, D>(\n    series,\n    groups,\n    xStartIndex,\n    xEndIndex,\n    getDataItem,\n    isStacked,\n    yAxis?.scale === 'log',\n    hiddenSet,\n    hideAndShowBehavior\n  );\n\n  if (dataMin == null) {\n    dataMin = data.dataMin;\n  }\n\n  if (dataMax == null) {\n    dataMax = data.dataMax;\n  }\n  return {\n    dataMax,\n    dataMin,\n    xMin: data.xMin,\n    xMax: data.xMax,\n    yMin: data.yMin,\n    yMax: data.yMax,\n    idToDataMap: data.idToDataMap\n  };\n}\n\n/**\n * For a given groupIndex gIndex, and seriesIndex sIndex, returns the next groupIndex that has not null data.\n * @param gIndex The groupIndex.\n * @param sIndex The seriesIndex.\n * @param groups The groups arrray.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nfunction findNextGroupWithData<D>(\n  gIndex: number,\n  sIndex: number,\n  groups: Group[],\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  let right = gIndex;\n  while (right < groups.length) {\n    const hasData = !!getDataItem(sIndex, right);\n    if (hasData) {\n      return right;\n    }\n    right += 1;\n  }\n  return -1;\n}\n\n/**\n * For a given groupIndex gIndex, and seriesIndex sIndex, returns the prev groupIndex that has not null data.\n * @param gIndex The groupIndex.\n * @param sIndex The seriesIndex.\n * @param groups The groups arrray.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nfunction findPreviousGroupWithData<D>(\n  gIndex: number,\n  sIndex: number,\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  let left = gIndex;\n  while (left >= 0) {\n    const hasData = !!getDataItem(sIndex, left);\n    if (hasData) {\n      return left;\n    }\n    left -= 1;\n  }\n  return -1;\n}\n\n/**\n * Finds the nearest data group/item for the given x axis coordinate.\n * @param x The x coordinate.\n * @param groups The groups array.\n * @param series The series array.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nexport function findNearestRegularAxisIndex<K, D>(\n  x: number,\n  groups: Group[],\n  series: ChartSeriesData<K, D>[],\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  const keyFunc = (index: number) => getTime(groups[index].id);\n\n  if (groups.length < 2) {\n    return 0;\n  }\n\n  if (keyFunc(0) > x) {\n    return Math.min(\n      ...series.map((_, sIndex) => findNextGroupWithData<D>(0, sIndex, groups, getDataItem))\n    );\n  }\n\n  if (keyFunc(groups.length - 1) < x) {\n    return Math.max(\n      ...series.map((_, sIndex) =>\n        findPreviousGroupWithData(groups.length - 1, sIndex, getDataItem)\n      )\n    );\n  }\n\n  const groupIndex = findGroup(0, groups.length - 1, x, keyFunc);\n\n  const prevIndex = Math.max(\n    ...series.map((_, sIndex) => findPreviousGroupWithData(groupIndex, sIndex, getDataItem))\n  );\n\n  if (prevIndex === groupIndex) return prevIndex;\n\n  const nextIndex = Math.min(\n    ...series.map((_, sIndex) => findNextGroupWithData<D>(groupIndex, sIndex, groups, getDataItem))\n  );\n\n  if (keyFunc(nextIndex) - x < x - keyFunc(prevIndex)) {\n    return nextIndex;\n  }\n  return prevIndex;\n}\n\n/**\n * Finds the nearest data group/item for the given x axis coordinate in mixed frequency time axis chart.\n * @param x The x axis coordinate\n * @param groups The chart groups.\n * @param series The chart series.\n * @param getDataItem The function that returns data item for each series and groups.\n */\nexport function getNearestMixedFrequencyDataItem<K, D extends { x?: number | string }>(\n  target: number,\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined\n) {\n  /**\n   * first find the data items in each series closest to the given value and\n   * then find the closest among them.\n   * TODO: make this O(log(n))\n   */\n  return series.map((_, seriesIndex) => {\n    let min = Number.MAX_VALUE;\n    let minIndex = 0;\n    for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n      const x = getDataItem(seriesIndex, groupIndex)?.x;\n      if (!x) {\n        continue;\n      }\n      const time = getTime(x);\n      const dist = Math.abs(target - time);\n      if (dist < min) {\n        min = dist;\n        minIndex = groupIndex;\n      }\n    }\n    return { seriesIndex, groupIndex: minIndex };\n  });\n}\n\n/**\n * For a given target value, binary searches the index between min and max. The keyFunc returns the\n * value for each given index.\n * @param min The minimum index to search.\n * @param max The maximum index to search.\n * @param target The target value to find the neareast index to.\n * @param keyFunc The function that returns the target value for each given index.\n * @returns\n */\nfunction findGroup(min: number, max: number, target: number, keyFunc: (index: number) => number) {\n  let left = min;\n  let right = max;\n\n  const foundIndex = (ll: number, rr: number) => {\n    return rr - ll === 1 && keyFunc(ll) <= target && target <= keyFunc(rr);\n  };\n\n  let moveRight = 0;\n  let step = Math.floor((right - left) / 2);\n  while (!foundIndex(left, right)) {\n    const newIndex = moveRight ? Math.floor(left + step) : Math.ceil(right - step);\n    const diff = target - keyFunc(newIndex);\n    if (0 <= diff) {\n      left = newIndex;\n      moveRight = moveRight ? 0 : 1;\n    } else {\n      right = newIndex;\n    }\n    step = Math.floor((right - left) / 2);\n  }\n  return target - keyFunc(left) < keyFunc(right) - target ? left : right;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  DataAxisProps,\n  Group,\n  GroupAxisProps,\n  TimeAxisProps,\n  AxisPosition,\n  ChartSeriesData,\n  Scale\n} from '../UNSAFE_visTypes/chart';\nimport { Dimension } from '../UNSAFE_visTypes/common';\nimport { BarItemData, BarSeriesData } from '../../UNSAFE_BarChart/barChart.types';\nimport { DataAxisInfo } from '../../PRIVATE_Axis/dataAxisInfo';\nimport { getDataAxisProps } from '../../PRIVATE_Axis/utils/dataAxisUtil';\nimport {\n  findNearestRegularAxisIndex,\n  getDataExtent,\n  getNearestMixedFrequencyDataItem\n} from './dataUtils';\nimport { getAxesPosition } from '../../PRIVATE_Axis/utils/axisUtils';\nimport {\n  getStartAndEndTime,\n  getTime,\n  getTimeAxisInfo,\n  getTimeAxisProps\n} from '../../PRIVATE_Axis/timeAxis';\nimport type { GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\nimport { cloneDimension } from '../../utils/PRIVATE_visLayoutUtils';\nimport { getGroupAxisInfo, getGroupAxisProps } from '#PRIVATE_Axis/groupAxis';\nimport { LineAreaItem } from '#UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { ScatterItem } from '#UNSAFE_ScatterChart/scatterChart.types';\n\ntype GetTimeAxisInfoReturnType = ReturnType<typeof getTimeAxisInfo>;\n\ntype GetGroupAxisInfoReturnType = ReturnType<typeof getGroupAxisInfo>;\nimport { ChartOverviewConfig } from '#utils/UNSAFE_visTypes/chart/chart.types';\nimport { getOverviewHeight } from './overviewUtils';\n\nconst OUTER_GAP_WIDTH = 10;\nconst OUTER_GAP_HEIGHT = 8;\nconst MIN_SCROLL_SIZE = 12;\nconst SCROLL_GAP = 6;\nexport const TIME_AXIS_OVERVIEW_PANE_SIZE = 0.25;\nexport const OVERVIEW_PANE_SIZE = 0.2;\n\n/**\n * Returns the chart layout info.\n * @returns\n */\nexport function getLayoutInfo<\n  K extends string | number,\n  D extends LineAreaItem<K> | ScatterItem<K> | BarItemData<K>\n>(\n  series: BarSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  xAxis: GroupAxisProps | TimeAxisProps | DataAxisProps | undefined,\n  yAxis: DataAxisProps | undefined,\n  availSpace: Dimension,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  isHoriz: boolean,\n  isRtl: boolean,\n  isStacked: boolean,\n  axisFontSize: string,\n  offset: number,\n  locale: string,\n  getTextDimensions?: GetTextDimensionsType,\n  isTestEnv?: boolean,\n  hasXDataAxis?: boolean\n) {\n  const isTimeAxis = (xAxis as TimeAxisProps)?.timeAxisType != null;\n  const { xAxisPosition, yAxisPosition } = getAxesPosition(yAxis, isHoriz, isRtl);\n  let xAxisInfo;\n  let dataInfo;\n  let minExtent;\n  if (hasXDataAxis) {\n    dataInfo = getDataExtent<K, D>(\n      series,\n      groups,\n      getDataItem,\n      0,\n      groups.length - 1,\n      isStacked,\n      hiddenSet,\n      hideAndShowBehavior,\n      xAxis as DataAxisProps\n    );\n    xAxisInfo = new DataAxisInfo({\n      ...(xAxis as DataAxisProps),\n      dataMin: dataInfo.xMin,\n      dataMax: dataInfo.xMax\n    });\n    minExtent = xAxisInfo.getMinExtent();\n  } else {\n    if (isTimeAxis) {\n      const timeAxisRange = getStartAndEndTime(groups, series, getDataItem, xAxis as TimeAxisProps);\n      xAxisInfo = getTimeAxisInfo(groups, xAxis as TimeAxisProps, offset, timeAxisRange);\n      minExtent = xAxisInfo.minAxisExtent;\n    } else {\n      xAxisInfo = getGroupAxisInfo(groups, xAxis as GroupAxisProps, offset);\n      minExtent = 1;\n    }\n\n    dataInfo = getDataExtent<K, D>(\n      series,\n      groups,\n      getDataItem,\n      xAxisInfo.startIndex,\n      xAxisInfo.endIndex,\n      isStacked,\n      hiddenSet,\n      hideAndShowBehavior,\n      yAxis\n    );\n  }\n  const { dataMax, dataMin, yMin, yMax, idToDataMap } = dataInfo;\n\n  const yAxisInfo = new DataAxisInfo({\n    ...yAxis,\n    dataMax: hasXDataAxis ? yMax : dataMax,\n    dataMin: hasXDataAxis ? yMin : dataMin\n  });\n  const { axisDim: yDim } = getDataAxisProps(\n    yAxisPosition,\n    cloneDimension(availSpace),\n    isRtl,\n    locale,\n    yAxis,\n    yAxisInfo,\n    axisFontSize,\n    getTextDimensions\n  );\n\n  const isXAxisHoriz = xAxisPosition === 'bottom';\n\n  // get updated available space for x axis.\n  const { xSpace: xAvailSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    isXAxisHoriz ? availSpace.height : availSpace.width,\n    yDim\n  );\n\n  const axisProps = isTimeAxis\n    ? getTimeAxisProps(\n        groups,\n        xAxisPosition,\n        xAvailSpace,\n\n        xAxisInfo.viewportMin!,\n\n        xAxisInfo.viewportMax!,\n\n        (xAxisInfo as GetTimeAxisInfoReturnType).averageInterval,\n        isRtl,\n        xAxis as TimeAxisProps,\n        axisFontSize,\n        getTextDimensions\n      )\n    : hasXDataAxis\n    ? getDataAxisProps(\n        xAxisPosition,\n        xAvailSpace,\n        isRtl,\n        locale,\n        xAxis as DataAxisProps,\n        xAxisInfo as DataAxisInfo,\n        axisFontSize,\n        getTextDimensions\n      )\n    : getGroupAxisProps(\n        groups,\n        xAxisPosition,\n        xAvailSpace,\n        isRtl,\n        xAxisInfo.viewportMin!,\n        xAxisInfo.viewportMax!,\n        (xAxisInfo as GetGroupAxisInfoReturnType).startIndex,\n        (xAxisInfo as GetGroupAxisInfoReturnType).endIndex,\n        isHoriz,\n        xAxis as GroupAxisProps,\n        axisFontSize,\n        getTextDimensions,\n        isTestEnv\n      );\n\n  const { axisDim: xMaxDim, scale: xScale, groupWidth, ...xProps } = axisProps;\n\n  // recalculate y axis props after the x axis.\n  const { ySpace: newYSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    xMaxDim!,\n    isXAxisHoriz ? availSpace.width : availSpace.height\n  );\n\n  const newYProps = getDataAxisProps(\n    yAxisPosition,\n    newYSpace,\n    isRtl,\n    locale,\n    yAxis,\n    yAxisInfo,\n    axisFontSize,\n    getTextDimensions\n  );\n\n  const { axisDim: yMaxDim, scale: yScale, ...yProps } = newYProps;\n\n  const { plotAreaSpace, xSpace, ySpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    xMaxDim!,\n    yMaxDim\n  );\n\n  return {\n    xViewportExtent: hasXDataAxis\n      ? (xAxisInfo as DataAxisInfo).getAxisViewport()\n      : // TODO: JET-71323\n        {\n          viewportMin: (xAxisInfo as GetTimeAxisInfoReturnType | GetGroupAxisInfoReturnType)\n            .viewportMin,\n          viewportMax: (xAxisInfo as GetTimeAxisInfoReturnType | GetGroupAxisInfoReturnType)\n            .viewportMax\n        },\n    xIndexExtent: {\n      startIndex: 'startIndex' in xAxisInfo ? xAxisInfo.startIndex : 0,\n      endIndex: 'endIndex' in xAxisInfo ? xAxisInfo.endIndex : groups.length - 1\n    },\n    yViewportExtent: yAxisInfo.getAxisViewport(),\n    yAxisExtent: yAxisInfo.getAxisExtent(),\n    xAxisMinExtent: minExtent,\n    xAxisExtent: hasXDataAxis\n      ? (xAxisInfo as DataAxisInfo).getAxisExtent()\n      : {\n          min: (xAxisInfo as GetTimeAxisInfoReturnType | GetGroupAxisInfoReturnType).min,\n          max: (xAxisInfo as GetTimeAxisInfoReturnType | GetGroupAxisInfoReturnType).max\n        },\n    xProps,\n    xScale,\n    xAxisPosition,\n    groupWidth,\n    yProps,\n    yScale,\n    yMaxDim,\n    yAxisPosition,\n    yMajorTicks: yAxisInfo.getTicks(),\n    xMajorTicks: hasXDataAxis\n      ? (xAxisInfo as DataAxisInfo).getTicks()\n      : (xAxisInfo as GetGroupAxisInfoReturnType).xTicks,\n    xMinorTicks: hasXDataAxis ? (xAxisInfo as DataAxisInfo).getMinorTicks() : undefined,\n    yMinorTicks: yAxisInfo.getMinorTicks(),\n    plotAreaSpace,\n    xSpace,\n    ySpace,\n    idToDataMap,\n    formatAxisLabel: axisProps.formatAxisLabel,\n    formatYValue: newYProps.formatYValue\n  };\n}\n\n/**\n * Returns the available space for x axis and y axis.\n * @param availSpace The available space of the chart.\n * @param xAxisPosition The position of x axis.\n * @param yAxisPosition The position of y axis.\n * @param xMaxDim The max dimension of x axis.\n * @param yMaxDim The max dimension of y axis.\n * @returns\n */\nexport function getSpaces(\n  availSpace: Dimension,\n  xAxisPosition: AxisPosition,\n  yAxisPosition: AxisPosition,\n  xMaxDim: number,\n  yMaxDim: number\n) {\n  const isXHoriz = xAxisPosition === 'bottom' || xAxisPosition === 'top';\n  const isYLeft = yAxisPosition === 'left';\n\n  let xSpace: Dimension;\n  let ySpace: Dimension;\n  let plotAreaSpace: Dimension;\n\n  if (isXHoriz) {\n    xSpace = getHorizSpace(\n      availSpace,\n      xAxisPosition,\n      isYLeft ? yMaxDim : 0,\n      !isYLeft ? yMaxDim : 0,\n      xMaxDim\n    );\n    ySpace = getVertSpace(\n      availSpace,\n      yAxisPosition as 'left' | 'right',\n      xAxisPosition === 'bottom' ? xMaxDim : 0,\n      xAxisPosition === 'top' ? xMaxDim : 0,\n      yMaxDim\n    );\n    plotAreaSpace = {\n      x: xSpace.x,\n      y: ySpace.y,\n      width: xSpace.width,\n      height: ySpace.height\n    };\n  } else {\n    xSpace = getVertSpace(\n      availSpace,\n      xAxisPosition,\n      yAxisPosition === 'bottom' ? yMaxDim : 0,\n      yAxisPosition === 'bottom' ? 0 : yMaxDim,\n      xMaxDim\n    );\n    ySpace = getHorizSpace(\n      availSpace,\n      yAxisPosition as 'top' | 'bottom',\n      xAxisPosition === 'left' ? xMaxDim : 0,\n      xAxisPosition === 'left' ? 0 : xMaxDim,\n      yMaxDim\n    );\n\n    plotAreaSpace = {\n      x: ySpace.x,\n      y: xSpace.y,\n      width: ySpace.width,\n      height: xSpace.height\n    };\n  }\n\n  return { xSpace, ySpace, plotAreaSpace };\n}\n\n/**\n * Returns the vertical sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the vertical section.\n * @param bottomOffset The bottom offset of the vertical section.\n * @param topOffset The top offset of the vertical section.\n * @param width The width of the section.\n * @returns\n */\nexport function getVertSpace(\n  availSpace: Dimension,\n  position: 'left' | 'right',\n  bottomOffset: number,\n  topOffset: number,\n  width: number\n) {\n  return {\n    x: position === 'left' ? availSpace.x : availSpace.x + availSpace.width - width,\n    width: width,\n    y: availSpace.y + topOffset,\n    height: availSpace.height - bottomOffset - topOffset\n  };\n}\n\n/**\n * Returns the horizontal sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the horizontal section.\n * @param leftOffset The left offset of the horizontal section.\n * @param rightOffset The right offset of the horizontal section.\n * @param height The height of the section.\n * @returns\n */\nexport function getHorizSpace(\n  availSpace: Dimension,\n  position: 'top' | 'bottom',\n  leftOffset: number,\n  rightOffset: number,\n  height: number\n) {\n  return {\n    x: availSpace.x + leftOffset,\n    width: availSpace.width - leftOffset - rightOffset,\n    y: position === 'top' ? availSpace.y : availSpace.y + availSpace.height - height,\n    height: height\n  };\n}\n\n/**\n * Returns the outer spacing for the chart.\n * @param width The height of the chart.\n * @param height The width of the chart.\n * @returns\n */\nexport function getOuterGaps(width: number, height: number) {\n  const widthRatio = Math.min(width / 400, 1);\n  const heightRatio = Math.min(height / 300, 1);\n  return {\n    width: widthRatio * OUTER_GAP_WIDTH,\n    height: heightRatio * OUTER_GAP_HEIGHT\n  };\n}\n\n/**\n * Returns the default available space for chart.\n * @param width The width of the chart.\n * @param height The height of the chart.\n * @returns\n */\nexport function getAvailSpace(width: number, height: number) {\n  const gaps = getOuterGaps(width, height);\n  return {\n    width: width - 2 * gaps.width,\n    height: height - 2 * gaps.height,\n    x: gaps.width,\n    y: gaps.height\n  };\n}\n\n/**\n * Retuns the available space for the scrollbar.\n * @param availSpace\n * @param zoomAndScroll\n * @param xAxisPosition\n * @returns\n */\nexport function getScrollBarSpace(\n  isTimeAxis: boolean,\n  availSpace: Dimension,\n  zoomAndScroll: 'live' | 'off',\n  xAxisPosition: AxisPosition,\n  overview?: 'on' | 'off' | ChartOverviewConfig\n) {\n  const dims = { x: 0, y: 0, height: 0, width: 0 };\n  const avSpace = cloneDimension(availSpace);\n\n  let scrollSize = MIN_SCROLL_SIZE;\n  const overviewSize = isTimeAxis ? TIME_AXIS_OVERVIEW_PANE_SIZE : OVERVIEW_PANE_SIZE;\n\n  if (overview === 'on' && xAxisPosition === 'bottom') {\n    scrollSize = availSpace.height * overviewSize;\n  } else if (overview !== undefined) {\n    scrollSize = getOverviewHeight(isTimeAxis, availSpace.height, overview);\n  } else if (zoomAndScroll === 'off') {\n    return { scrollDims: dims, availSpace: avSpace };\n  }\n\n  if (xAxisPosition === 'left') {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y;\n    dims.width = scrollSize;\n    dims.height = availSpace.height;\n\n    avSpace.x += dims.width + SCROLL_GAP;\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else if (xAxisPosition === 'right') {\n    dims.x = availSpace.x + availSpace.width - scrollSize;\n    dims.width = scrollSize;\n    dims.height = availSpace.height;\n    dims.y = availSpace.y;\n\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y + availSpace.height - scrollSize;\n    dims.height = scrollSize;\n    dims.width = availSpace.width;\n\n    avSpace.height -= dims.height + SCROLL_GAP;\n  }\n  return { scrollDims: dims, availSpace: avSpace };\n}\n\n/**\n * Updates the scrollbar space\n * @param availSpace\n * @param isHoriz\n * @param yMaxDim\n */\nexport function updateScrollBarSpace(\n  availSpace: Dimension,\n  isHoriz: boolean,\n  isRtl: boolean,\n  yMaxDim: number\n) {\n  const newDims = cloneDimension(availSpace);\n  if (isHoriz) {\n    newDims.width -= yMaxDim;\n    newDims.x += isRtl ? 0 : yMaxDim;\n  } else {\n    newDims.height -= yMaxDim;\n  }\n  return newDims;\n}\n\nexport function findNearestDataPoint<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  xScale: Scale,\n  yScale: Scale,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  getSeriesDataInfo: (seriesIndex: number) => { offset: number; dataWidth: number },\n  getYCoord: (\n    value: number,\n    yScale: Scale,\n    isStacked: boolean,\n    isLog: boolean,\n    dataItemGaps: number,\n    negCummValue: number,\n    posCummValue: number\n  ) => number,\n  isLog: boolean,\n  dataItemGaps: number,\n  hiddenIds?: Set<number | string>,\n  timeAxisType?: 'enabled' | 'mixedFrequency' | 'skipGaps'\n) {\n  return (x: number, y: number) => {\n    let candidates: { seriesIndex: number; groupIndex: number }[] = [];\n    let neareastGroupIndex = Math.round(x);\n    let groupCenter = xScale.transform(neareastGroupIndex);\n    const isMixedFrequency = timeAxisType === 'mixedFrequency';\n\n    if (timeAxisType === 'enabled' || timeAxisType === 'skipGaps') {\n      neareastGroupIndex = findNearestRegularAxisIndex<K, D>(x, groups, series, getDataItem);\n      groupCenter = xScale.transform(getTime(groups[neareastGroupIndex].id));\n    }\n    candidates = series.map((_, sIndex) => ({\n      groupIndex: neareastGroupIndex,\n      seriesIndex: sIndex\n    }));\n\n    if (isMixedFrequency) {\n      candidates = getNearestMixedFrequencyDataItem<K, D>(x, series, groups, getDataItem);\n    }\n\n    let posCummValue = 0;\n    let negCummValue = 0;\n\n    let minDistance = Number.MAX_VALUE;\n    let minDistanceDims2 = Number.MAX_VALUE;\n    let minSeriesIndex = 0;\n    let minSeriesCenter = groupCenter;\n\n    let yCoord;\n\n    // Currently this logic is aware of various chart settings. Another approach is\n    // purely geometric (save dims of each chart item and sort by some distance measure).\n    // Not sure which one is faster but can consider for performance evaluation.\n    candidates.forEach(({ seriesIndex, groupIndex }) => {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id!) || item.value == null || (isLog && item.value <= 0)) {\n        return;\n      }\n\n      let dist = 0;\n      let dist2 = 0;\n\n      if (isMixedFrequency) {\n        dist = Math.abs(xScale.transform(getTime(item?.x!)) - xScale.transform(x));\n        dist2 = Math.abs(yScale.transform(item.value) - yScale.transform(y));\n      } else if (!isStacked) {\n        const { offset, dataWidth } = getSeriesDataInfo(seriesIndex);\n        const seriesCenter = offset + groupCenter + dataWidth / 2;\n        if (dataWidth === 0) {\n          dist = Math.abs(yScale.transform(item.value) - yScale.transform(y));\n        } else {\n          dist = Math.abs(xScale.transform(x) - seriesCenter);\n          if (dist < minDistance) {\n            minSeriesCenter = seriesCenter;\n          }\n        }\n      } else {\n        const itemY = (item.value < 0 ? negCummValue : posCummValue) + item.value / 2;\n        dist = Math.abs(y - itemY);\n      }\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        minSeriesIndex = seriesIndex;\n        neareastGroupIndex = groupIndex;\n        yCoord = getYCoord(\n          item.value,\n          yScale,\n          isStacked,\n          isLog,\n          dataItemGaps,\n          negCummValue,\n          posCummValue\n        );\n        if (isMixedFrequency) {\n          minDistanceDims2 = dist2;\n        }\n      } else if (dist === minDistance) {\n        if (isMixedFrequency && dist2 < minDistanceDims2) {\n          minDistance = dist;\n          minSeriesIndex = seriesIndex;\n          neareastGroupIndex = groupIndex;\n          minDistanceDims2 = dist2;\n          yCoord = getYCoord(\n            item.value,\n            yScale,\n            isStacked,\n            isLog,\n            dataItemGaps,\n            negCummValue,\n            posCummValue\n          );\n        }\n      }\n\n      if (isStacked) {\n        posCummValue += item.value > 0 ? item.value : 0;\n        negCummValue += item.value < 0 ? item.value : 0;\n      }\n    });\n    return {\n      seriesIndex: minSeriesIndex,\n      groupIndex: neareastGroupIndex,\n      y: yCoord,\n      x: isMixedFrequency\n        ? xScale.transform(getTime(getDataItem(minSeriesIndex, neareastGroupIndex)?.x!))\n        : isStacked\n        ? groupCenter\n        : minSeriesCenter\n    };\n  };\n}\n\nexport function getGroupCenterCoord<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  group: Group,\n  groupIndex: number,\n  xScale: Scale,\n  item: D,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  if (!timeAxisType) {\n    return xScale.transform(groupIndex);\n  } else if (timeAxisType === 'mixedFrequency') {\n    return xScale.transform(new Date(item.x!).getTime());\n  } else {\n    return xScale.transform(new Date(group.id).getTime());\n  }\n}\n\nexport function getMixedFreqGroupCenter<\n  K extends string | number,\n  D extends { x?: string; y?: number; value?: number; id: K }\n>(xScale: Scale, item: D) {\n  return xScale.transform(new Date(item.x!).getTime());\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getTitleProps } from './utils/titleUtils';\nimport { ScaleLinear } from '#utils/PRIVATE_chartUtils';\nimport { AxisPosition, Group, GroupAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { AXIS_DEFAULTS } from './utils/axisDefaults';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getGroupAxisLabelsInfo, getTickLabelInfo, updateLabelsDims } from './utils/labelUtils';\nimport { getAxisMaxSize, getAxisRange, getSafeSkips, getTickLabelAnchor } from './utils/axisUtils';\n\n/**\n * Retuns the groups axis labels.\n * @param groups The groups array.\n * @param startIndex The viewport start index.\n * @param endIndex The viewport end index.\n * @returns\n */\nfunction getGroupAxisLabels(groups: Group[], startIndex: number, endIndex: number) {\n  const ticks = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    ticks.push(groups[i].name || groups[i].id);\n  }\n  return ticks;\n}\n\nfunction getTicks(startIndex: number, endIndex: number) {\n  const ticks = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    ticks.push(i);\n  }\n  return ticks;\n}\n\n/**\n * Retuns the info about group axis.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the chart.\n * @returns\n */\nexport function getGroupAxisInfo(groups: Group[], xAxis: GroupAxisProps = {}, offset: number) {\n  let { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n\n  if (viewportMin != null) {\n    const groupIndex = Math.max(0, Math.ceil(viewportMin));\n    viewportStartGroup = groups[isNaN(groupIndex) ? 0 : groupIndex].id;\n  }\n\n  if (viewportStartGroup != null && viewportMin == null) {\n    viewportMin = groups.findIndex((value: Group) => value.id === viewportStartGroup);\n  }\n\n  if (viewportMin == null) {\n    viewportMin = -1 * offset;\n    viewportStartGroup = groups[0]?.id;\n  }\n\n  if (viewportMax != null) {\n    const groupIndex = Math.min(groups.length - 1, Math.floor(viewportMax));\n    viewportEndGroup = groups[groupIndex < 0 ? 0 : groupIndex].id;\n  }\n\n  if (viewportEndGroup != null && viewportMax == null) {\n    viewportMax = groups.findIndex((value: Group) => value.id === viewportEndGroup);\n  }\n\n  if (viewportMax == null) {\n    viewportMax = groups.length - 1 + offset;\n    viewportEndGroup = groups[Math.floor(viewportMax)]?.id;\n  }\n\n  const xTicks = getTicks(0, groups.length - 1);\n\n  return {\n    min: -1 * offset,\n    max: groups.length - offset,\n    viewportMin,\n    viewportMax,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex: Math.max(0, Math.ceil(viewportMin!)),\n    endIndex: Math.min(Math.floor(viewportMax), viewportMax!),\n    xTicks\n  };\n}\n\n/**\n * The function that returns the x axis properties.\n * @param groupAxisIno The GroupAxisInfo.\n * @param groupAxis The groupAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getGroupAxisProps(\n  groups: Group[],\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  viewportMin: number,\n  viewportMax: number,\n  startIndex: number,\n  endIndex: number,\n  isDomainFlipped: boolean,\n  groupAxis?: GroupAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType,\n  isTestEnv?: boolean\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, groupAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...groupAxis?.titleStyle };\n\n  const { titleDim, ...titleProps } = getTitleProps(\n    groupAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  const axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  const domain: [number, number] = isDomainFlipped\n    ? [viewportMax, viewportMin]\n    : [viewportMin, viewportMax];\n  const scale = new ScaleLinear(domain, [start, end]);\n  const groupWidth = Math.abs(end - start) / (viewportMax - viewportMin);\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: groupAxis?.tickLabel?.style?.color,\n    ...groupAxis?.tickLabel?.style,\n    textAnchor: getTickLabelAnchor(position, isRtl),\n    dominantBaseline: 'middle'\n  };\n\n  let isLabelRendered = groupAxis?.tickLabel?.isRendered != false;\n\n  const labelsInView = getGroupAxisLabels(groups, startIndex, endIndex);\n\n  const numOfSafeSkips = getSafeSkips(groupWidth, tickLabelStyle, getTextDimensions);\n\n  const maxLabelDim = axisMaxDim - axisDim - AXIS_DEFAULTS.labelGap;\n\n  const isWrapAllowed = tickLabelStyle.whiteSpace != 'nowrap';\n\n  const getLabelInfo = (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    isWrapAllowed: boolean\n  ) => {\n    const rangeValue = scale.transform(index + startIndex);\n    return getTickLabelInfo(\n      rangeValue,\n      label,\n      tickLabelStyle,\n      isHoriz,\n      isRotated,\n      isWrapAllowed,\n      allowTruncate,\n      isHoriz ? groupWidth : maxLabelDim,\n      isHoriz ? maxLabelDim : groupWidth,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const autoRotate = groupAxis?.tickLabel?.autoRotate != false;\n  const { maxWidth, maxHeight, tickLabels } = getGroupAxisLabelsInfo(\n    labelsInView,\n    getLabelInfo,\n    isHoriz,\n    autoRotate,\n    isWrapAllowed,\n    numOfSafeSkips\n  );\n\n  isLabelRendered =\n    isLabelRendered && isHoriz\n      ? maxHeight + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim\n      : maxWidth + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim;\n\n  const getAxisPos = (index: number) => {\n    return scale.transform(startIndex + index);\n  };\n\n  let labelDims = 0;\n  if (isLabelRendered) {\n    updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position);\n    labelDims = isHoriz ? maxHeight + AXIS_DEFAULTS.labelGap : maxWidth + AXIS_DEFAULTS.labelGap;\n    tickLabels.forEach((label) => {\n      label['dataProps'] = {\n        'data-oj-object': 'group',\n        'data-oj-group-index': label.index.toString(),\n        'data-oj-text': label.isTruncated ? label.text : undefined,\n        'data-oj-private-group-id': isTestEnv ? groups[label.index].id : undefined\n      };\n    });\n  }\n\n  return {\n    title: isTitleRendered ? groupAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    titleStyle,\n    tickLabels: isLabelRendered ? tickLabels : [],\n    tickLabelStyle,\n    axisDim: isTitleRendered ? labelDims + axisDim : labelDims,\n    scale,\n    groupWidth,\n    formatAxisLabel: undefined // TODO : JET-69997 - groupAxis support formatLabel\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ChartOverviewConfig,\n  Scale,\n  ViewportDetail\n} from '#utils/UNSAFE_visTypes/chart/chart.types';\nimport { OVERVIEW_PANE_SIZE, TIME_AXIS_OVERVIEW_PANE_SIZE } from './layoutUtils';\n\nexport function getOverviewHeight(\n  isTimeAxis: boolean,\n  chartHeight: number,\n  overview: ChartOverviewConfig | 'on' | 'off'\n) {\n  if (overview === 'off') {\n    return 0;\n  }\n\n  if (overview === 'on') {\n    return chartHeight * (isTimeAxis ? TIME_AXIS_OVERVIEW_PANE_SIZE : OVERVIEW_PANE_SIZE);\n  }\n  const isPercent = overview.height.includes('%');\n  const ratio = parseFloat(overview.height);\n  return isPercent ? (ratio / 100) * chartHeight : ratio;\n}\n\nexport function updateViewportFromOverview(\n  xAxisExtent: { min: number; max: number },\n  isRtl: boolean,\n  windowX: number,\n  windowWidth: number,\n  deltaX: number,\n  deltaWidth: number,\n  xScale: Scale,\n  onViewportChange?: (detail: ViewportDetail) => void\n) {\n  const start = windowX + deltaX;\n  const end = windowX + deltaX + windowWidth + deltaWidth;\n  const xMin = Math.max(xAxisExtent.min, xScale.invert(isRtl ? end : start));\n  const xMax = Math.min(xAxisExtent.max, xScale.invert(isRtl ? start : end));\n  onViewportChange?.({\n    xMin,\n    xMax\n  });\n}\n"],"names":["DataAxisInfo","constructor","scale","baselineScaling","dataMax","dataMin","min","max","viewportMin","viewportMax","options","this","isLog","isZeroBaseline","setDataRange","setViewportRange","majorIncrement","actualToLinear","step","minorIncrement","minorStep","minMajorIncrement","minStep","calcAxisExtents","Math","setDefaultMin","scaleUnit","ceil","floor","setDefaultMax","maxValue","minValue","axisStep","calcAxisStep","calcMajorMinorSteps","majorTickCount","minorTickCount","spread","pow","log10","increment","testVal","firstDigit","getDefaultAxisStep","t","first2Digits","round","scaleFactor","linearToActual","value","getScale","range","getAxisViewport","domain","ScaleLog","ScaleLinear","getFirstTick","getAxisExtent","getTicks","firstTick","ticks","push","getMinorTicks","coords","i","j","linearValue","minorValue","getStep","getMinExtent","AXIS_MAX_RATIO","getAxesPosition","yAxis","isHoriz","isRtl","xAxisPosition","yAxisPosition","position","getTickLabelAnchor","getAxisRange","availSpace","x","y","width","height","x2","rangeStart","rangeEnd","getAxisMaxSize","axisSize","size","undefined","getSafeSkips","groupWidth","tickLabelStyle","getTextDimensions","textDims","gaps","AXIS_DEFAULTS","labelGap","defaultTitleProps","text","lines","lineProps","titleDim","dims","isTruncated","isRotated","getTitleProps","title","titleStyle","maxHeight","maxWidth","lineHeight","getTextInfo","positionMultilineText","getSectionDims","reverse","scalesOrder","map","_","getLinearAxisValueFormatter","tickStep","locale","absMax","abs","length","findNearestLEScaleFactor","getPowerOfTen","getScaleFactor","decimalPlaces","scaleFactorDiff","tickStepPowerOfTen","getDecimalPlaces","defaultConverter","Intl","NumberFormat","style","notation","numberingSystem","useGrouping","formattedScale","format","formattedScaleParts","exec","numberConverterOptions","minimumFractionDigits","maximumFractionDigits","suffix","fsn","Number","formattedScaledNumber","toString","val","power","Infinity","MAX_VALUE","getDataAxisProps","dataAxis","dataAxisInfo","axisFontSize","start","end","axisInfo","axisMaxDim","fontSize","titleProps","titleWidth","titleHeight","isTitleRendered","axisDim","titleGap","fill","tickLabel","color","textAnchor","dominantBaseline","linearFormatter","isLabelRendered","isRendered","labels","formatter","maxLabelHeight","tickLabels","getDataAxisLabelsInfo","tick","index","coord","transform","getTickLabelInfo","getAxisPos","labelDims","updateLabelsDims","formatYValue","formatAxisLabel","TIME_SECOND","TIME_MINUTE","TIME_HOUR","TIME_DAY","TIME_MONTH_MIN","TIME_MONTH_MAX","TIME_YEAR_MIN","TIME_YEAR_MAX","getTimeAxisProps","groups","averageInterval","xAxis","timeAxisType","valueToCoord","startCoord","endCoord","ratio","minVal","timeToIndex","maxVal","getCoordFromValue","getLocale","gap","times","getLabelPos","getMixedFrequencyStep","date","Date","id","getTime","level1Formatter","Array","isArray","level2Formatter","granularity","calculateGranularity","initialInterval","intervals","Set","hasMissingValues","ret","intervalsCache","timeLength","previousDate","currentDate","currentInterval","calculateGranularInterval","add","minimumInterval","result","gcd","getGCDInterval","currentValue","previousValue","ratioOfCurrentIntervalToMinimumInterval","numMissingValues","fillIntervalInMilliseconds","treatMissingValues","label","totalWidth","labelHeight","getTickLabelGap","isLabel1Rendered","isLabel2Rendered","labelInfos1","labelInfos2","label1Formatter","label2Formatter","coords1","coords2","prevDate","isOneLevel","time","label1","label2","generateLabels","numOfSafeSkips","getLabel1Dims","rangeValue","didNotFit","getLabel2Dims","label1MaxWidth","label1MaxHeight","tickLabels1","getGroupAxisLabelsInfo","label2MaxWidth","label2MaxHeight","tickLabels2","skipLabelsGreedy","level2AxisDim","concat","forEach","invert","endIndex","startIndex","startTime","endTime","indexToTime","getValueFromCoord","axisValue","twoLabels","merge","timeRange","formatLabelWithFormatter","bOneLabel","isVert","formatDate","getMonth","getFullYear","getDate","getHours","formatTime","getMinutes","getSeconds","showDay","showMonth","showYear","year","month","day","toLocaleDateString","showMinute","showSecond","hour","minute","second","toLocaleTimeString","anchor","initialTimezoneOffset","getTimezoneOffset","setMonth","setHours","addOneYear","addOneMonth","timezoneCorrection","correction","setFullYear","uxTime","isoToNumber","dateString","getTimeAxisInfo","offset","timeAxisRange","viewportEndGroup","viewportStartGroup","axisType","getAverageInterval","axisOffset","globalMin","globalMax","group","timeStamp","minAxisExtent","prevTimezoneOffset","currentTimezoneOffset","currentTime","currentTimezoneOffsetCorrection","granularInterval","setTime","interval1","interval2","getDataExtent","series","getDataItem","xStartIndex","xEndIndex","isStacked","hiddenSet","hideAndShowBehavior","data","xMin","xMax","yMin","yMax","idToDataMap","Map","groupIndex","posCumulValue","negCumulValue","seriesIndex","item","itemHasValue","set","has","getDataMinMax","findNextGroupWithData","gIndex","sIndex","right","findPreviousGroupWithData","left","findNearestRegularAxisIndex","keyFunc","target","foundIndex","ll","rr","moveRight","newIndex","findGroup","prevIndex","nextIndex","OUTER_GAP_WIDTH","OUTER_GAP_HEIGHT","TIME_AXIS_OVERVIEW_PANE_SIZE","OVERVIEW_PANE_SIZE","getSpaces","xMaxDim","yMaxDim","isYLeft","xSpace","ySpace","plotAreaSpace","getHorizSpace","getVertSpace","bottomOffset","topOffset","leftOffset","rightOffset","getOuterGaps","widthRatio","heightRatio","xScale","yScale","getSeriesDataInfo","getYCoord","dataItemGaps","hiddenIds","candidates","neareastGroupIndex","groupCenter","isMixedFrequency","minIndex","dist","getNearestMixedFrequencyDataItem","yCoord","posCummValue","negCummValue","minDistance","minDistanceDims2","minSeriesIndex","minSeriesCenter","dist2","itemY","dataWidth","seriesCenter","isTestEnv","hasXDataAxis","isTimeAxis","xAxisInfo","dataInfo","minExtent","timeAxis","numGroups","itemX","num","getStartAndEndTime","isNaN","findIndex","xTicks","getGroupAxisInfo","yAxisInfo","yDim","cloneDimension","isXAxisHoriz","xAvailSpace","axisProps","isDomainFlipped","groupAxis","labelsInView","name","getGroupAxisLabels","maxLabelDim","isWrapAllowed","whiteSpace","autoRotate","allowTruncate","getGroupAxisProps","xProps","newYSpace","newYProps","yProps","xViewportExtent","xIndexExtent","yViewportExtent","yAxisExtent","xAxisMinExtent","xAxisExtent","yMajorTicks","xMajorTicks","xMinorTicks","yMinorTicks","zoomAndScroll","overview","avSpace","scrollSize","overviewSize","chartHeight","isPercent","includes","parseFloat","getOverviewHeight","scrollDims","newDims","windowX","windowWidth","deltaX","deltaWidth","onViewportChange"],"mappings":"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"}