{"version":3,"file":"chartUtils-ed1b8cf4.js","sources":["../../src/PRIVATE_LineAreaComponents/AreaSeries.tsx","../../src/PRIVATE_LineAreaComponents/utils/chartUtils.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { getCmdsForArea } from '#utils/PRIVATE_chartUtils/utils';\nimport { Point } from '#utils/PRIVATE_visSVGUtils';\nimport { Scale } from '#utils/UNSAFE_visTypes/chart';\nimport { dvtVars } from '#Common/themes/themeContract.css';\n\ntype AreaSeriesProps = {\n  yScale: Scale;\n  color: ColorProps['color'];\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  isLog: boolean;\n  areaColorOpacity: number;\n  lineSegments: Point[][];\n  bottomCoords?: Point[];\n  isHighlighted: boolean;\n  isBottomSegmentCurved: boolean;\n  seriesIndex: number;\n};\n\nexport function AreaSeries({\n  yScale,\n  lineType = 'straight',\n  color,\n  isHorizontal,\n  isLog,\n  areaColorOpacity,\n  lineSegments,\n  bottomCoords,\n  isHighlighted,\n  isBottomSegmentCurved,\n  seriesIndex\n}: AreaSeriesProps) {\n  const style = {\n    fill: color,\n    opacity: isHighlighted\n      ? areaColorOpacity\n      : `calc(${dvtVars.dimmedOpacity} * ${areaColorOpacity})`\n  };\n  return (\n    <>\n      {lineSegments.map((lineSegment: Point[]) => {\n        if (lineSegment.length < 2) {\n          return;\n        }\n\n        let baseCoords;\n        if (bottomCoords) {\n          // custom bottom coords. eg: top of last series in stacked area\n          baseCoords = bottomCoords;\n        } else {\n          // TODO: make this more generic when we support apps setting baseline\n          // for log assume domain min is the baseline, otherwise use 0 baseline\n          const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);\n          baseCoords = isHorizontal\n            ? ([\n                [baselineCoord, lineSegment[0][1]],\n                [baselineCoord, lineSegment[lineSegment.length - 1][1]]\n              ] as Point[])\n            : ([\n                [lineSegment[0][0], baselineCoord],\n                [lineSegment[lineSegment.length - 1][0], baselineCoord]\n              ] as Point[]);\n        }\n        const cmds = getCmdsForArea(\n          lineSegment,\n          baseCoords,\n          lineType,\n          isHorizontal,\n          isBottomSegmentCurved\n        );\n        return (\n          <path d={cmds} style={style} data-oj-series-index={seriesIndex} data-oj-object={'area'} />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Group, Scale } from '#utils/UNSAFE_visTypes/chart';\n\nexport const getLineAreaChartItemPosition = (\n  seriesIndex: number,\n  groupIndex: number,\n  // TODO: JET-71332 ; should only be (number | undefined)[][]\n  // scatter chart does not call this function\n  renderedSeries: (number | undefined)[][] | (number[] | { x: number; y: number }[])[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => { x?: any } | undefined,\n  groups: Group[],\n  isHoriz: boolean,\n  xScale: Scale,\n  yScale: Scale,\n  timeAxisType?: string\n) => {\n  // TODO: JET-71332; remove as number after JET-71332 is fixed\n  const value = renderedSeries[seriesIndex][groupIndex] as number;\n  if (value == null) {\n    return undefined;\n  }\n\n  let xVal = groupIndex;\n  if (timeAxisType) {\n    const val =\n      timeAxisType === 'mixedFrequency'\n        ? getDataItem(seriesIndex, groupIndex)?.x\n        : groups[groupIndex].id;\n    xVal = new Date(val).getTime();\n  }\n\n  const x = isHoriz ? yScale.transform(value) : xScale.transform(xVal);\n  const y = isHoriz ? xScale.transform(xVal) : yScale.transform(value);\n\n  return { x, y, height: 0, width: 0 };\n};\n"],"names":["yScale","lineType","color","isHorizontal","isLog","areaColorOpacity","lineSegments","bottomCoords","isHighlighted","isBottomSegmentCurved","seriesIndex","style","fill","opacity","dvtVars","dimmedOpacity","_jsx","map","lineSegment","length","baseCoords","baselineCoord","transform","domain","cmds","getCmdsForArea","d","groupIndex","renderedSeries","getDataItem","groups","isHoriz","xScale","timeAxisType","value","xVal","val","x","id","Date","getTime","y","height","width"],"mappings":"kJA4BM,UAAqBA,OACzBA,EAAMC,SACNA,EAAW,WAAUC,MACrBA,EAAKC,aACLA,EAAYC,MACZA,EAAKC,iBACLA,EAAgBC,aAChBA,EAAYC,aACZA,EAAYC,cACZA,EAAaC,sBACbA,EAAqBC,YACrBA,IAEA,MAAMC,EAAQ,CACZC,KAAMV,EACNW,QAASL,EACLH,EACA,QAAQS,EAAAA,QAAQC,mBAAmBV,MAEzC,OACEW,EAAAA,yBACGV,EAAaW,KAAKC,IACjB,GAAIA,EAAYC,OAAS,EACvB,OAGF,IAAIC,EACJ,GAAIb,EAEFa,EAAab,MACR,CAGL,MAAMc,EAAgBrB,EAAOsB,UAAUlB,EAAQJ,EAAOuB,SAAS,GAAK,GACpEH,EAAajB,EACR,CACC,CAACkB,EAAeH,EAAY,GAAG,IAC/B,CAACG,EAAeH,EAAYA,EAAYC,OAAS,GAAG,KAErD,CACC,CAACD,EAAY,GAAG,GAAIG,GACpB,CAACH,EAAYA,EAAYC,OAAS,GAAG,GAAIE,GAEhD,CACD,MAAMG,EAAOC,EAAAA,eACXP,EACAE,EACAnB,EACAE,EACAM,GAEF,OACEO,MAAA,OAAA,CAAMU,EAAGF,EAAMb,MAAOA,yBAA6BD,EAAW,iBAAkB,QAChF,KAIV,iCC5E4C,CAC1CA,EACAiB,EAGAC,EACAC,EACAC,EACAC,EACAC,EACAhC,EACAiC,KAGA,MAAMC,EAAQN,EAAelB,GAAaiB,GAC1C,GAAa,MAATO,EACF,OAGF,IAAIC,EAAOR,EACX,GAAIM,EAAc,CAChB,MAAMG,EACa,mBAAjBH,EACIJ,EAAYnB,EAAaiB,IAAaU,EACtCP,EAAOH,GAAYW,GACzBH,EAAO,IAAII,KAAKH,GAAKI,SACtB,CAKD,MAAO,CAAEH,EAHCN,EAAU/B,EAAOsB,UAAUY,GAASF,EAAOV,UAAUa,GAGnDM,EAFFV,EAAUC,EAAOV,UAAUa,GAAQnC,EAAOsB,UAAUY,GAE/CQ,OAAQ,EAAGC,MAAO,EAAG"}