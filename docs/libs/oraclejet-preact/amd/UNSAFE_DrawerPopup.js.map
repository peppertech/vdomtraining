{"version":3,"file":"UNSAFE_DrawerPopup.js","sources":["../../src/UNSAFE_DrawerPopup/DrawerPopup.tsx"],"sourcesContent":["import { JSX, RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback, useMemo } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  getActiveElement,\n  focusOnElementOrNearestAncestor\n} from '../utils/PRIVATE_tabbableUtils';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { RtlSide } from '../UNSAFE_Floating';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\n\n// Hooks\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useSwipe } from '../hooks/UNSAFE_useSwipe';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { DrawerPopupVariantOptions } from './themes/DrawerPopupStyles.css';\nimport { colorInterpolations, ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { DrawerPopupRedwoodTheme } from './themes/redwood/DrawerPopupTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype NormalizedPlacement = 'left' | 'right' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'closing';\ntype VisibilityStatus = 'hidden' | 'visible';\ntype DisplayModeHorizontal = 'overlay' | 'fullOverlay';\ntype OnCloseDetail = {\n  reason: 'outsideClick' | 'escapeKey' | 'swipe';\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * Specifies whether the Drawer is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies at what edge the Drawer opens.\n     * Supported values are:\n     * <p><code>start</code>, <code>end</code>, <code>bottom</code></p>\n     * Default is <code>start</code>.\n     */\n    placement?: Placement;\n    /**\n     * Specifies modality of the Darwer.\n     * Supported values are:\n     * <p><code>modal</code>, <code>modeless</code></p>\n     * Default is <code>modal</code>.\n     */\n    modality?: 'modal' | 'modeless';\n    /**\n     * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n     * The parent should listen to this event and close the Drawer. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     * Supported detail values are:\n     * <p><code>outsideClick</code>, <code>escapeKey</code></p>, <code>swipe</code>\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Optional ref for an element to focus on when component mounts.\n     */\n    autoFocusRef?: RefObject<HTMLElement>;\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  } & TestIdProps;\n\n// Constants\nconst displayModefullWidthThreshold = 600;\nconst zero = '0px';\nconst duration = 250;\n\nconst getElementHeight = (element: HTMLDivElement): number => {\n  return Math.round(element.offsetHeight);\n};\n\nconst getElementWidth = (element: HTMLDivElement): number => {\n  return Math.round(element.getBoundingClientRect().width);\n};\n\n/**\n * A drawer popup adds a single slide-in side content alongside some primary content to an application window.\n *\n * This drawer always overlays the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerPopup = forwardRef(\n  (\n    {\n      children,\n      isOpen = false,\n      autoFocusRef,\n      placement = 'start',\n      modality = 'modal',\n      onClose,\n      onTransitionEnd,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    // Initialize states\n    const [status, setStatus] = useState<Status>(isOpen ? 'initial' : 'unmounted');\n    const [visibility, setVisibility] = useState<VisibilityStatus>('hidden');\n    const [isOutsideClickDisabled, setIsOutsideClickDisabled] = useState<boolean>(!isOpen);\n    const [displayModeHorizontal, setDisplayModeHorizontal] =\n      useState<DisplayModeHorizontal>('overlay');\n\n    const rootRef = useRef<HTMLDivElement>(null);\n    const launcherRef = useRef<HTMLElement | null>(null);\n    const elementWithFocusBeforeDrawerClosesRef = useRef<HTMLElement | null>(null);\n\n    const mergedRef = useMemo(() => mergeRefs(rootRef, ref), [rootRef, ref]);\n\n    const isBottomPlacement = placement === 'bottom';\n\n    // Animation config\n    const animationStates = {\n      opening: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: getTranslateY()\n            },\n            to: {\n              translateY: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: getTranslateX()\n            },\n            to: {\n              translateX: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      },\n      closing: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: zero\n            },\n            to: {\n              translateY: getTranslateY()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: zero\n            },\n            to: {\n              translateX: getTranslateX()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      }\n    };\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    // Normalizing position\n    const { direction } = useUser();\n    const getNormalizedPlacement = (): RtlSide => {\n      return normalizePosition(placement, direction);\n    };\n\n    const getTranslateX = (): string => {\n      return `${getNormalizedPlacement() === 'right' ? '' : '-'}${getElementWidth(\n        rootRef.current as HTMLDivElement\n      )}px`;\n    };\n\n    const getTranslateY = (): string => {\n      return `${getElementHeight(rootRef.current as HTMLDivElement)}px`;\n    };\n\n    const setInitialFocus = () => {\n      // Set focus to the first match:\n      // 1. First element inside the drawer matching [autofocus]\n      const autofocusItems: HTMLElement[] = getAutofocusFocusables(rootRef.current as HTMLElement);\n      if (autofocusItems.length > 0) {\n        focusOn(autofocusItems[0]);\n        return;\n      }\n      // 2. Tabbable element inside the content element\n      // 3. The drawer itself\n      focusWithin(rootRef.current as HTMLElement);\n    };\n\n    const returnFocusToLauncher = (): void => {\n      // Return the focus to the drawer's launcher only if the focus\n      // is currently living within a drawer.\n      // As we do not apply focus-trap in modeless mode, user is able to\n      // get the focus out of the drawer. In this case we do not want to handle it.\n      if (rootRef.current?.contains(elementWithFocusBeforeDrawerClosesRef.current)) {\n        focusOnElementOrNearestAncestor(launcherRef.current as HTMLElement);\n      }\n    };\n\n    // Remove style attribute left on the element by the Animation util\n    const removeAnimationInlineStyles = useCallback(() => {\n      rootRef.current?.style?.removeProperty('transform');\n    }, []);\n\n    // Animation\n    const { nodeRef } = useAnimation<Status, HTMLDivElement>(status, {\n      animationStates,\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === 'opening') {\n          removeAnimationInlineStyles();\n          setInitialFocus();\n          onTransitionEnd?.(true);\n        } else if (!isOpen) {\n          returnFocusToLauncher();\n          nodeRef(null);\n          setVisibility('hidden');\n          setStatus('unmounted');\n          onTransitionEnd?.(false);\n        }\n      }\n    });\n\n    useEffect(() => {\n      // 1. Ignore status update on initial render\n      if (status === 'unmounted' && !isOpen) {\n        return;\n      }\n\n      // 2. Mount visually hidden component\n      // Component gets mounted, but will be visually hidden to avoid flickering\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      if (status === 'unmounted' && isOpen) {\n        setStatus('initial');\n        return;\n      }\n\n      // 3. Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (status === 'initial' && isOpen) {\n        nodeRef(rootRef.current);\n        setIsOutsideClickDisabled(false);\n        setStatus('opening');\n        return;\n      }\n\n      // 3. Unhide component. It becomes visible.\n      if (status === 'opening' && isOpen) {\n        setVisibility('visible');\n        return;\n      }\n\n      // 4. Closing\n      if (!isOpen) {\n        elementWithFocusBeforeDrawerClosesRef.current = getActiveElement() as HTMLElement;\n        setIsOutsideClickDisabled(true);\n        setStatus('closing');\n      }\n    }, [isOpen, status, nodeRef]);\n\n    // Launcher handler\n    useEffect(() => {\n      if (status === 'opening') {\n        // Remember launcher\n        launcherRef.current = getActiveElement() as HTMLElement;\n\n        // Register F6 key handler. It is modeless only feature.\n        if (modality === 'modeless') {\n          launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n        }\n      }\n      if (status === 'closing' && modality === 'modeless') {\n        return () => {\n          // Deregister F6 key handler\n          launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n        };\n      }\n      return;\n    }, [modality, status]);\n\n    const launcherKeyDownCallback = (event: KeyboardEvent): void => {\n      // Moves focus from launcher (must have focus) back to the Drawer\n      if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        // Focus on first tabbable in a container or container itself if there is none\n        focusWithin(rootRef.current as HTMLElement);\n      }\n    };\n\n    const handleKeyDown = useCallback(\n      (event: KeyboardEvent) => {\n        const launcherEl = launcherRef.current;\n        switch (event.code) {\n          case 'Escape': {\n            onClose?.({ reason: 'escapeKey' });\n            break;\n          }\n          case 'F6':\n            if (modality === 'modeless') {\n              // Prevent default F6 handlers.\n              // F6 is a standard Chrome address bar shortcut on Windows.\n              event.preventDefault();\n              event.stopPropagation();\n              // Focus launcher\n              if (launcherEl) {\n                focusOn(launcherEl);\n              }\n              break;\n            }\n        }\n      },\n      [onClose, modality]\n    );\n\n    // OutsideClick handler\n    const handleOutsideClick = useCallback(() => {\n      // Trigger onClose event with outside click detail\n      onClose?.({ reason: 'outsideClick' });\n    }, [onClose]);\n\n    useOutsideClick({\n      isDisabled: isOutsideClickDisabled,\n      ref: rootRef,\n      handler: handleOutsideClick\n    });\n\n    // Drawer placement\n    const getDrawerPlacement = (): NormalizedPlacement => {\n      if (isBottomPlacement) {\n        return placement;\n      } else {\n        if (direction === 'rtl') {\n          return placement === 'start' ? 'right' : 'left';\n        } else {\n          return placement === 'start' ? 'left' : 'right';\n        }\n      }\n    };\n\n    const clientHints = getClientHints();\n\n    const getViewportWidth = useCallback((): number => {\n      if (clientHints.platform === 'ios') {\n        // On ios window.innerWidth is not recommended way of measuring the viewport\n        return document.documentElement.clientWidth;\n      }\n      return window.innerWidth;\n    }, [clientHints.platform]);\n\n    // Window resize handler\n    // Handles display mode: Overlay <> Full overlay (full width side drawers)\n    const handleResize = useCallback(() => {\n      const viewportWidth = getViewportWidth();\n      if (displayModeHorizontal === 'overlay' && viewportWidth < displayModefullWidthThreshold) {\n        setDisplayModeHorizontal('fullOverlay');\n      }\n      if (\n        displayModeHorizontal === 'fullOverlay' &&\n        viewportWidth > displayModefullWidthThreshold\n      ) {\n        setDisplayModeHorizontal('overlay');\n      }\n    }, [getViewportWidth, displayModeHorizontal]);\n\n    useEffect(() => {\n      const root = rootRef.current;\n      if (root && status === 'opening') {\n        const resizeObserver = new ResizeObserver(() => {\n          handleResize();\n        });\n        resizeObserver.observe(document.body);\n        return () => {\n          resizeObserver.unobserve(document.body);\n        };\n      }\n      return undefined;\n    }, [status, handleResize]);\n\n    const dispatchSwipeOnClose = useCallback(() => {\n      onClose?.({ reason: 'swipe' });\n    }, [onClose]);\n\n    // OutsideClick handler\n    const swipeHandler = useCallback(\n      (event: any): void => {\n        const swipeDir = event.direction;\n        // LTR\n        if (direction === 'ltr') {\n          if (\n            (placement === 'start' && swipeDir === 'left') ||\n            (placement === 'end' && swipeDir === 'right')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // RTL\n        if (direction === 'rtl') {\n          if (\n            (placement === 'start' && swipeDir === 'right') ||\n            (placement === 'end' && swipeDir === 'left')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // Bottom\n        if (placement === 'bottom' && swipeDir === 'down') {\n          dispatchSwipeOnClose();\n        }\n      },\n      [direction, placement, dispatchSwipeOnClose]\n    );\n\n    const swipeOptions = {\n      threshold: 50,\n      maximumTime: 750,\n      tolerance: 40\n    };\n    const { swipeProps } = useSwipe(swipeHandler, swipeOptions);\n\n    // Styles\n    const { classes } = useComponentTheme<DrawerPopupVariantOptions>(DrawerPopupRedwoodTheme, {\n      placement: getDrawerPlacement(),\n      visibility,\n      displayModeHorizontal:\n        ['start', 'end'].indexOf(placement) > -1 ? displayModeHorizontal : undefined\n    });\n\n    const interpolations = [...Object.values(colorInterpolations)];\n    const styleInterpolations = mergeInterpolations<ColorProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n\n    const renderDrawer = () => {\n      return (\n        <div\n          ref={mergedRef}\n          className={classes}\n          style={styles}\n          tabIndex={-1}\n          role=\"dialog\"\n          onKeyDown={handleKeyDown}\n          aria-label={ariaLabel}\n          aria-labelledby={ariaLabelledBy}\n          aria-describedby={ariaDescribedBy}\n          {...swipeProps}\n          {...testIdProps}>\n          <FocusTrap autoFocusRef={autoFocusRef}>{children}</FocusTrap>\n        </div>\n      );\n    };\n\n    const isMounted = status !== 'unmounted';\n    if (isMounted) {\n      // Modal vs. modelss upper wrapper\n      if (modality === 'modal') {\n        return <Modal isOpen={isMounted}>{renderDrawer()}</Modal>;\n      } else {\n        return <Layer>{renderDrawer()}</Layer>;\n      }\n    }\n\n    return null;\n  }\n);\n"],"names":["zero","duration","DrawerPopup","forwardRef","children","isOpen","autoFocusRef","placement","modality","onClose","onTransitionEnd","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","ref","status","setStatus","useState","visibility","setVisibility","isOutsideClickDisabled","setIsOutsideClickDisabled","displayModeHorizontal","setDisplayModeHorizontal","rootRef","useRef","launcherRef","elementWithFocusBeforeDrawerClosesRef","mergedRef","useMemo","mergeRefs","isBottomPlacement","animationStates","opening","from","translateY","getTranslateY","to","options","translateX","getTranslateX","closing","testIdProps","useTestId","direction","useUser","normalizePosition","element","current","Math","round","getBoundingClientRect","width","offsetHeight","removeAnimationInlineStyles","useCallback","style","removeProperty","nodeRef","useAnimation","isAnimatedOnMount","onAnimationEnd","autofocusItems","getAutofocusFocusables","length","focusOn","focusWithin","setInitialFocus","contains","focusOnElementOrNearestAncestor","useEffect","getActiveElement","addEventListener","launcherKeyDownCallback","removeEventListener","event","code","preventDefault","stopPropagation","handleKeyDown","launcherEl","reason","handleOutsideClick","useOutsideClick","isDisabled","handler","clientHints","getClientHints","getViewportWidth","platform","document","documentElement","clientWidth","window","innerWidth","handleResize","viewportWidth","resizeObserver","ResizeObserver","observe","body","unobserve","dispatchSwipeOnClose","swipeHandler","swipeDir","swipeProps","useSwipe","threshold","maximumTime","tolerance","classes","useComponentTheme","DrawerPopupRedwoodTheme","indexOf","undefined","interpolations","Object","values","colorInterpolations","styleInterpolations","mergeInterpolations","styles","renderDrawer","_jsx","className","tabIndex","role","onKeyDown","FocusTrap","isMounted","jsx","Modal","Layer"],"mappings":"gwDA+FA,MACMA,GAAO,MACPC,GAAW,IAeJC,GAAcC,EAAUA,YACnC,EAEIC,WACAC,UAAS,EACTC,eACAC,YAAY,QACZC,WAAW,QACXC,UACAC,kBACA,aAAcC,EACd,kBAAmBC,EACnB,mBAAoBC,EACpBC,YACGC,GAELC,KAGA,MAAOC,EAAQC,GAAaC,EAAQA,SAASd,EAAS,UAAY,cAC3De,EAAYC,GAAiBF,EAAQA,SAAmB,WACxDG,EAAwBC,GAA6BJ,EAAAA,UAAmBd,IACxEmB,EAAuBC,GAC5BN,EAAQA,SAAwB,WAE5BO,EAAUC,SAAuB,MACjCC,EAAcD,SAA2B,MACzCE,EAAwCF,SAA2B,MAEnEG,EAAYC,WAAQ,IAAMC,YAAUN,EAASV,IAAM,CAACU,EAASV,IAE7DiB,EAAkC,WAAd1B,EAGpB2B,EAAkB,CACtBC,QAAS,IACHF,EACK,CACLG,KAAM,CACJC,WAAYC,KAEdC,GAAI,CACFF,WAAYrC,IAEdwC,QAAS,CACPvC,SAAUA,KAIP,CACLmC,KAAM,CACJK,WAAYC,KAEdH,GAAI,CACFE,WAAYzC,IAEdwC,QAAS,CACPvC,SAAUA,KAKlB0C,QAAS,IACHV,EACK,CACLG,KAAM,CACJC,WAAYrC,IAEduC,GAAI,CACFF,WAAYC,KAEdE,QAAS,CACPvC,SAAUA,KAIP,CACLmC,KAAM,CACJK,WAAYzC,IAEduC,GAAI,CACFE,WAAYC,KAEdF,QAAS,CACPvC,SAAUA,MAQd2C,EAAcC,YAAU/B,IAGxBgC,UAAEA,GAAcC,EAAAA,UAKhBL,EAAgB,KACpB,MAAO,GAAgC,UAJhCM,EAAiBA,kBAACzC,EAAWuC,GAIa,GAAK,MA9GnCG,EA+GjBvB,EAAQwB,QA9GPC,KAAKC,MAAMH,EAAQI,wBAAwBC,WAD5B,IAACL,CAgHd,EAGDX,EAAgB,KACpB,MAAO,GAxHaW,EAwHOvB,EAAQwB,QAvHhCC,KAAKC,MAAMH,EAAQM,kBADH,IAACN,CAwH6C,EA2B7DO,EAA8BC,EAAAA,aAAY,KAC9C/B,EAAQwB,SAASQ,OAAOC,eAAe,YAAY,GAClD,KAGGC,QAAEA,GAAYC,EAAYA,aAAyB5C,EAAQ,CAC/DiB,kBACA4B,mBAAmB,EACnBC,eAAgB,KACC,YAAX9C,GACFuC,IAlCkB,MAGtB,MAAMQ,EAAgCC,EAAAA,uBAAuBvC,EAAQwB,SACjEc,EAAeE,OAAS,EAC1BC,UAAQH,EAAe,IAKzBI,cAAY1C,EAAQwB,QAAuB,EAyBvCmB,GACA3D,KAAkB,IACRL,IAnBVqB,EAAQwB,SAASoB,SAASzC,EAAsCqB,UAClEqB,kCAAgC3C,EAAYsB,SAoB1CU,EAAQ,MACRvC,EAAc,UACdH,EAAU,aACVR,KAAkB,GACnB,IAIL8D,EAAAA,WAAU,KAER,GAAe,cAAXvD,GAA2BZ,EAA/B,CAQA,GAAe,cAAXY,IAA0BZ,EAS9B,MAAe,YAAXY,GAAwBZ,GAC1BuD,EAAQlC,EAAQwB,SAChB3B,GAA0B,QAC1BL,EAAU,iBAKG,YAAXD,GAAwBZ,EAC1BgB,EAAc,WAKXhB,IACHwB,EAAsCqB,QAAUuB,EAAAA,mBAChDlD,GAA0B,GAC1BL,EAAU,aAzBVA,EAAU,UAPX,CAiCA,GACA,CAACb,EAAQY,EAAQ2C,IAGpBY,EAAAA,WAAU,KAUR,GATe,YAAXvD,IAEFW,EAAYsB,QAAUuB,EAAAA,mBAGL,aAAbjE,GACFoB,EAAYsB,SAASwB,iBAAiB,UAAWC,IAGtC,YAAX1D,GAAqC,aAAbT,EAC1B,MAAO,KAELoB,EAAYsB,SAAS0B,oBAAoB,UAAWD,EAAwB,CAGzE,GACN,CAACnE,EAAUS,IAEd,MAAM0D,EAA2BE,IAE3BjD,EAAYsB,UAAYuB,EAAAA,oBAAqC,OAAfI,EAAMC,OAGtDD,EAAME,iBACNF,EAAMG,kBAGNZ,cAAY1C,EAAQwB,SACrB,EAGG+B,EAAgBxB,eACnBoB,IACC,MAAMK,EAAatD,EAAYsB,QAC/B,OAAQ2B,EAAMC,MACZ,IAAK,SACHrE,IAAU,CAAE0E,OAAQ,cACpB,MAEF,IAAK,KACH,GAAiB,aAAb3E,EAAyB,CAG3BqE,EAAME,iBACNF,EAAMG,kBAEFE,GACFf,EAAOA,QAACe,GAEV,KACD,EACJ,GAEH,CAACzE,EAASD,IAIN4E,EAAqB3B,EAAAA,aAAY,KAErChD,IAAU,CAAE0E,OAAQ,gBAAiB,GACpC,CAAC1E,IAEJ4E,kBAAgB,CACdC,WAAYhE,EACZN,IAAKU,EACL6D,QAASH,IAIX,MAYMI,GAAcC,EAAAA,iBAEdC,GAAmBjC,EAAAA,aAAY,IACN,QAAzB+B,GAAYG,SAEPC,SAASC,gBAAgBC,YAE3BC,OAAOC,YACb,CAACR,GAAYG,WAIVM,GAAexC,EAAAA,aAAY,KAC/B,MAAMyC,EAAgBR,KACQ,YAA1BlE,GAAuC0E,EAvTX,KAwT9BzE,EAAyB,eAGC,gBAA1BD,GACA0E,EA5T8B,KA8T9BzE,EAAyB,UAC1B,GACA,CAACiE,GAAkBlE,IAEtBgD,EAAAA,WAAU,KAER,GADa9C,EAAQwB,SACE,YAAXjC,EAAsB,CAChC,MAAMkF,EAAiB,IAAIC,gBAAe,KACxCH,IAAc,IAGhB,OADAE,EAAeE,QAAQT,SAASU,MACzB,KACLH,EAAeI,UAAUX,SAASU,KAAK,CAE1C,CACe,GACf,CAACrF,EAAQgF,KAEZ,MAAMO,GAAuB/C,EAAAA,aAAY,KACvChD,IAAU,CAAE0E,OAAQ,SAAU,GAC7B,CAAC1E,IAGEgG,GAAehD,eAClBoB,IACC,MAAM6B,EAAW7B,EAAM/B,UAEL,QAAdA,IAEe,UAAdvC,GAAsC,SAAbmG,GACX,QAAdnG,GAAoC,UAAbmG,IAExBF,KAIc,QAAd1D,IAEe,UAAdvC,GAAsC,UAAbmG,GACX,QAAdnG,GAAoC,SAAbmG,IAExBF,KAIc,WAAdjG,GAAuC,SAAbmG,GAC5BF,IACD,GAEH,CAAC1D,EAAWvC,EAAWiG,MAQnBG,WAAEA,IAAeC,EAAQA,SAACH,GALX,CACnBI,UAAW,GACXC,YAAa,IACbC,UAAW,MAKPC,QAAEA,IAAYC,EAAiBA,kBAA4BC,0BAAyB,CACxF3G,UA7FI0B,EACK1B,EAEW,QAAduC,EACmB,UAAdvC,EAAwB,QAAU,OAEpB,UAAdA,EAAwB,OAAS,QAwF5Ca,aACAI,sBACE,CAAC,QAAS,OAAO2F,QAAQ5G,IAAc,EAAIiB,OAAwB4F,IAGjEC,GAAiB,IAAIC,OAAOC,OAAOC,EAAAA,sBACnCC,GAAsBC,sBAAgCL,QACjDM,IAAWF,GAAoB1G,GAEpC6G,GAAe,IAEjBC,EAAAA,WACE7G,IAAKc,EACLgG,UAAWd,GACXtD,MAAOiE,GACPI,UAAW,EACXC,KAAK,SACLC,UAAWhD,EAAa,aACZtE,EACK,kBAAAC,qBACCC,KACd8F,MACA/D,EAAWxC,SACfyH,MAACK,EAASA,UAAA,CAAC5H,aAAcA,WAAeF,MAKxC+H,GAAuB,cAAXlH,EAClB,OAAIkH,GAEe,UAAb3H,EACKqH,EAAAO,IAACC,EAAKA,MAAA,CAAChI,OAAQ8H,GAAY/H,SAAAwH,OAE3BC,EAAAA,IAACS,EAAAA,MAAK,CAAAlI,SAAEwH,OAIZ,IAAI"}