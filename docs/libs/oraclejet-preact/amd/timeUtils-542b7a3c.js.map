{"version":3,"file":"timeUtils-542b7a3c.js","sources":["../../src/utils/UNSAFE_timeUtils/timeUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { checkNoCalendarExtension } from '#utils/UNSAFE_calendarDateUtils';\nimport {\n  AmPmLocalizedValues,\n  FilteredDateTimeFormatPart,\n  Hour,\n  MillisecondPlaceholder,\n  Time,\n  TimeGranularity,\n  TimePlaceholders\n} from './types';\n\n// For locales that start with 'en', we use these placeholders.\nconst EN_LOCALE_PLACEHOLDER_HOUR = 'hh';\nconst EN_LOCALE_PLACEHOLDER_MINUTE = 'mm';\nconst EN_LOCALE_PLACEHOLDER_SECOND = 'ss';\nconst EN_LOCALE_PLACEHOLDER_MILLISECOND = 'sss';\n// For locales that do not start with 'en', we use these placeholders.\nconst NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER = '--';\nconst NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER = '---';\n\nconst AM_VALUE = 0;\nconst PM_VALUE = 12;\n\n/**\n * Returns a new array where the value in the masks array of type/value objects is replaced\n * with the string placeholders based on the locale.\n * For example, [{type='hour', value='hh'}, {type='minute', value='mm'} for 'en' locales,\n * or value='--' for non-'en' locales.\n * @param {BCP47Locale} locale - The locale.\n * @param {TimePlaceholders} masks - The TimePlaceholder masks\n * @returns A new array where the value in the masks array of type/value objects is replaced with\n * the string placeholders based on the locale.\n */\nconst replaceCustomMasksValuesWithPlaceholders = (\n  locale: BCP47Locale,\n  masks: TimePlaceholders\n): TimePlaceholders => {\n  const {\n    hourPlaceholder,\n    minutePlaceholder,\n    secondPlaceholder,\n    millisecondPlaceholder,\n    dayPeriodPlaceholder\n  } = getTimePlaceholderValuesFromLocale(locale);\n\n  return masks.map((p) => {\n    switch (p.type) {\n      case 'hour':\n        return { ...p, value: hourPlaceholder };\n      case 'minute':\n        return { ...p, value: minutePlaceholder };\n      case 'second':\n        return { ...p, value: secondPlaceholder };\n      case 'millisecond':\n        return { ...p, value: millisecondPlaceholder };\n      case 'dayPeriod':\n        return { ...p, value: dayPeriodPlaceholder };\n      default:\n        return { ...p };\n    }\n  }) as TimePlaceholders;\n};\n\n/**\n * Retrieves the TimePlaceholders masks where value has the placeholder (e.g., 'hh' or '--')\n * by using a new instance of Intl.DateTimeFormat with the locale, granularity, and hour12.\n *\n * @param {BCP47Locale} locale - The locale\n * @param {TimeGranularity} granularity - The granularity of the desired time mask.\n * @param hour12 - passes through to Intl.DateTimeFormat's hour12, which indicates\n * if the hour is a 12-hour (as opposed to 24-hour) clock.\n * E.g., new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(date)\n * @returns Returns the TimePlaceholder masks where value has the placeholders (e.g., 'hh' or '--').\n */\nconst getTimeMasksFromLocaleAndOptions = (\n  locale: BCP47Locale = 'en-US',\n  granularity: TimeGranularity,\n  hour12?: boolean\n) => {\n  checkNoCalendarExtension(locale);\n\n  // Filter out anything not related to a time mask.\n  // This does not filter out spaces, e.g., the literal space between the time and the dayPeriod.\n  const filterByTimeType = (parts: Intl.DateTimeFormatPart[]) => {\n    return parts.filter(\n      (p): p is FilteredDateTimeFormatPart =>\n        p.type === 'minute' ||\n        p.type === 'hour' ||\n        p.type === 'second' ||\n        p.type === 'dayPeriod' ||\n        p.type === 'literal'\n    );\n  };\n\n  const testDateWithTime = new Date('2022-11-30T00:00:00');\n  // If granularity is milliseconds, we use timeStyle: 'medium'. Later we stitch in the literal and millisecond part to medium since\n  // there is not a timeStyle for milliseconds, and you cannot use fractionalSecond: 3 with timeStyle in Intl.DateTimeFormat.\n  const timeStyle = granularity === 'minute' ? 'short' : 'medium';\n  const formatter = getTimeFormatterShortMedium(locale, timeStyle, hour12);\n\n  const parts = formatter.formatToParts(testDateWithTime);\n\n  const timeParts = filterByTimeType(parts);\n\n  // If granularity is millisecond, then add a separator and fractionalSecond to the array after seconds.\n  let allTimeParts;\n  if (granularity === 'millisecond') {\n    allTimeParts = insertFractionalSecond(locale, timeParts);\n  } else {\n    allTimeParts = timeParts;\n  }\n\n  // map it so that it has the same type as InputTimeMask's masks type of TimePlaceholders\n  const masks = allTimeParts.map((part) => {\n    switch (part.type) {\n      case 'fractionalSecond':\n        return { type: 'millisecond', value: part.value } as MillisecondPlaceholder;\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'dayPeriod':\n      case 'literal':\n        return { ...part };\n    }\n  });\n\n  // replace part value with placeholder\n  return replaceCustomMasksValuesWithPlaceholders(locale, masks as TimePlaceholders);\n};\n\nconst cachedFractionalSecondsDigitFormatter = new Map<BCP47Locale, Intl.DateTimeFormat>();\n/**\n * Returns a new array with the fractionalSecond part\n * and its preceding separator part merged into the parts array after the seconds part.\n *\n * There is not an Intl.DateTimeFormat timeStyle option that displays milliseconds,\n * and you cannot use fractionalSecond: 3 with a timeStyle option at the same time in Intl.DateTimeFormat.\n * Therefore to get the parts for granularity: 'millisecond',\n * get parts from timeStyle: 'medium' and call this function with those parts. This function will stitch in\n * the separator and fractionalSecond parts after the 'second' part.\n *\n * @param {BCP47Locale} locale\n * @param {FilteredDateTimeFormatPart[]} parts - The parts from calling Intl.DateTimeFormat with timeStyle: 'medium'.\n * @returns a new parts array with the fractionalSecond and its preceding separator stitched into the parts array\n * after the 'second' part.\n */\nconst insertFractionalSecond = (locale: BCP47Locale, parts: FilteredDateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'second');\n  if (index === -1) {\n    // 'second' not found, return the array as is\n    return parts;\n  }\n\n  const cacheKey = `${locale}`;\n  let formatter = cachedFractionalSecondsDigitFormatter.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat(locale, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: '2-digit',\n      fractionalSecondDigits: 3,\n      numberingSystem: 'latn'\n    });\n    cachedFractionalSecondsDigitFormatter.set(cacheKey, formatter);\n  }\n\n  // get separatorValue that comes before the fractionalSecond part.\n  const partsWithFractionalSeconds = formatter.formatToParts(new Date());\n  const separatorPart = getLiteralBeforeFractionalSecond(partsWithFractionalSeconds);\n  if (separatorPart === null) {\n    return parts;\n  }\n  const newParts: FilteredDateTimeFormatPart[] = [\n    { type: 'literal', value: separatorPart.value },\n    { type: 'fractionalSecond', value: 'sss' }\n  ];\n\n  return [...parts.slice(0, index + 1), ...newParts, ...parts.slice(index + 1)];\n};\n\n/**\n * Finds and returns the 'literal' part immediately before the first 'fractionalSecond' part in an\n * array of Intl.DateTimeFormatPart objects. If not found, returns null.\n * @param {Intl.DateTimeFormatPart[]} parts\n * @returns {Intl.DateTimeFormatPart[]|null} - The literal part before the 'fractionalSecond' part.\n */\nconst getLiteralBeforeFractionalSecond = (parts: Intl.DateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'fractionalSecond');\n  if (index > 0 && parts[index - 1].type === 'literal') {\n    return parts[index - 1];\n  }\n  return null;\n};\n\n/**\n * Creates an object with the time segment placeholders based on the locale.\n * For locales that start with 'en', we use 'hh', 'mm', 'ss', 'sss', for\n * other locales we use '--' or '---' if millisecond.\n *\n * @param {BCP47Locale} locale\n * @returns An object with the time segment placeholders.\n */\nconst getTimePlaceholderValuesFromLocale = (locale: BCP47Locale) => {\n  const { am } = getAmPmStringsForLocale(locale);\n\n  if (locale.startsWith('en')) {\n    return {\n      hourPlaceholder: EN_LOCALE_PLACEHOLDER_HOUR,\n      minutePlaceholder: EN_LOCALE_PLACEHOLDER_MINUTE,\n      secondPlaceholder: EN_LOCALE_PLACEHOLDER_SECOND,\n      millisecondPlaceholder: EN_LOCALE_PLACEHOLDER_MILLISECOND,\n      dayPeriodPlaceholder: am\n    };\n  }\n\n  return {\n    hourPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    minutePlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    secondPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    millisecondPlaceholder: NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER,\n    dayPeriodPlaceholder: am\n  };\n};\n\n/**\n * Creates a time formatter using new Intl.DateTimeFormat for the locale.\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {'short'|'medium'} timeStyle - The timeStyle formatting option.\n * @param {boolean} hour12 - Whether to use 12-hour time format.\n * @returns A new formatter instance for the specified locale and options.\n */\nconst getTimeFormatterShortMedium = (\n  locale: BCP47Locale,\n  timeStyle: 'short' | 'medium',\n  hour12?: boolean\n) => {\n  const options =\n    hour12 === undefined\n      ? { timeStyle, numberingSystem: 'latn' }\n      : { timeStyle, hour12, numberingSystem: 'latn' };\n\n  return new Intl.DateTimeFormat(locale, options);\n};\n\n/**\n * Gets the day period value strings for AM and PM.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @returns An object containing the AM and PM strings for the locale.\n */\nconst getAmPmStringsForLocale = (locale: BCP47Locale): AmPmLocalizedValues => {\n  const am = getDayPeriodValueStr(locale, 0); // 0 is 12 AM\n  const pm = getDayPeriodValueStr(locale, 13); // 13 is 1 PM\n  return { am, pm };\n};\n\nconst cachedDayPeriodString = new Map<string, string>();\n\n/**\n * Retrieves the day period string for a specific locale and hour.\n * This uses a cache so a new instance of Intl.DateTimeFormat with hour12: true so even if the locale\n * does not have a 1-12 hour time by default, the hour12: true parameter will force it.\n * For example, for 'en-US' if the hour is 0, this returns 'AM'. If the hour is 13, this returns 'PM'.\n * For 'ms', if the hour is 0, this returns 'PG'.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {Hour} hour - The hour for which to get the day period (0-23).\n * @returns {string} The locale's day period value for the hour. All locales have a dayPeriod string, but\n * just in case we default to 'AM' and 'PM'.\n */\nconst getDayPeriodValueStr = (locale: BCP47Locale = 'en-US', hour: Hour) => {\n  const morningIsoHourStr = '00';\n  const eveningIsoHourStr = '23';\n  const isoHourStr = hour < 12 ? morningIsoHourStr : eveningIsoHourStr;\n\n  // is locale + isoHourStr in the cache? If so, return it.\n  const dayPeriod = cachedDayPeriodString.get(`${locale}-${isoHourStr}`);\n  if (!dayPeriod) {\n    // This sets hour12 to true.\n    const formatter = getTimeFormatterShortMedium(locale, 'short', true);\n    // Cache both am and pm values at the same time in order to use the same formatter for performance sake.\n    [morningIsoHourStr, eveningIsoHourStr].forEach((hourToCache) => {\n      const isoStr = `2022-11-30T${hourToCache}:00:00`;\n      const date = new Date(isoStr);\n      const parts = formatter.formatToParts(date);\n      const dayPeriodPart = parts.find((p) => p.type === 'dayPeriod');\n      // All locales I tested have a dayPeriod string when hour12: true,\n      // but just in case there is a locale for Intl.DateTimeFormat with no dayPeriod string, we default to one.\n      const defaultDayPeriodToCache = hourToCache === morningIsoHourStr ? 'AM' : 'PM';\n      const dayPeriodToCache = dayPeriodPart ? dayPeriodPart.value : defaultDayPeriodToCache;\n      cachedDayPeriodString.set(`${locale}-${hourToCache}`, dayPeriodToCache);\n    });\n    // return the dayPeriod for the hour requested that we just cached.\n    return cachedDayPeriodString.get(`${locale}-${isoHourStr}`)!;\n  }\n  return dayPeriod;\n};\n\nconst getDayPeriodValueFromHour = (hour: Hour) => {\n  return hour > 11 ? PM_VALUE : AM_VALUE;\n};\n\n/**\n * Formats a Time object into a string based on the provided masks.\n * Handles hour conversion (12-hour/24-hour) since the Time object is in 24-hour format,\n * and the mask, if it has the dayPeriod, is in 12-hour format. Applies leading\n * zeros to hour if leadingZeroForHour is true. Pads zeros to minute, second, and millisecond so\n * that the digits equal two for minute/second and three for millisecond.\n * The timeMasks must have the correct segments to match the granularity before calling this function.\n * @param locale\n * @param time\n * @param granularity\n * @param timeMasks\n * @param leadingZeroForHour\n * @returns a formatted time string\n */\nconst formatTimeFromMasks = (\n  locale: BCP47Locale,\n  time: Time,\n  granularity: TimeGranularity,\n  timeMasks: TimePlaceholders,\n  leadingZeroForHour: boolean\n) => {\n  checkNoCalendarExtension(locale);\n  // First, the time must be complete.\n  if (\n    time.hour === undefined ||\n    time.minute === undefined ||\n    (granularity === 'second' && time.second === undefined) ||\n    (granularity === 'millisecond' && time.millisecond === undefined)\n  ) {\n    return '';\n  }\n\n  const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');\n  const dayPeriodToDisplay = hasDayPeriod ? getDayPeriodValueStr(locale, time.hour) : ''; // e.g., 'AM' or 'PM' for 'en-US'\n\n  // Format hour with optional leading zero\n  const timeHour = hasDayPeriod ? to12Hour(time.hour) : time.hour;\n  const hourToDisplay = leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n\n  // Format minute, second, and millisecond with necessary padding\n  const minuteToDisplay = padWithZero(time.minute, 2);\n  const secondToDisplay = padWithZero(time.second, 2);\n  const millisecondToDisplay = padWithZero(time.millisecond, 3);\n\n  // Map timeMasks to their corresponding values and join them into a formatted time string.\n  const timeValues = timeMasks.map(({ type, value }) =>\n    type === 'hour'\n      ? hourToDisplay\n      : type === 'minute'\n      ? minuteToDisplay\n      : type === 'second'\n      ? secondToDisplay\n      : type === 'millisecond'\n      ? millisecondToDisplay\n      : type === 'dayPeriod'\n      ? dayPeriodToDisplay\n      : value\n  );\n  return timeValues.join('');\n};\n\n/**\n * Retrieves the hour string. If the display has a day period, then the hour string\n * will be 1-12, otherwise it will be 0-23.\n * @param hour\n * @param hasDayPeriod true if the time to display has a day period segment (e.g., a segment that shows AM or PM).\n * This means the time field has a 1-12 hour time.\n * @param leadingZeroForHour If true, the hour string will have length of 2, with leading zeros if necessary to pad it out.\n * @returns\n */\nconst getHourValueStr = (hour: Hour, hasDayPeriod: boolean, leadingZeroForHour: boolean) => {\n  // If hasDayPeriod, the hour to display is in the range of 1-12. E.g., 1:00 AM.\n  // Since the hour parameter is 0-23, the hour to display needs to be converted to a 1-12 hour string.\n  // If hasDayPeriod is false, the hour to display is in the range of 0-23. E.g., 01:00.\n  const timeHour = hasDayPeriod ? to12Hour(hour) : hour;\n  return leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n};\n\nconst cachedTimeStyleShortHasLeadingZero = new Map<BCP47Locale, boolean>();\n/**\n * Returns true if the locale's hour has a leading zero by default.\n *\n * This method uses a cached new Intl.DateTimeFormat(locale),\n * and uses formatToParts for hour\n * to figure out if the hour has a leading zero.\n *\n * @param {BCP47Locale} locale - the locale\n * @returns true if hour starts with 0 for the specific locale.\n */\nconst getLeadingZeroForHour = (locale: BCP47Locale) => {\n  // check timeStyle short for the locale\n  // and see if the hour starts with 0.\n  // if so, return true;\n  const value = new Date('1995-12-17T09:30:00');\n  const cacheKey = `${locale}`;\n  let isLeadingZero = cachedTimeStyleShortHasLeadingZero.get(cacheKey);\n  if (isLeadingZero === undefined) {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeStyle: 'short',\n      numberingSystem: 'latn'\n    });\n    const parts = formatter.formatToParts(value);\n    const hourPart = parts.find((part) => part.type === 'hour');\n    const hourValue = hourPart?.value!;\n    isLeadingZero = hourValue.startsWith('0');\n    cachedTimeStyleShortHasLeadingZero.set(cacheKey, isLeadingZero);\n  }\n\n  return isLeadingZero;\n};\n\n/**\n * Converts the 24-hour hour to a 12-hour hour.\n * @param {Hour} hour24\n * @returns\n */\nconst to12Hour = (hour24: Hour) => {\n  const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;\n  return hour12;\n};\n\nconst padWithZero = (num: number | undefined, length: number) => {\n  return num !== undefined ? num.toString().padStart(length, '0') : '';\n};\n\n/**\n * Returns true if the time params represent two different times.\n * @param t1\n * @param t2\n * @returns true if the time params represent two different times.\n */\nconst timesAreDifferent = (t1: Time | undefined, t2: Time | undefined) => {\n  const isEmpty = (time: Time | undefined) => {\n    return (\n      !time || // if time is undefined\n      (time.hour === undefined &&\n        time.minute === undefined &&\n        time.second === undefined &&\n        time.millisecond === undefined)\n    );\n  };\n\n  // Both are empty/undefined, return false (same)\n  if (isEmpty(t1) && isEmpty(t2)) return false;\n\n  // If one is empty/undefined and the other isn't, return true (different)\n  if (isEmpty(t1) !== isEmpty(t2)) return true;\n\n  // Return true if any of the segment values don't match.\n  if (\n    t1?.hour !== t2?.hour ||\n    t1?.minute !== t2?.minute ||\n    t1?.second !== t2?.second ||\n    t1?.millisecond !== t2?.millisecond\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Determines whether the input string matches the start of the 'am' and/or 'pm' strings in the given am/pm object.\n *\n * The match is case-insensitive and ignores leading and trailing whitespace.\n *\n * If the input matches with only the start of the 'am' string, 'am' is returned.\n * If the input matches with only the start of the 'pm' string, 'pm' is returned.\n * If the input matches the start of both the 'am' and 'pm strings (e.g., the 'am'/'pm' strings have the same starting letter(s) and the input is too short to disambiguate),\n * 'both is returned.\n * If the input does not match the start of either string, 'none' is returned.\n * @param {AmPmLocalizedValues} amPmObj - An object containing the am and pm strings for the current locale.\n * @param {string} input - The user provided string to match against the am an pm strings.\n * @returns {('am' | 'pm' | 'none' | 'both')}\n */\nconst getAmPmMatchType = (amPmObj: AmPmLocalizedValues, input: string) => {\n  const trimmedInput = input.trim().toLowerCase();\n\n  // If input is empty after trimming, return 'none'\n  if (trimmedInput === '') {\n    return 'none';\n  }\n\n  // Check if the input matches as a prefix in either property (am or pm)\n  const matchesAM = amPmObj.am.toLowerCase().startsWith(trimmedInput);\n  const matchesPM = amPmObj.pm.toLowerCase().startsWith(trimmedInput);\n\n  // If both match, return 'both'\n  if (matchesAM && matchesPM) {\n    return 'both';\n  }\n\n  // If only one matches, return that\n  if (matchesAM) {\n    return 'am';\n  }\n\n  if (matchesPM) {\n    return 'pm';\n  }\n\n  // If neither matches\n  return 'none';\n};\n\nexport {\n  AM_VALUE,\n  PM_VALUE,\n  getAmPmMatchType,\n  getAmPmStringsForLocale,\n  getDayPeriodValueFromHour,\n  getDayPeriodValueStr,\n  getHourValueStr,\n  getTimeMasksFromLocaleAndOptions,\n  formatTimeFromMasks,\n  getLeadingZeroForHour,\n  padWithZero,\n  timesAreDifferent,\n  replaceCustomMasksValuesWithPlaceholders\n};\n"],"names":["NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER","replaceCustomMasksValuesWithPlaceholders","locale","masks","hourPlaceholder","minutePlaceholder","secondPlaceholder","millisecondPlaceholder","dayPeriodPlaceholder","getTimePlaceholderValuesFromLocale","map","p","type","value","cachedFractionalSecondsDigitFormatter","Map","insertFractionalSecond","parts","index","findIndex","part","cacheKey","formatter","get","Intl","DateTimeFormat","hour","minute","second","fractionalSecondDigits","numberingSystem","set","partsWithFractionalSeconds","formatToParts","Date","separatorPart","getLiteralBeforeFractionalSecond","newParts","slice","am","getAmPmStringsForLocale","startsWith","getTimeFormatterShortMedium","timeStyle","hour12","options","undefined","getDayPeriodValueStr","pm","cachedDayPeriodString","morningIsoHourStr","eveningIsoHourStr","isoHourStr","dayPeriod","forEach","hourToCache","date","dayPeriodPart","find","defaultDayPeriodToCache","dayPeriodToCache","cachedTimeStyleShortHasLeadingZero","to12Hour","hour24","padWithZero","num","length","toString","padStart","time","granularity","timeMasks","leadingZeroForHour","checkNoCalendarExtension","millisecond","hasDayPeriod","some","dayPeriodToDisplay","timeHour","hourToDisplay","minuteToDisplay","secondToDisplay","millisecondToDisplay","join","amPmObj","input","trimmedInput","trim","toLowerCase","matchesAM","matchesPM","isLeadingZero","hourPart","hourValue","testDateWithTime","timeParts","filter","filterByTimeType","allTimeParts","t1","t2","isEmpty"],"mappings":"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"}