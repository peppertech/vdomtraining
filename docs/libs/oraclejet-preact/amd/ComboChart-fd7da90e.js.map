{"version":3,"file":"ComboChart-fd7da90e.js","sources":["../../src/UNSAFE_ComboChart/OverviewComboChart.tsx","../../src/UNSAFE_ComboChart/ComboChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComboChart } from './ComboChart';\nimport { ComboChartProps, LineAreaItem } from './ComboChart.types';\n\nexport function OverviewComboChart<K extends string | number, D extends LineAreaItem<K>>(\n  props: ComboChartProps<K, D>\n) {\n  return (\n    <ComboChart\n      datatip={() => ({ content: '' })}\n      zoomAndScroll=\"off\"\n      plotArea={{\n        yMajorTick: {\n          isRendered: false\n        },\n        xMajorTick: {}\n      }}\n      xAxis={{\n        tickLabel: {\n          autoRotate: false,\n          // @ts-ignore\n          isRendered: props.xAxis?.timeAxisType ? true : false\n        }\n      }}\n      series={props.series}\n      groups={props.groups}\n      getDataItem={props.getDataItem}\n      yAxis={{\n        tickLabel: {\n          isRendered: false\n        }\n      }}\n      overview=\"off\"\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComboChartProps, LineAreaItem } from './ComboChart.types';\nimport { findNearestDataPoint } from '#utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from '#PRIVATE_LineAreaComponents/AreaSeries';\nimport { getMarkers, getSeriesData } from '#utils/PRIVATE_chartUtils/utils';\nimport { MarkersWithLabel } from '#PRIVATE_Chart/MarkersWithLabel';\nimport { getLineAreaChartNavUtil } from '#utils/PRIVATE_chartUtils/navUtils';\nimport { Chart } from '#PRIVATE_Chart';\nimport { Scale, TimeAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { getColorRamp } from '#utils/UNSAFE_visUtils';\nimport { LineSeries } from '#PRIVATE_LineAreaComponents/LineSeries';\nimport { Point } from '#utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '#utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '#Common/themes/themeContract.css';\nimport { getItemColor, getMarkerType } from '#utils/PRIVATE_chartUtils/dataStyleUtils';\nimport { BarGroup } from '#UNSAFE_BarChart/BarGroup';\nimport { getBarPosition } from '#UNSAFE_BarChart/utils/barLayoutUtils';\nimport { getLineAreaChartItemPosition } from '#PRIVATE_LineAreaComponents/utils/chartUtils';\nimport { getBarGapRatio } from '#UNSAFE_BarChart/utils/barSeriesUtils';\nimport { OverviewComboChart } from './OverviewComboChart';\n\nconst BAR_AXIS_OFFSET = 0.5;\n\nconst AXIS_OFFSET = 0.2;\n\nconst LINE_WITH_AREA_OPACITY = 0.2;\n\n/**\n * The ComboChart displays information graphically using bars, lines and filled areas, making relationships among the data easier to understand.\n */\nexport function ComboChart<K extends string | number, D extends LineAreaItem<K>>({\n  width,\n  height,\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  dataItemGaps = 0.5,\n  dataLabelEffect = 'outline',\n  ...props\n}: ComboChartProps<K, D>) {\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const filteredBarSeries = series.filter((currentSeries) => currentSeries.type === 'bar');\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  // TODO: JET-71332 ; should only be (number | undefined)[][]\n  // remove the type inference from scatter chart item.\n  const renderedSeries = getSeriesData<K, D>(\n    series.length,\n    groups.length,\n    getDataItem,\n    hiddenSet,\n    isLog\n  );\n\n  const hasArea = renderedSeries.some(\n    (_, index) => series[index].type === 'area' || series[index].type === 'lineWithArea'\n  );\n  const hasBar = renderedSeries.some((_, index) => series[index].type === 'bar');\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number): D | undefined => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    } as D;\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    // TODO: JET-71332\n    //@ts-ignore\n    return getLineAreaChartNavUtil<D>(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale, groupWidth: number, gapRatio: number) => {\n    const _getBarPosition = hasBar\n      ? getBarPosition(\n          filteredBarSeries,\n          groups,\n          getDataItem,\n          xScale,\n          yScale,\n          hiddenSet,\n          dataItemGaps,\n          groupWidth,\n          gapRatio,\n          yAxis?.scale === 'log',\n          isStacked,\n          isRtl,\n          isHoriz,\n          timeAxisType\n        )\n      : undefined;\n\n    return (seriesIndex: number, groupIndex: number) => {\n      const seriesItem = series[seriesIndex];\n      if (seriesItem.type === 'bar') {\n        return _getBarPosition ? _getBarPosition(seriesIndex, groupIndex) : undefined;\n      } else {\n        return getLineAreaChartItemPosition(\n          seriesIndex,\n          groupIndex,\n          renderedSeries,\n          getDataItem,\n          groups,\n          isHoriz,\n          xScale,\n          yScale,\n          timeAxisType\n        );\n      }\n    };\n  };\n\n  const getMarkerColorAndType = (seriesIndex: number, groupIndex: number) => {\n    const color = getItemColor(seriesIndex, groupIndex, series, getDataItem);\n    const markerType = getMarkerType(seriesIndex, groupIndex, getDataItem);\n    return { color, markerType };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint<K, D>(\n      series,\n      groups,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet,\n      timeAxisType\n    );\n  };\n  const markers = getMarkers();\n\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedSet}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      series={series}\n      defaultOverviewContentRenderer={() => {\n        return <OverviewComboChart groups={groups} series={series} getDataItem={getDataItem} />;\n      }}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      getMarkerInfo={getMarkerColorAndType}\n      renderGridLinesInFront={hasArea}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      offset={hasBar ? BAR_AXIS_OFFSET : AXIS_OFFSET}\n      isRtl={isRtl}\n      {...props}>\n      {({\n        xStartIndex,\n        xEndIndex,\n        xScale,\n        yScale,\n        activeId,\n        focusedItemInfo,\n        hoveredItemInfo,\n        isPointInsideMarquee,\n        getTextDimensions,\n        defaultFontSize,\n        groupWidth\n      }) => {\n        let barSeriesIndex = -1;\n        return (\n          <>\n            {renderedSeries.map((valueSeries, index) => {\n              const currentSeries = series[index];\n\n              const areaOpacity =\n                currentSeries.type === 'lineWithArea' ? LINE_WITH_AREA_OPACITY : 1;\n              const isAreaRendered =\n                currentSeries.type === 'area' || currentSeries.type === 'lineWithArea';\n              const isContrastLineNeeded = currentSeries.type === 'area';\n\n              if (valueSeries.length === 0) {\n                return;\n              }\n\n              const lineSegmentCoords: Point[][] = getLineAreaSegments<K, D>(\n                yScale,\n                xScale,\n                valueSeries,\n                xStartIndex,\n                xEndIndex,\n                isHoriz,\n                isLog,\n                groups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                currentSeries.type !== 'bar'\n                  ? currentSeries.lineType === 'curved' &&\n                    isStacked &&\n                    renderedSeries.length > 1 &&\n                    index > 0\n                  : isStacked && renderedSeries.length > 1 && index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined ||\n                highlightedSet.size === 0 ||\n                highlightedSet.has(currentSeries.id);\n\n              const prevCoords =\n                isStacked && index != 0\n                  ? allLineSegmentCoords.reduce((prevValue, newValue, j) => {\n                      // find the index i such that i < index, and series i  has at least\n                      // one or more data item unhidden. Only such series will can be\n                      // used as bottomCoord for current series. Otherwise we have to use\n                      // baseline coord\n                      if (j >= index) {\n                        return prevValue;\n                      }\n                      if (newValue.length > 0) {\n                        return j;\n                      }\n                      return prevValue;\n                    }, 0)\n                  : undefined;\n              if (currentSeries.type === 'bar') barSeriesIndex = barSeriesIndex + 1;\n              return (\n                <>\n                  {currentSeries.type === 'bar' &&\n                    groups.slice(xStartIndex, xEndIndex + 1).map((_, index) => {\n                      const barGroup = (\n                        <BarGroup\n                          yScale={yScale}\n                          xScale={xScale}\n                          groupIndex={index + xStartIndex}\n                          selectedIds={selectedSet}\n                          hiddenIds={hiddenSet}\n                          highlightedIds={highlightedIds ? highlightedSet : highlightedIds}\n                          isDrillEnabled={drilling === 'on'}\n                          series={filteredBarSeries}\n                          barGapRatio={getBarGapRatio(isStacked, xStartIndex, xEndIndex)}\n                          dataItemGaps={dataItemGaps}\n                          isPointInsideMarquee={isPointInsideMarquee}\n                          isStacked={isStacked}\n                          groupWidth={groupWidth}\n                          group={groups[index]}\n                          timeAxisType={(props.xAxis as TimeAxisProps)?.timeAxisType}\n                          colors={colors}\n                          activeId={activeId}\n                          isLog={yAxis?.scale === 'log'}\n                          orientation={orientation}\n                          getDataItem={getDataItem}\n                          isSelectionEnabled={selectionMode != 'none'}\n                          isRtl={isRtl}\n                          focusedItemInfo={focusedItemInfo}\n                          hoveredItemInfo={hoveredItemInfo}\n                          getTextDimensions={getTextDimensions}\n                          defaultFontSize={defaultFontSize}\n                          seriesIndex={barSeriesIndex}\n                        />\n                      );\n\n                      return barGroup;\n                    })}\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={yScale}\n                      lineType={currentSeries.lineType}\n                      color={currentSeries.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={areaOpacity}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={\n                        prevCoords !== undefined &&\n                        allLineSegmentCoords[prevCoords].some((value) => value != null)\n                          ? allLineSegmentCoords[prevCoords]\n                          : undefined\n                      }\n                      lineSegments={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  {currentSeries.type === 'line' && (\n                    <LineSeries\n                      lineType={currentSeries.lineType}\n                      lineColor={\n                        isContrastLineNeeded\n                          ? colorSchemeVars.dvt.contrastLine\n                          : currentSeries.lineColor\n                      }\n                      lineWidth={isContrastLineNeeded ? 1.25 : currentSeries.lineWidth}\n                      lineStyle={currentSeries.lineStyle || 'solid'}\n                      color={currentSeries.lineColor || colors[index % colors.length]}\n                      lineSegmentCoords={lineSegmentCoords}\n                      isHorizontal={isHoriz}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (currentSeries.type === 'line' || isAreaRendered) && (\n                      <MarkersWithLabel\n                        yScale={yScale}\n                        xScale={xScale}\n                        groups={groups}\n                        series={currentSeries}\n                        timeAxisType={timeAxisType}\n                        color={\n                          colors[\n                            index % colors.length\n                          ] /* TODO : make this use getItemColor function from dataStyleUtils. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        isPointInsideMarquee={isPointInsideMarquee}\n                        selectedIds={selectedSet}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index &&\n                          focusedItemInfo.isFocusVisible &&\n                          !(props.isDataCursorEnabled && props.dataCursorStyle?.isMarkerDisplayed)\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                        defaultFontSize={defaultFontSize}\n                        dataLabelEffect={dataLabelEffect}\n                        isHighContrast={isHighContrast}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n          </>\n          //TODO - handle isStack part\n        );\n      }}\n    </Chart>\n  );\n}\n"],"names":["OverviewComboChart","props","_jsx","ComboChart","datatip","content","zoomAndScroll","plotArea","yMajorTick","isRendered","xMajorTick","xAxis","tickLabel","autoRotate","timeAxisType","series","groups","getDataItem","yAxis","overview","BAR_AXIS_OFFSET","AXIS_OFFSET","LINE_WITH_AREA_OPACITY","width","height","selectedIds","hiddenIds","highlightedIds","hideAndShowBehavior","orientation","isStacked","selectionMode","drilling","dataItemGaps","dataLabelEffect","direction","forcedColors","useUser","isHighContrast","filteredBarSeries","filter","currentSeries","type","isRtl","isLog","scale","hiddenSet","Set","selectedSet","highlightedSet","isHoriz","colors","getColorRamp","renderedSeries","getSeriesData","length","hasArea","some","_","index","hasBar","renderedGetDataItem","seriesIndex","groupIndex","value","markers","getMarkers","allLineSegmentCoords","jsx","Chart","defaultOverviewContentRenderer","findNearest","xScale","yScale","findNearestDataPoint","offset","dataWidth","transform","getDataItemPos","groupWidth","gapRatio","_getBarPosition","getBarPosition","undefined","getLineAreaChartItemPosition","getMarkerInfo","color","getItemColor","markerType","getMarkerType","renderGridLinesInFront","getNavUtil","startIndex","endIndex","getLineAreaChartNavUtil","getGapRatio","children","xStartIndex","xEndIndex","activeId","focusedItemInfo","hoveredItemInfo","isPointInsideMarquee","getTextDimensions","defaultFontSize","barSeriesIndex","_Fragment","Fragment","map","valueSeries","areaOpacity","isAreaRendered","isContrastLineNeeded","lineSegmentCoords","getLineAreaSegments","isBottomSegmentCurved","lineType","isHighlighted","size","has","id","prevCoords","reduce","prevValue","newValue","j","_jsxs","slice","BarGroup","isDrillEnabled","barGapRatio","getBarGapRatio","group","isSelectionEnabled","AreaSeries","areaColor","isHorizontal","areaColorOpacity","bottomCoords","lineSegments","LineSeries","lineColor","colorSchemeVars","dvt","contrastLine","lineWidth","lineStyle","MarkersWithLabel","focusedItemIndex","isFocusVisible","isDataCursorEnabled","dataCursorStyle","isMarkerDisplayed","hoveredItemIndex","isCurrent"],"mappings":"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"}