{"version":3,"file":"useSelection-b137b39f.js","sources":["../../src/hooks/PRIVATE_useSelection/useSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { Keys, containsKey, isKeyDefined, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { SelectionDetail, SelectionMode } from '../../UNSAFE_Collection';\nimport { useUser } from '../UNSAFE_useUser';\n\n/**\n * Type for selection behavior.  See useMultipleSelection hook for details.\n */\nexport const behaviors = ['toggle', 'replace'] as const;\nexport type SelectionBehavior = (typeof behaviors)[number];\n\n/**\n * Type for payload of selection range change event handler\n */\nexport type SelectionRangeDetail<K> = {\n  value: { start: K; end: K };\n};\n\nconst isShiftModeSupported = <K>(\n  anchorKey: K,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  isClickEvent: boolean\n) => {\n  return (\n    selectionMode === 'multiple' &&\n    selectionBehavior !== 'toggle' &&\n    (isClickEvent || containsKey(selectedKeys, anchorKey))\n  );\n};\n\nconst handleSelect = <K>(\n  event: MouseEvent | KeyboardEvent,\n  keyExtractor: (element: HTMLElement) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  isSelectionRequired: boolean,\n  keyboardCursorRef: RefObject<K | undefined>,\n  anchorKey?: K,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) => {\n  const itemKey = keyExtractor(event.target as HTMLElement);\n  if (itemKey == null) {\n    return;\n  }\n\n  // handle shift key selection\n  if (\n    event.shiftKey &&\n    anchorKey !== undefined &&\n    onRangeChange &&\n    isShiftModeSupported(\n      anchorKey,\n      selectedKeys,\n      selectionMode,\n      selectionBehavior,\n      event.type === 'click'\n    )\n  ) {\n    onRangeChange({ value: { start: anchorKey, end: itemKey } });\n    // set keyboard selection cursor in case user extends with SHIFT+ARROW\n    if (keyboardCursorRef) {\n      keyboardCursorRef.current = itemKey;\n    }\n    return;\n  }\n\n  const selected = containsKey(selectedKeys, itemKey);\n  let keySet = selectedKeys;\n  if (!selected) {\n    if (\n      selectionMode === 'single' ||\n      (event as KeyboardEvent).key === 'Enter' ||\n      (selectionBehavior === 'replace' && !(event.ctrlKey || event.metaKey))\n    ) {\n      // should only contains this item key\n      keySet = { all: false, keys: new Set([itemKey]) };\n    } else {\n      // add to existing selected keys\n      keySet = addKey(selectedKeys, itemKey);\n    }\n  } else if ((event as KeyboardEvent).key !== 'Enter') {\n    // no de-select for enter key\n    if (\n      selectionBehavior === 'toggle' ||\n      event.ctrlKey ||\n      event.metaKey ||\n      (event as KeyboardEvent).key === ' '\n    ) {\n      // de-select only when ctrl/meta key is pressed or selectionBehavior is\n      // explicitly set to toggle\n      keySet = removeKey(selectedKeys, itemKey, isSelectionRequired);\n    } else if (selectionMode === 'multiple' && (selectedKeys.all || selectedKeys.keys.size > 1)) {\n      // in this case everything should be de-selected except for this key\n      keySet = { all: false, keys: new Set([itemKey]) };\n    }\n  }\n\n  // only invoke callback if there is really a change\n  // note onSelectionChange should never be null here\n  if (selectedKeys != keySet && onChange) {\n    onChange({ value: keySet, target: event.target });\n    if (event.type === 'click') {\n      event.stopPropagation();\n    }\n  }\n};\n\n/**\n * Hook for handling various selection mode.  This can be reuse by all Collection components.\n * @param keyExtractor function to extract the key based on provided element\n * @param selectedKeys the currently selected keys\n * @param selectionMode the selection mode\n * @param isSelectionRequired true if empty selected key is not allowed, false otherwise\n * @param selectionBehavior the selection behavior.  If the value is 'toggle', then the key is\n *                          added/removed from the current selected keys.  If the value is 'replace',\n *                          then the current selected keys are cleared first before the key is added\n *                          unless the ctrl/shift/meta key is pressed.\n * @param allowEnterKey whether enter key can be use to change selection.\n * @param onChange callback function that is invoked when selection has changed.\n * @param anchorKey the anchor key.  Usually this is the same as current key except when shift key is pressed.\n * @param currentKey the current key\n * @param getVerticalPrevNextKey function to get the previous/next key in the vertical direction based on the current key\n * @param getHorizontalPrevNextKey function to get the previous/next key in the horizontal direction based on the current key\n * @param scrollToKey function to scroll the item with the key to be visible\n * @param onRangeChange callback function that is invoked when the selection range has changed.\n * @returns an event map that the consumer can register as event listeners\n */\nexport function useSelection<K>(\n  keyExtractor: (element: HTMLElement) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  selectionBehavior: SelectionBehavior,\n  allowEnterKey: boolean,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  anchorKey?: K,\n  currentKey?: K | undefined,\n  getVerticalPrevNextKey?: (currentKey: K | undefined, isPrev: boolean) => () => K | null,\n  getHorizontalPrevNextKey?: (currentKey: K | undefined, isPrev: boolean) => () => K | null,\n  scrollToKey?: (key: K) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) {\n  // ref to track the cursor for the SHIFT+ARROW keyboard selection separately than the anchor of the selection.\n  const keyboardSelectionCursor = useRef<K>();\n\n  const isTouchPointerRef = useRef<boolean>(false);\n\n  const onPointerDown = useCallback(\n    (event: PointerEvent) => {\n      isTouchPointerRef.current = event.pointerType === 'touch';\n    },\n    [isTouchPointerRef]\n  );\n\n  const onClick = useCallback(\n    (event: MouseEvent) => {\n      handleSelect(\n        event,\n        keyExtractor,\n        selectedKeys,\n        selectionMode,\n        isTouchPointerRef.current ? 'toggle' : selectionBehavior,\n        isSelectionRequired,\n        keyboardSelectionCursor,\n        currentKey,\n        onChange,\n        onRangeChange\n      );\n      if (!event.shiftKey) {\n        // reset keyboard cursor when using mouse to select\n        keyboardSelectionCursor.current = undefined;\n      }\n    },\n    [\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      selectionBehavior,\n      isSelectionRequired,\n      keyboardSelectionCursor,\n      currentKey,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  // general keyboard events listen to keyUp for a11y\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      // older browser that we don't support returns 'Spacebar' for space key\n      if (event.key === ' ' || (event.key === 'Enter' && allowEnterKey)) {\n        handleSelect(\n          event,\n          keyExtractor,\n          selectedKeys,\n          selectionMode,\n          selectionBehavior,\n          isSelectionRequired,\n          keyboardSelectionCursor,\n          anchorKey,\n          onChange,\n          event.shiftKey && event.key === ' ' ? onRangeChange : undefined\n        );\n      }\n    },\n    [\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      selectionBehavior,\n      isSelectionRequired,\n      anchorKey,\n      onChange,\n      onRangeChange,\n      allowEnterKey\n    ]\n  );\n\n  const { direction } = useUser();\n\n  // arrowKey events listen to keyDown so they can support holding them down\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // prevent default (propagation) for keyDown to space bar causing container to scroll\n      if (event.key === ' ') {\n        event.preventDefault();\n        return;\n      }\n\n      const key = keyboardSelectionCursor.current || currentKey;\n      const isRtl = direction === 'rtl';\n\n      const keyHandlers: Record<string, (() => K | null) | undefined> = {\n        ArrowUp: getVerticalPrevNextKey?.(key, true),\n        ArrowDown: getVerticalPrevNextKey?.(key, false),\n        ArrowLeft: getHorizontalPrevNextKey?.(key, !isRtl),\n        ArrowRight: getHorizontalPrevNextKey?.(key, isRtl)\n      };\n      const isBothDirections = getVerticalPrevNextKey && getHorizontalPrevNextKey;\n      if (Object.keys(keyHandlers).includes(event.key)) {\n        if (event.shiftKey && scrollToKey && selectionMode === 'multiple') {\n          let keySet = selectedKeys;\n          // on first selection event, set keyboard cursor to start at currentKey\n          if (!keyboardSelectionCursor.current && isKeyDefined(currentKey)) {\n            keySet = { all: false, keys: new Set([currentKey as K]) };\n          }\n          const newAnchorKey = keyHandlers[event.key];\n          const cursorKey = newAnchorKey?.();\n          if (cursorKey != null) {\n            // keep visible\n            scrollToKey(cursorKey);\n\n            // if in 2D, use range selection to extend or subtract\n            if (isBothDirections) {\n              if (onRangeChange && currentKey != null) {\n                onRangeChange({ value: { start: currentKey, end: cursorKey } });\n              }\n            } else {\n              // extend selection\n              if (!containsKey(keySet, cursorKey)) {\n                keySet = addKey(keySet, cursorKey);\n                // subtract from selection\n              } else if (\n                keyboardSelectionCursor.current != null &&\n                keyboardSelectionCursor.current !== cursorKey\n              ) {\n                keySet = removeKey(keySet, keyboardSelectionCursor.current, isSelectionRequired);\n              }\n              if (selectedKeys != keySet && onChange) {\n                onChange({ value: keySet, target: event.target });\n              }\n            }\n            // update selection cursor\n            keyboardSelectionCursor.current = cursorKey;\n          }\n        } else {\n          // reset keyBoard on non-shifted arrow use as this interrupts the extend mode (and would make for messy logic that doesn't align with current Jet behavior)\n          keyboardSelectionCursor.current = undefined;\n        }\n      }\n    },\n    [\n      selectedKeys,\n      isSelectionRequired,\n      onChange,\n      currentKey,\n      getVerticalPrevNextKey,\n      getHorizontalPrevNextKey,\n      scrollToKey,\n      direction,\n      onRangeChange,\n      selectionMode\n    ]\n  );\n\n  const selectionProps =\n    selectionMode === 'none' || onChange == null\n      ? {}\n      : { onPointerDown, onClick, onKeyDown, onKeyUp };\n  return { selectionProps };\n}\n"],"names":["handleSelect","event","keyExtractor","selectedKeys","selectionMode","selectionBehavior","isSelectionRequired","keyboardCursorRef","anchorKey","onChange","onRangeChange","itemKey","target","shiftKey","undefined","isClickEvent","containsKey","isShiftModeSupported","type","value","start","end","current","keySet","key","ctrlKey","metaKey","removeKey","all","keys","size","Set","addKey","stopPropagation","allowEnterKey","currentKey","getVerticalPrevNextKey","getHorizontalPrevNextKey","scrollToKey","keyboardSelectionCursor","useRef","isTouchPointerRef","onPointerDown","useCallback","pointerType","onClick","onKeyUp","direction","useUser","onKeyDown","preventDefault","isRtl","keyHandlers","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","isBothDirections","Object","includes","isKeyDefined","newAnchorKey","cursorKey","selectionProps"],"mappings":"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"}