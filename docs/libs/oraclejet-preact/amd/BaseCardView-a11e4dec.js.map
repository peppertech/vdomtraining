{"version":3,"file":"BaseCardView-a11e4dec.js","sources":["../../src/PRIVATE_BaseCardView/BaseCardViewReorderableItem.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewItem.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewLayout.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewSkeletonContainer.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewSkeleton.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewUtils.ts","../../src/PRIVATE_BaseCardView/BaseCardView.tsx","../../src/PRIVATE_BaseCardView/useCardViewReorder.ts"],"sourcesContent":["import { useRef, useCallback } from 'preact/hooks';\nimport { useReorderableItem } from '../hooks/PRIVATE_useReorderable';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { ITEM_SELECTOR } from '../utils/PRIVATE_collectionUtils';\nimport { ListItemRendererContext } from '../UNSAFE_Collection';\nimport { ReorderableItemProps } from '../UNSAFE_Collection/Reorderable.types';\nimport { multiVariantStyles, styles } from './themes/BaseCardViewStyles.css';\nimport { GutterSize } from './BaseCardViewUtils';\n\nexport type BaseCardViewReorderableItemProps<K> = ReorderableItemProps<K> & {\n  currentKey: K | undefined;\n  gutterSize: GutterSize;\n  columns: number;\n};\n\n/**\n * The internal component used to render a reorderable item in CardView.\n */\nexport function BaseCardViewReorderableItem<K extends string | number, D>({\n  currentKey,\n  children,\n  dragKey,\n  setDragKey,\n  onReorder,\n  rootRef,\n  gutterSize,\n  columns,\n  context\n}: BaseCardViewReorderableItemProps<K> & { context: ListItemRendererContext<K, D> }) {\n  const itemRef = useRef<HTMLDivElement | null>(null);\n  const isOneColumn = columns === 1;\n  const isFirstColumn = context.index % columns === 0;\n  const isLastColumn = context.index % columns === columns - 1;\n  const variantClasses = multiVariantStyles({\n    itemOverlayFront: gutterSize\n  });\n  const variantClassesVertical = multiVariantStyles({\n    itemOverlayFrontVertical: gutterSize\n  });\n  const itemStyles = {\n    itemOverlayFront: isOneColumn ? variantClassesVertical : variantClasses,\n    itemOverlayRear: isOneColumn ? styles.itemOverlayRearVertical : styles.itemOverlayRear,\n    itemDragger: styles.itemDragger\n  };\n  const getItem = useCallback(() => itemRef?.current?.closest(ITEM_SELECTOR) as HTMLElement, []);\n  const setTransferData = useCallback(\n    (event: DragEvent) => {\n      event.dataTransfer?.setData('text/cardview-items-key', JSON.stringify(context.metadata.key));\n    },\n    [context.metadata.key]\n  );\n  const { rootProps, isDragged, overlayZoneBeforeProps, overlayZoneAfterProps } =\n    useReorderableItem({\n      currentKey,\n      isDisabled: onReorder ? false : true,\n      draggable: onReorder ? true : false,\n      dragKey,\n      setDragKey,\n      onReorder,\n      rootRef,\n      ref: itemRef,\n      getItem,\n      setTransferData,\n      itemStyles,\n      itemSelector: ITEM_SELECTOR,\n      isVertical: isOneColumn\n    });\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const overlayZoneBeforeClass = classNames([\n    overlayZoneBeforeProps?.class,\n    !isOneColumn && !isRtl && isFirstColumn && styles.itemOverlayFrontEdge,\n    !isOneColumn && isRtl && isLastColumn && styles.itemOverlayFrontEdge\n  ]);\n\n  const overlayZoneAfterClass = classNames([\n    overlayZoneAfterProps?.class,\n    !isOneColumn && !isRtl && isLastColumn && styles.itemOverlayRearEdge,\n    !isOneColumn && isRtl && isFirstColumn && styles.itemOverlayRearEdge\n  ]);\n\n  return (\n    <div {...rootProps} draggable={false}>\n      {children}\n      {!isDragged && dragKey && (\n        <>\n          <div {...overlayZoneBeforeProps} class={overlayZoneBeforeClass}></div>\n          <div {...overlayZoneAfterProps} class={overlayZoneAfterClass}></div>\n        </>\n      )}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { memo } from 'preact/compat';\nimport {\n  useRef,\n  useCallback,\n  useLayoutEffect,\n  useMemo,\n  useEffect,\n  StateUpdater,\n  Dispatch,\n  MutableRef\n} from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { warn } from '../utils/UNSAFE_logger';\nimport { allTabbableElements } from '../utils/PRIVATE_tabbableUtils';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useAnimation, UseAnimationConfig } from '../hooks/UNSAFE_useAnimation';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { SelectionMode, ListItemRendererContext } from '../UNSAFE_Collection';\nimport { multiVariantStyles, styles } from './themes/BaseCardViewStyles.css';\nimport { compareListItemContext } from '../utils/PRIVATE_collectionUtils';\nimport {\n  BaseCardViewReorderableItem,\n  BaseCardViewReorderableItemProps\n} from './BaseCardViewReorderableItem';\n\n/**\n * Props for the BaseCardViewItem Component\n */\nexport type Props<K, D> = {\n  children: (context: ListItemRendererContext<K, D>) => ComponentChildren;\n  context: ListItemRendererContext<K, D>;\n  isTabbable: boolean;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isSelected: boolean;\n  selectionMode: SelectionMode;\n  focusBehavior: 'card' | 'content';\n  setIsFocusBehaviorValid?: Dispatch<StateUpdater<boolean>>;\n  initialAnimation?: 'slideUp' | 'slideDown';\n  isGridLayout?: boolean;\n  updateCardSize?: (width: number, height: number) => void;\n} & {\n  reorderItemProps?: Omit<BaseCardViewReorderableItemProps<K>, 'children'>;\n};\n\n/**\n * The internal component used to render a single item in CardView.\n */\nexport function BaseCardViewItem<K extends string | number, D>({\n  children,\n  context,\n  isTabbable,\n  isFocused,\n  isFocusRingVisible,\n  isSelected,\n  selectionMode,\n  focusBehavior,\n  setIsFocusBehaviorValid,\n  initialAnimation,\n  isGridLayout,\n  updateCardSize,\n  reorderItemProps\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const itemKey = context.metadata.key;\n  const itemIndex = context.index;\n\n  const isItemFocused = isFocused && isFocusRingVisible;\n  const variantClasses = multiVariantStyles({\n    itemFocused: focusBehavior === 'card' && isItemFocused ? 'isItemFocused' : 'isNotItemFocused',\n    itemInitialOpacity: initialAnimation ? 'isTransparent' : 'isNotTransparent',\n    itemInGridLayout: isGridLayout ? 'isInGridLayout' : 'isNotInGridLayout'\n  });\n  const classes = classNames([styles.itemStyle, variantClasses]);\n\n  /*********************************** Tabbable Mode ***********************************/\n\n  // don't bubble Arrow Up/Down/Left/Right events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (\n      focusBehavior === 'card' &&\n      isTabbable &&\n      (event.key === 'ArrowDown' ||\n        event.key === 'ArrowUp' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight')\n    ) {\n      event.stopPropagation();\n    }\n  };\n\n  /************************************ Card Size ************************************/\n\n  const handleResize = useCallback(\n    (entry: ResizeObserverEntry) => {\n      updateCardSize?.(entry.contentRect.width, entry.contentRect.height);\n    },\n    [updateCardSize]\n  );\n\n  const nullRef = useRef<HTMLDivElement>(null);\n  useResizeObserver(updateCardSize ? rootRef : nullRef, handleResize);\n\n  /********************************* Focus Behavior *********************************/\n\n  useLayoutEffect(() => {\n    if (focusBehavior === 'content' && isItemFocused) {\n      // rootRef is cardview item, its first child is the focus trap div, so its first grand child\n      // is the actual content\n      const content = rootRef.current?.firstElementChild?.firstElementChild as HTMLElement;\n      const focusable = allTabbableElements(content, true, true);\n      if (focusable.length === 0 || focusable.length > 1) {\n        warn(\n          `${focusable.length} focusable elements are detected in the card. 'content' focusBehavior is intended only for use when the card has single focusable element. Please specify one focusable element in the card or switch the focusBehavior to 'card'.`\n        );\n        setIsFocusBehaviorValid?.(false);\n      } else {\n        focusable[0].focus();\n      }\n    }\n  }, [focusBehavior, isItemFocused, setIsFocusBehaviorValid]);\n\n  /******************************** Initial Animation ********************************/\n\n  // animation for slide up/down\n  const { nodeRef: nodeRefSlide, controller: controllerSlide } = useAnimation<\n    'slideUp' | 'slideDown' | 'none',\n    HTMLDivElement\n  >(initialAnimation || 'none', animationConfigSlide(itemIndex));\n\n  // animation for opacity change\n  const { nodeRef: nodeRefOpacity, controller: controllerOpacity } = useAnimation<\n    'opacity' | 'none',\n    HTMLDivElement\n  >((initialAnimation && 'opacity') || 'none', animationConfigOpacity(itemIndex, timeoutRef));\n\n  // max cap for animation is 1s\n  useEffect(() => {\n    if (initialAnimation !== undefined) {\n      timeoutRef.current = setTimeout(() => {\n        controllerSlide.cancel();\n        controllerOpacity.cancel();\n        if (rootRef.current) {\n          rootRef.current.style.opacity = '1';\n        }\n      }, 1000);\n    }\n  }, [controllerOpacity, controllerSlide, initialAnimation]);\n\n  // TODO: issue track in JET-57681, we currently have two useAnimation() because the opacity and\n  // slide up/down have different durations, and the current API couldn't handle this case, we will\n  // update this once the API is updated\n\n  /********************************** Child Component **********************************/\n\n  const itemRefs = useMemo(() => {\n    // NOTE: spot an issue when we click the cards during animation is processing, the cards would not finish\n    // the current animations and stay as what it is, e.g. leave itself as half transparent.\n    // need to remove nodeRefSlide and nodeRefOpacity to avoid this issue.\n    if (initialAnimation === undefined) {\n      return mergeRefs(rootRef);\n    }\n    return mergeRefs(rootRef, nodeRefSlide, nodeRefOpacity);\n  }, [rootRef, nodeRefSlide, nodeRefOpacity, initialAnimation]);\n\n  const childrenComponent = reorderItemProps ? (\n    <BaseCardViewReorderableItem {...reorderItemProps} context={context}>\n      {children(context)}\n    </BaseCardViewReorderableItem>\n  ) : (\n    children(context)\n  );\n\n  return (\n    <div\n      id={useId()}\n      ref={itemRefs}\n      class={classes}\n      role=\"gridcell\"\n      data-oj-key={itemKey}\n      onKeyDown={handleKeyDown}\n      aria-selected={selectionMode === 'none' ? undefined : isSelected}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n          {childrenComponent}\n        </FocusTrap>\n      </TabbableModeContext.Provider>\n    </div>\n  );\n}\n\nconst animationConfigSlide = (\n  index: number\n): UseAnimationConfig<'slideUp' | 'slideDown' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      slideUp: {\n        from: {\n          translateY: '50px'\n        },\n        to: {\n          translateY: '0px'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      },\n      slideDown: {\n        from: {\n          translateY: '-50px'\n        },\n        to: {\n          translateY: '0'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      }\n    },\n    isAnimatedOnMount: true\n  };\n};\n\nconst animationConfigOpacity = (\n  index: number,\n  timeoutRef: MutableRef<ReturnType<typeof setTimeout> | undefined>\n): UseAnimationConfig<'opacity' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      opacity: {\n        from: {\n          opacity: 0\n        },\n        to: {\n          opacity: 1\n        },\n        options: {\n          duration: 150,\n          delay: index * 50,\n          easing: 'linear'\n        }\n      }\n    },\n    isAnimatedOnMount: true,\n    onAnimationEnd: () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    }\n  };\n};\n\n/**\n * Compare the equality between two reorderItemProps, especially useful for memoized items\n */\nconst compareReorderItemProps = <K, D>(\n  props1: Props<K, D>['reorderItemProps'],\n  props2: Props<K, D>['reorderItemProps']\n) => {\n  return (\n    props1?.['currentKey'] === props2?.['currentKey'] &&\n    props1?.['dragKey'] === props2?.['dragKey'] &&\n    props1?.['columns'] === props2?.['columns']\n  );\n};\n\nexport const MemoizeBaseCardViewItem = memo(\n  BaseCardViewItem,\n  <K, D>(prev: Props<K, D>, next: Props<K, D>) => {\n    if (prev && next) {\n      return (\n        prev.children === next.children &&\n        prev.isTabbable === next.isTabbable &&\n        prev.isFocused === next.isFocused &&\n        prev.isFocusRingVisible === next.isFocusRingVisible &&\n        prev.isSelected === next.isSelected &&\n        prev.initialAnimation === next.initialAnimation &&\n        prev.focusBehavior === next.focusBehavior &&\n        compareListItemContext(prev.context, next.context) &&\n        compareReorderItemProps(prev.reorderItemProps, next.reorderItemProps)\n      );\n    }\n    return false;\n  }\n);\n","import { ComponentChildren } from 'preact';\nimport { Grid } from '../UNSAFE_Grid';\nimport { Flex } from '../UNSAFE_Flex';\nimport { GutterSize } from './BaseCardViewUtils';\nimport { cardViewVars } from './themes/BaseCardViewContract.css';\n\ntype Props = {\n  children: ComponentChildren;\n  layout: 'grid' | 'flex';\n  gutterSize: GutterSize;\n  columns: number;\n};\n\nexport function BaseCardViewLayout({ children, layout, gutterSize, columns }: Props) {\n  const gap = cardViewVars.gutterSize[gutterSize];\n  if (layout === 'grid') {\n    return columns < 1 ? null : (\n      <Grid gridTemplateColumns={`repeat(${columns}, 1fr)`} gap={gap}>\n        {children}\n      </Grid>\n    );\n  } else {\n    return (\n      <Flex wrap=\"wrap\" gap={gap}>\n        {children}\n      </Flex>\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, Fragment } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\n\ntype Props = {\n  /**\n   * Allows to pass skeletons\n   **/\n  children: ComponentChildren;\n};\n\n/**\n * Allows to specify the time delay for rendering the component\n **/\nconst timerValue = 50;\n\n/**\n * BaseCardViewSkeletonContainer renders skeletons after 50ms threshold defined in the Redwood spec\n **/\nexport function BaseCardViewSkeletonContainer({ children }: Props) {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsVisible(true);\n    }, timerValue);\n  }, []);\n\n  return isVisible ? <Fragment>{children}</Fragment> : <div class={LOADMORE_STYLE_CLASS}></div>;\n}\n","import { Size } from '../utils/UNSAFE_size';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { BaseCardViewSkeletonContainer } from './BaseCardViewSkeletonContainer';\n\n// these are arbitrary values by now, might update them with definite values in the future\nconst DEFAULT_SKELETON_NUMBER = 25;\nconst DEFAULT_SKELETON_WIDTH = '60x';\nconst DEFAULT_SKELETON_HEIGHT = '70x';\n\ntype SkeletonProps = {\n  layout: 'flex' | 'grid';\n  colCount: number;\n  totalCount: number;\n  cardWidth?: number;\n  cardHeight?: number;\n};\n\n/**\n * A function that returns an array of skeletons based on count\n * @param count the number of skeletons\n */\nconst getSkeletonsByCount = (\n  layout: 'flex' | 'grid',\n  count = DEFAULT_SKELETON_NUMBER,\n  width?: Size,\n  height?: Size,\n  isUnique = true\n) => {\n  const sw = width || (layout === 'flex' ? DEFAULT_SKELETON_WIDTH : '100%');\n  const sh = height || DEFAULT_SKELETON_HEIGHT;\n\n  return [...Array(count)].map((_v, i) => (\n    // create unique keys if needed, otherwise the animations won't start at the same time, because the old copy of skeletons\n    // could be reused, even the key is specified by useId(), combine count with time to make the key unique.\n    <Skeleton key={isUnique && `${i}${new Date().getTime()}`} width={sw} height={sh} />\n  ));\n};\n\n/**\n * When there is no data (i.e. data is an empty array or null, and hasMore is false), we will show 25 card skeletons with default size\n */\nexport const InitialLoadSkeletons = (props: { layout: SkeletonProps['layout'] }) => (\n  <BaseCardViewSkeletonContainer>{getSkeletonsByCount(props.layout)}</BaseCardViewSkeletonContainer>\n);\n\n/**\n * When we are fetching the initial data (i.e. data is an empty array, and hasMore is true), we will show 25 card skeletons with default size,\n * because we don't know the card dimension at this time. Since there is more data to load, we will specify LOADMORE_STYLE_CLASS on skeletons\n */\nexport const DefaultLoadMoreSkeletons = (props: { layout: SkeletonProps['layout'] }) => {\n  const firstSkeleton = (\n    <div class={LOADMORE_STYLE_CLASS}>{getSkeletonsByCount(props.layout, 1)}</div>\n  );\n  const otherSkeletons = getSkeletonsByCount(props.layout, DEFAULT_SKELETON_NUMBER - 1);\n  const skeletons = [firstSkeleton, ...otherSkeletons];\n  return <BaseCardViewSkeletonContainer>{skeletons}</BaseCardViewSkeletonContainer>;\n};\n\n/**\n * During the render that we measure and update card dimension, we will hide skeletons temporarily\n * to avoid showing incorrect skeletons\n */\nconst InvisibleSkeletons = () => {\n  return <div class={LOADMORE_STYLE_CLASS}></div>;\n};\n\nexport const LoadMoreSkeletons = (props: SkeletonProps) => {\n  if (props.colCount < 1 || props.cardWidth == null || props.cardHeight == null) {\n    // if column count / card width / card height are invalid, we will show the invisible skeletons\n    return <InvisibleSkeletons />;\n  } else {\n    // after initial renders, show skeletons with correct dimension and count\n    const skeletons = [];\n\n    const firstRowColCount = props.colCount - (props.totalCount % props.colCount);\n    const isOnlyOneRow = firstRowColCount === props.colCount;\n\n    const cardWidth = `calc(${props.cardWidth}px)` as Size;\n    const cardHeight = props.cardHeight\n      ? (`calc(${props.cardHeight}px)` as Size)\n      : DEFAULT_SKELETON_HEIGHT;\n\n    const width: Size = props.layout === 'flex' ? cardWidth : '100%';\n    const height: Size = props.layout === 'flex' || isOnlyOneRow ? cardHeight : '100%';\n\n    // first row\n    const firstSkeleton = (\n      <div class={LOADMORE_STYLE_CLASS}>{getSkeletonsByCount(props.layout, 1, width, height)}</div>\n    );\n    skeletons.push(firstSkeleton);\n    skeletons.push(getSkeletonsByCount(props.layout, firstRowColCount - 1, width, height));\n\n    // second row\n    if (!isOnlyOneRow) {\n      skeletons.push(getSkeletonsByCount(props.layout, props.colCount, width, cardHeight));\n    }\n\n    return <BaseCardViewSkeletonContainer>{skeletons}</BaseCardViewSkeletonContainer>;\n  }\n};\n","import { Size } from '../utils/UNSAFE_size';\n\nexport const emptyKeys = { all: false, keys: new Set() };\nexport type GutterSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n\n/**\n * A mapping of gutterSize to concrete size in pixels\n */\nexport const gutterSizeToPX: Record<string, number> = {\n  xs: 12,\n  sm: 16,\n  md: 24,\n  lg: 48,\n  xl: 64\n};\n\nexport const getGapSize = (gutterSize?: GutterSize) => {\n  const px = gutterSizeToPX[gutterSize || 'sm'];\n  const gap = `${px / 4}x` as Size;\n  return gap;\n};\n\nexport const getColCount = (gapWidth: number, cardWidth?: number, rootWidth?: number) => {\n  if (!cardWidth || !rootWidth) return 0;\n\n  // if we have n cards, we have n-1 gaps\n  const colCount = Math.floor((rootWidth + gapWidth) / (gapWidth + cardWidth));\n  return Math.max(1, colCount);\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment } from 'preact';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { useRef, useCallback, useEffect, useState, useImperativeHandle } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport {\n  getPrevNextKeyByCount,\n  getFirstVisibleKey,\n  getViewportConfig,\n  findElementByKey,\n  keyExtractor,\n  handleSelectionRange,\n  ITEM_SELECTOR\n} from '../utils/PRIVATE_collectionUtils';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { useSelection, SelectionRangeDetail } from '../hooks/PRIVATE_useSelection';\nimport { ReorderableContext } from '../hooks/PRIVATE_useReorderable';\nimport { ItemContext, ListItemRendererContext, SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { HiddenAccessible } from '../UNSAFE_HiddenAccessible';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { styles } from './themes/BaseCardViewStyles.css';\nimport { Props } from '../UNSAFE_CardFlexView';\nimport { MemoizeBaseCardViewItem } from './BaseCardViewItem';\nimport { BaseCardViewLayout } from './BaseCardViewLayout';\nimport {\n  DefaultLoadMoreSkeletons,\n  LoadMoreSkeletons,\n  InitialLoadSkeletons\n} from './BaseCardViewSkeleton';\nimport { gutterSizeToPX, emptyKeys } from './BaseCardViewUtils';\nimport { useCardViewReorder } from './useCardViewReorder';\n// TODO: add this import due to issue JET-67485, need to update once Stable is introduced\nimport './themes/redwood/BaseCardViewBaseTheme.css';\n\n/**\n * Props specific for the GradGridBaseImpl Component\n */\ntype BaseCardViewImplProps<K, D> = Props<K, D> & {\n  /**\n   * Provide the number of columns to render;\n   */\n  columns: number;\n  /**\n   * The layout of the BaseCardView. When we use CardGridView as parent, we will use grid layout;\n   * when we use CardFlexView as parent, we will use flex layout.\n   */\n  layout: 'grid' | 'flex';\n  /**\n   * Card dimension, including width and height\n   */\n  cardSize: { width?: number; height?: number };\n  /**\n   * A callback function to update card dimension, including width and height\n   */\n  updateCardSize: (width: number, height: number) => void;\n};\n\nconst BaseCardViewImpl = forwardRef(\n  <K extends string | number, D>(\n    {\n      children,\n      data,\n      onLoadMore = () => {},\n      hasMore = false,\n      getRowKey,\n      currentKey,\n      onCurrentKeyChange,\n      selectionMode = 'none',\n      selectedKeys = emptyKeys as Keys<K>,\n      onSelectionChange,\n      onReorder,\n      viewportConfig,\n      focusBehavior = 'card',\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      initialAnimation = 'slideUp',\n      gutterSize = 'sm',\n      columns,\n      layout,\n      cardSize,\n      updateCardSize\n    }: BaseCardViewImplProps<K, D>,\n    ref?: ForwardedRef<HTMLDivElement>\n  ) => {\n    const rootRef = useRef<HTMLDivElement>(null);\n    useImperativeHandle(ref!, () => rootRef.current!, [rootRef]);\n\n    // tracking the anchor key which is used for shift+click selection\n    const anchorKey = useRef<K | undefined>();\n    // tracking pending current key in pointer down event\n    const pendingCurrentKey = useRef<K>();\n\n    const gutterSizePX = gutterSizeToPX[gutterSize];\n    const layoutProps = { layout, columns, gutterSize };\n    const isInitialAnimation = useRef(true);\n    useEffect(() => {\n      if (cardSize.height != undefined && cardSize.width != undefined) {\n        isInitialAnimation.current = false;\n      }\n    }, [cardSize]);\n\n    const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n    const ariaRowcount = hasMore || !data || columns < 1 ? -1 : Math.ceil(data?.length / columns);\n    const ariaColcount = columns < 1 ? -1 : columns;\n\n    const [isFocusBehaviorValid, setIsFocusBehaviorValid] = useState(true);\n    const validFocusBehavior = isFocusBehaviorValid ? focusBehavior : 'card';\n\n    // ensure current item is scrolled into view when current item is updated\n    // during reordering, enable that during keyboard reordering, disable that during mouse reordering\n    const scrollCurrItemIntoView = useRef(false);\n    const isReorderEnabled = onReorder != undefined;\n\n    const isFetching = useRef(false);\n\n    /*****************************************************************************************/\n    /************************************* Tabbable Mode *************************************/\n    /*****************************************************************************************/\n\n    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n      rootRef,\n      (element) => {\n        return keyExtractor(element, ITEM_SELECTOR) as K;\n      },\n      currentKey,\n      onCurrentKeyChange\n    );\n\n    /*****************************************************************************************/\n    /********************************* Current Key and Focus *********************************/\n    /*****************************************************************************************/\n\n    const { currentKeyProps } = useCurrentKey(\n      (element) => keyExtractor(element, ITEM_SELECTOR),\n      selectionMode !== 'multiple',\n      // init a function every time to make sure we pass in the latest columns,\n      // otherwise the new key might be wrong after resize\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, -columns),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, columns),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, -1),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, 1),\n      currentKey,\n      onCurrentKeyChange\n    );\n\n    const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n      'ArrowUp',\n      'ArrowDown',\n      'ArrowLeft',\n      'ArrowRight'\n    ]);\n\n    const handleFocus = () => {\n      // handle initial focus\n      if (\n        !isKeyDefined(currentKey) &&\n        onCurrentKeyChange &&\n        isCurrentTabbableKey(undefined) &&\n        rootRef.current\n      ) {\n        const firstKey =\n          pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n        if (isKeyDefined(firstKey)) {\n          onCurrentKeyChange({ value: firstKey });\n        }\n      } else if (isKeyDefined(currentKey) && rootRef.current) {\n        // if currentKey is defined, make sure scroll the current item into view when cardview regains focus\n        const elem = findElementByKey(rootRef.current, currentKey as K, ITEM_SELECTOR);\n        elem?.scrollIntoView({ block: 'nearest' });\n      }\n    };\n\n    // need to track pointer down element to set currentItem when initial focus happens\n    const handlePointerDown = (event: PointerEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (isKeyDefined(key)) {\n        pendingCurrentKey.current = key as K;\n      }\n    };\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      // for content focusBehavior, when users tab out, we need to focus back to card grid, to ensure\n      // the tabbing order works properly, otherwise the focus might get stuck at the current item\n      if (validFocusBehavior === 'content' && event.key === 'Tab') {\n        rootRef.current?.focus({ preventScroll: true });\n      }\n      // during keyboard reordering, the current item should be scrolled into view\n      const keyHandlers = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n      if (\n        isReorderEnabled &&\n        (event.metaKey || event.ctrlKey) &&\n        event.shiftKey &&\n        keyHandlers.includes(event.key)\n      ) {\n        scrollCurrItemIntoView.current = true;\n      }\n    };\n\n    useEffect(() => {\n      if (currentKey != null && rootRef.current) {\n        const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n        if (elem) {\n          // only update aria-activedescendant for screen reader in default focusBehavior\n          if (validFocusBehavior === 'card') {\n            const cell = elem.closest(`[role=gridcell]`);\n            const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n            if (cell && activeDescendant !== cell.id) {\n              rootRef.current.setAttribute('aria-activedescendant', cell.id);\n              scrollCurrItemIntoView.current = true;\n            }\n          }\n          // make sure current item is visible\n          if (scrollCurrItemIntoView.current) {\n            elem.scrollIntoView({ block: 'nearest' });\n            scrollCurrItemIntoView.current = false;\n          }\n        }\n      }\n      // listen to data because the current item would re-render when data is updated, i.e. the id\n      // of current item would be updated, so the currentKey itself couldn't guarantee the root has\n      // the latest aria-activedescendant\n    }, [currentKey, data, validFocusBehavior, isReorderEnabled]);\n\n    /*****************************************************************************************/\n    /*************************************** Selection ***************************************/\n    /*****************************************************************************************/\n\n    const handleSelectionChange = useCallback(\n      (detail: SelectionDetail<K>) => {\n        if (onSelectionChange) {\n          if (detail.value.all === false && detail.value.keys.size > 0) {\n            // during regular selection, the last key selected by a user gesture is the anchor key\n            anchorKey.current = Array.from(detail.value.keys.values()).pop();\n          }\n          onSelectionChange(detail);\n        }\n      },\n      [anchorKey, onSelectionChange]\n    );\n\n    const handleSelectionRangeChange = useCallback(\n      (detail: SelectionRangeDetail<K>) => {\n        if (data && onSelectionChange) {\n          const value = handleSelectionRange(detail, data, getRowKey);\n          // for non-virtualized CardView, value should always be an array\n          if (Array.isArray(value)) {\n            if (detail.eventType === 'shiftSpace') {\n              // during range selection by shift+space, the first key selected by a user gesture is the anchor key\n              anchorKey.current = detail.value.start;\n            } else {\n              // during range selection by shift+click/arrow keys, the last key selected by a user gesture is the anchor key\n              anchorKey.current = detail.value.end;\n            }\n            onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n          }\n        }\n      },\n      [data, onSelectionChange, getRowKey]\n    );\n\n    const { selectionProps } = useSelection(\n      (element: HTMLElement) => {\n        if (element === rootRef.current) {\n          return currentKey === undefined ? null : currentKey;\n        }\n        return keyExtractor(element, ITEM_SELECTOR) as K;\n      },\n      selectedKeys,\n      selectionMode,\n      false,\n      'toggle',\n      false,\n      handleSelectionChange,\n      anchorKey.current,\n      currentKey,\n      (currentKey: K | undefined, isPrev: boolean) => () =>\n        getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -columns : columns),\n      (currentKey: K | undefined, isPrev: boolean) => () =>\n        getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -1 : 1),\n      (key: K) => {\n        if (rootRef.current) {\n          const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n          if (elem) {\n            elem.scrollIntoView({ block: 'nearest' });\n          }\n        }\n      },\n      handleSelectionRangeChange\n    );\n\n    /*****************************************************************************************/\n    /**************************************** Reorder ****************************************/\n    /*****************************************************************************************/\n\n    const {\n      reorderProps,\n      reorderItemProps,\n      reorderContext,\n      reorderInstructionsId,\n      reorderInstructions\n    } = useCardViewReorder({\n      currentKey,\n      onReorder,\n      gutterSize,\n      columns,\n      rootRef,\n      scrollCurrItemIntoView\n    });\n\n    const reorderAcc = isReorderEnabled && (\n      <>\n        <span id={reorderInstructionsId}>\n          <HiddenAccessible>{reorderInstructions}</HiddenAccessible>\n        </span>\n      </>\n    );\n\n    /*****************************************************************************************/\n    /************************************* Load More *****************************************/\n    /*****************************************************************************************/\n\n    const handleLoadMore = useCallback(() => {\n      // check isFetching to avoid multiple load more at the same time (details in JET-61117)\n      if (!isFetching.current) {\n        isFetching.current = true;\n        onLoadMore();\n      }\n    }, [isFetching, onLoadMore]);\n\n    useEffect(() => {\n      isFetching.current = false;\n      // listen to data and hasMore because when one of them gets updated, the fetching is done\n    }, [data, hasMore]);\n\n    /*****************************************************************************************/\n    /************************************ Child Component ************************************/\n    /*****************************************************************************************/\n\n    const getItemContext = useCallback(\n      (context: ItemContext<D>) => {\n        const key = getRowKey(context.data);\n        const selectorRenderer =\n          selectionMode === 'multiple'\n            ? () => (\n                <Selector\n                  onChange={onSelectionChange}\n                  rowKey={key}\n                  selectedKeys={selectedKeys}></Selector>\n              )\n            : undefined;\n\n        return {\n          index: context.index,\n          data: context.data,\n          metadata: { key: key },\n          selector: selectorRenderer,\n          isSelected: containsKey(selectedKeys, key)\n        };\n      },\n      [selectionMode, selectedKeys, onSelectionChange, getRowKey]\n    );\n\n    const childrenComponent = (context: ItemContext<D>) => {\n      const cardItemContext = getItemContext(context);\n      const isTabbable = isCurrentTabbableKey(cardItemContext.metadata.key);\n      const isFocused = currentKey === cardItemContext.metadata.key && !isTabbable;\n      const isFocusRingVisible = isFocused && showFocusRing;\n      const isSelected = cardItemContext.isSelected;\n      const itemRenderFunc = (context: ListItemRendererContext<K, D>) => (\n        <MemoizeBaseCardViewItem\n          key={cardItemContext.metadata.key}\n          context={context}\n          isTabbable={isTabbable}\n          isFocused={isFocused}\n          isFocusRingVisible={isFocusRingVisible}\n          isGridLayout={layout === 'grid'}\n          isSelected={isSelected}\n          selectionMode={selectionMode}\n          focusBehavior={validFocusBehavior}\n          {...(focusBehavior === 'content' && { setIsFocusBehaviorValid })}\n          {...(isInitialAnimation.current && { initialAnimation })}\n          {...(cardItemContext.index === 0 && !cardSize.width && { updateCardSize })}\n          {...(isReorderEnabled && { reorderItemProps })}>\n          {children}\n        </MemoizeBaseCardViewItem>\n      );\n      return itemRenderFunc(cardItemContext);\n    };\n\n    // todo: issue track in JET-57952, need a way to show the skeletons in keyboard navigation\n    const skeletons =\n      data && !data.length && hasMore ? (\n        <DefaultLoadMoreSkeletons layout={layout} />\n      ) : (\n        <LoadMoreSkeletons\n          layout={layout}\n          colCount={columns}\n          totalCount={data?.length || 0}\n          cardWidth={cardSize.width}\n          cardHeight={cardSize.height}\n        />\n      );\n\n    viewportConfig = getViewportConfig(rootRef, viewportConfig);\n    const collectionComponent = (\n      <div role=\"row\">\n        <BaseCardViewLayout {...layoutProps}>\n          <LoadMoreCollection\n            data={data}\n            hasMore={hasMore}\n            onLoadMore={handleLoadMore}\n            loadMoreIndicator={skeletons}\n            loadMoreThreshold={gutterSizePX + 4} // gap size + padding\n            viewportConfig={viewportConfig}>\n            {childrenComponent}\n          </LoadMoreCollection>\n        </BaseCardViewLayout>\n      </div>\n    );\n\n    const initialLoadSkeletons = (\n      <BaseCardViewLayout {...layoutProps}>\n        <InitialLoadSkeletons layout={layout} />\n      </BaseCardViewLayout>\n    );\n\n    return (\n      <div\n        {...mergeProps(\n          currentKeyProps,\n          focusRingProps,\n          selectionProps,\n          reorderProps,\n          {\n            onFocus: handleFocus,\n            onPointerDown: handlePointerDown,\n            onKeyDown: handleKeyDown\n          },\n          // only enable tabbable mode in default focusBehavior\n          { ...(validFocusBehavior === 'card' && tabbableModeProps) }\n        )}\n        ref={rootRef}\n        role=\"grid\"\n        class={styles.baseStyle}\n        tabIndex={0}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-multiselectable={ariaMultiSelectable}\n        aria-rowcount={ariaRowcount}\n        aria-colcount={ariaColcount}>\n        <ReorderableContext.Provider value={reorderContext}>\n          {!data ? (\n            initialLoadSkeletons\n          ) : data.length || hasMore ? (\n            collectionComponent\n          ) : (\n            <Fragment />\n          )}\n        </ReorderableContext.Provider>\n        {reorderAcc}\n      </div>\n    );\n  }\n);\n\n/**\n * Props specific for the BaseCardView\n */\ntype BaseCardViewProps<K, D> = BaseCardViewImplProps<K, D> & {\n  ref?: ForwardedRef<HTMLDivElement>;\n};\n\n/**\n * Cast BaseCardViewImpl to generic type, because BaseCardViewImpl would infer the generic type to specific type,\n * i.e infer <K extends string | number, D> to <string | number, unknown>, which will cause type issues in the parent component\n */\nexport const BaseCardView = BaseCardViewImpl as <K extends string | number, D>(\n  props: BaseCardViewProps<K, D>\n) => JSX.Element;\n","import { RefObject } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { ITEM_SELECTOR, dragToScroll } from '../utils/PRIVATE_collectionUtils';\nimport { useReorderable } from '../hooks/PRIVATE_useReorderable';\nimport { Props } from '../UNSAFE_CardFlexView';\nimport { GutterSize } from './BaseCardViewUtils';\n\ntype useCardViewReorderProps<K, D> = Pick<Props<K, D>, 'currentKey' | 'onReorder'> & {\n  gutterSize: GutterSize;\n  columns: number;\n  rootRef: RefObject<HTMLDivElement>;\n  scrollCurrItemIntoView: RefObject<boolean>;\n};\n\nexport const useCardViewReorder = <K extends string | number, D>({\n  currentKey,\n  onReorder,\n  gutterSize,\n  columns,\n  rootRef,\n  scrollCurrItemIntoView\n}: useCardViewReorderProps<K, D>) => {\n  const isReorderEnabled = onReorder != undefined;\n\n  const [dragKey, setDragKey] = useState<K | undefined>(undefined);\n  const { reorderProps, reorderContext, reorderInstructionsId, reorderInstructions } =\n    useReorderable({\n      onReorder,\n      rootRef,\n      itemSelector: ITEM_SELECTOR,\n      isDisabled: !isReorderEnabled,\n      columns\n    });\n\n  if (!isReorderEnabled) {\n    return {\n      reorderProps,\n      reorderContext,\n      reorderInstructionsId,\n      reorderInstructions\n    } as const;\n  }\n\n  const handleDragOver = (event: DragEvent) => {\n    dragToScroll(event, dragKey !== undefined, rootRef.current);\n    // during mouse reordering, the drag item might not be the same as current item,\n    // so we should disallow current item scroll into view\n    scrollCurrItemIntoView.current = false;\n  };\n\n  const reorderEventProps = { ...reorderProps, onDragOver: handleDragOver };\n\n  const reorderItemProps = {\n    currentKey,\n    dragKey,\n    setDragKey,\n    onReorder,\n    rootRef,\n    gutterSize,\n    columns\n  };\n\n  return {\n    reorderProps: reorderEventProps,\n    reorderItemProps,\n    reorderContext,\n    reorderInstructionsId,\n    reorderInstructions\n  } as const;\n};\n"],"names":["BaseCardViewReorderableItem","currentKey","children","dragKey","setDragKey","onReorder","rootRef","gutterSize","columns","context","itemRef","useRef","isOneColumn","isFirstColumn","index","isLastColumn","variantClasses","multiVariantStyles","itemOverlayFront","variantClassesVertical","itemOverlayFrontVertical","itemStyles","itemOverlayRear","styles","itemOverlayRearVertical","itemDragger","getItem","useCallback","current","closest","ITEM_SELECTOR","setTransferData","event","dataTransfer","setData","JSON","stringify","metadata","key","rootProps","isDragged","overlayZoneBeforeProps","overlayZoneAfterProps","useReorderableItem","isDisabled","draggable","ref","itemSelector","isVertical","direction","useUser","isRtl","overlayZoneBeforeClass","classNames","class","itemOverlayFrontEdge","overlayZoneAfterClass","itemOverlayRearEdge","_jsxs","jsxs","_Fragment","Fragment","_jsx","animationConfigSlide","animationStates","slideUp","from","translateY","to","options","duration","delay","easing","slideDown","isAnimatedOnMount","animationConfigOpacity","timeoutRef","opacity","onAnimationEnd","clearTimeout","MemoizeBaseCardViewItem","memo","isTabbable","isFocused","isFocusRingVisible","isSelected","selectionMode","focusBehavior","setIsFocusBehaviorValid","initialAnimation","isGridLayout","updateCardSize","reorderItemProps","itemKey","itemIndex","isItemFocused","itemFocused","itemInitialOpacity","itemInGridLayout","classes","itemStyle","handleResize","entry","contentRect","width","height","nullRef","useResizeObserver","useLayoutEffect","content","firstElementChild","focusable","allTabbableElements","length","warn","focus","nodeRef","nodeRefSlide","controller","controllerSlide","useAnimation","nodeRefOpacity","controllerOpacity","useEffect","undefined","setTimeout","cancel","style","itemRefs","useMemo","mergeRefs","childrenComponent","id","useId","role","onKeyDown","stopPropagation","TabbableModeContext","Provider","value","FocusTrap","restoreFocusRef","prev","next","compareListItemContext","props1","props2","BaseCardViewLayout","layout","gap","cardViewVars","jsx","Grid","gridTemplateColumns","Flex","wrap","BaseCardViewSkeletonContainer","isVisible","setIsVisible","useState","LOADMORE_STYLE_CLASS","getSkeletonsByCount","count","isUnique","sw","sh","Array","map","_v","i","Skeleton","Date","getTime","InitialLoadSkeletons","props","DefaultLoadMoreSkeletons","skeletons","DEFAULT_SKELETON_NUMBER","InvisibleSkeletons","LoadMoreSkeletons","colCount","cardWidth","cardHeight","firstRowColCount","totalCount","isOnlyOneRow","firstSkeleton","push","emptyKeys","all","keys","Set","gutterSizeToPX","xs","sm","md","lg","xl","BaseCardView","forwardRef","data","onLoadMore","hasMore","getRowKey","onCurrentKeyChange","selectedKeys","onSelectionChange","viewportConfig","ariaLabel","ariaLabelledBy","cardSize","useImperativeHandle","anchorKey","pendingCurrentKey","gutterSizePX","layoutProps","isInitialAnimation","ariaMultiSelectable","ariaRowcount","Math","ceil","ariaColcount","isFocusBehaviorValid","validFocusBehavior","scrollCurrItemIntoView","isReorderEnabled","isFetching","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","element","keyExtractor","currentKeyProps","useCurrentKey","getPrevNextKeyByCount","showFocusRing","focusRingProps","useCollectionFocusRing","elem","findElementByKey","cell","activeDescendant","getAttribute","setAttribute","scrollIntoView","block","handleSelectionChange","detail","size","values","pop","handleSelectionRangeChange","handleSelectionRange","isArray","eventType","start","end","target","selectionProps","useSelection","isPrev","reorderProps","reorderContext","reorderInstructionsId","reorderInstructions","useReorderable","onDragOver","dragToScroll","useCardViewReorder","reorderAcc","HiddenAccessible","handleLoadMore","getItemContext","selectorRenderer","Selector","onChange","rowKey","selector","containsKey","getViewportConfig","collectionComponent","LoadMoreCollection","loadMoreIndicator","loadMoreThreshold","cardItemContext","itemRenderFunc","initialLoadSkeletons","mergeProps","onFocus","isKeyDefined","firstKey","getFirstVisibleKey","onPointerDown","preventScroll","metaKey","ctrlKey","shiftKey","includes","baseStyle","tabIndex","ReorderableContext","gapWidth","rootWidth","floor","max"],"mappings":"6kCAmBM,SAAUA,GAA0DC,WACxEA,EAAUC,SACVA,EAAQC,QACRA,EAAOC,WACPA,EAAUC,UACVA,EAASC,QACTA,EAAOC,WACPA,EAAUC,QACVA,EAAOC,QACPA,IAEA,MAAMC,EAAUC,SAA8B,MACxCC,EAA0B,IAAZJ,EACdK,EAAgBJ,EAAQK,MAAQN,GAAY,EAC5CO,EAAeN,EAAQK,MAAQN,GAAYA,EAAU,EACrDQ,EAAiBC,EAAAA,mBAAmB,CACxCC,iBAAkBX,IAEdY,EAAyBF,EAAAA,mBAAmB,CAChDG,yBAA0Bb,IAEtBc,EAAa,CACjBH,iBAAkBN,EAAcO,EAAyBH,EACzDM,gBAAiBV,EAAcW,EAAAA,OAAOC,wBAA0BD,EAAMA,OAACD,gBACvEG,YAAaF,EAAMA,OAACE,aAEhBC,EAAUC,EAAWA,aAAC,IAAMjB,GAASkB,SAASC,QAAQC,EAAAA,gBAA+B,IACrFC,EAAkBJ,eACrBK,IACCA,EAAMC,cAAcC,QAAQ,0BAA2BC,KAAKC,UAAU3B,EAAQ4B,SAASC,KAAK,GAE9F,CAAC7B,EAAQ4B,SAASC,OAEdC,UAAEA,EAASC,UAAEA,EAASC,uBAAEA,EAAsBC,sBAAEA,GACpDC,EAAAA,mBAAmB,CACjB1C,aACA2C,YAAYvC,EACZwC,YAAWxC,EACXF,UACAC,aACAC,YACAC,UACAwC,IAAKpC,EACLgB,UACAK,kBACAV,aACA0B,aAAcjB,EAAaA,cAC3BkB,WAAYpC,KAGVqC,UAAEA,GAAcC,EAAAA,UAChBC,EAAsB,QAAdF,EAERG,EAAyBC,EAAAA,WAAW,CACxCZ,GAAwBa,OACvB1C,IAAgBuC,GAAStC,GAAiBU,EAAMA,OAACgC,sBACjD3C,GAAeuC,GAASpC,GAAgBQ,EAAMA,OAACgC,uBAG5CC,EAAwBH,EAAAA,WAAW,CACvCX,GAAuBY,OACtB1C,IAAgBuC,GAASpC,GAAgBQ,EAAMA,OAACkC,qBAChD7C,GAAeuC,GAAStC,GAAiBU,EAAMA,OAACkC,sBAGnD,OACEC,EAAAA,KAAS,MAAA,IAAAnB,EAAWM,WAAW,EAAK3C,SAAA,CACjCA,GACCsC,GAAarC,GACbuD,EACEC,KAAAC,EAAAC,SAAA,CAAA3D,SAAA,CAAA4D,EAAAA,IAAA,MAAA,IAASrB,EAAwBa,MAAOF,IACxCU,EAAAA,cAASpB,EAAuBY,MAAOE,SAKjD,CC8GA,MAAMO,EACJjD,IAEO,CACLkD,gBAAiB,CACfC,QAAS,CACPC,KAAM,CACJC,WAAY,QAEdC,GAAI,CACFD,WAAY,OAEdE,QAAS,CACPC,SAAU,IACVC,MAAe,GAARzD,EACP0D,OAAQ,CAAC,EAAG,EAAG,GAAK,KAGxBC,UAAW,CACTP,KAAM,CACJC,WAAY,SAEdC,GAAI,CACFD,WAAY,KAEdE,QAAS,CACPC,SAAU,IACVC,MAAe,GAARzD,EACP0D,OAAQ,CAAC,EAAG,EAAG,GAAK,MAI1BE,mBAAmB,IAIjBC,EAAyB,CAC7B7D,EACA8D,KAEO,CACLZ,gBAAiB,CACfa,QAAS,CACPX,KAAM,CACJW,QAAS,GAEXT,GAAI,CACFS,QAAS,GAEXR,QAAS,CACPC,SAAU,IACVC,MAAe,GAARzD,EACP0D,OAAQ,YAIdE,mBAAmB,EACnBI,eAAgB,KACVF,EAAWhD,SACbmD,aAAaH,EAAWhD,QACzB,IAmBMoD,EAA0BC,EAAAA,MAjOvB,UAA+C/E,SAC7DA,EAAQO,QACRA,EAAOyE,WACPA,EAAUC,UACVA,EAASC,mBACTA,EAAkBC,WAClBA,EAAUC,cACVA,EAAaC,cACbA,EAAaC,wBACbA,EAAuBC,iBACvBA,EAAgBC,aAChBA,EAAYC,eACZA,EAAcC,iBACdA,IAEA,MAAMtF,EAAUK,SAAuB,MACjCiE,EAAajE,EAAAA,SACbkF,EAAUpF,EAAQ4B,SAASC,IAC3BwD,EAAYrF,EAAQK,MAEpBiF,EAAgBZ,GAAaC,EAC7BpE,EAAiBC,EAAAA,mBAAmB,CACxC+E,YAA+B,SAAlBT,GAA4BQ,EAAgB,gBAAkB,mBAC3EE,mBAAoBR,EAAmB,gBAAkB,mBACzDS,iBAAkBR,EAAe,iBAAmB,sBAEhDS,EAAU9C,EAAAA,WAAW,CAAC9B,EAAMA,OAAC6E,UAAWpF,IAqBxCqF,EAAe1E,eAClB2E,IACCX,IAAiBW,EAAMC,YAAYC,MAAOF,EAAMC,YAAYE,OAAO,GAErE,CAACd,IAGGe,EAAU/F,SAAuB,MACvCgG,EAAAA,kBAAkBhB,EAAiBrF,EAAUoG,EAASL,GAItDO,EAAAA,iBAAgB,KACd,GAAsB,YAAlBrB,GAA+BQ,EAAe,CAGhD,MAAMc,EAAUvG,EAAQsB,SAASkF,mBAAmBA,kBAC9CC,EAAYC,EAAmBA,oBAACH,GAAS,GAAM,GAC5B,IAArBE,EAAUE,QAAgBF,EAAUE,OAAS,GAC/CC,EAAAA,KACE,GAAGH,EAAUE,4OAEfzB,KAA0B,IAE1BuB,EAAU,GAAGI,OAEhB,IACA,CAAC5B,EAAeQ,EAAeP,IAKlC,MAAQ4B,QAASC,EAAcC,WAAYC,GAAoBC,eAG7D/B,GAAoB,OAAQ1B,EAAqB+B,KAG3CsB,QAASK,EAAgBH,WAAYI,GAAsBF,EAAYA,aAG5E/B,EAAoB,UAAc,OAAQd,EAAuBmB,EAAWlB,IAG/E+C,EAAAA,WAAU,UACiBC,IAArBnC,IACFb,EAAWhD,QAAUiG,YAAW,KAC9BN,EAAgBO,SAChBJ,EAAkBI,SACdxH,EAAQsB,UACVtB,EAAQsB,QAAQmG,MAAMlD,QAAU,IACjC,GACA,KACJ,GACA,CAAC6C,EAAmBH,EAAiB9B,IAQxC,MAAMuC,EAAWC,EAAAA,SAAQ,SAIEL,IAArBnC,EACKyC,EAAAA,UAAU5H,GAEZ4H,YAAU5H,EAAS+G,EAAcI,IACvC,CAACnH,EAAS+G,EAAcI,EAAgBhC,IAErC0C,EAAoBvC,EACxB9B,EAAAA,IAAC9D,EAA2B,IAAK4F,EAAkBnF,QAASA,EACzDP,SAAAA,EAASO,KAGZP,EAASO,GAGX,OACEqD,MACE,MAAA,CAAAsE,GAAIC,EAAKA,QACTvF,IAAKkF,EACL1E,MAAO6C,EACPmC,KAAK,WACQ,cAAAzC,EACb0C,UAtGmBvG,IAED,SAAlBuD,IACAL,GACe,cAAdlD,EAAMM,KACS,YAAdN,EAAMM,KACQ,cAAdN,EAAMM,KACQ,eAAdN,EAAMM,KAERN,EAAMwG,iBACP,EA4FyB,gBACS,SAAlBlD,OAA2BsC,EAAYvC,KAC9B,iBAAZQ,GAAwB,CAAE,mBAAoB,UAC1D3F,SAAA4D,MAAC2E,EAAAA,oBAAoBC,SAAS,CAAAC,MAAO,CAAEzD,cAAYhF,SACjD4D,MAAC8E,EAAAA,UAAS,CAAChG,YAAasC,EAAY2D,iBAAiB,EAClD3I,SAAAiI,OAKX,IAmFE,CAAOW,EAAmBC,KACxB,SAAID,IAAQC,KAERD,EAAK5I,WAAa6I,EAAK7I,UACvB4I,EAAK5D,aAAe6D,EAAK7D,YACzB4D,EAAK3D,YAAc4D,EAAK5D,WACxB2D,EAAK1D,qBAAuB2D,EAAK3D,oBACjC0D,EAAKzD,aAAe0D,EAAK1D,YACzByD,EAAKrD,mBAAqBsD,EAAKtD,kBAC/BqD,EAAKvD,gBAAkBwD,EAAKxD,eAC5ByD,EAAAA,uBAAuBF,EAAKrI,QAASsI,EAAKtI,WAtBhDwI,EAuB8BH,EAAKlD,iBAtBnCsD,EAsBqDH,EAAKnD,iBAnBxDqD,GAAqB,aAAMC,GAAqB,YAChDD,GAAkB,UAAMC,GAAkB,SAC1CD,GAAkB,UAAMC,GAAkB,UAPd,IAC9BD,EACAC,CAyBc,IC/RV,SAAUC,GAAmBjJ,SAAEA,EAAQkJ,OAAEA,EAAM7I,WAAEA,EAAUC,QAAEA,IACjE,MAAM6I,EAAMC,EAAAA,aAAa/I,WAAWA,GACpC,MAAe,SAAX6I,EACK5I,EAAU,EAAI,KACnBsD,EAACyF,IAAAC,EAAIA,KAAC,CAAAC,oBAAqB,UAAUjJ,UAAiB6I,IAAKA,EACxDnJ,SAAAA,IAKH4D,EAAAyF,IAACG,OAAI,CAACC,KAAK,OAAON,IAAKA,EAAGnJ,SACvBA,GAIT,CCFgB,SAAA0J,GAA8B1J,SAAEA,IAC9C,MAAO2J,EAAWC,GAAgBC,EAAQA,UAAC,GAQ3C,OANApC,EAAAA,WAAU,KACRE,YAAW,KACTiC,GAAa,EAAK,GAVL,GAWD,GACb,IAEID,EAAY/F,EAAAyF,IAAC1F,WAAU,CAAA3D,SAAAA,IAAuB4D,EAAAA,IAAA,MAAA,CAAKR,MAAO0G,EAAAA,sBACnE,CC9BA,MAgBMC,EAAsB,CAC1Bb,EACAc,EAlB8B,GAmB9B1D,EACAC,EACA0D,GAAW,KAEX,MAAMC,EAAK5D,IAAqB,SAAX4C,EAtBQ,MAsBqC,QAC5DiB,EAAK5D,GAtBmB,MAwB9B,MAAO,IAAI6D,MAAMJ,IAAQK,KAAI,CAACC,EAAIC,IAGhC3G,EAACyF,IAAAmB,EAAQA,SAAiD,CAAAlE,MAAO4D,EAAI3D,OAAQ4D,GAA9DF,GAAY,GAAGM,KAAI,IAAIE,MAAOC,cAC7C,EAMSC,EAAwBC,GACnChH,MAAC8F,EAA6B,CAAA1J,SAAE+J,EAAoBa,EAAM1B,UAO/C2B,EAA4BD,IACvC,MAIME,EAAY,CAHhBlH,aAAKR,MAAO0G,EAAoBA,qBAAG9J,SAAA+J,EAAoBa,EAAM1B,OAAQ,QAEhDa,EAAoBa,EAAM1B,OAAQ6B,KAEzD,OAAOnH,EAACyF,IAAAK,EAA+B,CAAA1J,SAAA8K,GAA0C,EAO7EE,EAAqB,IAClBpH,EAAKyF,IAAA,MAAA,CAAAjG,MAAO0G,EAAAA,uBAGRmB,EAAqBL,IAChC,GAAIA,EAAMM,SAAW,GAAwB,MAAnBN,EAAMO,WAAyC,MAApBP,EAAMQ,WAEzD,OAAOxH,EAAAyF,IAAC2B,EAAkB,CAAA,GACrB,CAEL,MAAMF,EAAY,GAEZO,EAAmBT,EAAMM,SAAYN,EAAMU,WAAaV,EAAMM,SAC9DK,EAAeF,IAAqBT,EAAMM,SAE1CC,EAAY,QAAQP,EAAMO,eAC1BC,EAAaR,EAAMQ,WACpB,QAAQR,EAAMQ,gBAxES,MA2EtB9E,EAA+B,SAAjBsE,EAAM1B,OAAoBiC,EAAY,OACpD5E,EAAgC,SAAjBqE,EAAM1B,QAAqBqC,EAAeH,EAAa,OAGtEI,EACJ5H,EAAAA,IAAA,MAAA,CAAKR,MAAO0G,EAAoBA,qBAAG9J,SAAA+J,EAAoBa,EAAM1B,OAAQ,EAAG5C,EAAOC,KAUjF,OARAuE,EAAUW,KAAKD,GACfV,EAAUW,KAAK1B,EAAoBa,EAAM1B,OAAQmC,EAAmB,EAAG/E,EAAOC,IAGzEgF,GACHT,EAAUW,KAAK1B,EAAoBa,EAAM1B,OAAQ0B,EAAMM,SAAU5E,EAAO8E,IAGnExH,EAACyF,IAAAK,EAA+B,CAAA1J,SAAA8K,GACxC,GCjGUY,EAAY,CAAEC,KAAK,EAAOC,KAAM,IAAIC,KAMpCC,EAAyC,CACpDC,GAAI,GACJC,GAAI,GACJC,GAAI,GACJC,GAAI,GACJC,GAAI,ICydOC,EAnaYC,EAAUA,YACjC,EAEIrM,WACAsM,OACAC,aAAa,SACbC,WAAU,EACVC,YACA1M,aACA2M,qBACAtH,gBAAgB,OAChBuH,eAAejB,EACfkB,oBACAzM,YACA0M,iBACAxH,gBAAgB,OAChB,aAAcyH,EACd,kBAAmBC,EACnBxH,mBAAmB,UACnBlF,aAAa,KACbC,UACA4I,SACA8D,WACAvH,kBAEF7C,KAEA,MAAMxC,EAAUK,SAAuB,MACvCwM,EAAmBA,oBAACrK,GAAM,IAAMxC,EAAQsB,SAAU,CAACtB,IAGnD,MAAM8M,EAAYzM,EAAAA,SAEZ0M,EAAoB1M,EAAAA,SAEpB2M,EAAetB,EAAezL,GAC9BgN,EAAc,CAAEnE,SAAQ5I,UAASD,cACjCiN,EAAqB7M,UAAO,GAClCgH,EAAAA,WAAU,KACeC,MAAnBsF,EAASzG,QAAyCmB,MAAlBsF,EAAS1G,QAC3CgH,EAAmB5L,SAAU,EAC9B,GACA,CAACsL,IAEJ,MAAMO,EAAwC,SAAlBnI,OAA2BsC,EAA8B,aAAlBtC,EAC7DoI,EAAehB,IAAYF,GAAQhM,EAAU,GAAK,EAAImN,KAAKC,KAAKpB,GAAMvF,OAASzG,GAC/EqN,EAAerN,EAAU,GAAK,EAAIA,GAEjCsN,GAAsBtI,IAA2BuE,EAAQA,UAAC,GAC3DgE,GAAqBD,GAAuBvI,EAAgB,OAI5DyI,GAAyBrN,UAAO,GAChCsN,GAAgCrG,MAAbvH,EAEnB6N,GAAavN,UAAO,IAMnBwN,GAAsBC,IAAqBC,EAAAA,mBAChD/N,GACCgO,GACQC,EAAYA,aAACD,EAASxM,EAAAA,gBAE/B7B,EACA2M,IAOI4B,gBAAEA,IAAoBC,EAAAA,eACzBH,GAAYC,EAAYA,aAACD,EAASxM,EAAAA,gBACjB,aAAlBwD,GAGA,IAAMoJ,EAAqBA,sBAAClC,EAAMG,EAAW1M,GAAaO,KAC1D,IAAMkO,EAAAA,sBAAsBlC,EAAMG,EAAW1M,EAAYO,KACzD,IAAMkO,EAAAA,sBAAsBlC,EAAMG,EAAW1M,GAAa,KAC1D,IAAMyO,EAAqBA,sBAAClC,EAAMG,EAAW1M,EAAY,IACzDA,EACA2M,IAGK+B,GAAeC,IAAkBC,EAAAA,uBAAuBvO,EAAS,CACtE,UACA,YACA,YACA,eAiDFqH,EAAAA,WAAU,KACR,GAAkB,MAAd1H,GAAsBK,EAAQsB,QAAS,CACzC,MAAMkN,EAAOC,EAAAA,iBAAiBzO,EAAQsB,QAAS3B,EAAY6B,EAAAA,eAC3D,GAAIgN,EAAM,CAER,GAA2B,SAAvBf,GAA+B,CACjC,MAAMiB,EAAOF,EAAKjN,QAAQ,mBACpBoN,EAAmB3O,EAAQsB,QAAQsN,aAAa,yBAClDF,GAAQC,IAAqBD,EAAK5G,KACpC9H,EAAQsB,QAAQuN,aAAa,wBAAyBH,EAAK5G,IAC3D4F,GAAuBpM,SAAU,EAEpC,CAEGoM,GAAuBpM,UACzBkN,EAAKM,eAAe,CAAEC,MAAO,YAC7BrB,GAAuBpM,SAAU,EAEpC,CACF,IAIA,CAAC3B,EAAYuM,EAAMuB,GAAoBE,KAM1C,MAAMqB,GAAwB3N,eAC3B4N,IACKzC,KACuB,IAArByC,EAAO5G,MAAMkD,KAAiB0D,EAAO5G,MAAMmD,KAAK0D,KAAO,IAEzDpC,EAAUxL,QAAU0I,MAAMpG,KAAKqL,EAAO5G,MAAMmD,KAAK2D,UAAUC,OAE7D5C,EAAkByC,GACnB,GAEH,CAACnC,EAAWN,IAGR6C,GAA6BhO,eAChC4N,IACC,GAAI/C,GAAQM,EAAmB,CAC7B,MAAMnE,EAAQiH,EAAoBA,qBAACL,EAAQ/C,EAAMG,GAE7CrC,MAAMuF,QAAQlH,KACS,eAArB4G,EAAOO,UAET1C,EAAUxL,QAAU2N,EAAO5G,MAAMoH,MAGjC3C,EAAUxL,QAAU2N,EAAO5G,MAAMqH,IAEnClD,EAAkB,CAAEnE,MAAO,CAAEkD,KAAK,EAAOC,KAAM,IAAIC,IAAIpD,IAAUsH,OAAQ,OAE5E,IAEH,CAACzD,EAAMM,EAAmBH,KAGtBuD,eAAEA,IAAmBC,EAAYA,cACpC7B,GACKA,IAAYhO,EAAQsB,aACAgG,IAAf3H,EAA2B,KAAOA,EAEpCsO,EAAYA,aAACD,EAASxM,EAAAA,gBAE/B+K,EACAvH,GACA,EACA,UACA,EACAgK,GACAlC,EAAUxL,QACV3B,GACA,CAACA,EAA2BmQ,IAAoB,IAC9C1B,EAAqBA,sBAAClC,EAAMG,EAAW1M,EAAYmQ,GAAU5P,EAAUA,KACzE,CAACP,EAA2BmQ,IAAoB,IAC9C1B,EAAqBA,sBAAClC,EAAMG,EAAW1M,EAAYmQ,GAAU,EAAI,KAClE9N,IACC,GAAIhC,EAAQsB,QAAS,CACnB,MAAMkN,EAAOC,EAAAA,iBAAiBzO,EAAQsB,QAASU,EAAKR,EAAAA,eAChDgN,GACFA,EAAKM,eAAe,CAAEC,MAAO,WAEhC,IAEHM,KAOIU,aACJA,GAAYzK,iBACZA,GAAgB0K,eAChBA,GAAcC,sBACdA,GAAqBC,oBACrBA,ICvS4B,GAChCvQ,aACAI,YACAE,aACAC,UACAF,UACA0N,6BAEA,MAAMC,EAAgCrG,MAAbvH,GAElBF,EAASC,GAAc2J,EAAQA,cAAgBnC,IAChDyI,aAAEA,EAAYC,eAAEA,EAAcC,sBAAEA,EAAqBC,oBAAEA,GAC3DC,EAAAA,eAAe,CACbpQ,YACAC,UACAyC,aAAcjB,EAAaA,cAC3Bc,YAAaqL,EACbzN,YAGJ,OAAKyN,EA4BE,CACLoC,aAbwB,IAAKA,EAAcK,WAPrB1O,IACtB2O,EAAYA,aAAC3O,OAAmB4F,IAAZzH,EAAuBG,EAAQsB,SAGnDoM,EAAuBpM,SAAU,CAAK,GAiBtCgE,iBAZuB,CACvB3F,aACAE,UACAC,aACAC,YACAC,UACAC,aACAC,WAMA8P,iBACAC,wBACAC,uBAhCO,CACLH,eACAC,iBACAC,wBACAC,sBA6BM,EDkPJI,CAAmB,CACrB3Q,aACAI,YACAE,aACAC,UACAF,UACA0N,4BAGI6C,GAAa5C,IACjBnK,MAAAF,EAAAA,SAAA,CAAA1D,SACE4D,EAAAA,YAAMsE,GAAImI,GACRrQ,SAAA4D,EAAAA,IAACgN,EAAAA,iBAAkB,CAAA5Q,SAAAsQ,SASnBO,GAAiBpP,EAAAA,aAAY,KAE5BuM,GAAWtM,UACdsM,GAAWtM,SAAU,EACrB6K,IACD,GACA,CAACyB,GAAYzB,IAEhB9E,EAAAA,WAAU,KACRuG,GAAWtM,SAAU,CAAK,GAEzB,CAAC4K,EAAME,IAMV,MAAMsE,GAAiBrP,eACpBlB,IACC,MAAM6B,EAAMqK,EAAUlM,EAAQ+L,MACxByE,EACc,aAAlB3L,EACI,IACExB,EAACyF,IAAA2H,YACCC,SAAUrE,EACVsE,OAAQ9O,EACRuK,aAAcA,SAElBjF,EAEN,MAAO,CACL9G,MAAOL,EAAQK,MACf0L,KAAM/L,EAAQ+L,KACdnK,SAAU,CAAEC,IAAKA,GACjB+O,SAAUJ,EACV5L,WAAYiM,EAAAA,YAAYzE,EAAcvK,GACvC,GAEH,CAACgD,EAAeuH,EAAcC,EAAmBH,IA+B7C3B,GACJwB,IAASA,EAAKvF,QAAUyF,EACtB5I,EAAAA,IAACiH,EAAwB,CAAC3B,OAAQA,IAElCtF,EAAAyF,IAAC4B,EAAiB,CAChB/B,OAAQA,EACRgC,SAAU5K,EACVgL,WAAYgB,GAAMvF,QAAU,EAC5BoE,UAAW6B,EAAS1G,MACpB8E,WAAY4B,EAASzG,SAI3BsG,EAAiBwE,EAAiBA,kBAACjR,EAASyM,GAC5C,MAAMyE,GACJ1N,EAAAA,IAAA,MAAA,CAAKwE,KAAK,eACRxE,EAAAA,IAACqF,MAAuBoE,EAAWrN,SACjC4D,EAAAA,IAAC2N,EAAAA,mBAAkB,CACjBjF,KAAMA,EACNE,QAASA,EACTD,WAAYsE,GACZW,kBAAmB1G,GACnB2G,kBAAmBrE,EAAe,EAClCP,eAAgBA,EAAc7M,SAnDXO,IACzB,MAAMmR,EAAkBZ,GAAevQ,GACjCyE,EAAaiJ,GAAqByD,EAAgBvP,SAASC,KAC3D6C,EAAYlF,IAAe2R,EAAgBvP,SAASC,MAAQ4C,EAC5DE,EAAqBD,GAAawJ,GAClCtJ,EAAauM,EAAgBvM,WAmBnC,MAlBuB,CAAC5E,GACtBqD,EAAAA,IAACkB,GAECvE,QAASA,EACTyE,WAAYA,EACZC,UAAWA,EACXC,mBAAoBA,EACpBM,aAAyB,SAAX0D,EACd/D,WAAYA,EACZC,cAAeA,EACfC,cAAewI,MACQ,YAAlBxI,GAA+B,CAAEC,+BACjCgI,EAAmB5L,SAAW,CAAE6D,uBACN,IAA1BmM,EAAgB9Q,QAAgBoM,EAAS1G,OAAS,CAAEb,qBACpDsI,IAAoB,CAAErI,qBAC1B1F,SAAAA,GAbI0R,EAAgBvP,SAASC,KAgB3BuP,CAAeD,EAAgB,QAkClCE,GACJhO,EAACyF,IAAAJ,MAAuBoE,EAAWrN,SACjC4D,MAAC+G,GAAqBzB,OAAQA,MAIlC,OACE1F,EACMC,KAAA,MAAA,IAAAoO,EAAAA,WACFvD,GACAI,GACAsB,GACAG,GACA,CACE2B,QA1RY,KAElB,IACGC,EAAYA,aAAChS,IACd2M,GACAuB,QAAqBvG,IACrBtH,EAAQsB,QACR,CACA,MAAMsQ,EACJ7E,EAAkBzL,SAAYuQ,EAAkBA,mBAAC7R,EAAQsB,QAASE,EAAAA,eAChEmQ,EAAAA,aAAaC,IACftF,EAAmB,CAAEjE,MAAOuJ,GAE/B,MAAM,GAAID,eAAahS,IAAeK,EAAQsB,QAAS,CAEtD,MAAMkN,EAAOC,EAAAA,iBAAiBzO,EAAQsB,QAAS3B,EAAiB6B,EAAAA,eAChEgN,GAAMM,eAAe,CAAEC,MAAO,WAC/B,GA0QK+C,cAtQmBpQ,IACzB,MAAMM,EAAMiM,EAAYA,aAACvM,EAAMiO,OAAuBnO,EAAaA,eAC/DmQ,EAAAA,aAAa3P,KACf+K,EAAkBzL,QAAUU,EAC7B,EAmQKiG,UAhQevG,IAGM,YAAvB+L,IAAkD,QAAd/L,EAAMM,KAC5ChC,EAAQsB,SAASuF,MAAM,CAAEkL,eAAe,IAKxCpE,KACCjM,EAAMsQ,SAAWtQ,EAAMuQ,UACxBvQ,EAAMwQ,UAJY,CAAC,YAAa,aAAc,UAAW,aAK7CC,SAASzQ,EAAMM,OAE3B0L,GAAuBpM,SAAU,EAClC,GAoPG,IAA6B,SAAvBmM,IAAiCK,KAEzCtL,IAAKxC,EACLgI,KAAK,OACLhF,MAAO/B,EAAAA,OAAOmR,UACdC,SAAU,EACE,aAAA3F,EACK,kBAAAC,yBACKQ,EAAmB,gBAC1BC,EACA,gBAAAG,YACf/J,MAAC8O,EAAAA,mBAAmBlK,UAASC,MAAO2H,GACjCpQ,SAACsM,EAEEA,EAAKvF,QAAUyF,EAAO,GAGxB5I,EAAAA,IAACD,EAAQA,kBAGZgN,KAEH,mCDjcqB,CAACgC,EAAkBxH,EAAoByH,KAChE,IAAKzH,IAAcyH,EAAW,OAAO,EAGrC,MAAM1H,EAAWuC,KAAKoF,OAAOD,EAAYD,IAAaA,EAAWxH,IACjE,OAAOsC,KAAKqF,IAAI,EAAG5H,EAAS"}